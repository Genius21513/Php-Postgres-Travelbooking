/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@alpinejs/focus/dist/module.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/@alpinejs/focus/dist/module.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ module_default)\n/* harmony export */ });\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", {value: true});\nvar __commonJS = (callback, module) => () => {\n  if (!module) {\n    module = {exports: {}};\n    callback(module.exports, module);\n  }\n  return module.exports;\n};\nvar __exportStar = (target, module, desc) => {\n  if (module && typeof module === \"object\" || typeof module === \"function\") {\n    for (let key of __getOwnPropNames(module))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, {get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable});\n  }\n  return target;\n};\nvar __toModule = (module) => {\n  return __exportStar(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, \"default\", module && module.__esModule && \"default\" in module ? {get: () => module.default, enumerable: true} : {value: module, enumerable: true})), module);\n};\n\n// node_modules/tabbable/dist/index.js\nvar require_dist = __commonJS((exports) => {\n  /*!\n  * tabbable 5.2.1\n  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n  */\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  var candidateSelectors = [\"input\", \"select\", \"textarea\", \"a[href]\", \"button\", \"[tabindex]\", \"audio[controls]\", \"video[controls]\", '[contenteditable]:not([contenteditable=\"false\"])', \"details>summary:first-of-type\", \"details\"];\n  var candidateSelector = /* @__PURE__ */ candidateSelectors.join(\",\");\n  var matches = typeof Element === \"undefined\" ? function() {\n  } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n  var getCandidates = function getCandidates2(el, includeContainer, filter) {\n    var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n    if (includeContainer && matches.call(el, candidateSelector)) {\n      candidates.unshift(el);\n    }\n    candidates = candidates.filter(filter);\n    return candidates;\n  };\n  var isContentEditable = function isContentEditable2(node) {\n    return node.contentEditable === \"true\";\n  };\n  var getTabindex = function getTabindex2(node) {\n    var tabindexAttr = parseInt(node.getAttribute(\"tabindex\"), 10);\n    if (!isNaN(tabindexAttr)) {\n      return tabindexAttr;\n    }\n    if (isContentEditable(node)) {\n      return 0;\n    }\n    if ((node.nodeName === \"AUDIO\" || node.nodeName === \"VIDEO\" || node.nodeName === \"DETAILS\") && node.getAttribute(\"tabindex\") === null) {\n      return 0;\n    }\n    return node.tabIndex;\n  };\n  var sortOrderedTabbables = function sortOrderedTabbables2(a, b) {\n    return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n  };\n  var isInput = function isInput2(node) {\n    return node.tagName === \"INPUT\";\n  };\n  var isHiddenInput = function isHiddenInput2(node) {\n    return isInput(node) && node.type === \"hidden\";\n  };\n  var isDetailsWithSummary = function isDetailsWithSummary2(node) {\n    var r = node.tagName === \"DETAILS\" && Array.prototype.slice.apply(node.children).some(function(child) {\n      return child.tagName === \"SUMMARY\";\n    });\n    return r;\n  };\n  var getCheckedRadio = function getCheckedRadio2(nodes, form) {\n    for (var i = 0; i < nodes.length; i++) {\n      if (nodes[i].checked && nodes[i].form === form) {\n        return nodes[i];\n      }\n    }\n  };\n  var isTabbableRadio = function isTabbableRadio2(node) {\n    if (!node.name) {\n      return true;\n    }\n    var radioScope = node.form || node.ownerDocument;\n    var queryRadios = function queryRadios2(name) {\n      return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n    };\n    var radioSet;\n    if (typeof window !== \"undefined\" && typeof window.CSS !== \"undefined\" && typeof window.CSS.escape === \"function\") {\n      radioSet = queryRadios(window.CSS.escape(node.name));\n    } else {\n      try {\n        radioSet = queryRadios(node.name);\n      } catch (err) {\n        console.error(\"Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s\", err.message);\n        return false;\n      }\n    }\n    var checked = getCheckedRadio(radioSet, node.form);\n    return !checked || checked === node;\n  };\n  var isRadio = function isRadio2(node) {\n    return isInput(node) && node.type === \"radio\";\n  };\n  var isNonTabbableRadio = function isNonTabbableRadio2(node) {\n    return isRadio(node) && !isTabbableRadio(node);\n  };\n  var isHidden = function isHidden2(node, displayCheck) {\n    if (getComputedStyle(node).visibility === \"hidden\") {\n      return true;\n    }\n    var isDirectSummary = matches.call(node, \"details>summary:first-of-type\");\n    var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n    if (matches.call(nodeUnderDetails, \"details:not([open]) *\")) {\n      return true;\n    }\n    if (!displayCheck || displayCheck === \"full\") {\n      while (node) {\n        if (getComputedStyle(node).display === \"none\") {\n          return true;\n        }\n        node = node.parentElement;\n      }\n    } else if (displayCheck === \"non-zero-area\") {\n      var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;\n      return width === 0 && height === 0;\n    }\n    return false;\n  };\n  var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {\n    if (isInput(node) || node.tagName === \"SELECT\" || node.tagName === \"TEXTAREA\" || node.tagName === \"BUTTON\") {\n      var parentNode = node.parentElement;\n      while (parentNode) {\n        if (parentNode.tagName === \"FIELDSET\" && parentNode.disabled) {\n          for (var i = 0; i < parentNode.children.length; i++) {\n            var child = parentNode.children.item(i);\n            if (child.tagName === \"LEGEND\") {\n              if (child.contains(node)) {\n                return false;\n              }\n              return true;\n            }\n          }\n          return true;\n        }\n        parentNode = parentNode.parentElement;\n      }\n    }\n    return false;\n  };\n  var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {\n    if (node.disabled || isHiddenInput(node) || isHidden(node, options.displayCheck) || isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n      return false;\n    }\n    return true;\n  };\n  var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {\n    if (!isNodeMatchingSelectorFocusable(options, node) || isNonTabbableRadio(node) || getTabindex(node) < 0) {\n      return false;\n    }\n    return true;\n  };\n  var tabbable2 = function tabbable3(el, options) {\n    options = options || {};\n    var regularTabbables = [];\n    var orderedTabbables = [];\n    var candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n    candidates.forEach(function(candidate, i) {\n      var candidateTabindex = getTabindex(candidate);\n      if (candidateTabindex === 0) {\n        regularTabbables.push(candidate);\n      } else {\n        orderedTabbables.push({\n          documentOrder: i,\n          tabIndex: candidateTabindex,\n          node: candidate\n        });\n      }\n    });\n    var tabbableNodes = orderedTabbables.sort(sortOrderedTabbables).map(function(a) {\n      return a.node;\n    }).concat(regularTabbables);\n    return tabbableNodes;\n  };\n  var focusable2 = function focusable3(el, options) {\n    options = options || {};\n    var candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n    return candidates;\n  };\n  var isTabbable = function isTabbable2(node, options) {\n    options = options || {};\n    if (!node) {\n      throw new Error(\"No node provided\");\n    }\n    if (matches.call(node, candidateSelector) === false) {\n      return false;\n    }\n    return isNodeMatchingSelectorTabbable(options, node);\n  };\n  var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat(\"iframe\").join(\",\");\n  var isFocusable2 = function isFocusable3(node, options) {\n    options = options || {};\n    if (!node) {\n      throw new Error(\"No node provided\");\n    }\n    if (matches.call(node, focusableCandidateSelector) === false) {\n      return false;\n    }\n    return isNodeMatchingSelectorFocusable(options, node);\n  };\n  exports.focusable = focusable2;\n  exports.isFocusable = isFocusable2;\n  exports.isTabbable = isTabbable;\n  exports.tabbable = tabbable2;\n});\n\n// node_modules/focus-trap/dist/focus-trap.js\nvar require_focus_trap = __commonJS((exports) => {\n  /*!\n  * focus-trap 6.6.1\n  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n  */\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  var tabbable2 = require_dist();\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) {\n        symbols = symbols.filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n      }\n      keys.push.apply(keys, symbols);\n    }\n    return keys;\n  }\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function(key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n    return target;\n  }\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  }\n  var activeFocusTraps = function() {\n    var trapQueue = [];\n    return {\n      activateTrap: function activateTrap(trap) {\n        if (trapQueue.length > 0) {\n          var activeTrap = trapQueue[trapQueue.length - 1];\n          if (activeTrap !== trap) {\n            activeTrap.pause();\n          }\n        }\n        var trapIndex = trapQueue.indexOf(trap);\n        if (trapIndex === -1) {\n          trapQueue.push(trap);\n        } else {\n          trapQueue.splice(trapIndex, 1);\n          trapQueue.push(trap);\n        }\n      },\n      deactivateTrap: function deactivateTrap(trap) {\n        var trapIndex = trapQueue.indexOf(trap);\n        if (trapIndex !== -1) {\n          trapQueue.splice(trapIndex, 1);\n        }\n        if (trapQueue.length > 0) {\n          trapQueue[trapQueue.length - 1].unpause();\n        }\n      }\n    };\n  }();\n  var isSelectableInput = function isSelectableInput2(node) {\n    return node.tagName && node.tagName.toLowerCase() === \"input\" && typeof node.select === \"function\";\n  };\n  var isEscapeEvent = function isEscapeEvent2(e) {\n    return e.key === \"Escape\" || e.key === \"Esc\" || e.keyCode === 27;\n  };\n  var isTabEvent = function isTabEvent2(e) {\n    return e.key === \"Tab\" || e.keyCode === 9;\n  };\n  var delay = function delay2(fn) {\n    return setTimeout(fn, 0);\n  };\n  var findIndex = function findIndex2(arr, fn) {\n    var idx = -1;\n    arr.every(function(value, i) {\n      if (fn(value)) {\n        idx = i;\n        return false;\n      }\n      return true;\n    });\n    return idx;\n  };\n  var valueOrHandler = function valueOrHandler2(value) {\n    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      params[_key - 1] = arguments[_key];\n    }\n    return typeof value === \"function\" ? value.apply(void 0, params) : value;\n  };\n  var createFocusTrap2 = function createFocusTrap3(elements, userOptions) {\n    var doc = document;\n    var config = _objectSpread2({\n      returnFocusOnDeactivate: true,\n      escapeDeactivates: true,\n      delayInitialFocus: true\n    }, userOptions);\n    var state = {\n      containers: [],\n      tabbableGroups: [],\n      nodeFocusedBeforeActivation: null,\n      mostRecentlyFocusedNode: null,\n      active: false,\n      paused: false,\n      delayInitialFocusTimer: void 0\n    };\n    var trap;\n    var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {\n      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n    };\n    var containersContain = function containersContain2(element) {\n      return state.containers.some(function(container) {\n        return container.contains(element);\n      });\n    };\n    var getNodeForOption = function getNodeForOption2(optionName) {\n      var optionValue = config[optionName];\n      if (!optionValue) {\n        return null;\n      }\n      var node = optionValue;\n      if (typeof optionValue === \"string\") {\n        node = doc.querySelector(optionValue);\n        if (!node) {\n          throw new Error(\"`\".concat(optionName, \"` refers to no known node\"));\n        }\n      }\n      if (typeof optionValue === \"function\") {\n        node = optionValue();\n        if (!node) {\n          throw new Error(\"`\".concat(optionName, \"` did not return a node\"));\n        }\n      }\n      return node;\n    };\n    var getInitialFocusNode = function getInitialFocusNode2() {\n      var node;\n      if (getOption({}, \"initialFocus\") === false) {\n        return false;\n      }\n      if (getNodeForOption(\"initialFocus\") !== null) {\n        node = getNodeForOption(\"initialFocus\");\n      } else if (containersContain(doc.activeElement)) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n        node = firstTabbableNode || getNodeForOption(\"fallbackFocus\");\n      }\n      if (!node) {\n        throw new Error(\"Your focus-trap needs to have at least one focusable element\");\n      }\n      return node;\n    };\n    var updateTabbableNodes = function updateTabbableNodes2() {\n      state.tabbableGroups = state.containers.map(function(container) {\n        var tabbableNodes = tabbable2.tabbable(container);\n        if (tabbableNodes.length > 0) {\n          return {\n            container,\n            firstTabbableNode: tabbableNodes[0],\n            lastTabbableNode: tabbableNodes[tabbableNodes.length - 1]\n          };\n        }\n        return void 0;\n      }).filter(function(group) {\n        return !!group;\n      });\n      if (state.tabbableGroups.length <= 0 && !getNodeForOption(\"fallbackFocus\")) {\n        throw new Error(\"Your focus-trap must have at least one container with at least one tabbable node in it at all times\");\n      }\n    };\n    var tryFocus = function tryFocus2(node) {\n      if (node === false) {\n        return;\n      }\n      if (node === doc.activeElement) {\n        return;\n      }\n      if (!node || !node.focus) {\n        tryFocus2(getInitialFocusNode());\n        return;\n      }\n      node.focus({\n        preventScroll: !!config.preventScroll\n      });\n      state.mostRecentlyFocusedNode = node;\n      if (isSelectableInput(node)) {\n        node.select();\n      }\n    };\n    var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {\n      var node = getNodeForOption(\"setReturnFocus\");\n      return node ? node : previousActiveElement;\n    };\n    var checkPointerDown = function checkPointerDown2(e) {\n      if (containersContain(e.target)) {\n        return;\n      }\n      if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n        trap.deactivate({\n          returnFocus: config.returnFocusOnDeactivate && !tabbable2.isFocusable(e.target)\n        });\n        return;\n      }\n      if (valueOrHandler(config.allowOutsideClick, e)) {\n        return;\n      }\n      e.preventDefault();\n    };\n    var checkFocusIn = function checkFocusIn2(e) {\n      var targetContained = containersContain(e.target);\n      if (targetContained || e.target instanceof Document) {\n        if (targetContained) {\n          state.mostRecentlyFocusedNode = e.target;\n        }\n      } else {\n        e.stopImmediatePropagation();\n        tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n      }\n    };\n    var checkTab = function checkTab2(e) {\n      updateTabbableNodes();\n      var destinationNode = null;\n      if (state.tabbableGroups.length > 0) {\n        var containerIndex = findIndex(state.tabbableGroups, function(_ref) {\n          var container = _ref.container;\n          return container.contains(e.target);\n        });\n        if (containerIndex < 0) {\n          if (e.shiftKey) {\n            destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n          } else {\n            destinationNode = state.tabbableGroups[0].firstTabbableNode;\n          }\n        } else if (e.shiftKey) {\n          var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref2) {\n            var firstTabbableNode = _ref2.firstTabbableNode;\n            return e.target === firstTabbableNode;\n          });\n          if (startOfGroupIndex < 0 && state.tabbableGroups[containerIndex].container === e.target) {\n            startOfGroupIndex = containerIndex;\n          }\n          if (startOfGroupIndex >= 0) {\n            var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n            var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n            destinationNode = destinationGroup.lastTabbableNode;\n          }\n        } else {\n          var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {\n            var lastTabbableNode = _ref3.lastTabbableNode;\n            return e.target === lastTabbableNode;\n          });\n          if (lastOfGroupIndex < 0 && state.tabbableGroups[containerIndex].container === e.target) {\n            lastOfGroupIndex = containerIndex;\n          }\n          if (lastOfGroupIndex >= 0) {\n            var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n            var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n            destinationNode = _destinationGroup.firstTabbableNode;\n          }\n        }\n      } else {\n        destinationNode = getNodeForOption(\"fallbackFocus\");\n      }\n      if (destinationNode) {\n        e.preventDefault();\n        tryFocus(destinationNode);\n      }\n    };\n    var checkKey = function checkKey2(e) {\n      if (isEscapeEvent(e) && valueOrHandler(config.escapeDeactivates) !== false) {\n        e.preventDefault();\n        trap.deactivate();\n        return;\n      }\n      if (isTabEvent(e)) {\n        checkTab(e);\n        return;\n      }\n    };\n    var checkClick = function checkClick2(e) {\n      if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n        return;\n      }\n      if (containersContain(e.target)) {\n        return;\n      }\n      if (valueOrHandler(config.allowOutsideClick, e)) {\n        return;\n      }\n      e.preventDefault();\n      e.stopImmediatePropagation();\n    };\n    var addListeners = function addListeners2() {\n      if (!state.active) {\n        return;\n      }\n      activeFocusTraps.activateTrap(trap);\n      state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {\n        tryFocus(getInitialFocusNode());\n      }) : tryFocus(getInitialFocusNode());\n      doc.addEventListener(\"focusin\", checkFocusIn, true);\n      doc.addEventListener(\"mousedown\", checkPointerDown, {\n        capture: true,\n        passive: false\n      });\n      doc.addEventListener(\"touchstart\", checkPointerDown, {\n        capture: true,\n        passive: false\n      });\n      doc.addEventListener(\"click\", checkClick, {\n        capture: true,\n        passive: false\n      });\n      doc.addEventListener(\"keydown\", checkKey, {\n        capture: true,\n        passive: false\n      });\n      return trap;\n    };\n    var removeListeners = function removeListeners2() {\n      if (!state.active) {\n        return;\n      }\n      doc.removeEventListener(\"focusin\", checkFocusIn, true);\n      doc.removeEventListener(\"mousedown\", checkPointerDown, true);\n      doc.removeEventListener(\"touchstart\", checkPointerDown, true);\n      doc.removeEventListener(\"click\", checkClick, true);\n      doc.removeEventListener(\"keydown\", checkKey, true);\n      return trap;\n    };\n    trap = {\n      activate: function activate(activateOptions) {\n        if (state.active) {\n          return this;\n        }\n        var onActivate = getOption(activateOptions, \"onActivate\");\n        var onPostActivate = getOption(activateOptions, \"onPostActivate\");\n        var checkCanFocusTrap = getOption(activateOptions, \"checkCanFocusTrap\");\n        if (!checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n        state.active = true;\n        state.paused = false;\n        state.nodeFocusedBeforeActivation = doc.activeElement;\n        if (onActivate) {\n          onActivate();\n        }\n        var finishActivation = function finishActivation2() {\n          if (checkCanFocusTrap) {\n            updateTabbableNodes();\n          }\n          addListeners();\n          if (onPostActivate) {\n            onPostActivate();\n          }\n        };\n        if (checkCanFocusTrap) {\n          checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n          return this;\n        }\n        finishActivation();\n        return this;\n      },\n      deactivate: function deactivate(deactivateOptions) {\n        if (!state.active) {\n          return this;\n        }\n        clearTimeout(state.delayInitialFocusTimer);\n        state.delayInitialFocusTimer = void 0;\n        removeListeners();\n        state.active = false;\n        state.paused = false;\n        activeFocusTraps.deactivateTrap(trap);\n        var onDeactivate = getOption(deactivateOptions, \"onDeactivate\");\n        var onPostDeactivate = getOption(deactivateOptions, \"onPostDeactivate\");\n        var checkCanReturnFocus = getOption(deactivateOptions, \"checkCanReturnFocus\");\n        if (onDeactivate) {\n          onDeactivate();\n        }\n        var returnFocus = getOption(deactivateOptions, \"returnFocus\", \"returnFocusOnDeactivate\");\n        var finishDeactivation = function finishDeactivation2() {\n          delay(function() {\n            if (returnFocus) {\n              tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n            }\n            if (onPostDeactivate) {\n              onPostDeactivate();\n            }\n          });\n        };\n        if (returnFocus && checkCanReturnFocus) {\n          checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n          return this;\n        }\n        finishDeactivation();\n        return this;\n      },\n      pause: function pause() {\n        if (state.paused || !state.active) {\n          return this;\n        }\n        state.paused = true;\n        removeListeners();\n        return this;\n      },\n      unpause: function unpause() {\n        if (!state.paused || !state.active) {\n          return this;\n        }\n        state.paused = false;\n        updateTabbableNodes();\n        addListeners();\n        return this;\n      },\n      updateContainerElements: function updateContainerElements(containerElements) {\n        var elementsAsArray = [].concat(containerElements).filter(Boolean);\n        state.containers = elementsAsArray.map(function(element) {\n          return typeof element === \"string\" ? doc.querySelector(element) : element;\n        });\n        if (state.active) {\n          updateTabbableNodes();\n        }\n        return this;\n      }\n    };\n    trap.updateContainerElements(elements);\n    return trap;\n  };\n  exports.createFocusTrap = createFocusTrap2;\n});\n\n// packages/focus/src/index.js\nvar import_focus_trap = __toModule(require_focus_trap());\nvar import_tabbable = __toModule(require_dist());\nfunction src_default(Alpine) {\n  let lastFocused;\n  let currentFocused;\n  window.addEventListener(\"focusin\", () => {\n    lastFocused = currentFocused;\n    currentFocused = document.activeElement;\n  });\n  Alpine.magic(\"focus\", (el) => {\n    let within = el;\n    return {\n      __noscroll: false,\n      __wrapAround: false,\n      within(el2) {\n        within = el2;\n        return this;\n      },\n      withoutScrolling() {\n        this.__noscroll = true;\n        return this;\n      },\n      noscroll() {\n        this.__noscroll = true;\n        return this;\n      },\n      withWrapAround() {\n        this.__wrapAround = true;\n        return this;\n      },\n      wrap() {\n        return this.withWrapAround();\n      },\n      focusable(el2) {\n        return (0, import_tabbable.isFocusable)(el2);\n      },\n      previouslyFocused() {\n        return lastFocused;\n      },\n      lastFocused() {\n        return lastFocused;\n      },\n      focused() {\n        return currentFocused;\n      },\n      focusables() {\n        if (Array.isArray(within))\n          return within;\n        return (0, import_tabbable.focusable)(within, {displayCheck: \"none\"});\n      },\n      all() {\n        return this.focusables();\n      },\n      isFirst(el2) {\n        let els = this.all();\n        return els[0] && els[0].isSameNode(el2);\n      },\n      isLast(el2) {\n        let els = this.all();\n        return els.length && els.slice(-1)[0].isSameNode(el2);\n      },\n      getFirst() {\n        return this.all()[0];\n      },\n      getLast() {\n        return this.all().slice(-1)[0];\n      },\n      getNext() {\n        let list = this.all();\n        let current = document.activeElement;\n        if (list.indexOf(current) === -1)\n          return;\n        if (this.__wrapAround && list.indexOf(current) === list.length - 1) {\n          return list[0];\n        }\n        return list[list.indexOf(current) + 1];\n      },\n      getPrevious() {\n        let list = this.all();\n        let current = document.activeElement;\n        if (list.indexOf(current) === -1)\n          return;\n        if (this.__wrapAround && list.indexOf(current) === 0) {\n          return list.slice(-1)[0];\n        }\n        return list[list.indexOf(current) - 1];\n      },\n      first() {\n        this.focus(this.getFirst());\n      },\n      last() {\n        this.focus(this.getLast());\n      },\n      next() {\n        this.focus(this.getNext());\n      },\n      previous() {\n        this.focus(this.getPrevious());\n      },\n      prev() {\n        return this.previous();\n      },\n      focus(el2) {\n        if (!el2)\n          return;\n        setTimeout(() => {\n          if (!el2.hasAttribute(\"tabindex\"))\n            el2.setAttribute(\"tabindex\", \"0\");\n          el2.focus({preventScroll: this._noscroll});\n        });\n      }\n    };\n  });\n  Alpine.directive(\"trap\", Alpine.skipDuringClone((el, {expression, modifiers}, {effect, evaluateLater}) => {\n    let evaluator = evaluateLater(expression);\n    let oldValue = false;\n    let trap = (0, import_focus_trap.createFocusTrap)(el, {\n      escapeDeactivates: false,\n      allowOutsideClick: true,\n      fallbackFocus: () => el\n    });\n    let undoInert = () => {\n    };\n    let undoDisableScrolling = () => {\n    };\n    effect(() => evaluator((value) => {\n      if (oldValue === value)\n        return;\n      if (value && !oldValue) {\n        setTimeout(() => {\n          if (modifiers.includes(\"inert\"))\n            undoInert = setInert(el);\n          if (modifiers.includes(\"noscroll\"))\n            undoDisableScrolling = disableScrolling();\n          trap.activate();\n        });\n      }\n      if (!value && oldValue) {\n        undoInert();\n        undoInert = () => {\n        };\n        undoDisableScrolling();\n        undoDisableScrolling = () => {\n        };\n        trap.deactivate({\n          returnFocus: !modifiers.includes(\"noreturn\")\n        });\n      }\n      oldValue = !!value;\n    }));\n  }, (el, {expression, modifiers}, {evaluate}) => {\n    if (modifiers.includes(\"inert\") && evaluate(expression))\n      setInert(el);\n  }));\n}\nfunction setInert(el) {\n  let undos = [];\n  crawlSiblingsUp(el, (sibling) => {\n    let cache = sibling.hasAttribute(\"aria-hidden\");\n    sibling.setAttribute(\"aria-hidden\", \"true\");\n    undos.push(() => cache || sibling.removeAttribute(\"aria-hidden\"));\n  });\n  return () => {\n    while (undos.length)\n      undos.pop()();\n  };\n}\nfunction crawlSiblingsUp(el, callback) {\n  if (el.isSameNode(document.body) || !el.parentNode)\n    return;\n  Array.from(el.parentNode.children).forEach((sibling) => {\n    if (!sibling.isSameNode(el))\n      callback(sibling);\n    crawlSiblingsUp(el.parentNode, callback);\n  });\n}\nfunction disableScrolling() {\n  let overflow = document.documentElement.style.overflow;\n  let paddingRight = document.documentElement.style.paddingRight;\n  let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n  document.documentElement.style.overflow = \"hidden\";\n  document.documentElement.style.paddingRight = `${scrollbarWidth}px`;\n  return () => {\n    document.documentElement.style.overflow = overflow;\n    document.documentElement.style.paddingRight = paddingRight;\n  };\n}\n\n// packages/focus/builds/module.js\nvar module_default = src_default;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFscGluZWpzL2ZvY3VzL2Rpc3QvbW9kdWxlLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFlBQVk7QUFDOUU7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtGQUErRjtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyxtRUFBbUUsNkNBQTZDLEdBQUcsZ0NBQWdDO0FBQ3RQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQ0FBZ0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsYUFBYTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxxQkFBcUI7QUFDNUUsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhCQUE4QjtBQUNuRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSCx3REFBd0Qsc0JBQXNCLEdBQUcsc0JBQXNCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRyxRQUFRLHNCQUFzQixHQUFHLFNBQVM7QUFDN0M7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGVBQWU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFscGluZWpzL2ZvY3VzL2Rpc3QvbW9kdWxlLmVzbS5qcz8yNzUxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG52YXIgX19jb21tb25KUyA9IChjYWxsYmFjaywgbW9kdWxlKSA9PiAoKSA9PiB7XG4gIGlmICghbW9kdWxlKSB7XG4gICAgbW9kdWxlID0ge2V4cG9ydHM6IHt9fTtcbiAgICBjYWxsYmFjayhtb2R1bGUuZXhwb3J0cywgbW9kdWxlKTtcbiAgfVxuICByZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59O1xudmFyIF9fZXhwb3J0U3RhciA9ICh0YXJnZXQsIG1vZHVsZSwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlICYmIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHtnZXQ6ICgpID0+IG1vZHVsZVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUpID0+IHtcbiAgcmV0dXJuIF9fZXhwb3J0U3RhcihfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUgPyB7Z2V0OiAoKSA9PiBtb2R1bGUuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZX0gOiB7dmFsdWU6IG1vZHVsZSwgZW51bWVyYWJsZTogdHJ1ZX0pKSwgbW9kdWxlKTtcbn07XG5cbi8vIG5vZGVfbW9kdWxlcy90YWJiYWJsZS9kaXN0L2luZGV4LmpzXG52YXIgcmVxdWlyZV9kaXN0ID0gX19jb21tb25KUygoZXhwb3J0cykgPT4ge1xuICAvKiFcbiAgKiB0YWJiYWJsZSA1LjIuMVxuICAqIEBsaWNlbnNlIE1JVCwgaHR0cHM6Ly9naXRodWIuY29tL2ZvY3VzLXRyYXAvdGFiYmFibGUvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICAqL1xuICBcInVzZSBzdHJpY3RcIjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KTtcbiAgdmFyIGNhbmRpZGF0ZVNlbGVjdG9ycyA9IFtcImlucHV0XCIsIFwic2VsZWN0XCIsIFwidGV4dGFyZWFcIiwgXCJhW2hyZWZdXCIsIFwiYnV0dG9uXCIsIFwiW3RhYmluZGV4XVwiLCBcImF1ZGlvW2NvbnRyb2xzXVwiLCBcInZpZGVvW2NvbnRyb2xzXVwiLCAnW2NvbnRlbnRlZGl0YWJsZV06bm90KFtjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXSknLCBcImRldGFpbHM+c3VtbWFyeTpmaXJzdC1vZi10eXBlXCIsIFwiZGV0YWlsc1wiXTtcbiAgdmFyIGNhbmRpZGF0ZVNlbGVjdG9yID0gLyogQF9fUFVSRV9fICovIGNhbmRpZGF0ZVNlbGVjdG9ycy5qb2luKFwiLFwiKTtcbiAgdmFyIG1hdGNoZXMgPSB0eXBlb2YgRWxlbWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IGZ1bmN0aW9uKCkge1xuICB9IDogRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG4gIHZhciBnZXRDYW5kaWRhdGVzID0gZnVuY3Rpb24gZ2V0Q2FuZGlkYXRlczIoZWwsIGluY2x1ZGVDb250YWluZXIsIGZpbHRlcikge1xuICAgIHZhciBjYW5kaWRhdGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGVsLnF1ZXJ5U2VsZWN0b3JBbGwoY2FuZGlkYXRlU2VsZWN0b3IpKTtcbiAgICBpZiAoaW5jbHVkZUNvbnRhaW5lciAmJiBtYXRjaGVzLmNhbGwoZWwsIGNhbmRpZGF0ZVNlbGVjdG9yKSkge1xuICAgICAgY2FuZGlkYXRlcy51bnNoaWZ0KGVsKTtcbiAgICB9XG4gICAgY2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMuZmlsdGVyKGZpbHRlcik7XG4gICAgcmV0dXJuIGNhbmRpZGF0ZXM7XG4gIH07XG4gIHZhciBpc0NvbnRlbnRFZGl0YWJsZSA9IGZ1bmN0aW9uIGlzQ29udGVudEVkaXRhYmxlMihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuY29udGVudEVkaXRhYmxlID09PSBcInRydWVcIjtcbiAgfTtcbiAgdmFyIGdldFRhYmluZGV4ID0gZnVuY3Rpb24gZ2V0VGFiaW5kZXgyKG5vZGUpIHtcbiAgICB2YXIgdGFiaW5kZXhBdHRyID0gcGFyc2VJbnQobm9kZS5nZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKSwgMTApO1xuICAgIGlmICghaXNOYU4odGFiaW5kZXhBdHRyKSkge1xuICAgICAgcmV0dXJuIHRhYmluZGV4QXR0cjtcbiAgICB9XG4gICAgaWYgKGlzQ29udGVudEVkaXRhYmxlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKChub2RlLm5vZGVOYW1lID09PSBcIkFVRElPXCIgfHwgbm9kZS5ub2RlTmFtZSA9PT0gXCJWSURFT1wiIHx8IG5vZGUubm9kZU5hbWUgPT09IFwiREVUQUlMU1wiKSAmJiBub2RlLmdldEF0dHJpYnV0ZShcInRhYmluZGV4XCIpID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUudGFiSW5kZXg7XG4gIH07XG4gIHZhciBzb3J0T3JkZXJlZFRhYmJhYmxlcyA9IGZ1bmN0aW9uIHNvcnRPcmRlcmVkVGFiYmFibGVzMihhLCBiKSB7XG4gICAgcmV0dXJuIGEudGFiSW5kZXggPT09IGIudGFiSW5kZXggPyBhLmRvY3VtZW50T3JkZXIgLSBiLmRvY3VtZW50T3JkZXIgOiBhLnRhYkluZGV4IC0gYi50YWJJbmRleDtcbiAgfTtcbiAgdmFyIGlzSW5wdXQgPSBmdW5jdGlvbiBpc0lucHV0Mihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gXCJJTlBVVFwiO1xuICB9O1xuICB2YXIgaXNIaWRkZW5JbnB1dCA9IGZ1bmN0aW9uIGlzSGlkZGVuSW5wdXQyKG5vZGUpIHtcbiAgICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09IFwiaGlkZGVuXCI7XG4gIH07XG4gIHZhciBpc0RldGFpbHNXaXRoU3VtbWFyeSA9IGZ1bmN0aW9uIGlzRGV0YWlsc1dpdGhTdW1tYXJ5Mihub2RlKSB7XG4gICAgdmFyIHIgPSBub2RlLnRhZ05hbWUgPT09IFwiREVUQUlMU1wiICYmIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShub2RlLmNoaWxkcmVuKS5zb21lKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQudGFnTmFtZSA9PT0gXCJTVU1NQVJZXCI7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG4gIH07XG4gIHZhciBnZXRDaGVja2VkUmFkaW8gPSBmdW5jdGlvbiBnZXRDaGVja2VkUmFkaW8yKG5vZGVzLCBmb3JtKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG5vZGVzW2ldLmNoZWNrZWQgJiYgbm9kZXNbaV0uZm9ybSA9PT0gZm9ybSkge1xuICAgICAgICByZXR1cm4gbm9kZXNbaV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgaXNUYWJiYWJsZVJhZGlvID0gZnVuY3Rpb24gaXNUYWJiYWJsZVJhZGlvMihub2RlKSB7XG4gICAgaWYgKCFub2RlLm5hbWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgcmFkaW9TY29wZSA9IG5vZGUuZm9ybSB8fCBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgdmFyIHF1ZXJ5UmFkaW9zID0gZnVuY3Rpb24gcXVlcnlSYWRpb3MyKG5hbWUpIHtcbiAgICAgIHJldHVybiByYWRpb1Njb3BlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJyYWRpb1wiXVtuYW1lPVwiJyArIG5hbWUgKyAnXCJdJyk7XG4gICAgfTtcbiAgICB2YXIgcmFkaW9TZXQ7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5DU1MgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5DU1MuZXNjYXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJhZGlvU2V0ID0gcXVlcnlSYWRpb3Mod2luZG93LkNTUy5lc2NhcGUobm9kZS5uYW1lKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJhZGlvU2V0ID0gcXVlcnlSYWRpb3Mobm9kZS5uYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTG9va3MgbGlrZSB5b3UgaGF2ZSBhIHJhZGlvIGJ1dHRvbiB3aXRoIGEgbmFtZSBhdHRyaWJ1dGUgY29udGFpbmluZyBpbnZhbGlkIENTUyBzZWxlY3RvciBjaGFyYWN0ZXJzIGFuZCBuZWVkIHRoZSBDU1MuZXNjYXBlIHBvbHlmaWxsOiAlc1wiLCBlcnIubWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNoZWNrZWQgPSBnZXRDaGVja2VkUmFkaW8ocmFkaW9TZXQsIG5vZGUuZm9ybSk7XG4gICAgcmV0dXJuICFjaGVja2VkIHx8IGNoZWNrZWQgPT09IG5vZGU7XG4gIH07XG4gIHZhciBpc1JhZGlvID0gZnVuY3Rpb24gaXNSYWRpbzIobm9kZSkge1xuICAgIHJldHVybiBpc0lucHV0KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gXCJyYWRpb1wiO1xuICB9O1xuICB2YXIgaXNOb25UYWJiYWJsZVJhZGlvID0gZnVuY3Rpb24gaXNOb25UYWJiYWJsZVJhZGlvMihub2RlKSB7XG4gICAgcmV0dXJuIGlzUmFkaW8obm9kZSkgJiYgIWlzVGFiYmFibGVSYWRpbyhub2RlKTtcbiAgfTtcbiAgdmFyIGlzSGlkZGVuID0gZnVuY3Rpb24gaXNIaWRkZW4yKG5vZGUsIGRpc3BsYXlDaGVjaykge1xuICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKG5vZGUpLnZpc2liaWxpdHkgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgaXNEaXJlY3RTdW1tYXJ5ID0gbWF0Y2hlcy5jYWxsKG5vZGUsIFwiZGV0YWlscz5zdW1tYXJ5OmZpcnN0LW9mLXR5cGVcIik7XG4gICAgdmFyIG5vZGVVbmRlckRldGFpbHMgPSBpc0RpcmVjdFN1bW1hcnkgPyBub2RlLnBhcmVudEVsZW1lbnQgOiBub2RlO1xuICAgIGlmIChtYXRjaGVzLmNhbGwobm9kZVVuZGVyRGV0YWlscywgXCJkZXRhaWxzOm5vdChbb3Blbl0pICpcIikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWRpc3BsYXlDaGVjayB8fCBkaXNwbGF5Q2hlY2sgPT09IFwiZnVsbFwiKSB7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5kaXNwbGF5ID09PSBcIm5vbmVcIikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXNwbGF5Q2hlY2sgPT09IFwibm9uLXplcm8tYXJlYVwiKSB7XG4gICAgICB2YXIgX25vZGUkZ2V0Qm91bmRpbmdDbGllID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgd2lkdGggPSBfbm9kZSRnZXRCb3VuZGluZ0NsaWUud2lkdGgsIGhlaWdodCA9IF9ub2RlJGdldEJvdW5kaW5nQ2xpZS5oZWlnaHQ7XG4gICAgICByZXR1cm4gd2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIHZhciBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0ID0gZnVuY3Rpb24gaXNEaXNhYmxlZEZyb21GaWVsZHNldDIobm9kZSkge1xuICAgIGlmIChpc0lucHV0KG5vZGUpIHx8IG5vZGUudGFnTmFtZSA9PT0gXCJTRUxFQ1RcIiB8fCBub2RlLnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIiB8fCBub2RlLnRhZ05hbWUgPT09IFwiQlVUVE9OXCIpIHtcbiAgICAgIHZhciBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgd2hpbGUgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUudGFnTmFtZSA9PT0gXCJGSUVMRFNFVFwiICYmIHBhcmVudE5vZGUuZGlzYWJsZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHBhcmVudE5vZGUuY2hpbGRyZW4uaXRlbShpKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC50YWdOYW1lID09PSBcIkxFR0VORFwiKSB7XG4gICAgICAgICAgICAgIGlmIChjaGlsZC5jb250YWlucyhub2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICB2YXIgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZSA9IGZ1bmN0aW9uIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUyKG9wdGlvbnMsIG5vZGUpIHtcbiAgICBpZiAobm9kZS5kaXNhYmxlZCB8fCBpc0hpZGRlbklucHV0KG5vZGUpIHx8IGlzSGlkZGVuKG5vZGUsIG9wdGlvbnMuZGlzcGxheUNoZWNrKSB8fCBpc0RldGFpbHNXaXRoU3VtbWFyeShub2RlKSB8fCBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0KG5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICB2YXIgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlID0gZnVuY3Rpb24gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlMihvcHRpb25zLCBub2RlKSB7XG4gICAgaWYgKCFpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG9wdGlvbnMsIG5vZGUpIHx8IGlzTm9uVGFiYmFibGVSYWRpbyhub2RlKSB8fCBnZXRUYWJpbmRleChub2RlKSA8IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIHZhciB0YWJiYWJsZTIgPSBmdW5jdGlvbiB0YWJiYWJsZTMoZWwsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgcmVndWxhclRhYmJhYmxlcyA9IFtdO1xuICAgIHZhciBvcmRlcmVkVGFiYmFibGVzID0gW107XG4gICAgdmFyIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKGVsLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpKTtcbiAgICBjYW5kaWRhdGVzLmZvckVhY2goZnVuY3Rpb24oY2FuZGlkYXRlLCBpKSB7XG4gICAgICB2YXIgY2FuZGlkYXRlVGFiaW5kZXggPSBnZXRUYWJpbmRleChjYW5kaWRhdGUpO1xuICAgICAgaWYgKGNhbmRpZGF0ZVRhYmluZGV4ID09PSAwKSB7XG4gICAgICAgIHJlZ3VsYXJUYWJiYWJsZXMucHVzaChjYW5kaWRhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3JkZXJlZFRhYmJhYmxlcy5wdXNoKHtcbiAgICAgICAgICBkb2N1bWVudE9yZGVyOiBpLFxuICAgICAgICAgIHRhYkluZGV4OiBjYW5kaWRhdGVUYWJpbmRleCxcbiAgICAgICAgICBub2RlOiBjYW5kaWRhdGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHRhYmJhYmxlTm9kZXMgPSBvcmRlcmVkVGFiYmFibGVzLnNvcnQoc29ydE9yZGVyZWRUYWJiYWJsZXMpLm1hcChmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gYS5ub2RlO1xuICAgIH0pLmNvbmNhdChyZWd1bGFyVGFiYmFibGVzKTtcbiAgICByZXR1cm4gdGFiYmFibGVOb2RlcztcbiAgfTtcbiAgdmFyIGZvY3VzYWJsZTIgPSBmdW5jdGlvbiBmb2N1c2FibGUzKGVsLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKGVsLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUuYmluZChudWxsLCBvcHRpb25zKSk7XG4gICAgcmV0dXJuIGNhbmRpZGF0ZXM7XG4gIH07XG4gIHZhciBpc1RhYmJhYmxlID0gZnVuY3Rpb24gaXNUYWJiYWJsZTIobm9kZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghbm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbm9kZSBwcm92aWRlZFwiKTtcbiAgICB9XG4gICAgaWYgKG1hdGNoZXMuY2FsbChub2RlLCBjYW5kaWRhdGVTZWxlY3RvcikgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUob3B0aW9ucywgbm9kZSk7XG4gIH07XG4gIHZhciBmb2N1c2FibGVDYW5kaWRhdGVTZWxlY3RvciA9IC8qIEBfX1BVUkVfXyAqLyBjYW5kaWRhdGVTZWxlY3RvcnMuY29uY2F0KFwiaWZyYW1lXCIpLmpvaW4oXCIsXCIpO1xuICB2YXIgaXNGb2N1c2FibGUyID0gZnVuY3Rpb24gaXNGb2N1c2FibGUzKG5vZGUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG5vZGUgcHJvdmlkZWRcIik7XG4gICAgfVxuICAgIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgZm9jdXNhYmxlQ2FuZGlkYXRlU2VsZWN0b3IpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKTtcbiAgfTtcbiAgZXhwb3J0cy5mb2N1c2FibGUgPSBmb2N1c2FibGUyO1xuICBleHBvcnRzLmlzRm9jdXNhYmxlID0gaXNGb2N1c2FibGUyO1xuICBleHBvcnRzLmlzVGFiYmFibGUgPSBpc1RhYmJhYmxlO1xuICBleHBvcnRzLnRhYmJhYmxlID0gdGFiYmFibGUyO1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9mb2N1cy10cmFwL2Rpc3QvZm9jdXMtdHJhcC5qc1xudmFyIHJlcXVpcmVfZm9jdXNfdHJhcCA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgLyohXG4gICogZm9jdXMtdHJhcCA2LjYuMVxuICAqIEBsaWNlbnNlIE1JVCwgaHR0cHM6Ly9naXRodWIuY29tL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gICovXG4gIFwidXNlIHN0cmljdFwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICB2YXIgdGFiYmFibGUyID0gcmVxdWlyZV9kaXN0KCk7XG4gIGZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHtcbiAgICAgICAgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG4gIH1cbiAgZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgICAgaWYgKGkgJSAyKSB7XG4gICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIHZhciBhY3RpdmVGb2N1c1RyYXBzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRyYXBRdWV1ZSA9IFtdO1xuICAgIHJldHVybiB7XG4gICAgICBhY3RpdmF0ZVRyYXA6IGZ1bmN0aW9uIGFjdGl2YXRlVHJhcCh0cmFwKSB7XG4gICAgICAgIGlmICh0cmFwUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBhY3RpdmVUcmFwID0gdHJhcFF1ZXVlW3RyYXBRdWV1ZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAoYWN0aXZlVHJhcCAhPT0gdHJhcCkge1xuICAgICAgICAgICAgYWN0aXZlVHJhcC5wYXVzZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJhcEluZGV4ID0gdHJhcFF1ZXVlLmluZGV4T2YodHJhcCk7XG4gICAgICAgIGlmICh0cmFwSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgdHJhcFF1ZXVlLnB1c2godHJhcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJhcFF1ZXVlLnNwbGljZSh0cmFwSW5kZXgsIDEpO1xuICAgICAgICAgIHRyYXBRdWV1ZS5wdXNoKHRyYXApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVhY3RpdmF0ZVRyYXA6IGZ1bmN0aW9uIGRlYWN0aXZhdGVUcmFwKHRyYXApIHtcbiAgICAgICAgdmFyIHRyYXBJbmRleCA9IHRyYXBRdWV1ZS5pbmRleE9mKHRyYXApO1xuICAgICAgICBpZiAodHJhcEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHRyYXBRdWV1ZS5zcGxpY2UodHJhcEluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhcFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0cmFwUXVldWVbdHJhcFF1ZXVlLmxlbmd0aCAtIDFdLnVucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0oKTtcbiAgdmFyIGlzU2VsZWN0YWJsZUlucHV0ID0gZnVuY3Rpb24gaXNTZWxlY3RhYmxlSW5wdXQyKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiYgdHlwZW9mIG5vZGUuc2VsZWN0ID09PSBcImZ1bmN0aW9uXCI7XG4gIH07XG4gIHZhciBpc0VzY2FwZUV2ZW50ID0gZnVuY3Rpb24gaXNFc2NhcGVFdmVudDIoZSkge1xuICAgIHJldHVybiBlLmtleSA9PT0gXCJFc2NhcGVcIiB8fCBlLmtleSA9PT0gXCJFc2NcIiB8fCBlLmtleUNvZGUgPT09IDI3O1xuICB9O1xuICB2YXIgaXNUYWJFdmVudCA9IGZ1bmN0aW9uIGlzVGFiRXZlbnQyKGUpIHtcbiAgICByZXR1cm4gZS5rZXkgPT09IFwiVGFiXCIgfHwgZS5rZXlDb2RlID09PSA5O1xuICB9O1xuICB2YXIgZGVsYXkgPSBmdW5jdGlvbiBkZWxheTIoZm4pIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChmbiwgMCk7XG4gIH07XG4gIHZhciBmaW5kSW5kZXggPSBmdW5jdGlvbiBmaW5kSW5kZXgyKGFyciwgZm4pIHtcbiAgICB2YXIgaWR4ID0gLTE7XG4gICAgYXJyLmV2ZXJ5KGZ1bmN0aW9uKHZhbHVlLCBpKSB7XG4gICAgICBpZiAoZm4odmFsdWUpKSB7XG4gICAgICAgIGlkeCA9IGk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBpZHg7XG4gIH07XG4gIHZhciB2YWx1ZU9ySGFuZGxlciA9IGZ1bmN0aW9uIHZhbHVlT3JIYW5kbGVyMih2YWx1ZSkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXJhbXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcGFyYW1zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gdmFsdWUuYXBwbHkodm9pZCAwLCBwYXJhbXMpIDogdmFsdWU7XG4gIH07XG4gIHZhciBjcmVhdGVGb2N1c1RyYXAyID0gZnVuY3Rpb24gY3JlYXRlRm9jdXNUcmFwMyhlbGVtZW50cywgdXNlck9wdGlvbnMpIHtcbiAgICB2YXIgZG9jID0gZG9jdW1lbnQ7XG4gICAgdmFyIGNvbmZpZyA9IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgIHJldHVybkZvY3VzT25EZWFjdGl2YXRlOiB0cnVlLFxuICAgICAgZXNjYXBlRGVhY3RpdmF0ZXM6IHRydWUsXG4gICAgICBkZWxheUluaXRpYWxGb2N1czogdHJ1ZVxuICAgIH0sIHVzZXJPcHRpb25zKTtcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBjb250YWluZXJzOiBbXSxcbiAgICAgIHRhYmJhYmxlR3JvdXBzOiBbXSxcbiAgICAgIG5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbjogbnVsbCxcbiAgICAgIG1vc3RSZWNlbnRseUZvY3VzZWROb2RlOiBudWxsLFxuICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgIHBhdXNlZDogZmFsc2UsXG4gICAgICBkZWxheUluaXRpYWxGb2N1c1RpbWVyOiB2b2lkIDBcbiAgICB9O1xuICAgIHZhciB0cmFwO1xuICAgIHZhciBnZXRPcHRpb24gPSBmdW5jdGlvbiBnZXRPcHRpb24yKGNvbmZpZ092ZXJyaWRlT3B0aW9ucywgb3B0aW9uTmFtZSwgY29uZmlnT3B0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIGNvbmZpZ092ZXJyaWRlT3B0aW9ucyAmJiBjb25maWdPdmVycmlkZU9wdGlvbnNbb3B0aW9uTmFtZV0gIT09IHZvaWQgMCA/IGNvbmZpZ092ZXJyaWRlT3B0aW9uc1tvcHRpb25OYW1lXSA6IGNvbmZpZ1tjb25maWdPcHRpb25OYW1lIHx8IG9wdGlvbk5hbWVdO1xuICAgIH07XG4gICAgdmFyIGNvbnRhaW5lcnNDb250YWluID0gZnVuY3Rpb24gY29udGFpbmVyc0NvbnRhaW4yKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5jb250YWluZXJzLnNvbWUoZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXIuY29udGFpbnMoZWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBnZXROb2RlRm9yT3B0aW9uID0gZnVuY3Rpb24gZ2V0Tm9kZUZvck9wdGlvbjIob3B0aW9uTmFtZSkge1xuICAgICAgdmFyIG9wdGlvblZhbHVlID0gY29uZmlnW29wdGlvbk5hbWVdO1xuICAgICAgaWYgKCFvcHRpb25WYWx1ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBub2RlID0gb3B0aW9uVmFsdWU7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvblZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG5vZGUgPSBkb2MucXVlcnlTZWxlY3RvcihvcHRpb25WYWx1ZSk7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBcIi5jb25jYXQob3B0aW9uTmFtZSwgXCJgIHJlZmVycyB0byBubyBrbm93biBub2RlXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25WYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG5vZGUgPSBvcHRpb25WYWx1ZSgpO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgXCIuY29uY2F0KG9wdGlvbk5hbWUsIFwiYCBkaWQgbm90IHJldHVybiBhIG5vZGVcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIHZhciBnZXRJbml0aWFsRm9jdXNOb2RlID0gZnVuY3Rpb24gZ2V0SW5pdGlhbEZvY3VzTm9kZTIoKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIGlmIChnZXRPcHRpb24oe30sIFwiaW5pdGlhbEZvY3VzXCIpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZ2V0Tm9kZUZvck9wdGlvbihcImluaXRpYWxGb2N1c1wiKSAhPT0gbnVsbCkge1xuICAgICAgICBub2RlID0gZ2V0Tm9kZUZvck9wdGlvbihcImluaXRpYWxGb2N1c1wiKTtcbiAgICAgIH0gZWxzZSBpZiAoY29udGFpbmVyc0NvbnRhaW4oZG9jLmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgIG5vZGUgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmaXJzdFRhYmJhYmxlR3JvdXAgPSBzdGF0ZS50YWJiYWJsZUdyb3Vwc1swXTtcbiAgICAgICAgdmFyIGZpcnN0VGFiYmFibGVOb2RlID0gZmlyc3RUYWJiYWJsZUdyb3VwICYmIGZpcnN0VGFiYmFibGVHcm91cC5maXJzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgbm9kZSA9IGZpcnN0VGFiYmFibGVOb2RlIHx8IGdldE5vZGVGb3JPcHRpb24oXCJmYWxsYmFja0ZvY3VzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdXIgZm9jdXMtdHJhcCBuZWVkcyB0byBoYXZlIGF0IGxlYXN0IG9uZSBmb2N1c2FibGUgZWxlbWVudFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgdmFyIHVwZGF0ZVRhYmJhYmxlTm9kZXMgPSBmdW5jdGlvbiB1cGRhdGVUYWJiYWJsZU5vZGVzMigpIHtcbiAgICAgIHN0YXRlLnRhYmJhYmxlR3JvdXBzID0gc3RhdGUuY29udGFpbmVycy5tYXAoZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgICAgIHZhciB0YWJiYWJsZU5vZGVzID0gdGFiYmFibGUyLnRhYmJhYmxlKGNvbnRhaW5lcik7XG4gICAgICAgIGlmICh0YWJiYWJsZU5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgZmlyc3RUYWJiYWJsZU5vZGU6IHRhYmJhYmxlTm9kZXNbMF0sXG4gICAgICAgICAgICBsYXN0VGFiYmFibGVOb2RlOiB0YWJiYWJsZU5vZGVzW3RhYmJhYmxlTm9kZXMubGVuZ3RoIC0gMV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuICEhZ3JvdXA7XG4gICAgICB9KTtcbiAgICAgIGlmIChzdGF0ZS50YWJiYWJsZUdyb3Vwcy5sZW5ndGggPD0gMCAmJiAhZ2V0Tm9kZUZvck9wdGlvbihcImZhbGxiYWNrRm9jdXNcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91ciBmb2N1cy10cmFwIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgY29udGFpbmVyIHdpdGggYXQgbGVhc3Qgb25lIHRhYmJhYmxlIG5vZGUgaW4gaXQgYXQgYWxsIHRpbWVzXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHRyeUZvY3VzID0gZnVuY3Rpb24gdHJ5Rm9jdXMyKG5vZGUpIHtcbiAgICAgIGlmIChub2RlID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gZG9jLmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFub2RlIHx8ICFub2RlLmZvY3VzKSB7XG4gICAgICAgIHRyeUZvY3VzMihnZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlLmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogISFjb25maWcucHJldmVudFNjcm9sbFxuICAgICAgfSk7XG4gICAgICBzdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSA9IG5vZGU7XG4gICAgICBpZiAoaXNTZWxlY3RhYmxlSW5wdXQobm9kZSkpIHtcbiAgICAgICAgbm9kZS5zZWxlY3QoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBnZXRSZXR1cm5Gb2N1c05vZGUgPSBmdW5jdGlvbiBnZXRSZXR1cm5Gb2N1c05vZGUyKHByZXZpb3VzQWN0aXZlRWxlbWVudCkge1xuICAgICAgdmFyIG5vZGUgPSBnZXROb2RlRm9yT3B0aW9uKFwic2V0UmV0dXJuRm9jdXNcIik7XG4gICAgICByZXR1cm4gbm9kZSA/IG5vZGUgOiBwcmV2aW91c0FjdGl2ZUVsZW1lbnQ7XG4gICAgfTtcbiAgICB2YXIgY2hlY2tQb2ludGVyRG93biA9IGZ1bmN0aW9uIGNoZWNrUG9pbnRlckRvd24yKGUpIHtcbiAgICAgIGlmIChjb250YWluZXJzQ29udGFpbihlLnRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlT3JIYW5kbGVyKGNvbmZpZy5jbGlja091dHNpZGVEZWFjdGl2YXRlcywgZSkpIHtcbiAgICAgICAgdHJhcC5kZWFjdGl2YXRlKHtcbiAgICAgICAgICByZXR1cm5Gb2N1czogY29uZmlnLnJldHVybkZvY3VzT25EZWFjdGl2YXRlICYmICF0YWJiYWJsZTIuaXNGb2N1c2FibGUoZS50YXJnZXQpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVPckhhbmRsZXIoY29uZmlnLmFsbG93T3V0c2lkZUNsaWNrLCBlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICB2YXIgY2hlY2tGb2N1c0luID0gZnVuY3Rpb24gY2hlY2tGb2N1c0luMihlKSB7XG4gICAgICB2YXIgdGFyZ2V0Q29udGFpbmVkID0gY29udGFpbmVyc0NvbnRhaW4oZS50YXJnZXQpO1xuICAgICAgaWYgKHRhcmdldENvbnRhaW5lZCB8fCBlLnRhcmdldCBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICAgIGlmICh0YXJnZXRDb250YWluZWQpIHtcbiAgICAgICAgICBzdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSA9IGUudGFyZ2V0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB0cnlGb2N1cyhzdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSB8fCBnZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGNoZWNrVGFiID0gZnVuY3Rpb24gY2hlY2tUYWIyKGUpIHtcbiAgICAgIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKTtcbiAgICAgIHZhciBkZXN0aW5hdGlvbk5vZGUgPSBudWxsO1xuICAgICAgaWYgKHN0YXRlLnRhYmJhYmxlR3JvdXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lckluZGV4ID0gZmluZEluZGV4KHN0YXRlLnRhYmJhYmxlR3JvdXBzLCBmdW5jdGlvbihfcmVmKSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IF9yZWYuY29udGFpbmVyO1xuICAgICAgICAgIHJldHVybiBjb250YWluZXIuY29udGFpbnMoZS50YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbnRhaW5lckluZGV4IDwgMCkge1xuICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbk5vZGUgPSBzdGF0ZS50YWJiYWJsZUdyb3Vwc1tzdGF0ZS50YWJiYWJsZUdyb3Vwcy5sZW5ndGggLSAxXS5sYXN0VGFiYmFibGVOb2RlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbk5vZGUgPSBzdGF0ZS50YWJiYWJsZUdyb3Vwc1swXS5maXJzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgIHZhciBzdGFydE9mR3JvdXBJbmRleCA9IGZpbmRJbmRleChzdGF0ZS50YWJiYWJsZUdyb3VwcywgZnVuY3Rpb24oX3JlZjIpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdFRhYmJhYmxlTm9kZSA9IF9yZWYyLmZpcnN0VGFiYmFibGVOb2RlO1xuICAgICAgICAgICAgcmV0dXJuIGUudGFyZ2V0ID09PSBmaXJzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoc3RhcnRPZkdyb3VwSW5kZXggPCAwICYmIHN0YXRlLnRhYmJhYmxlR3JvdXBzW2NvbnRhaW5lckluZGV4XS5jb250YWluZXIgPT09IGUudGFyZ2V0KSB7XG4gICAgICAgICAgICBzdGFydE9mR3JvdXBJbmRleCA9IGNvbnRhaW5lckluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhcnRPZkdyb3VwSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdmFyIGRlc3RpbmF0aW9uR3JvdXBJbmRleCA9IHN0YXJ0T2ZHcm91cEluZGV4ID09PSAwID8gc3RhdGUudGFiYmFibGVHcm91cHMubGVuZ3RoIC0gMSA6IHN0YXJ0T2ZHcm91cEluZGV4IC0gMTtcbiAgICAgICAgICAgIHZhciBkZXN0aW5hdGlvbkdyb3VwID0gc3RhdGUudGFiYmFibGVHcm91cHNbZGVzdGluYXRpb25Hcm91cEluZGV4XTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uTm9kZSA9IGRlc3RpbmF0aW9uR3JvdXAubGFzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGxhc3RPZkdyb3VwSW5kZXggPSBmaW5kSW5kZXgoc3RhdGUudGFiYmFibGVHcm91cHMsIGZ1bmN0aW9uKF9yZWYzKSB7XG4gICAgICAgICAgICB2YXIgbGFzdFRhYmJhYmxlTm9kZSA9IF9yZWYzLmxhc3RUYWJiYWJsZU5vZGU7XG4gICAgICAgICAgICByZXR1cm4gZS50YXJnZXQgPT09IGxhc3RUYWJiYWJsZU5vZGU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGxhc3RPZkdyb3VwSW5kZXggPCAwICYmIHN0YXRlLnRhYmJhYmxlR3JvdXBzW2NvbnRhaW5lckluZGV4XS5jb250YWluZXIgPT09IGUudGFyZ2V0KSB7XG4gICAgICAgICAgICBsYXN0T2ZHcm91cEluZGV4ID0gY29udGFpbmVySW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsYXN0T2ZHcm91cEluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHZhciBfZGVzdGluYXRpb25Hcm91cEluZGV4ID0gbGFzdE9mR3JvdXBJbmRleCA9PT0gc3RhdGUudGFiYmFibGVHcm91cHMubGVuZ3RoIC0gMSA/IDAgOiBsYXN0T2ZHcm91cEluZGV4ICsgMTtcbiAgICAgICAgICAgIHZhciBfZGVzdGluYXRpb25Hcm91cCA9IHN0YXRlLnRhYmJhYmxlR3JvdXBzW19kZXN0aW5hdGlvbkdyb3VwSW5kZXhdO1xuICAgICAgICAgICAgZGVzdGluYXRpb25Ob2RlID0gX2Rlc3RpbmF0aW9uR3JvdXAuZmlyc3RUYWJiYWJsZU5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXN0aW5hdGlvbk5vZGUgPSBnZXROb2RlRm9yT3B0aW9uKFwiZmFsbGJhY2tGb2N1c1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZXN0aW5hdGlvbk5vZGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0cnlGb2N1cyhkZXN0aW5hdGlvbk5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGNoZWNrS2V5ID0gZnVuY3Rpb24gY2hlY2tLZXkyKGUpIHtcbiAgICAgIGlmIChpc0VzY2FwZUV2ZW50KGUpICYmIHZhbHVlT3JIYW5kbGVyKGNvbmZpZy5lc2NhcGVEZWFjdGl2YXRlcykgIT09IGZhbHNlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdHJhcC5kZWFjdGl2YXRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RhYkV2ZW50KGUpKSB7XG4gICAgICAgIGNoZWNrVGFiKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgY2hlY2tDbGljayA9IGZ1bmN0aW9uIGNoZWNrQ2xpY2syKGUpIHtcbiAgICAgIGlmICh2YWx1ZU9ySGFuZGxlcihjb25maWcuY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMsIGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjb250YWluZXJzQ29udGFpbihlLnRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlT3JIYW5kbGVyKGNvbmZpZy5hbGxvd091dHNpZGVDbGljaywgZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB9O1xuICAgIHZhciBhZGRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcnMyKCkge1xuICAgICAgaWYgKCFzdGF0ZS5hY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYWN0aXZlRm9jdXNUcmFwcy5hY3RpdmF0ZVRyYXAodHJhcCk7XG4gICAgICBzdGF0ZS5kZWxheUluaXRpYWxGb2N1c1RpbWVyID0gY29uZmlnLmRlbGF5SW5pdGlhbEZvY3VzID8gZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeUZvY3VzKGdldEluaXRpYWxGb2N1c05vZGUoKSk7XG4gICAgICB9KSA6IHRyeUZvY3VzKGdldEluaXRpYWxGb2N1c05vZGUoKSk7XG4gICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgY2hlY2tGb2N1c0luLCB0cnVlKTtcbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGNoZWNrUG9pbnRlckRvd24sIHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIGNoZWNrUG9pbnRlckRvd24sIHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBjaGVja0NsaWNrLCB7XG4gICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBjaGVja0tleSwge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJhcDtcbiAgICB9O1xuICAgIHZhciByZW1vdmVMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMyKCkge1xuICAgICAgaWYgKCFzdGF0ZS5hY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIGNoZWNrRm9jdXNJbiwgdHJ1ZSk7XG4gICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBjaGVja1BvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBjaGVja1BvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgY2hlY2tDbGljaywgdHJ1ZSk7XG4gICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgY2hlY2tLZXksIHRydWUpO1xuICAgICAgcmV0dXJuIHRyYXA7XG4gICAgfTtcbiAgICB0cmFwID0ge1xuICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uIGFjdGl2YXRlKGFjdGl2YXRlT3B0aW9ucykge1xuICAgICAgICBpZiAoc3RhdGUuYWN0aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9uQWN0aXZhdGUgPSBnZXRPcHRpb24oYWN0aXZhdGVPcHRpb25zLCBcIm9uQWN0aXZhdGVcIik7XG4gICAgICAgIHZhciBvblBvc3RBY3RpdmF0ZSA9IGdldE9wdGlvbihhY3RpdmF0ZU9wdGlvbnMsIFwib25Qb3N0QWN0aXZhdGVcIik7XG4gICAgICAgIHZhciBjaGVja0NhbkZvY3VzVHJhcCA9IGdldE9wdGlvbihhY3RpdmF0ZU9wdGlvbnMsIFwiY2hlY2tDYW5Gb2N1c1RyYXBcIik7XG4gICAgICAgIGlmICghY2hlY2tDYW5Gb2N1c1RyYXApIHtcbiAgICAgICAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLm5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbiA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICAgICAgICBpZiAob25BY3RpdmF0ZSkge1xuICAgICAgICAgIG9uQWN0aXZhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmluaXNoQWN0aXZhdGlvbiA9IGZ1bmN0aW9uIGZpbmlzaEFjdGl2YXRpb24yKCkge1xuICAgICAgICAgIGlmIChjaGVja0NhbkZvY3VzVHJhcCkge1xuICAgICAgICAgICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICBpZiAob25Qb3N0QWN0aXZhdGUpIHtcbiAgICAgICAgICAgIG9uUG9zdEFjdGl2YXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY2hlY2tDYW5Gb2N1c1RyYXApIHtcbiAgICAgICAgICBjaGVja0NhbkZvY3VzVHJhcChzdGF0ZS5jb250YWluZXJzLmNvbmNhdCgpKS50aGVuKGZpbmlzaEFjdGl2YXRpb24sIGZpbmlzaEFjdGl2YXRpb24pO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGZpbmlzaEFjdGl2YXRpb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZGVhY3RpdmF0ZTogZnVuY3Rpb24gZGVhY3RpdmF0ZShkZWFjdGl2YXRlT3B0aW9ucykge1xuICAgICAgICBpZiAoIXN0YXRlLmFjdGl2ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dChzdGF0ZS5kZWxheUluaXRpYWxGb2N1c1RpbWVyKTtcbiAgICAgICAgc3RhdGUuZGVsYXlJbml0aWFsRm9jdXNUaW1lciA9IHZvaWQgMDtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgIHN0YXRlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgYWN0aXZlRm9jdXNUcmFwcy5kZWFjdGl2YXRlVHJhcCh0cmFwKTtcbiAgICAgICAgdmFyIG9uRGVhY3RpdmF0ZSA9IGdldE9wdGlvbihkZWFjdGl2YXRlT3B0aW9ucywgXCJvbkRlYWN0aXZhdGVcIik7XG4gICAgICAgIHZhciBvblBvc3REZWFjdGl2YXRlID0gZ2V0T3B0aW9uKGRlYWN0aXZhdGVPcHRpb25zLCBcIm9uUG9zdERlYWN0aXZhdGVcIik7XG4gICAgICAgIHZhciBjaGVja0NhblJldHVybkZvY3VzID0gZ2V0T3B0aW9uKGRlYWN0aXZhdGVPcHRpb25zLCBcImNoZWNrQ2FuUmV0dXJuRm9jdXNcIik7XG4gICAgICAgIGlmIChvbkRlYWN0aXZhdGUpIHtcbiAgICAgICAgICBvbkRlYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV0dXJuRm9jdXMgPSBnZXRPcHRpb24oZGVhY3RpdmF0ZU9wdGlvbnMsIFwicmV0dXJuRm9jdXNcIiwgXCJyZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZVwiKTtcbiAgICAgICAgdmFyIGZpbmlzaERlYWN0aXZhdGlvbiA9IGZ1bmN0aW9uIGZpbmlzaERlYWN0aXZhdGlvbjIoKSB7XG4gICAgICAgICAgZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAocmV0dXJuRm9jdXMpIHtcbiAgICAgICAgICAgICAgdHJ5Rm9jdXMoZ2V0UmV0dXJuRm9jdXNOb2RlKHN0YXRlLm5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uUG9zdERlYWN0aXZhdGUpIHtcbiAgICAgICAgICAgICAgb25Qb3N0RGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocmV0dXJuRm9jdXMgJiYgY2hlY2tDYW5SZXR1cm5Gb2N1cykge1xuICAgICAgICAgIGNoZWNrQ2FuUmV0dXJuRm9jdXMoZ2V0UmV0dXJuRm9jdXNOb2RlKHN0YXRlLm5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbikpLnRoZW4oZmluaXNoRGVhY3RpdmF0aW9uLCBmaW5pc2hEZWFjdGl2YXRpb24pO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGZpbmlzaERlYWN0aXZhdGlvbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICAgIGlmIChzdGF0ZS5wYXVzZWQgfHwgIXN0YXRlLmFjdGl2ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnBhdXNlZCA9IHRydWU7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICB1bnBhdXNlOiBmdW5jdGlvbiB1bnBhdXNlKCkge1xuICAgICAgICBpZiAoIXN0YXRlLnBhdXNlZCB8fCAhc3RhdGUuYWN0aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKTtcbiAgICAgICAgYWRkTGlzdGVuZXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZUNvbnRhaW5lckVsZW1lbnRzOiBmdW5jdGlvbiB1cGRhdGVDb250YWluZXJFbGVtZW50cyhjb250YWluZXJFbGVtZW50cykge1xuICAgICAgICB2YXIgZWxlbWVudHNBc0FycmF5ID0gW10uY29uY2F0KGNvbnRhaW5lckVsZW1lbnRzKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgIHN0YXRlLmNvbnRhaW5lcnMgPSBlbGVtZW50c0FzQXJyYXkubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIGVsZW1lbnQgPT09IFwic3RyaW5nXCIgPyBkb2MucXVlcnlTZWxlY3RvcihlbGVtZW50KSA6IGVsZW1lbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3RhdGUuYWN0aXZlKSB7XG4gICAgICAgICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG4gICAgdHJhcC51cGRhdGVDb250YWluZXJFbGVtZW50cyhlbGVtZW50cyk7XG4gICAgcmV0dXJuIHRyYXA7XG4gIH07XG4gIGV4cG9ydHMuY3JlYXRlRm9jdXNUcmFwID0gY3JlYXRlRm9jdXNUcmFwMjtcbn0pO1xuXG4vLyBwYWNrYWdlcy9mb2N1cy9zcmMvaW5kZXguanNcbnZhciBpbXBvcnRfZm9jdXNfdHJhcCA9IF9fdG9Nb2R1bGUocmVxdWlyZV9mb2N1c190cmFwKCkpO1xudmFyIGltcG9ydF90YWJiYWJsZSA9IF9fdG9Nb2R1bGUocmVxdWlyZV9kaXN0KCkpO1xuZnVuY3Rpb24gc3JjX2RlZmF1bHQoQWxwaW5lKSB7XG4gIGxldCBsYXN0Rm9jdXNlZDtcbiAgbGV0IGN1cnJlbnRGb2N1c2VkO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgKCkgPT4ge1xuICAgIGxhc3RGb2N1c2VkID0gY3VycmVudEZvY3VzZWQ7XG4gICAgY3VycmVudEZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICB9KTtcbiAgQWxwaW5lLm1hZ2ljKFwiZm9jdXNcIiwgKGVsKSA9PiB7XG4gICAgbGV0IHdpdGhpbiA9IGVsO1xuICAgIHJldHVybiB7XG4gICAgICBfX25vc2Nyb2xsOiBmYWxzZSxcbiAgICAgIF9fd3JhcEFyb3VuZDogZmFsc2UsXG4gICAgICB3aXRoaW4oZWwyKSB7XG4gICAgICAgIHdpdGhpbiA9IGVsMjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgd2l0aG91dFNjcm9sbGluZygpIHtcbiAgICAgICAgdGhpcy5fX25vc2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgbm9zY3JvbGwoKSB7XG4gICAgICAgIHRoaXMuX19ub3Njcm9sbCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHdpdGhXcmFwQXJvdW5kKCkge1xuICAgICAgICB0aGlzLl9fd3JhcEFyb3VuZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHdyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhXcmFwQXJvdW5kKCk7XG4gICAgICB9LFxuICAgICAgZm9jdXNhYmxlKGVsMikge1xuICAgICAgICByZXR1cm4gKDAsIGltcG9ydF90YWJiYWJsZS5pc0ZvY3VzYWJsZSkoZWwyKTtcbiAgICAgIH0sXG4gICAgICBwcmV2aW91c2x5Rm9jdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIGxhc3RGb2N1c2VkO1xuICAgICAgfSxcbiAgICAgIGxhc3RGb2N1c2VkKCkge1xuICAgICAgICByZXR1cm4gbGFzdEZvY3VzZWQ7XG4gICAgICB9LFxuICAgICAgZm9jdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRGb2N1c2VkO1xuICAgICAgfSxcbiAgICAgIGZvY3VzYWJsZXMoKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHdpdGhpbikpXG4gICAgICAgICAgcmV0dXJuIHdpdGhpbjtcbiAgICAgICAgcmV0dXJuICgwLCBpbXBvcnRfdGFiYmFibGUuZm9jdXNhYmxlKSh3aXRoaW4sIHtkaXNwbGF5Q2hlY2s6IFwibm9uZVwifSk7XG4gICAgICB9LFxuICAgICAgYWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb2N1c2FibGVzKCk7XG4gICAgICB9LFxuICAgICAgaXNGaXJzdChlbDIpIHtcbiAgICAgICAgbGV0IGVscyA9IHRoaXMuYWxsKCk7XG4gICAgICAgIHJldHVybiBlbHNbMF0gJiYgZWxzWzBdLmlzU2FtZU5vZGUoZWwyKTtcbiAgICAgIH0sXG4gICAgICBpc0xhc3QoZWwyKSB7XG4gICAgICAgIGxldCBlbHMgPSB0aGlzLmFsbCgpO1xuICAgICAgICByZXR1cm4gZWxzLmxlbmd0aCAmJiBlbHMuc2xpY2UoLTEpWzBdLmlzU2FtZU5vZGUoZWwyKTtcbiAgICAgIH0sXG4gICAgICBnZXRGaXJzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsKClbMF07XG4gICAgICB9LFxuICAgICAgZ2V0TGFzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsKCkuc2xpY2UoLTEpWzBdO1xuICAgICAgfSxcbiAgICAgIGdldE5leHQoKSB7XG4gICAgICAgIGxldCBsaXN0ID0gdGhpcy5hbGwoKTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICBpZiAobGlzdC5pbmRleE9mKGN1cnJlbnQpID09PSAtMSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLl9fd3JhcEFyb3VuZCAmJiBsaXN0LmluZGV4T2YoY3VycmVudCkgPT09IGxpc3QubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHJldHVybiBsaXN0WzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0W2xpc3QuaW5kZXhPZihjdXJyZW50KSArIDFdO1xuICAgICAgfSxcbiAgICAgIGdldFByZXZpb3VzKCkge1xuICAgICAgICBsZXQgbGlzdCA9IHRoaXMuYWxsKCk7XG4gICAgICAgIGxldCBjdXJyZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgaWYgKGxpc3QuaW5kZXhPZihjdXJyZW50KSA9PT0gLTEpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5fX3dyYXBBcm91bmQgJiYgbGlzdC5pbmRleE9mKGN1cnJlbnQpID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGxpc3Quc2xpY2UoLTEpWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0W2xpc3QuaW5kZXhPZihjdXJyZW50KSAtIDFdO1xuICAgICAgfSxcbiAgICAgIGZpcnN0KCkge1xuICAgICAgICB0aGlzLmZvY3VzKHRoaXMuZ2V0Rmlyc3QoKSk7XG4gICAgICB9LFxuICAgICAgbGFzdCgpIHtcbiAgICAgICAgdGhpcy5mb2N1cyh0aGlzLmdldExhc3QoKSk7XG4gICAgICB9LFxuICAgICAgbmV4dCgpIHtcbiAgICAgICAgdGhpcy5mb2N1cyh0aGlzLmdldE5leHQoKSk7XG4gICAgICB9LFxuICAgICAgcHJldmlvdXMoKSB7XG4gICAgICAgIHRoaXMuZm9jdXModGhpcy5nZXRQcmV2aW91cygpKTtcbiAgICAgIH0sXG4gICAgICBwcmV2KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpO1xuICAgICAgfSxcbiAgICAgIGZvY3VzKGVsMikge1xuICAgICAgICBpZiAoIWVsMilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICghZWwyLmhhc0F0dHJpYnV0ZShcInRhYmluZGV4XCIpKVxuICAgICAgICAgICAgZWwyLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKTtcbiAgICAgICAgICBlbDIuZm9jdXMoe3ByZXZlbnRTY3JvbGw6IHRoaXMuX25vc2Nyb2xsfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICBBbHBpbmUuZGlyZWN0aXZlKFwidHJhcFwiLCBBbHBpbmUuc2tpcER1cmluZ0Nsb25lKChlbCwge2V4cHJlc3Npb24sIG1vZGlmaWVyc30sIHtlZmZlY3QsIGV2YWx1YXRlTGF0ZXJ9KSA9PiB7XG4gICAgbGV0IGV2YWx1YXRvciA9IGV2YWx1YXRlTGF0ZXIoZXhwcmVzc2lvbik7XG4gICAgbGV0IG9sZFZhbHVlID0gZmFsc2U7XG4gICAgbGV0IHRyYXAgPSAoMCwgaW1wb3J0X2ZvY3VzX3RyYXAuY3JlYXRlRm9jdXNUcmFwKShlbCwge1xuICAgICAgZXNjYXBlRGVhY3RpdmF0ZXM6IGZhbHNlLFxuICAgICAgYWxsb3dPdXRzaWRlQ2xpY2s6IHRydWUsXG4gICAgICBmYWxsYmFja0ZvY3VzOiAoKSA9PiBlbFxuICAgIH0pO1xuICAgIGxldCB1bmRvSW5lcnQgPSAoKSA9PiB7XG4gICAgfTtcbiAgICBsZXQgdW5kb0Rpc2FibGVTY3JvbGxpbmcgPSAoKSA9PiB7XG4gICAgfTtcbiAgICBlZmZlY3QoKCkgPT4gZXZhbHVhdG9yKCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKG9sZFZhbHVlID09PSB2YWx1ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHZhbHVlICYmICFvbGRWYWx1ZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiaW5lcnRcIikpXG4gICAgICAgICAgICB1bmRvSW5lcnQgPSBzZXRJbmVydChlbCk7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcIm5vc2Nyb2xsXCIpKVxuICAgICAgICAgICAgdW5kb0Rpc2FibGVTY3JvbGxpbmcgPSBkaXNhYmxlU2Nyb2xsaW5nKCk7XG4gICAgICAgICAgdHJhcC5hY3RpdmF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsdWUgJiYgb2xkVmFsdWUpIHtcbiAgICAgICAgdW5kb0luZXJ0KCk7XG4gICAgICAgIHVuZG9JbmVydCA9ICgpID0+IHtcbiAgICAgICAgfTtcbiAgICAgICAgdW5kb0Rpc2FibGVTY3JvbGxpbmcoKTtcbiAgICAgICAgdW5kb0Rpc2FibGVTY3JvbGxpbmcgPSAoKSA9PiB7XG4gICAgICAgIH07XG4gICAgICAgIHRyYXAuZGVhY3RpdmF0ZSh7XG4gICAgICAgICAgcmV0dXJuRm9jdXM6ICFtb2RpZmllcnMuaW5jbHVkZXMoXCJub3JldHVyblwiKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG9sZFZhbHVlID0gISF2YWx1ZTtcbiAgICB9KSk7XG4gIH0sIChlbCwge2V4cHJlc3Npb24sIG1vZGlmaWVyc30sIHtldmFsdWF0ZX0pID0+IHtcbiAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiaW5lcnRcIikgJiYgZXZhbHVhdGUoZXhwcmVzc2lvbikpXG4gICAgICBzZXRJbmVydChlbCk7XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIHNldEluZXJ0KGVsKSB7XG4gIGxldCB1bmRvcyA9IFtdO1xuICBjcmF3bFNpYmxpbmdzVXAoZWwsIChzaWJsaW5nKSA9PiB7XG4gICAgbGV0IGNhY2hlID0gc2libGluZy5oYXNBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKTtcbiAgICBzaWJsaW5nLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICB1bmRvcy5wdXNoKCgpID0+IGNhY2hlIHx8IHNpYmxpbmcucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIikpO1xuICB9KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB3aGlsZSAodW5kb3MubGVuZ3RoKVxuICAgICAgdW5kb3MucG9wKCkoKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyYXdsU2libGluZ3NVcChlbCwgY2FsbGJhY2spIHtcbiAgaWYgKGVsLmlzU2FtZU5vZGUoZG9jdW1lbnQuYm9keSkgfHwgIWVsLnBhcmVudE5vZGUpXG4gICAgcmV0dXJuO1xuICBBcnJheS5mcm9tKGVsLnBhcmVudE5vZGUuY2hpbGRyZW4pLmZvckVhY2goKHNpYmxpbmcpID0+IHtcbiAgICBpZiAoIXNpYmxpbmcuaXNTYW1lTm9kZShlbCkpXG4gICAgICBjYWxsYmFjayhzaWJsaW5nKTtcbiAgICBjcmF3bFNpYmxpbmdzVXAoZWwucGFyZW50Tm9kZSwgY2FsbGJhY2spO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGRpc2FibGVTY3JvbGxpbmcoKSB7XG4gIGxldCBvdmVyZmxvdyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdztcbiAgbGV0IHBhZGRpbmdSaWdodCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQ7XG4gIGxldCBzY3JvbGxiYXJXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gYCR7c2Nyb2xsYmFyV2lkdGh9cHhgO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBwYWRkaW5nUmlnaHQ7XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2ZvY3VzL2J1aWxkcy9tb2R1bGUuanNcbnZhciBtb2R1bGVfZGVmYXVsdCA9IHNyY19kZWZhdWx0O1xuZXhwb3J0IHtcbiAgbW9kdWxlX2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@alpinejs/focus/dist/module.esm.js\n");

/***/ }),

/***/ "./node_modules/alpinejs/dist/module.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/alpinejs/dist/module.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ module_default)\n/* harmony export */ });\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", {value: true});\nvar __commonJS = (callback, module) => () => {\n  if (!module) {\n    module = {exports: {}};\n    callback(module.exports, module);\n  }\n  return module.exports;\n};\nvar __exportStar = (target, module, desc) => {\n  if (module && typeof module === \"object\" || typeof module === \"function\") {\n    for (let key of __getOwnPropNames(module))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, {get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable});\n  }\n  return target;\n};\nvar __toModule = (module) => {\n  return __exportStar(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, \"default\", module && module.__esModule && \"default\" in module ? {get: () => module.default, enumerable: true} : {value: module, enumerable: true})), module);\n};\n\n// node_modules/@vue/shared/dist/shared.cjs.js\nvar require_shared_cjs = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  function makeMap(str, expectsLowerCase) {\n    const map = Object.create(null);\n    const list = str.split(\",\");\n    for (let i = 0; i < list.length; i++) {\n      map[list[i]] = true;\n    }\n    return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];\n  }\n  var PatchFlagNames = {\n    [1]: `TEXT`,\n    [2]: `CLASS`,\n    [4]: `STYLE`,\n    [8]: `PROPS`,\n    [16]: `FULL_PROPS`,\n    [32]: `HYDRATE_EVENTS`,\n    [64]: `STABLE_FRAGMENT`,\n    [128]: `KEYED_FRAGMENT`,\n    [256]: `UNKEYED_FRAGMENT`,\n    [512]: `NEED_PATCH`,\n    [1024]: `DYNAMIC_SLOTS`,\n    [2048]: `DEV_ROOT_FRAGMENT`,\n    [-1]: `HOISTED`,\n    [-2]: `BAIL`\n  };\n  var slotFlagsText = {\n    [1]: \"STABLE\",\n    [2]: \"DYNAMIC\",\n    [3]: \"FORWARDED\"\n  };\n  var GLOBALS_WHITE_LISTED = \"Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt\";\n  var isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);\n  var range = 2;\n  function generateCodeFrame(source, start2 = 0, end = source.length) {\n    const lines = source.split(/\\r?\\n/);\n    let count = 0;\n    const res = [];\n    for (let i = 0; i < lines.length; i++) {\n      count += lines[i].length + 1;\n      if (count >= start2) {\n        for (let j = i - range; j <= i + range || end > count; j++) {\n          if (j < 0 || j >= lines.length)\n            continue;\n          const line = j + 1;\n          res.push(`${line}${\" \".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\n          const lineLength = lines[j].length;\n          if (j === i) {\n            const pad = start2 - (count - lineLength) + 1;\n            const length = Math.max(1, end > count ? lineLength - pad : end - start2);\n            res.push(`   |  ` + \" \".repeat(pad) + \"^\".repeat(length));\n          } else if (j > i) {\n            if (end > count) {\n              const length = Math.max(Math.min(end - count, lineLength), 1);\n              res.push(`   |  ` + \"^\".repeat(length));\n            }\n            count += lineLength + 1;\n          }\n        }\n        break;\n      }\n    }\n    return res.join(\"\\n\");\n  }\n  var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\n  var isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);\n  var isBooleanAttr2 = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);\n  var unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\n  var attrValidationCache = {};\n  function isSSRSafeAttrName(name) {\n    if (attrValidationCache.hasOwnProperty(name)) {\n      return attrValidationCache[name];\n    }\n    const isUnsafe = unsafeAttrCharRE.test(name);\n    if (isUnsafe) {\n      console.error(`unsafe attribute name: ${name}`);\n    }\n    return attrValidationCache[name] = !isUnsafe;\n  }\n  var propsToAttrMap = {\n    acceptCharset: \"accept-charset\",\n    className: \"class\",\n    htmlFor: \"for\",\n    httpEquiv: \"http-equiv\"\n  };\n  var isNoUnitNumericStyleProp = /* @__PURE__ */ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-miterlimit,stroke-opacity,stroke-width`);\n  var isKnownAttr = /* @__PURE__ */ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);\n  function normalizeStyle(value) {\n    if (isArray(value)) {\n      const res = {};\n      for (let i = 0; i < value.length; i++) {\n        const item = value[i];\n        const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);\n        if (normalized) {\n          for (const key in normalized) {\n            res[key] = normalized[key];\n          }\n        }\n      }\n      return res;\n    } else if (isObject(value)) {\n      return value;\n    }\n  }\n  var listDelimiterRE = /;(?![^(]*\\))/g;\n  var propertyDelimiterRE = /:(.+)/;\n  function parseStringStyle(cssText) {\n    const ret = {};\n    cssText.split(listDelimiterRE).forEach((item) => {\n      if (item) {\n        const tmp = item.split(propertyDelimiterRE);\n        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n      }\n    });\n    return ret;\n  }\n  function stringifyStyle(styles) {\n    let ret = \"\";\n    if (!styles) {\n      return ret;\n    }\n    for (const key in styles) {\n      const value = styles[key];\n      const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n      if (isString(value) || typeof value === \"number\" && isNoUnitNumericStyleProp(normalizedKey)) {\n        ret += `${normalizedKey}:${value};`;\n      }\n    }\n    return ret;\n  }\n  function normalizeClass(value) {\n    let res = \"\";\n    if (isString(value)) {\n      res = value;\n    } else if (isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        const normalized = normalizeClass(value[i]);\n        if (normalized) {\n          res += normalized + \" \";\n        }\n      }\n    } else if (isObject(value)) {\n      for (const name in value) {\n        if (value[name]) {\n          res += name + \" \";\n        }\n      }\n    }\n    return res.trim();\n  }\n  var HTML_TAGS = \"html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot\";\n  var SVG_TAGS = \"svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view\";\n  var VOID_TAGS = \"area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr\";\n  var isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);\n  var isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);\n  var isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);\n  var escapeRE = /[\"'&<>]/;\n  function escapeHtml(string) {\n    const str = \"\" + string;\n    const match = escapeRE.exec(str);\n    if (!match) {\n      return str;\n    }\n    let html = \"\";\n    let escaped;\n    let index;\n    let lastIndex = 0;\n    for (index = match.index; index < str.length; index++) {\n      switch (str.charCodeAt(index)) {\n        case 34:\n          escaped = \"&quot;\";\n          break;\n        case 38:\n          escaped = \"&amp;\";\n          break;\n        case 39:\n          escaped = \"&#39;\";\n          break;\n        case 60:\n          escaped = \"&lt;\";\n          break;\n        case 62:\n          escaped = \"&gt;\";\n          break;\n        default:\n          continue;\n      }\n      if (lastIndex !== index) {\n        html += str.substring(lastIndex, index);\n      }\n      lastIndex = index + 1;\n      html += escaped;\n    }\n    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;\n  }\n  var commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\n  function escapeHtmlComment(src) {\n    return src.replace(commentStripRE, \"\");\n  }\n  function looseCompareArrays(a, b) {\n    if (a.length !== b.length)\n      return false;\n    let equal = true;\n    for (let i = 0; equal && i < a.length; i++) {\n      equal = looseEqual(a[i], b[i]);\n    }\n    return equal;\n  }\n  function looseEqual(a, b) {\n    if (a === b)\n      return true;\n    let aValidType = isDate(a);\n    let bValidType = isDate(b);\n    if (aValidType || bValidType) {\n      return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n    }\n    aValidType = isArray(a);\n    bValidType = isArray(b);\n    if (aValidType || bValidType) {\n      return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n    }\n    aValidType = isObject(a);\n    bValidType = isObject(b);\n    if (aValidType || bValidType) {\n      if (!aValidType || !bValidType) {\n        return false;\n      }\n      const aKeysCount = Object.keys(a).length;\n      const bKeysCount = Object.keys(b).length;\n      if (aKeysCount !== bKeysCount) {\n        return false;\n      }\n      for (const key in a) {\n        const aHasKey = a.hasOwnProperty(key);\n        const bHasKey = b.hasOwnProperty(key);\n        if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {\n          return false;\n        }\n      }\n    }\n    return String(a) === String(b);\n  }\n  function looseIndexOf(arr, val) {\n    return arr.findIndex((item) => looseEqual(item, val));\n  }\n  var toDisplayString = (val) => {\n    return val == null ? \"\" : isObject(val) ? JSON.stringify(val, replacer, 2) : String(val);\n  };\n  var replacer = (_key, val) => {\n    if (isMap(val)) {\n      return {\n        [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {\n          entries[`${key} =>`] = val2;\n          return entries;\n        }, {})\n      };\n    } else if (isSet(val)) {\n      return {\n        [`Set(${val.size})`]: [...val.values()]\n      };\n    } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n      return String(val);\n    }\n    return val;\n  };\n  var babelParserDefaultPlugins = [\n    \"bigInt\",\n    \"optionalChaining\",\n    \"nullishCoalescingOperator\"\n  ];\n  var EMPTY_OBJ = Object.freeze({});\n  var EMPTY_ARR = Object.freeze([]);\n  var NOOP = () => {\n  };\n  var NO = () => false;\n  var onRE = /^on[^a-z]/;\n  var isOn = (key) => onRE.test(key);\n  var isModelListener = (key) => key.startsWith(\"onUpdate:\");\n  var extend = Object.assign;\n  var remove = (arr, el) => {\n    const i = arr.indexOf(el);\n    if (i > -1) {\n      arr.splice(i, 1);\n    }\n  };\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  var hasOwn = (val, key) => hasOwnProperty.call(val, key);\n  var isArray = Array.isArray;\n  var isMap = (val) => toTypeString(val) === \"[object Map]\";\n  var isSet = (val) => toTypeString(val) === \"[object Set]\";\n  var isDate = (val) => val instanceof Date;\n  var isFunction = (val) => typeof val === \"function\";\n  var isString = (val) => typeof val === \"string\";\n  var isSymbol = (val) => typeof val === \"symbol\";\n  var isObject = (val) => val !== null && typeof val === \"object\";\n  var isPromise = (val) => {\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\n  };\n  var objectToString = Object.prototype.toString;\n  var toTypeString = (value) => objectToString.call(value);\n  var toRawType = (value) => {\n    return toTypeString(value).slice(8, -1);\n  };\n  var isPlainObject = (val) => toTypeString(val) === \"[object Object]\";\n  var isIntegerKey = (key) => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && \"\" + parseInt(key, 10) === key;\n  var isReservedProp = /* @__PURE__ */ makeMap(\",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted\");\n  var cacheStringFunction = (fn) => {\n    const cache = Object.create(null);\n    return (str) => {\n      const hit = cache[str];\n      return hit || (cache[str] = fn(str));\n    };\n  };\n  var camelizeRE = /-(\\w)/g;\n  var camelize = cacheStringFunction((str) => {\n    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n  });\n  var hyphenateRE = /\\B([A-Z])/g;\n  var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \"-$1\").toLowerCase());\n  var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\n  var toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);\n  var hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\n  var invokeArrayFns = (fns, arg) => {\n    for (let i = 0; i < fns.length; i++) {\n      fns[i](arg);\n    }\n  };\n  var def = (obj, key, value) => {\n    Object.defineProperty(obj, key, {\n      configurable: true,\n      enumerable: false,\n      value\n    });\n  };\n  var toNumber = (val) => {\n    const n = parseFloat(val);\n    return isNaN(n) ? val : n;\n  };\n  var _globalThis;\n  var getGlobalThis = () => {\n    return _globalThis || (_globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : {});\n  };\n  exports.EMPTY_ARR = EMPTY_ARR;\n  exports.EMPTY_OBJ = EMPTY_OBJ;\n  exports.NO = NO;\n  exports.NOOP = NOOP;\n  exports.PatchFlagNames = PatchFlagNames;\n  exports.babelParserDefaultPlugins = babelParserDefaultPlugins;\n  exports.camelize = camelize;\n  exports.capitalize = capitalize;\n  exports.def = def;\n  exports.escapeHtml = escapeHtml;\n  exports.escapeHtmlComment = escapeHtmlComment;\n  exports.extend = extend;\n  exports.generateCodeFrame = generateCodeFrame;\n  exports.getGlobalThis = getGlobalThis;\n  exports.hasChanged = hasChanged;\n  exports.hasOwn = hasOwn;\n  exports.hyphenate = hyphenate;\n  exports.invokeArrayFns = invokeArrayFns;\n  exports.isArray = isArray;\n  exports.isBooleanAttr = isBooleanAttr2;\n  exports.isDate = isDate;\n  exports.isFunction = isFunction;\n  exports.isGloballyWhitelisted = isGloballyWhitelisted;\n  exports.isHTMLTag = isHTMLTag;\n  exports.isIntegerKey = isIntegerKey;\n  exports.isKnownAttr = isKnownAttr;\n  exports.isMap = isMap;\n  exports.isModelListener = isModelListener;\n  exports.isNoUnitNumericStyleProp = isNoUnitNumericStyleProp;\n  exports.isObject = isObject;\n  exports.isOn = isOn;\n  exports.isPlainObject = isPlainObject;\n  exports.isPromise = isPromise;\n  exports.isReservedProp = isReservedProp;\n  exports.isSSRSafeAttrName = isSSRSafeAttrName;\n  exports.isSVGTag = isSVGTag;\n  exports.isSet = isSet;\n  exports.isSpecialBooleanAttr = isSpecialBooleanAttr;\n  exports.isString = isString;\n  exports.isSymbol = isSymbol;\n  exports.isVoidTag = isVoidTag;\n  exports.looseEqual = looseEqual;\n  exports.looseIndexOf = looseIndexOf;\n  exports.makeMap = makeMap;\n  exports.normalizeClass = normalizeClass;\n  exports.normalizeStyle = normalizeStyle;\n  exports.objectToString = objectToString;\n  exports.parseStringStyle = parseStringStyle;\n  exports.propsToAttrMap = propsToAttrMap;\n  exports.remove = remove;\n  exports.slotFlagsText = slotFlagsText;\n  exports.stringifyStyle = stringifyStyle;\n  exports.toDisplayString = toDisplayString;\n  exports.toHandlerKey = toHandlerKey;\n  exports.toNumber = toNumber;\n  exports.toRawType = toRawType;\n  exports.toTypeString = toTypeString;\n});\n\n// node_modules/@vue/shared/index.js\nvar require_shared = __commonJS((exports, module) => {\n  \"use strict\";\n  if (false) {} else {\n    module.exports = require_shared_cjs();\n  }\n});\n\n// node_modules/@vue/reactivity/dist/reactivity.cjs.js\nvar require_reactivity_cjs = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  var shared = require_shared();\n  var targetMap = new WeakMap();\n  var effectStack = [];\n  var activeEffect;\n  var ITERATE_KEY = Symbol(\"iterate\");\n  var MAP_KEY_ITERATE_KEY = Symbol(\"Map key iterate\");\n  function isEffect(fn) {\n    return fn && fn._isEffect === true;\n  }\n  function effect3(fn, options = shared.EMPTY_OBJ) {\n    if (isEffect(fn)) {\n      fn = fn.raw;\n    }\n    const effect4 = createReactiveEffect(fn, options);\n    if (!options.lazy) {\n      effect4();\n    }\n    return effect4;\n  }\n  function stop2(effect4) {\n    if (effect4.active) {\n      cleanup(effect4);\n      if (effect4.options.onStop) {\n        effect4.options.onStop();\n      }\n      effect4.active = false;\n    }\n  }\n  var uid = 0;\n  function createReactiveEffect(fn, options) {\n    const effect4 = function reactiveEffect() {\n      if (!effect4.active) {\n        return fn();\n      }\n      if (!effectStack.includes(effect4)) {\n        cleanup(effect4);\n        try {\n          enableTracking();\n          effectStack.push(effect4);\n          activeEffect = effect4;\n          return fn();\n        } finally {\n          effectStack.pop();\n          resetTracking();\n          activeEffect = effectStack[effectStack.length - 1];\n        }\n      }\n    };\n    effect4.id = uid++;\n    effect4.allowRecurse = !!options.allowRecurse;\n    effect4._isEffect = true;\n    effect4.active = true;\n    effect4.raw = fn;\n    effect4.deps = [];\n    effect4.options = options;\n    return effect4;\n  }\n  function cleanup(effect4) {\n    const {deps} = effect4;\n    if (deps.length) {\n      for (let i = 0; i < deps.length; i++) {\n        deps[i].delete(effect4);\n      }\n      deps.length = 0;\n    }\n  }\n  var shouldTrack = true;\n  var trackStack = [];\n  function pauseTracking() {\n    trackStack.push(shouldTrack);\n    shouldTrack = false;\n  }\n  function enableTracking() {\n    trackStack.push(shouldTrack);\n    shouldTrack = true;\n  }\n  function resetTracking() {\n    const last = trackStack.pop();\n    shouldTrack = last === void 0 ? true : last;\n  }\n  function track(target, type, key) {\n    if (!shouldTrack || activeEffect === void 0) {\n      return;\n    }\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = new Set());\n    }\n    if (!dep.has(activeEffect)) {\n      dep.add(activeEffect);\n      activeEffect.deps.push(dep);\n      if (activeEffect.options.onTrack) {\n        activeEffect.options.onTrack({\n          effect: activeEffect,\n          target,\n          type,\n          key\n        });\n      }\n    }\n  }\n  function trigger(target, type, key, newValue, oldValue, oldTarget) {\n    const depsMap = targetMap.get(target);\n    if (!depsMap) {\n      return;\n    }\n    const effects = new Set();\n    const add2 = (effectsToAdd) => {\n      if (effectsToAdd) {\n        effectsToAdd.forEach((effect4) => {\n          if (effect4 !== activeEffect || effect4.allowRecurse) {\n            effects.add(effect4);\n          }\n        });\n      }\n    };\n    if (type === \"clear\") {\n      depsMap.forEach(add2);\n    } else if (key === \"length\" && shared.isArray(target)) {\n      depsMap.forEach((dep, key2) => {\n        if (key2 === \"length\" || key2 >= newValue) {\n          add2(dep);\n        }\n      });\n    } else {\n      if (key !== void 0) {\n        add2(depsMap.get(key));\n      }\n      switch (type) {\n        case \"add\":\n          if (!shared.isArray(target)) {\n            add2(depsMap.get(ITERATE_KEY));\n            if (shared.isMap(target)) {\n              add2(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          } else if (shared.isIntegerKey(key)) {\n            add2(depsMap.get(\"length\"));\n          }\n          break;\n        case \"delete\":\n          if (!shared.isArray(target)) {\n            add2(depsMap.get(ITERATE_KEY));\n            if (shared.isMap(target)) {\n              add2(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          }\n          break;\n        case \"set\":\n          if (shared.isMap(target)) {\n            add2(depsMap.get(ITERATE_KEY));\n          }\n          break;\n      }\n    }\n    const run = (effect4) => {\n      if (effect4.options.onTrigger) {\n        effect4.options.onTrigger({\n          effect: effect4,\n          target,\n          key,\n          type,\n          newValue,\n          oldValue,\n          oldTarget\n        });\n      }\n      if (effect4.options.scheduler) {\n        effect4.options.scheduler(effect4);\n      } else {\n        effect4();\n      }\n    };\n    effects.forEach(run);\n  }\n  var isNonTrackableKeys = /* @__PURE__ */ shared.makeMap(`__proto__,__v_isRef,__isVue`);\n  var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(shared.isSymbol));\n  var get2 = /* @__PURE__ */ createGetter();\n  var shallowGet = /* @__PURE__ */ createGetter(false, true);\n  var readonlyGet = /* @__PURE__ */ createGetter(true);\n  var shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);\n  var arrayInstrumentations = {};\n  [\"includes\", \"indexOf\", \"lastIndexOf\"].forEach((key) => {\n    const method = Array.prototype[key];\n    arrayInstrumentations[key] = function(...args) {\n      const arr = toRaw2(this);\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, \"get\", i + \"\");\n      }\n      const res = method.apply(arr, args);\n      if (res === -1 || res === false) {\n        return method.apply(arr, args.map(toRaw2));\n      } else {\n        return res;\n      }\n    };\n  });\n  [\"push\", \"pop\", \"shift\", \"unshift\", \"splice\"].forEach((key) => {\n    const method = Array.prototype[key];\n    arrayInstrumentations[key] = function(...args) {\n      pauseTracking();\n      const res = method.apply(this, args);\n      resetTracking();\n      return res;\n    };\n  });\n  function createGetter(isReadonly2 = false, shallow = false) {\n    return function get3(target, key, receiver) {\n      if (key === \"__v_isReactive\") {\n        return !isReadonly2;\n      } else if (key === \"__v_isReadonly\") {\n        return isReadonly2;\n      } else if (key === \"__v_raw\" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\n        return target;\n      }\n      const targetIsArray = shared.isArray(target);\n      if (!isReadonly2 && targetIsArray && shared.hasOwn(arrayInstrumentations, key)) {\n        return Reflect.get(arrayInstrumentations, key, receiver);\n      }\n      const res = Reflect.get(target, key, receiver);\n      if (shared.isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n        return res;\n      }\n      if (!isReadonly2) {\n        track(target, \"get\", key);\n      }\n      if (shallow) {\n        return res;\n      }\n      if (isRef(res)) {\n        const shouldUnwrap = !targetIsArray || !shared.isIntegerKey(key);\n        return shouldUnwrap ? res.value : res;\n      }\n      if (shared.isObject(res)) {\n        return isReadonly2 ? readonly(res) : reactive3(res);\n      }\n      return res;\n    };\n  }\n  var set2 = /* @__PURE__ */ createSetter();\n  var shallowSet = /* @__PURE__ */ createSetter(true);\n  function createSetter(shallow = false) {\n    return function set3(target, key, value, receiver) {\n      let oldValue = target[key];\n      if (!shallow) {\n        value = toRaw2(value);\n        oldValue = toRaw2(oldValue);\n        if (!shared.isArray(target) && isRef(oldValue) && !isRef(value)) {\n          oldValue.value = value;\n          return true;\n        }\n      }\n      const hadKey = shared.isArray(target) && shared.isIntegerKey(key) ? Number(key) < target.length : shared.hasOwn(target, key);\n      const result = Reflect.set(target, key, value, receiver);\n      if (target === toRaw2(receiver)) {\n        if (!hadKey) {\n          trigger(target, \"add\", key, value);\n        } else if (shared.hasChanged(value, oldValue)) {\n          trigger(target, \"set\", key, value, oldValue);\n        }\n      }\n      return result;\n    };\n  }\n  function deleteProperty(target, key) {\n    const hadKey = shared.hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n      trigger(target, \"delete\", key, void 0, oldValue);\n    }\n    return result;\n  }\n  function has(target, key) {\n    const result = Reflect.has(target, key);\n    if (!shared.isSymbol(key) || !builtInSymbols.has(key)) {\n      track(target, \"has\", key);\n    }\n    return result;\n  }\n  function ownKeys(target) {\n    track(target, \"iterate\", shared.isArray(target) ? \"length\" : ITERATE_KEY);\n    return Reflect.ownKeys(target);\n  }\n  var mutableHandlers = {\n    get: get2,\n    set: set2,\n    deleteProperty,\n    has,\n    ownKeys\n  };\n  var readonlyHandlers = {\n    get: readonlyGet,\n    set(target, key) {\n      {\n        console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n      }\n      return true;\n    },\n    deleteProperty(target, key) {\n      {\n        console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n      }\n      return true;\n    }\n  };\n  var shallowReactiveHandlers = shared.extend({}, mutableHandlers, {\n    get: shallowGet,\n    set: shallowSet\n  });\n  var shallowReadonlyHandlers = shared.extend({}, readonlyHandlers, {\n    get: shallowReadonlyGet\n  });\n  var toReactive = (value) => shared.isObject(value) ? reactive3(value) : value;\n  var toReadonly = (value) => shared.isObject(value) ? readonly(value) : value;\n  var toShallow = (value) => value;\n  var getProto = (v) => Reflect.getPrototypeOf(v);\n  function get$1(target, key, isReadonly2 = false, isShallow = false) {\n    target = target[\"__v_raw\"];\n    const rawTarget = toRaw2(target);\n    const rawKey = toRaw2(key);\n    if (key !== rawKey) {\n      !isReadonly2 && track(rawTarget, \"get\", key);\n    }\n    !isReadonly2 && track(rawTarget, \"get\", rawKey);\n    const {has: has2} = getProto(rawTarget);\n    const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;\n    if (has2.call(rawTarget, key)) {\n      return wrap(target.get(key));\n    } else if (has2.call(rawTarget, rawKey)) {\n      return wrap(target.get(rawKey));\n    } else if (target !== rawTarget) {\n      target.get(key);\n    }\n  }\n  function has$1(key, isReadonly2 = false) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw2(target);\n    const rawKey = toRaw2(key);\n    if (key !== rawKey) {\n      !isReadonly2 && track(rawTarget, \"has\", key);\n    }\n    !isReadonly2 && track(rawTarget, \"has\", rawKey);\n    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n  }\n  function size(target, isReadonly2 = false) {\n    target = target[\"__v_raw\"];\n    !isReadonly2 && track(toRaw2(target), \"iterate\", ITERATE_KEY);\n    return Reflect.get(target, \"size\", target);\n  }\n  function add(value) {\n    value = toRaw2(value);\n    const target = toRaw2(this);\n    const proto = getProto(target);\n    const hadKey = proto.has.call(target, value);\n    if (!hadKey) {\n      target.add(value);\n      trigger(target, \"add\", value, value);\n    }\n    return this;\n  }\n  function set$1(key, value) {\n    value = toRaw2(value);\n    const target = toRaw2(this);\n    const {has: has2, get: get3} = getProto(target);\n    let hadKey = has2.call(target, key);\n    if (!hadKey) {\n      key = toRaw2(key);\n      hadKey = has2.call(target, key);\n    } else {\n      checkIdentityKeys(target, has2, key);\n    }\n    const oldValue = get3.call(target, key);\n    target.set(key, value);\n    if (!hadKey) {\n      trigger(target, \"add\", key, value);\n    } else if (shared.hasChanged(value, oldValue)) {\n      trigger(target, \"set\", key, value, oldValue);\n    }\n    return this;\n  }\n  function deleteEntry(key) {\n    const target = toRaw2(this);\n    const {has: has2, get: get3} = getProto(target);\n    let hadKey = has2.call(target, key);\n    if (!hadKey) {\n      key = toRaw2(key);\n      hadKey = has2.call(target, key);\n    } else {\n      checkIdentityKeys(target, has2, key);\n    }\n    const oldValue = get3 ? get3.call(target, key) : void 0;\n    const result = target.delete(key);\n    if (hadKey) {\n      trigger(target, \"delete\", key, void 0, oldValue);\n    }\n    return result;\n  }\n  function clear() {\n    const target = toRaw2(this);\n    const hadItems = target.size !== 0;\n    const oldTarget = shared.isMap(target) ? new Map(target) : new Set(target);\n    const result = target.clear();\n    if (hadItems) {\n      trigger(target, \"clear\", void 0, void 0, oldTarget);\n    }\n    return result;\n  }\n  function createForEach(isReadonly2, isShallow) {\n    return function forEach(callback, thisArg) {\n      const observed = this;\n      const target = observed[\"__v_raw\"];\n      const rawTarget = toRaw2(target);\n      const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;\n      !isReadonly2 && track(rawTarget, \"iterate\", ITERATE_KEY);\n      return target.forEach((value, key) => {\n        return callback.call(thisArg, wrap(value), wrap(key), observed);\n      });\n    };\n  }\n  function createIterableMethod(method, isReadonly2, isShallow) {\n    return function(...args) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw2(target);\n      const targetIsMap = shared.isMap(rawTarget);\n      const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n      const isKeyOnly = method === \"keys\" && targetIsMap;\n      const innerIterator = target[method](...args);\n      const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;\n      !isReadonly2 && track(rawTarget, \"iterate\", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n      return {\n        next() {\n          const {value, done} = innerIterator.next();\n          return done ? {value, done} : {\n            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n            done\n          };\n        },\n        [Symbol.iterator]() {\n          return this;\n        }\n      };\n    };\n  }\n  function createReadonlyMethod(type) {\n    return function(...args) {\n      {\n        const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n        console.warn(`${shared.capitalize(type)} operation ${key}failed: target is readonly.`, toRaw2(this));\n      }\n      return type === \"delete\" ? false : this;\n    };\n  }\n  var mutableInstrumentations = {\n    get(key) {\n      return get$1(this, key);\n    },\n    get size() {\n      return size(this);\n    },\n    has: has$1,\n    add,\n    set: set$1,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  var shallowInstrumentations = {\n    get(key) {\n      return get$1(this, key, false, true);\n    },\n    get size() {\n      return size(this);\n    },\n    has: has$1,\n    add,\n    set: set$1,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  var readonlyInstrumentations = {\n    get(key) {\n      return get$1(this, key, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has$1.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, false)\n  };\n  var shallowReadonlyInstrumentations = {\n    get(key) {\n      return get$1(this, key, true, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has$1.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, true)\n  };\n  var iteratorMethods = [\"keys\", \"values\", \"entries\", Symbol.iterator];\n  iteratorMethods.forEach((method) => {\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\n    shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\n  });\n  function createInstrumentationGetter(isReadonly2, shallow) {\n    const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;\n    return (target, key, receiver) => {\n      if (key === \"__v_isReactive\") {\n        return !isReadonly2;\n      } else if (key === \"__v_isReadonly\") {\n        return isReadonly2;\n      } else if (key === \"__v_raw\") {\n        return target;\n      }\n      return Reflect.get(shared.hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n    };\n  }\n  var mutableCollectionHandlers = {\n    get: createInstrumentationGetter(false, false)\n  };\n  var shallowCollectionHandlers = {\n    get: createInstrumentationGetter(false, true)\n  };\n  var readonlyCollectionHandlers = {\n    get: createInstrumentationGetter(true, false)\n  };\n  var shallowReadonlyCollectionHandlers = {\n    get: createInstrumentationGetter(true, true)\n  };\n  function checkIdentityKeys(target, has2, key) {\n    const rawKey = toRaw2(key);\n    if (rawKey !== key && has2.call(target, rawKey)) {\n      const type = shared.toRawType(target);\n      console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);\n    }\n  }\n  var reactiveMap = new WeakMap();\n  var shallowReactiveMap = new WeakMap();\n  var readonlyMap = new WeakMap();\n  var shallowReadonlyMap = new WeakMap();\n  function targetTypeMap(rawType) {\n    switch (rawType) {\n      case \"Object\":\n      case \"Array\":\n        return 1;\n      case \"Map\":\n      case \"Set\":\n      case \"WeakMap\":\n      case \"WeakSet\":\n        return 2;\n      default:\n        return 0;\n    }\n  }\n  function getTargetType(value) {\n    return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 : targetTypeMap(shared.toRawType(value));\n  }\n  function reactive3(target) {\n    if (target && target[\"__v_isReadonly\"]) {\n      return target;\n    }\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n  }\n  function shallowReactive(target) {\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n  }\n  function readonly(target) {\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n  }\n  function shallowReadonly(target) {\n    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n  }\n  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n    if (!shared.isObject(target)) {\n      {\n        console.warn(`value cannot be made reactive: ${String(target)}`);\n      }\n      return target;\n    }\n    if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n      return target;\n    }\n    const existingProxy = proxyMap.get(target);\n    if (existingProxy) {\n      return existingProxy;\n    }\n    const targetType = getTargetType(target);\n    if (targetType === 0) {\n      return target;\n    }\n    const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);\n    proxyMap.set(target, proxy);\n    return proxy;\n  }\n  function isReactive2(value) {\n    if (isReadonly(value)) {\n      return isReactive2(value[\"__v_raw\"]);\n    }\n    return !!(value && value[\"__v_isReactive\"]);\n  }\n  function isReadonly(value) {\n    return !!(value && value[\"__v_isReadonly\"]);\n  }\n  function isProxy(value) {\n    return isReactive2(value) || isReadonly(value);\n  }\n  function toRaw2(observed) {\n    return observed && toRaw2(observed[\"__v_raw\"]) || observed;\n  }\n  function markRaw(value) {\n    shared.def(value, \"__v_skip\", true);\n    return value;\n  }\n  var convert = (val) => shared.isObject(val) ? reactive3(val) : val;\n  function isRef(r) {\n    return Boolean(r && r.__v_isRef === true);\n  }\n  function ref(value) {\n    return createRef(value);\n  }\n  function shallowRef(value) {\n    return createRef(value, true);\n  }\n  var RefImpl = class {\n    constructor(_rawValue, _shallow = false) {\n      this._rawValue = _rawValue;\n      this._shallow = _shallow;\n      this.__v_isRef = true;\n      this._value = _shallow ? _rawValue : convert(_rawValue);\n    }\n    get value() {\n      track(toRaw2(this), \"get\", \"value\");\n      return this._value;\n    }\n    set value(newVal) {\n      if (shared.hasChanged(toRaw2(newVal), this._rawValue)) {\n        this._rawValue = newVal;\n        this._value = this._shallow ? newVal : convert(newVal);\n        trigger(toRaw2(this), \"set\", \"value\", newVal);\n      }\n    }\n  };\n  function createRef(rawValue, shallow = false) {\n    if (isRef(rawValue)) {\n      return rawValue;\n    }\n    return new RefImpl(rawValue, shallow);\n  }\n  function triggerRef(ref2) {\n    trigger(toRaw2(ref2), \"set\", \"value\", ref2.value);\n  }\n  function unref(ref2) {\n    return isRef(ref2) ? ref2.value : ref2;\n  }\n  var shallowUnwrapHandlers = {\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n    set: (target, key, value, receiver) => {\n      const oldValue = target[key];\n      if (isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      } else {\n        return Reflect.set(target, key, value, receiver);\n      }\n    }\n  };\n  function proxyRefs(objectWithRefs) {\n    return isReactive2(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n  }\n  var CustomRefImpl = class {\n    constructor(factory) {\n      this.__v_isRef = true;\n      const {get: get3, set: set3} = factory(() => track(this, \"get\", \"value\"), () => trigger(this, \"set\", \"value\"));\n      this._get = get3;\n      this._set = set3;\n    }\n    get value() {\n      return this._get();\n    }\n    set value(newVal) {\n      this._set(newVal);\n    }\n  };\n  function customRef(factory) {\n    return new CustomRefImpl(factory);\n  }\n  function toRefs(object) {\n    if (!isProxy(object)) {\n      console.warn(`toRefs() expects a reactive object but received a plain one.`);\n    }\n    const ret = shared.isArray(object) ? new Array(object.length) : {};\n    for (const key in object) {\n      ret[key] = toRef(object, key);\n    }\n    return ret;\n  }\n  var ObjectRefImpl = class {\n    constructor(_object, _key) {\n      this._object = _object;\n      this._key = _key;\n      this.__v_isRef = true;\n    }\n    get value() {\n      return this._object[this._key];\n    }\n    set value(newVal) {\n      this._object[this._key] = newVal;\n    }\n  };\n  function toRef(object, key) {\n    return isRef(object[key]) ? object[key] : new ObjectRefImpl(object, key);\n  }\n  var ComputedRefImpl = class {\n    constructor(getter, _setter, isReadonly2) {\n      this._setter = _setter;\n      this._dirty = true;\n      this.__v_isRef = true;\n      this.effect = effect3(getter, {\n        lazy: true,\n        scheduler: () => {\n          if (!this._dirty) {\n            this._dirty = true;\n            trigger(toRaw2(this), \"set\", \"value\");\n          }\n        }\n      });\n      this[\"__v_isReadonly\"] = isReadonly2;\n    }\n    get value() {\n      const self2 = toRaw2(this);\n      if (self2._dirty) {\n        self2._value = this.effect();\n        self2._dirty = false;\n      }\n      track(self2, \"get\", \"value\");\n      return self2._value;\n    }\n    set value(newValue) {\n      this._setter(newValue);\n    }\n  };\n  function computed(getterOrOptions) {\n    let getter;\n    let setter;\n    if (shared.isFunction(getterOrOptions)) {\n      getter = getterOrOptions;\n      setter = () => {\n        console.warn(\"Write operation failed: computed value is readonly\");\n      };\n    } else {\n      getter = getterOrOptions.get;\n      setter = getterOrOptions.set;\n    }\n    return new ComputedRefImpl(getter, setter, shared.isFunction(getterOrOptions) || !getterOrOptions.set);\n  }\n  exports.ITERATE_KEY = ITERATE_KEY;\n  exports.computed = computed;\n  exports.customRef = customRef;\n  exports.effect = effect3;\n  exports.enableTracking = enableTracking;\n  exports.isProxy = isProxy;\n  exports.isReactive = isReactive2;\n  exports.isReadonly = isReadonly;\n  exports.isRef = isRef;\n  exports.markRaw = markRaw;\n  exports.pauseTracking = pauseTracking;\n  exports.proxyRefs = proxyRefs;\n  exports.reactive = reactive3;\n  exports.readonly = readonly;\n  exports.ref = ref;\n  exports.resetTracking = resetTracking;\n  exports.shallowReactive = shallowReactive;\n  exports.shallowReadonly = shallowReadonly;\n  exports.shallowRef = shallowRef;\n  exports.stop = stop2;\n  exports.toRaw = toRaw2;\n  exports.toRef = toRef;\n  exports.toRefs = toRefs;\n  exports.track = track;\n  exports.trigger = trigger;\n  exports.triggerRef = triggerRef;\n  exports.unref = unref;\n});\n\n// node_modules/@vue/reactivity/index.js\nvar require_reactivity = __commonJS((exports, module) => {\n  \"use strict\";\n  if (false) {} else {\n    module.exports = require_reactivity_cjs();\n  }\n});\n\n// packages/alpinejs/src/scheduler.js\nvar flushPending = false;\nvar flushing = false;\nvar queue = [];\nfunction scheduler(callback) {\n  queueJob(callback);\n}\nfunction queueJob(job) {\n  if (!queue.includes(job))\n    queue.push(job);\n  queueFlush();\n}\nfunction queueFlush() {\n  if (!flushing && !flushPending) {\n    flushPending = true;\n    queueMicrotask(flushJobs);\n  }\n}\nfunction flushJobs() {\n  flushPending = false;\n  flushing = true;\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n  queue.length = 0;\n  flushing = false;\n}\n\n// packages/alpinejs/src/reactivity.js\nvar reactive;\nvar effect;\nvar release;\nvar raw;\nvar shouldSchedule = true;\nfunction disableEffectScheduling(callback) {\n  shouldSchedule = false;\n  callback();\n  shouldSchedule = true;\n}\nfunction setReactivityEngine(engine) {\n  reactive = engine.reactive;\n  release = engine.release;\n  effect = (callback) => engine.effect(callback, {scheduler: (task) => {\n    if (shouldSchedule) {\n      scheduler(task);\n    } else {\n      task();\n    }\n  }});\n  raw = engine.raw;\n}\nfunction overrideEffect(override) {\n  effect = override;\n}\nfunction elementBoundEffect(el) {\n  let cleanup = () => {\n  };\n  let wrappedEffect = (callback) => {\n    let effectReference = effect(callback);\n    if (!el._x_effects) {\n      el._x_effects = new Set();\n      el._x_runEffects = () => {\n        el._x_effects.forEach((i) => i());\n      };\n    }\n    el._x_effects.add(effectReference);\n    cleanup = () => {\n      if (effectReference === void 0)\n        return;\n      el._x_effects.delete(effectReference);\n      release(effectReference);\n    };\n  };\n  return [wrappedEffect, () => {\n    cleanup();\n  }];\n}\n\n// packages/alpinejs/src/mutation.js\nvar onAttributeAddeds = [];\nvar onElRemoveds = [];\nvar onElAddeds = [];\nfunction onElAdded(callback) {\n  onElAddeds.push(callback);\n}\nfunction onElRemoved(callback) {\n  onElRemoveds.push(callback);\n}\nfunction onAttributesAdded(callback) {\n  onAttributeAddeds.push(callback);\n}\nfunction onAttributeRemoved(el, name, callback) {\n  if (!el._x_attributeCleanups)\n    el._x_attributeCleanups = {};\n  if (!el._x_attributeCleanups[name])\n    el._x_attributeCleanups[name] = [];\n  el._x_attributeCleanups[name].push(callback);\n}\nfunction cleanupAttributes(el, names) {\n  if (!el._x_attributeCleanups)\n    return;\n  Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {\n    if (names === void 0 || names.includes(name)) {\n      value.forEach((i) => i());\n      delete el._x_attributeCleanups[name];\n    }\n  });\n}\nvar observer = new MutationObserver(onMutate);\nvar currentlyObserving = false;\nfunction startObservingMutations() {\n  observer.observe(document, {subtree: true, childList: true, attributes: true, attributeOldValue: true});\n  currentlyObserving = true;\n}\nfunction stopObservingMutations() {\n  flushObserver();\n  observer.disconnect();\n  currentlyObserving = false;\n}\nvar recordQueue = [];\nvar willProcessRecordQueue = false;\nfunction flushObserver() {\n  recordQueue = recordQueue.concat(observer.takeRecords());\n  if (recordQueue.length && !willProcessRecordQueue) {\n    willProcessRecordQueue = true;\n    queueMicrotask(() => {\n      processRecordQueue();\n      willProcessRecordQueue = false;\n    });\n  }\n}\nfunction processRecordQueue() {\n  onMutate(recordQueue);\n  recordQueue.length = 0;\n}\nfunction mutateDom(callback) {\n  if (!currentlyObserving)\n    return callback();\n  stopObservingMutations();\n  let result = callback();\n  startObservingMutations();\n  return result;\n}\nvar isCollecting = false;\nvar deferredMutations = [];\nfunction deferMutations() {\n  isCollecting = true;\n}\nfunction flushAndStopDeferringMutations() {\n  isCollecting = false;\n  onMutate(deferredMutations);\n  deferredMutations = [];\n}\nfunction onMutate(mutations) {\n  if (isCollecting) {\n    deferredMutations = deferredMutations.concat(mutations);\n    return;\n  }\n  let addedNodes = [];\n  let removedNodes = [];\n  let addedAttributes = new Map();\n  let removedAttributes = new Map();\n  for (let i = 0; i < mutations.length; i++) {\n    if (mutations[i].target._x_ignoreMutationObserver)\n      continue;\n    if (mutations[i].type === \"childList\") {\n      mutations[i].addedNodes.forEach((node) => node.nodeType === 1 && addedNodes.push(node));\n      mutations[i].removedNodes.forEach((node) => node.nodeType === 1 && removedNodes.push(node));\n    }\n    if (mutations[i].type === \"attributes\") {\n      let el = mutations[i].target;\n      let name = mutations[i].attributeName;\n      let oldValue = mutations[i].oldValue;\n      let add = () => {\n        if (!addedAttributes.has(el))\n          addedAttributes.set(el, []);\n        addedAttributes.get(el).push({name, value: el.getAttribute(name)});\n      };\n      let remove = () => {\n        if (!removedAttributes.has(el))\n          removedAttributes.set(el, []);\n        removedAttributes.get(el).push(name);\n      };\n      if (el.hasAttribute(name) && oldValue === null) {\n        add();\n      } else if (el.hasAttribute(name)) {\n        remove();\n        add();\n      } else {\n        remove();\n      }\n    }\n  }\n  removedAttributes.forEach((attrs, el) => {\n    cleanupAttributes(el, attrs);\n  });\n  addedAttributes.forEach((attrs, el) => {\n    onAttributeAddeds.forEach((i) => i(el, attrs));\n  });\n  addedNodes.forEach((node) => {\n    node._x_ignoreSelf = true;\n    node._x_ignore = true;\n  });\n  for (let node of addedNodes) {\n    if (removedNodes.includes(node))\n      continue;\n    delete node._x_ignoreSelf;\n    delete node._x_ignore;\n    onElAddeds.forEach((i) => i(node));\n    node._x_ignore = true;\n    node._x_ignoreSelf = true;\n  }\n  addedNodes.forEach((node) => {\n    delete node._x_ignoreSelf;\n    delete node._x_ignore;\n  });\n  for (let node of removedNodes) {\n    if (addedNodes.includes(node))\n      continue;\n    onElRemoveds.forEach((i) => i(node));\n  }\n  addedNodes = null;\n  removedNodes = null;\n  addedAttributes = null;\n  removedAttributes = null;\n}\n\n// packages/alpinejs/src/scope.js\nfunction addScopeToNode(node, data2, referenceNode) {\n  node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];\n  return () => {\n    node._x_dataStack = node._x_dataStack.filter((i) => i !== data2);\n  };\n}\nfunction refreshScope(element, scope) {\n  let existingScope = element._x_dataStack[0];\n  Object.entries(scope).forEach(([key, value]) => {\n    existingScope[key] = value;\n  });\n}\nfunction closestDataStack(node) {\n  if (node._x_dataStack)\n    return node._x_dataStack;\n  if (typeof ShadowRoot === \"function\" && node instanceof ShadowRoot) {\n    return closestDataStack(node.host);\n  }\n  if (!node.parentNode) {\n    return [];\n  }\n  return closestDataStack(node.parentNode);\n}\nfunction mergeProxies(objects) {\n  let thisProxy = new Proxy({}, {\n    ownKeys: () => {\n      return Array.from(new Set(objects.flatMap((i) => Object.keys(i))));\n    },\n    has: (target, name) => {\n      return objects.some((obj) => obj.hasOwnProperty(name));\n    },\n    get: (target, name) => {\n      return (objects.find((obj) => {\n        if (obj.hasOwnProperty(name)) {\n          let descriptor = Object.getOwnPropertyDescriptor(obj, name);\n          if (descriptor.get && descriptor.get._x_alreadyBound || descriptor.set && descriptor.set._x_alreadyBound) {\n            return true;\n          }\n          if ((descriptor.get || descriptor.set) && descriptor.enumerable) {\n            let getter = descriptor.get;\n            let setter = descriptor.set;\n            let property = descriptor;\n            getter = getter && getter.bind(thisProxy);\n            setter = setter && setter.bind(thisProxy);\n            if (getter)\n              getter._x_alreadyBound = true;\n            if (setter)\n              setter._x_alreadyBound = true;\n            Object.defineProperty(obj, name, {\n              ...property,\n              get: getter,\n              set: setter\n            });\n          }\n          return true;\n        }\n        return false;\n      }) || {})[name];\n    },\n    set: (target, name, value) => {\n      let closestObjectWithKey = objects.find((obj) => obj.hasOwnProperty(name));\n      if (closestObjectWithKey) {\n        closestObjectWithKey[name] = value;\n      } else {\n        objects[objects.length - 1][name] = value;\n      }\n      return true;\n    }\n  });\n  return thisProxy;\n}\n\n// packages/alpinejs/src/interceptor.js\nfunction initInterceptors(data2) {\n  let isObject = (val) => typeof val === \"object\" && !Array.isArray(val) && val !== null;\n  let recurse = (obj, basePath = \"\") => {\n    Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, {value, enumerable}]) => {\n      if (enumerable === false || value === void 0)\n        return;\n      let path = basePath === \"\" ? key : `${basePath}.${key}`;\n      if (typeof value === \"object\" && value !== null && value._x_interceptor) {\n        obj[key] = value.initialize(data2, path, key);\n      } else {\n        if (isObject(value) && value !== obj && !(value instanceof Element)) {\n          recurse(value, path);\n        }\n      }\n    });\n  };\n  return recurse(data2);\n}\nfunction interceptor(callback, mutateObj = () => {\n}) {\n  let obj = {\n    initialValue: void 0,\n    _x_interceptor: true,\n    initialize(data2, path, key) {\n      return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);\n    }\n  };\n  mutateObj(obj);\n  return (initialValue) => {\n    if (typeof initialValue === \"object\" && initialValue !== null && initialValue._x_interceptor) {\n      let initialize = obj.initialize.bind(obj);\n      obj.initialize = (data2, path, key) => {\n        let innerValue = initialValue.initialize(data2, path, key);\n        obj.initialValue = innerValue;\n        return initialize(data2, path, key);\n      };\n    } else {\n      obj.initialValue = initialValue;\n    }\n    return obj;\n  };\n}\nfunction get(obj, path) {\n  return path.split(\".\").reduce((carry, segment) => carry[segment], obj);\n}\nfunction set(obj, path, value) {\n  if (typeof path === \"string\")\n    path = path.split(\".\");\n  if (path.length === 1)\n    obj[path[0]] = value;\n  else if (path.length === 0)\n    throw error;\n  else {\n    if (obj[path[0]])\n      return set(obj[path[0]], path.slice(1), value);\n    else {\n      obj[path[0]] = {};\n      return set(obj[path[0]], path.slice(1), value);\n    }\n  }\n}\n\n// packages/alpinejs/src/magics.js\nvar magics = {};\nfunction magic(name, callback) {\n  magics[name] = callback;\n}\nfunction injectMagics(obj, el) {\n  Object.entries(magics).forEach(([name, callback]) => {\n    Object.defineProperty(obj, `$${name}`, {\n      get() {\n        return callback(el, {Alpine: alpine_default, interceptor});\n      },\n      enumerable: false\n    });\n  });\n  return obj;\n}\n\n// packages/alpinejs/src/utils/error.js\nfunction tryCatch(el, expression, callback, ...args) {\n  try {\n    return callback(...args);\n  } catch (e) {\n    handleError(e, el, expression);\n  }\n}\nfunction handleError(error2, el, expression = void 0) {\n  Object.assign(error2, {el, expression});\n  console.warn(`Alpine Expression Error: ${error2.message}\n\n${expression ? 'Expression: \"' + expression + '\"\\n\\n' : \"\"}`, el);\n  setTimeout(() => {\n    throw error2;\n  }, 0);\n}\n\n// packages/alpinejs/src/evaluator.js\nfunction evaluate(el, expression, extras = {}) {\n  let result;\n  evaluateLater(el, expression)((value) => result = value, extras);\n  return result;\n}\nfunction evaluateLater(...args) {\n  return theEvaluatorFunction(...args);\n}\nvar theEvaluatorFunction = normalEvaluator;\nfunction setEvaluator(newEvaluator) {\n  theEvaluatorFunction = newEvaluator;\n}\nfunction normalEvaluator(el, expression) {\n  let overriddenMagics = {};\n  injectMagics(overriddenMagics, el);\n  let dataStack = [overriddenMagics, ...closestDataStack(el)];\n  if (typeof expression === \"function\") {\n    return generateEvaluatorFromFunction(dataStack, expression);\n  }\n  let evaluator = generateEvaluatorFromString(dataStack, expression, el);\n  return tryCatch.bind(null, el, expression, evaluator);\n}\nfunction generateEvaluatorFromFunction(dataStack, func) {\n  return (receiver = () => {\n  }, {scope = {}, params = []} = {}) => {\n    let result = func.apply(mergeProxies([scope, ...dataStack]), params);\n    runIfTypeOfFunction(receiver, result);\n  };\n}\nvar evaluatorMemo = {};\nfunction generateFunctionFromString(expression, el) {\n  if (evaluatorMemo[expression]) {\n    return evaluatorMemo[expression];\n  }\n  let AsyncFunction = Object.getPrototypeOf(async function() {\n  }).constructor;\n  let rightSideSafeExpression = /^[\\n\\s]*if.*\\(.*\\)/.test(expression) || /^(let|const)\\s/.test(expression) ? `(() => { ${expression} })()` : expression;\n  const safeAsyncFunction = () => {\n    try {\n      return new AsyncFunction([\"__self\", \"scope\"], `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`);\n    } catch (error2) {\n      handleError(error2, el, expression);\n      return Promise.resolve();\n    }\n  };\n  let func = safeAsyncFunction();\n  evaluatorMemo[expression] = func;\n  return func;\n}\nfunction generateEvaluatorFromString(dataStack, expression, el) {\n  let func = generateFunctionFromString(expression, el);\n  return (receiver = () => {\n  }, {scope = {}, params = []} = {}) => {\n    func.result = void 0;\n    func.finished = false;\n    let completeScope = mergeProxies([scope, ...dataStack]);\n    if (typeof func === \"function\") {\n      let promise = func(func, completeScope).catch((error2) => handleError(error2, el, expression));\n      if (func.finished) {\n        runIfTypeOfFunction(receiver, func.result, completeScope, params, el);\n        func.result = void 0;\n      } else {\n        promise.then((result) => {\n          runIfTypeOfFunction(receiver, result, completeScope, params, el);\n        }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);\n      }\n    }\n  };\n}\nfunction runIfTypeOfFunction(receiver, value, scope, params, el) {\n  if (typeof value === \"function\") {\n    let result = value.apply(scope, params);\n    if (result instanceof Promise) {\n      result.then((i) => runIfTypeOfFunction(receiver, i, scope, params)).catch((error2) => handleError(error2, el, value));\n    } else {\n      receiver(result);\n    }\n  } else {\n    receiver(value);\n  }\n}\n\n// packages/alpinejs/src/directives.js\nvar prefixAsString = \"x-\";\nfunction prefix(subject = \"\") {\n  return prefixAsString + subject;\n}\nfunction setPrefix(newPrefix) {\n  prefixAsString = newPrefix;\n}\nvar directiveHandlers = {};\nfunction directive(name, callback) {\n  directiveHandlers[name] = callback;\n}\nfunction directives(el, attributes, originalAttributeOverride) {\n  let transformedAttributeMap = {};\n  let directives2 = Array.from(attributes).map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);\n  return directives2.map((directive2) => {\n    return getDirectiveHandler(el, directive2);\n  });\n}\nfunction attributesOnly(attributes) {\n  return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));\n}\nvar isDeferringHandlers = false;\nvar directiveHandlerStacks = new Map();\nvar currentHandlerStackKey = Symbol();\nfunction deferHandlingDirectives(callback) {\n  isDeferringHandlers = true;\n  let key = Symbol();\n  currentHandlerStackKey = key;\n  directiveHandlerStacks.set(key, []);\n  let flushHandlers = () => {\n    while (directiveHandlerStacks.get(key).length)\n      directiveHandlerStacks.get(key).shift()();\n    directiveHandlerStacks.delete(key);\n  };\n  let stopDeferring = () => {\n    isDeferringHandlers = false;\n    flushHandlers();\n  };\n  callback(flushHandlers);\n  stopDeferring();\n}\nfunction getDirectiveHandler(el, directive2) {\n  let noop = () => {\n  };\n  let handler3 = directiveHandlers[directive2.type] || noop;\n  let cleanups = [];\n  let cleanup = (callback) => cleanups.push(callback);\n  let [effect3, cleanupEffect] = elementBoundEffect(el);\n  cleanups.push(cleanupEffect);\n  let utilities = {\n    Alpine: alpine_default,\n    effect: effect3,\n    cleanup,\n    evaluateLater: evaluateLater.bind(evaluateLater, el),\n    evaluate: evaluate.bind(evaluate, el)\n  };\n  let doCleanup = () => cleanups.forEach((i) => i());\n  onAttributeRemoved(el, directive2.original, doCleanup);\n  let fullHandler = () => {\n    if (el._x_ignore || el._x_ignoreSelf)\n      return;\n    handler3.inline && handler3.inline(el, directive2, utilities);\n    handler3 = handler3.bind(handler3, el, directive2, utilities);\n    isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler3) : handler3();\n  };\n  fullHandler.runCleanups = doCleanup;\n  return fullHandler;\n}\nvar startingWith = (subject, replacement) => ({name, value}) => {\n  if (name.startsWith(subject))\n    name = name.replace(subject, replacement);\n  return {name, value};\n};\nvar into = (i) => i;\nfunction toTransformedAttributes(callback = () => {\n}) {\n  return ({name, value}) => {\n    let {name: newName, value: newValue} = attributeTransformers.reduce((carry, transform) => {\n      return transform(carry);\n    }, {name, value});\n    if (newName !== name)\n      callback(newName, name);\n    return {name: newName, value: newValue};\n  };\n}\nvar attributeTransformers = [];\nfunction mapAttributes(callback) {\n  attributeTransformers.push(callback);\n}\nfunction outNonAlpineAttributes({name}) {\n  return alpineAttributeRegex().test(name);\n}\nvar alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\\\b`);\nfunction toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {\n  return ({name, value}) => {\n    let typeMatch = name.match(alpineAttributeRegex());\n    let valueMatch = name.match(/:([a-zA-Z0-9\\-:]+)/);\n    let modifiers = name.match(/\\.[^.\\]]+(?=[^\\]]*$)/g) || [];\n    let original = originalAttributeOverride || transformedAttributeMap[name] || name;\n    return {\n      type: typeMatch ? typeMatch[1] : null,\n      value: valueMatch ? valueMatch[1] : null,\n      modifiers: modifiers.map((i) => i.replace(\".\", \"\")),\n      expression: value,\n      original\n    };\n  };\n}\nvar DEFAULT = \"DEFAULT\";\nvar directiveOrder = [\n  \"ignore\",\n  \"ref\",\n  \"data\",\n  \"bind\",\n  \"init\",\n  \"for\",\n  \"model\",\n  \"transition\",\n  \"show\",\n  \"if\",\n  DEFAULT,\n  \"element\"\n];\nfunction byPriority(a, b) {\n  let typeA = directiveOrder.indexOf(a.type) === -1 ? DEFAULT : a.type;\n  let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;\n  return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);\n}\n\n// packages/alpinejs/src/utils/dispatch.js\nfunction dispatch(el, name, detail = {}) {\n  el.dispatchEvent(new CustomEvent(name, {\n    detail,\n    bubbles: true,\n    composed: true,\n    cancelable: true\n  }));\n}\n\n// packages/alpinejs/src/nextTick.js\nvar tickStack = [];\nvar isHolding = false;\nfunction nextTick(callback) {\n  tickStack.push(callback);\n  queueMicrotask(() => {\n    isHolding || setTimeout(() => {\n      releaseNextTicks();\n    });\n  });\n}\nfunction releaseNextTicks() {\n  isHolding = false;\n  while (tickStack.length)\n    tickStack.shift()();\n}\nfunction holdNextTicks() {\n  isHolding = true;\n}\n\n// packages/alpinejs/src/utils/walk.js\nfunction walk(el, callback) {\n  if (typeof ShadowRoot === \"function\" && el instanceof ShadowRoot) {\n    Array.from(el.children).forEach((el2) => walk(el2, callback));\n    return;\n  }\n  let skip = false;\n  callback(el, () => skip = true);\n  if (skip)\n    return;\n  let node = el.firstElementChild;\n  while (node) {\n    walk(node, callback, false);\n    node = node.nextElementSibling;\n  }\n}\n\n// packages/alpinejs/src/utils/warn.js\nfunction warn(message, ...args) {\n  console.warn(`Alpine Warning: ${message}`, ...args);\n}\n\n// packages/alpinejs/src/lifecycle.js\nfunction start() {\n  if (!document.body)\n    warn(\"Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?\");\n  dispatch(document, \"alpine:init\");\n  dispatch(document, \"alpine:initializing\");\n  startObservingMutations();\n  onElAdded((el) => initTree(el, walk));\n  onElRemoved((el) => nextTick(() => destroyTree(el)));\n  onAttributesAdded((el, attrs) => {\n    directives(el, attrs).forEach((handle) => handle());\n  });\n  let outNestedComponents = (el) => !closestRoot(el.parentElement, true);\n  Array.from(document.querySelectorAll(allSelectors())).filter(outNestedComponents).forEach((el) => {\n    initTree(el);\n  });\n  dispatch(document, \"alpine:initialized\");\n}\nvar rootSelectorCallbacks = [];\nvar initSelectorCallbacks = [];\nfunction rootSelectors() {\n  return rootSelectorCallbacks.map((fn) => fn());\n}\nfunction allSelectors() {\n  return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());\n}\nfunction addRootSelector(selectorCallback) {\n  rootSelectorCallbacks.push(selectorCallback);\n}\nfunction addInitSelector(selectorCallback) {\n  initSelectorCallbacks.push(selectorCallback);\n}\nfunction closestRoot(el, includeInitSelectors = false) {\n  if (!el)\n    return;\n  const selectors = includeInitSelectors ? allSelectors() : rootSelectors();\n  if (selectors.some((selector) => el.matches(selector)))\n    return el;\n  if (!el.parentElement)\n    return;\n  return closestRoot(el.parentElement, includeInitSelectors);\n}\nfunction isRoot(el) {\n  return rootSelectors().some((selector) => el.matches(selector));\n}\nfunction initTree(el, walker = walk) {\n  deferHandlingDirectives(() => {\n    walker(el, (el2, skip) => {\n      directives(el2, el2.attributes).forEach((handle) => handle());\n      el2._x_ignore && skip();\n    });\n  });\n}\nfunction destroyTree(root) {\n  walk(root, (el) => cleanupAttributes(el));\n}\n\n// packages/alpinejs/src/utils/classes.js\nfunction setClasses(el, value) {\n  if (Array.isArray(value)) {\n    return setClassesFromString(el, value.join(\" \"));\n  } else if (typeof value === \"object\" && value !== null) {\n    return setClassesFromObject(el, value);\n  } else if (typeof value === \"function\") {\n    return setClasses(el, value());\n  }\n  return setClassesFromString(el, value);\n}\nfunction setClassesFromString(el, classString) {\n  let split = (classString2) => classString2.split(\" \").filter(Boolean);\n  let missingClasses = (classString2) => classString2.split(\" \").filter((i) => !el.classList.contains(i)).filter(Boolean);\n  let addClassesAndReturnUndo = (classes) => {\n    el.classList.add(...classes);\n    return () => {\n      el.classList.remove(...classes);\n    };\n  };\n  classString = classString === true ? classString = \"\" : classString || \"\";\n  return addClassesAndReturnUndo(missingClasses(classString));\n}\nfunction setClassesFromObject(el, classObject) {\n  let split = (classString) => classString.split(\" \").filter(Boolean);\n  let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);\n  let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);\n  let added = [];\n  let removed = [];\n  forRemove.forEach((i) => {\n    if (el.classList.contains(i)) {\n      el.classList.remove(i);\n      removed.push(i);\n    }\n  });\n  forAdd.forEach((i) => {\n    if (!el.classList.contains(i)) {\n      el.classList.add(i);\n      added.push(i);\n    }\n  });\n  return () => {\n    removed.forEach((i) => el.classList.add(i));\n    added.forEach((i) => el.classList.remove(i));\n  };\n}\n\n// packages/alpinejs/src/utils/styles.js\nfunction setStyles(el, value) {\n  if (typeof value === \"object\" && value !== null) {\n    return setStylesFromObject(el, value);\n  }\n  return setStylesFromString(el, value);\n}\nfunction setStylesFromObject(el, value) {\n  let previousStyles = {};\n  Object.entries(value).forEach(([key, value2]) => {\n    previousStyles[key] = el.style[key];\n    el.style.setProperty(kebabCase(key), value2);\n  });\n  setTimeout(() => {\n    if (el.style.length === 0) {\n      el.removeAttribute(\"style\");\n    }\n  });\n  return () => {\n    setStyles(el, previousStyles);\n  };\n}\nfunction setStylesFromString(el, value) {\n  let cache = el.getAttribute(\"style\", value);\n  el.setAttribute(\"style\", value);\n  return () => {\n    el.setAttribute(\"style\", cache);\n  };\n}\nfunction kebabCase(subject) {\n  return subject.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n\n// packages/alpinejs/src/utils/once.js\nfunction once(callback, fallback = () => {\n}) {\n  let called = false;\n  return function() {\n    if (!called) {\n      called = true;\n      callback.apply(this, arguments);\n    } else {\n      fallback.apply(this, arguments);\n    }\n  };\n}\n\n// packages/alpinejs/src/directives/x-transition.js\ndirective(\"transition\", (el, {value, modifiers, expression}, {evaluate: evaluate2}) => {\n  if (typeof expression === \"function\")\n    expression = evaluate2(expression);\n  if (!expression) {\n    registerTransitionsFromHelper(el, modifiers, value);\n  } else {\n    registerTransitionsFromClassString(el, expression, value);\n  }\n});\nfunction registerTransitionsFromClassString(el, classString, stage) {\n  registerTransitionObject(el, setClasses, \"\");\n  let directiveStorageMap = {\n    enter: (classes) => {\n      el._x_transition.enter.during = classes;\n    },\n    \"enter-start\": (classes) => {\n      el._x_transition.enter.start = classes;\n    },\n    \"enter-end\": (classes) => {\n      el._x_transition.enter.end = classes;\n    },\n    leave: (classes) => {\n      el._x_transition.leave.during = classes;\n    },\n    \"leave-start\": (classes) => {\n      el._x_transition.leave.start = classes;\n    },\n    \"leave-end\": (classes) => {\n      el._x_transition.leave.end = classes;\n    }\n  };\n  directiveStorageMap[stage](classString);\n}\nfunction registerTransitionsFromHelper(el, modifiers, stage) {\n  registerTransitionObject(el, setStyles);\n  let doesntSpecify = !modifiers.includes(\"in\") && !modifiers.includes(\"out\") && !stage;\n  let transitioningIn = doesntSpecify || modifiers.includes(\"in\") || [\"enter\"].includes(stage);\n  let transitioningOut = doesntSpecify || modifiers.includes(\"out\") || [\"leave\"].includes(stage);\n  if (modifiers.includes(\"in\") && !doesntSpecify) {\n    modifiers = modifiers.filter((i, index) => index < modifiers.indexOf(\"out\"));\n  }\n  if (modifiers.includes(\"out\") && !doesntSpecify) {\n    modifiers = modifiers.filter((i, index) => index > modifiers.indexOf(\"out\"));\n  }\n  let wantsAll = !modifiers.includes(\"opacity\") && !modifiers.includes(\"scale\");\n  let wantsOpacity = wantsAll || modifiers.includes(\"opacity\");\n  let wantsScale = wantsAll || modifiers.includes(\"scale\");\n  let opacityValue = wantsOpacity ? 0 : 1;\n  let scaleValue = wantsScale ? modifierValue(modifiers, \"scale\", 95) / 100 : 1;\n  let delay = modifierValue(modifiers, \"delay\", 0);\n  let origin = modifierValue(modifiers, \"origin\", \"center\");\n  let property = \"opacity, transform\";\n  let durationIn = modifierValue(modifiers, \"duration\", 150) / 1e3;\n  let durationOut = modifierValue(modifiers, \"duration\", 75) / 1e3;\n  let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;\n  if (transitioningIn) {\n    el._x_transition.enter.during = {\n      transformOrigin: origin,\n      transitionDelay: delay,\n      transitionProperty: property,\n      transitionDuration: `${durationIn}s`,\n      transitionTimingFunction: easing\n    };\n    el._x_transition.enter.start = {\n      opacity: opacityValue,\n      transform: `scale(${scaleValue})`\n    };\n    el._x_transition.enter.end = {\n      opacity: 1,\n      transform: `scale(1)`\n    };\n  }\n  if (transitioningOut) {\n    el._x_transition.leave.during = {\n      transformOrigin: origin,\n      transitionDelay: delay,\n      transitionProperty: property,\n      transitionDuration: `${durationOut}s`,\n      transitionTimingFunction: easing\n    };\n    el._x_transition.leave.start = {\n      opacity: 1,\n      transform: `scale(1)`\n    };\n    el._x_transition.leave.end = {\n      opacity: opacityValue,\n      transform: `scale(${scaleValue})`\n    };\n  }\n}\nfunction registerTransitionObject(el, setFunction, defaultValue = {}) {\n  if (!el._x_transition)\n    el._x_transition = {\n      enter: {during: defaultValue, start: defaultValue, end: defaultValue},\n      leave: {during: defaultValue, start: defaultValue, end: defaultValue},\n      in(before = () => {\n      }, after = () => {\n      }) {\n        transition(el, setFunction, {\n          during: this.enter.during,\n          start: this.enter.start,\n          end: this.enter.end\n        }, before, after);\n      },\n      out(before = () => {\n      }, after = () => {\n      }) {\n        transition(el, setFunction, {\n          during: this.leave.during,\n          start: this.leave.start,\n          end: this.leave.end\n        }, before, after);\n      }\n    };\n}\nwindow.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {\n  let clickAwayCompatibleShow = () => {\n    document.visibilityState === \"visible\" ? requestAnimationFrame(show) : setTimeout(show);\n  };\n  if (value) {\n    if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {\n      el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();\n    } else {\n      el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();\n    }\n    return;\n  }\n  el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {\n    el._x_transition.out(() => {\n    }, () => resolve(hide));\n    el._x_transitioning.beforeCancel(() => reject({isFromCancelledTransition: true}));\n  }) : Promise.resolve(hide);\n  queueMicrotask(() => {\n    let closest = closestHide(el);\n    if (closest) {\n      if (!closest._x_hideChildren)\n        closest._x_hideChildren = [];\n      closest._x_hideChildren.push(el);\n    } else {\n      queueMicrotask(() => {\n        let hideAfterChildren = (el2) => {\n          let carry = Promise.all([\n            el2._x_hidePromise,\n            ...(el2._x_hideChildren || []).map(hideAfterChildren)\n          ]).then(([i]) => i());\n          delete el2._x_hidePromise;\n          delete el2._x_hideChildren;\n          return carry;\n        };\n        hideAfterChildren(el).catch((e) => {\n          if (!e.isFromCancelledTransition)\n            throw e;\n        });\n      });\n    }\n  });\n};\nfunction closestHide(el) {\n  let parent = el.parentNode;\n  if (!parent)\n    return;\n  return parent._x_hidePromise ? parent : closestHide(parent);\n}\nfunction transition(el, setFunction, {during, start: start2, end} = {}, before = () => {\n}, after = () => {\n}) {\n  if (el._x_transitioning)\n    el._x_transitioning.cancel();\n  if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {\n    before();\n    after();\n    return;\n  }\n  let undoStart, undoDuring, undoEnd;\n  performTransition(el, {\n    start() {\n      undoStart = setFunction(el, start2);\n    },\n    during() {\n      undoDuring = setFunction(el, during);\n    },\n    before,\n    end() {\n      undoStart();\n      undoEnd = setFunction(el, end);\n    },\n    after,\n    cleanup() {\n      undoDuring();\n      undoEnd();\n    }\n  });\n}\nfunction performTransition(el, stages) {\n  let interrupted, reachedBefore, reachedEnd;\n  let finish = once(() => {\n    mutateDom(() => {\n      interrupted = true;\n      if (!reachedBefore)\n        stages.before();\n      if (!reachedEnd) {\n        stages.end();\n        releaseNextTicks();\n      }\n      stages.after();\n      if (el.isConnected)\n        stages.cleanup();\n      delete el._x_transitioning;\n    });\n  });\n  el._x_transitioning = {\n    beforeCancels: [],\n    beforeCancel(callback) {\n      this.beforeCancels.push(callback);\n    },\n    cancel: once(function() {\n      while (this.beforeCancels.length) {\n        this.beforeCancels.shift()();\n      }\n      ;\n      finish();\n    }),\n    finish\n  };\n  mutateDom(() => {\n    stages.start();\n    stages.during();\n  });\n  holdNextTicks();\n  requestAnimationFrame(() => {\n    if (interrupted)\n      return;\n    let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, \"\").replace(\"s\", \"\")) * 1e3;\n    let delay = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, \"\").replace(\"s\", \"\")) * 1e3;\n    if (duration === 0)\n      duration = Number(getComputedStyle(el).animationDuration.replace(\"s\", \"\")) * 1e3;\n    mutateDom(() => {\n      stages.before();\n    });\n    reachedBefore = true;\n    requestAnimationFrame(() => {\n      if (interrupted)\n        return;\n      mutateDom(() => {\n        stages.end();\n      });\n      releaseNextTicks();\n      setTimeout(el._x_transitioning.finish, duration + delay);\n      reachedEnd = true;\n    });\n  });\n}\nfunction modifierValue(modifiers, key, fallback) {\n  if (modifiers.indexOf(key) === -1)\n    return fallback;\n  const rawValue = modifiers[modifiers.indexOf(key) + 1];\n  if (!rawValue)\n    return fallback;\n  if (key === \"scale\") {\n    if (isNaN(rawValue))\n      return fallback;\n  }\n  if (key === \"duration\") {\n    let match = rawValue.match(/([0-9]+)ms/);\n    if (match)\n      return match[1];\n  }\n  if (key === \"origin\") {\n    if ([\"top\", \"right\", \"left\", \"center\", \"bottom\"].includes(modifiers[modifiers.indexOf(key) + 2])) {\n      return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(\" \");\n    }\n  }\n  return rawValue;\n}\n\n// packages/alpinejs/src/clone.js\nvar isCloning = false;\nfunction skipDuringClone(callback, fallback = () => {\n}) {\n  return (...args) => isCloning ? fallback(...args) : callback(...args);\n}\nfunction clone(oldEl, newEl) {\n  if (!newEl._x_dataStack)\n    newEl._x_dataStack = oldEl._x_dataStack;\n  isCloning = true;\n  dontRegisterReactiveSideEffects(() => {\n    cloneTree(newEl);\n  });\n  isCloning = false;\n}\nfunction cloneTree(el) {\n  let hasRunThroughFirstEl = false;\n  let shallowWalker = (el2, callback) => {\n    walk(el2, (el3, skip) => {\n      if (hasRunThroughFirstEl && isRoot(el3))\n        return skip();\n      hasRunThroughFirstEl = true;\n      callback(el3, skip);\n    });\n  };\n  initTree(el, shallowWalker);\n}\nfunction dontRegisterReactiveSideEffects(callback) {\n  let cache = effect;\n  overrideEffect((callback2, el) => {\n    let storedEffect = cache(callback2);\n    release(storedEffect);\n    return () => {\n    };\n  });\n  callback();\n  overrideEffect(cache);\n}\n\n// packages/alpinejs/src/utils/debounce.js\nfunction debounce(func, wait) {\n  var timeout;\n  return function() {\n    var context = this, args = arguments;\n    var later = function() {\n      timeout = null;\n      func.apply(context, args);\n    };\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\n// packages/alpinejs/src/utils/throttle.js\nfunction throttle(func, limit) {\n  let inThrottle;\n  return function() {\n    let context = this, args = arguments;\n    if (!inThrottle) {\n      func.apply(context, args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n}\n\n// packages/alpinejs/src/plugin.js\nfunction plugin(callback) {\n  callback(alpine_default);\n}\n\n// packages/alpinejs/src/store.js\nvar stores = {};\nvar isReactive = false;\nfunction store(name, value) {\n  if (!isReactive) {\n    stores = reactive(stores);\n    isReactive = true;\n  }\n  if (value === void 0) {\n    return stores[name];\n  }\n  stores[name] = value;\n  if (typeof value === \"object\" && value !== null && value.hasOwnProperty(\"init\") && typeof value.init === \"function\") {\n    stores[name].init();\n  }\n  initInterceptors(stores[name]);\n}\nfunction getStores() {\n  return stores;\n}\n\n// packages/alpinejs/src/datas.js\nvar datas = {};\nfunction data(name, callback) {\n  datas[name] = callback;\n}\nfunction injectDataProviders(obj, context) {\n  Object.entries(datas).forEach(([name, callback]) => {\n    Object.defineProperty(obj, name, {\n      get() {\n        return (...args) => {\n          return callback.bind(context)(...args);\n        };\n      },\n      enumerable: false\n    });\n  });\n  return obj;\n}\n\n// packages/alpinejs/src/alpine.js\nvar Alpine = {\n  get reactive() {\n    return reactive;\n  },\n  get release() {\n    return release;\n  },\n  get effect() {\n    return effect;\n  },\n  get raw() {\n    return raw;\n  },\n  version: \"3.5.2\",\n  flushAndStopDeferringMutations,\n  disableEffectScheduling,\n  setReactivityEngine,\n  closestDataStack,\n  skipDuringClone,\n  addRootSelector,\n  deferMutations,\n  mapAttributes,\n  evaluateLater,\n  setEvaluator,\n  mergeProxies,\n  closestRoot,\n  interceptor,\n  transition,\n  setStyles,\n  mutateDom,\n  directive,\n  throttle,\n  debounce,\n  evaluate,\n  initTree,\n  nextTick,\n  prefix: setPrefix,\n  plugin,\n  magic,\n  store,\n  start,\n  clone,\n  data\n};\nvar alpine_default = Alpine;\n\n// packages/alpinejs/src/index.js\nvar import_reactivity9 = __toModule(require_reactivity());\n\n// packages/alpinejs/src/magics/$nextTick.js\nmagic(\"nextTick\", () => nextTick);\n\n// packages/alpinejs/src/magics/$dispatch.js\nmagic(\"dispatch\", (el) => dispatch.bind(dispatch, el));\n\n// packages/alpinejs/src/magics/$watch.js\nmagic(\"watch\", (el) => (key, callback) => {\n  let evaluate2 = evaluateLater(el, key);\n  let firstTime = true;\n  let oldValue;\n  effect(() => evaluate2((value) => {\n    let div = document.createElement(\"div\");\n    div.dataset.throwAway = value;\n    if (!firstTime) {\n      queueMicrotask(() => {\n        callback(value, oldValue);\n        oldValue = value;\n      });\n    } else {\n      oldValue = value;\n    }\n    firstTime = false;\n  }));\n});\n\n// packages/alpinejs/src/magics/$store.js\nmagic(\"store\", getStores);\n\n// packages/alpinejs/src/magics/$data.js\nmagic(\"data\", (el) => {\n  return mergeProxies(closestDataStack(el));\n});\n\n// packages/alpinejs/src/magics/$root.js\nmagic(\"root\", (el) => closestRoot(el));\n\n// packages/alpinejs/src/magics/$refs.js\nmagic(\"refs\", (el) => {\n  if (el._x_refs_proxy)\n    return el._x_refs_proxy;\n  el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));\n  return el._x_refs_proxy;\n});\nfunction getArrayOfRefObject(el) {\n  let refObjects = [];\n  let currentEl = el;\n  while (currentEl) {\n    if (currentEl._x_refs)\n      refObjects.push(currentEl._x_refs);\n    currentEl = currentEl.parentNode;\n  }\n  return refObjects;\n}\n\n// packages/alpinejs/src/magics/$el.js\nmagic(\"el\", (el) => el);\n\n// packages/alpinejs/src/directives/x-ignore.js\nvar handler = () => {\n};\nhandler.inline = (el, {modifiers}, {cleanup}) => {\n  modifiers.includes(\"self\") ? el._x_ignoreSelf = true : el._x_ignore = true;\n  cleanup(() => {\n    modifiers.includes(\"self\") ? delete el._x_ignoreSelf : delete el._x_ignore;\n  });\n};\ndirective(\"ignore\", handler);\n\n// packages/alpinejs/src/directives/x-effect.js\ndirective(\"effect\", (el, {expression}, {effect: effect3}) => effect3(evaluateLater(el, expression)));\n\n// packages/alpinejs/src/utils/bind.js\nfunction bind(el, name, value, modifiers = []) {\n  if (!el._x_bindings)\n    el._x_bindings = reactive({});\n  el._x_bindings[name] = value;\n  name = modifiers.includes(\"camel\") ? camelCase(name) : name;\n  switch (name) {\n    case \"value\":\n      bindInputValue(el, value);\n      break;\n    case \"style\":\n      bindStyles(el, value);\n      break;\n    case \"class\":\n      bindClasses(el, value);\n      break;\n    default:\n      bindAttribute(el, name, value);\n      break;\n  }\n}\nfunction bindInputValue(el, value) {\n  if (el.type === \"radio\") {\n    if (el.attributes.value === void 0) {\n      el.value = value;\n    }\n    if (window.fromModel) {\n      el.checked = checkedAttrLooseCompare(el.value, value);\n    }\n  } else if (el.type === \"checkbox\") {\n    if (Number.isInteger(value)) {\n      el.value = value;\n    } else if (!Number.isInteger(value) && !Array.isArray(value) && typeof value !== \"boolean\" && ![null, void 0].includes(value)) {\n      el.value = String(value);\n    } else {\n      if (Array.isArray(value)) {\n        el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));\n      } else {\n        el.checked = !!value;\n      }\n    }\n  } else if (el.tagName === \"SELECT\") {\n    updateSelect(el, value);\n  } else {\n    if (el.value === value)\n      return;\n    el.value = value;\n  }\n}\nfunction bindClasses(el, value) {\n  if (el._x_undoAddedClasses)\n    el._x_undoAddedClasses();\n  el._x_undoAddedClasses = setClasses(el, value);\n}\nfunction bindStyles(el, value) {\n  if (el._x_undoAddedStyles)\n    el._x_undoAddedStyles();\n  el._x_undoAddedStyles = setStyles(el, value);\n}\nfunction bindAttribute(el, name, value) {\n  if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {\n    el.removeAttribute(name);\n  } else {\n    if (isBooleanAttr(name))\n      value = name;\n    setIfChanged(el, name, value);\n  }\n}\nfunction setIfChanged(el, attrName, value) {\n  if (el.getAttribute(attrName) != value) {\n    el.setAttribute(attrName, value);\n  }\n}\nfunction updateSelect(el, value) {\n  const arrayWrappedValue = [].concat(value).map((value2) => {\n    return value2 + \"\";\n  });\n  Array.from(el.options).forEach((option) => {\n    option.selected = arrayWrappedValue.includes(option.value);\n  });\n}\nfunction camelCase(subject) {\n  return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n}\nfunction checkedAttrLooseCompare(valueA, valueB) {\n  return valueA == valueB;\n}\nfunction isBooleanAttr(attrName) {\n  const booleanAttributes = [\n    \"disabled\",\n    \"checked\",\n    \"required\",\n    \"readonly\",\n    \"hidden\",\n    \"open\",\n    \"selected\",\n    \"autofocus\",\n    \"itemscope\",\n    \"multiple\",\n    \"novalidate\",\n    \"allowfullscreen\",\n    \"allowpaymentrequest\",\n    \"formnovalidate\",\n    \"autoplay\",\n    \"controls\",\n    \"loop\",\n    \"muted\",\n    \"playsinline\",\n    \"default\",\n    \"ismap\",\n    \"reversed\",\n    \"async\",\n    \"defer\",\n    \"nomodule\"\n  ];\n  return booleanAttributes.includes(attrName);\n}\nfunction attributeShouldntBePreservedIfFalsy(name) {\n  return ![\"aria-pressed\", \"aria-checked\", \"aria-expanded\"].includes(name);\n}\n\n// packages/alpinejs/src/utils/on.js\nfunction on(el, event, modifiers, callback) {\n  let listenerTarget = el;\n  let handler3 = (e) => callback(e);\n  let options = {};\n  let wrapHandler = (callback2, wrapper) => (e) => wrapper(callback2, e);\n  if (modifiers.includes(\"dot\"))\n    event = dotSyntax(event);\n  if (modifiers.includes(\"camel\"))\n    event = camelCase2(event);\n  if (modifiers.includes(\"passive\"))\n    options.passive = true;\n  if (modifiers.includes(\"capture\"))\n    options.capture = true;\n  if (modifiers.includes(\"window\"))\n    listenerTarget = window;\n  if (modifiers.includes(\"document\"))\n    listenerTarget = document;\n  if (modifiers.includes(\"prevent\"))\n    handler3 = wrapHandler(handler3, (next, e) => {\n      e.preventDefault();\n      next(e);\n    });\n  if (modifiers.includes(\"stop\"))\n    handler3 = wrapHandler(handler3, (next, e) => {\n      e.stopPropagation();\n      next(e);\n    });\n  if (modifiers.includes(\"self\"))\n    handler3 = wrapHandler(handler3, (next, e) => {\n      e.target === el && next(e);\n    });\n  if (modifiers.includes(\"away\") || modifiers.includes(\"outside\")) {\n    listenerTarget = document;\n    handler3 = wrapHandler(handler3, (next, e) => {\n      if (el.contains(e.target))\n        return;\n      if (el.offsetWidth < 1 && el.offsetHeight < 1)\n        return;\n      if (el._x_isShown === false)\n        return;\n      next(e);\n    });\n  }\n  handler3 = wrapHandler(handler3, (next, e) => {\n    if (isKeyEvent(event)) {\n      if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {\n        return;\n      }\n    }\n    next(e);\n  });\n  if (modifiers.includes(\"debounce\")) {\n    let nextModifier = modifiers[modifiers.indexOf(\"debounce\") + 1] || \"invalid-wait\";\n    let wait = isNumeric(nextModifier.split(\"ms\")[0]) ? Number(nextModifier.split(\"ms\")[0]) : 250;\n    handler3 = debounce(handler3, wait);\n  }\n  if (modifiers.includes(\"throttle\")) {\n    let nextModifier = modifiers[modifiers.indexOf(\"throttle\") + 1] || \"invalid-wait\";\n    let wait = isNumeric(nextModifier.split(\"ms\")[0]) ? Number(nextModifier.split(\"ms\")[0]) : 250;\n    handler3 = throttle(handler3, wait);\n  }\n  if (modifiers.includes(\"once\")) {\n    handler3 = wrapHandler(handler3, (next, e) => {\n      next(e);\n      listenerTarget.removeEventListener(event, handler3, options);\n    });\n  }\n  listenerTarget.addEventListener(event, handler3, options);\n  return () => {\n    listenerTarget.removeEventListener(event, handler3, options);\n  };\n}\nfunction dotSyntax(subject) {\n  return subject.replace(/-/g, \".\");\n}\nfunction camelCase2(subject) {\n  return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n}\nfunction isNumeric(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\nfunction kebabCase2(subject) {\n  return subject.replace(/([a-z])([A-Z])/g, \"$1-$2\").replace(/[_\\s]/, \"-\").toLowerCase();\n}\nfunction isKeyEvent(event) {\n  return [\"keydown\", \"keyup\"].includes(event);\n}\nfunction isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {\n  let keyModifiers = modifiers.filter((i) => {\n    return ![\"window\", \"document\", \"prevent\", \"stop\", \"once\"].includes(i);\n  });\n  if (keyModifiers.includes(\"debounce\")) {\n    let debounceIndex = keyModifiers.indexOf(\"debounce\");\n    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || \"invalid-wait\").split(\"ms\")[0]) ? 2 : 1);\n  }\n  if (keyModifiers.length === 0)\n    return false;\n  if (keyModifiers.length === 1 && keyToModifiers(e.key).includes(keyModifiers[0]))\n    return false;\n  const systemKeyModifiers = [\"ctrl\", \"shift\", \"alt\", \"meta\", \"cmd\", \"super\"];\n  const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));\n  keyModifiers = keyModifiers.filter((i) => !selectedSystemKeyModifiers.includes(i));\n  if (selectedSystemKeyModifiers.length > 0) {\n    const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {\n      if (modifier === \"cmd\" || modifier === \"super\")\n        modifier = \"meta\";\n      return e[`${modifier}Key`];\n    });\n    if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {\n      if (keyToModifiers(e.key).includes(keyModifiers[0]))\n        return false;\n    }\n  }\n  return true;\n}\nfunction keyToModifiers(key) {\n  if (!key)\n    return [];\n  key = kebabCase2(key);\n  let modifierToKeyMap = {\n    ctrl: \"control\",\n    slash: \"/\",\n    space: \"-\",\n    spacebar: \"-\",\n    cmd: \"meta\",\n    esc: \"escape\",\n    up: \"arrow-up\",\n    down: \"arrow-down\",\n    left: \"arrow-left\",\n    right: \"arrow-right\",\n    period: \".\",\n    equal: \"=\"\n  };\n  modifierToKeyMap[key] = key;\n  return Object.keys(modifierToKeyMap).map((modifier) => {\n    if (modifierToKeyMap[modifier] === key)\n      return modifier;\n  }).filter((modifier) => modifier);\n}\n\n// packages/alpinejs/src/directives/x-model.js\ndirective(\"model\", (el, {modifiers, expression}, {effect: effect3, cleanup}) => {\n  let evaluate2 = evaluateLater(el, expression);\n  let assignmentExpression = `${expression} = rightSideOfExpression($event, ${expression})`;\n  let evaluateAssignment = evaluateLater(el, assignmentExpression);\n  var event = el.tagName.toLowerCase() === \"select\" || [\"checkbox\", \"radio\"].includes(el.type) || modifiers.includes(\"lazy\") ? \"change\" : \"input\";\n  let assigmentFunction = generateAssignmentFunction(el, modifiers, expression);\n  let removeListener = on(el, event, modifiers, (e) => {\n    evaluateAssignment(() => {\n    }, {scope: {\n      $event: e,\n      rightSideOfExpression: assigmentFunction\n    }});\n  });\n  cleanup(() => removeListener());\n  let evaluateSetModel = evaluateLater(el, `${expression} = __placeholder`);\n  el._x_model = {\n    get() {\n      let result;\n      evaluate2((value) => result = value);\n      return result;\n    },\n    set(value) {\n      evaluateSetModel(() => {\n      }, {scope: {__placeholder: value}});\n    }\n  };\n  el._x_forceModelUpdate = () => {\n    evaluate2((value) => {\n      if (value === void 0 && expression.match(/\\./))\n        value = \"\";\n      window.fromModel = true;\n      mutateDom(() => bind(el, \"value\", value));\n      delete window.fromModel;\n    });\n  };\n  effect3(() => {\n    if (modifiers.includes(\"unintrusive\") && document.activeElement.isSameNode(el))\n      return;\n    el._x_forceModelUpdate();\n  });\n});\nfunction generateAssignmentFunction(el, modifiers, expression) {\n  if (el.type === \"radio\") {\n    mutateDom(() => {\n      if (!el.hasAttribute(\"name\"))\n        el.setAttribute(\"name\", expression);\n    });\n  }\n  return (event, currentValue) => {\n    return mutateDom(() => {\n      if (event instanceof CustomEvent && event.detail !== void 0) {\n        return event.detail || event.target.value;\n      } else if (el.type === \"checkbox\") {\n        if (Array.isArray(currentValue)) {\n          let newValue = modifiers.includes(\"number\") ? safeParseNumber(event.target.value) : event.target.value;\n          return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));\n        } else {\n          return event.target.checked;\n        }\n      } else if (el.tagName.toLowerCase() === \"select\" && el.multiple) {\n        return modifiers.includes(\"number\") ? Array.from(event.target.selectedOptions).map((option) => {\n          let rawValue = option.value || option.text;\n          return safeParseNumber(rawValue);\n        }) : Array.from(event.target.selectedOptions).map((option) => {\n          return option.value || option.text;\n        });\n      } else {\n        let rawValue = event.target.value;\n        return modifiers.includes(\"number\") ? safeParseNumber(rawValue) : modifiers.includes(\"trim\") ? rawValue.trim() : rawValue;\n      }\n    });\n  };\n}\nfunction safeParseNumber(rawValue) {\n  let number = rawValue ? parseFloat(rawValue) : null;\n  return isNumeric2(number) ? number : rawValue;\n}\nfunction checkedAttrLooseCompare2(valueA, valueB) {\n  return valueA == valueB;\n}\nfunction isNumeric2(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\n\n// packages/alpinejs/src/directives/x-cloak.js\ndirective(\"cloak\", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix(\"cloak\")))));\n\n// packages/alpinejs/src/directives/x-init.js\naddInitSelector(() => `[${prefix(\"init\")}]`);\ndirective(\"init\", skipDuringClone((el, {expression}) => {\n  if (typeof expression === \"string\") {\n    return !!expression.trim() && evaluate(el, expression, {}, false);\n  }\n  return evaluate(el, expression, {}, false);\n}));\n\n// packages/alpinejs/src/directives/x-text.js\ndirective(\"text\", (el, {expression}, {effect: effect3, evaluateLater: evaluateLater2}) => {\n  let evaluate2 = evaluateLater2(expression);\n  effect3(() => {\n    evaluate2((value) => {\n      mutateDom(() => {\n        el.textContent = value;\n      });\n    });\n  });\n});\n\n// packages/alpinejs/src/directives/x-html.js\ndirective(\"html\", (el, {expression}, {effect: effect3, evaluateLater: evaluateLater2}) => {\n  let evaluate2 = evaluateLater2(expression);\n  effect3(() => {\n    evaluate2((value) => {\n      el.innerHTML = value;\n    });\n  });\n});\n\n// packages/alpinejs/src/directives/x-bind.js\nmapAttributes(startingWith(\":\", into(prefix(\"bind:\"))));\ndirective(\"bind\", (el, {value, modifiers, expression, original}, {effect: effect3}) => {\n  if (!value)\n    return applyBindingsObject(el, expression, original, effect3);\n  if (value === \"key\")\n    return storeKeyForXFor(el, expression);\n  let evaluate2 = evaluateLater(el, expression);\n  effect3(() => evaluate2((result) => {\n    if (result === void 0 && expression.match(/\\./))\n      result = \"\";\n    mutateDom(() => bind(el, value, result, modifiers));\n  }));\n});\nfunction applyBindingsObject(el, expression, original, effect3) {\n  let getBindings = evaluateLater(el, expression);\n  let cleanupRunners = [];\n  effect3(() => {\n    while (cleanupRunners.length)\n      cleanupRunners.pop()();\n    getBindings((bindings) => {\n      let attributes = Object.entries(bindings).map(([name, value]) => ({name, value}));\n      attributes = attributes.filter((attr) => {\n        return !(typeof attr.value === \"object\" && !Array.isArray(attr.value) && attr.value !== null);\n      });\n      let staticAttributes = attributesOnly(attributes);\n      attributes = attributes.map((attribute) => {\n        if (staticAttributes.find((attr) => attr.name === attribute.name)) {\n          return {\n            name: `x-bind:${attribute.name}`,\n            value: `\"${attribute.value}\"`\n          };\n        }\n        return attribute;\n      });\n      directives(el, attributes, original).map((handle) => {\n        cleanupRunners.push(handle.runCleanups);\n        handle();\n      });\n    });\n  });\n}\nfunction storeKeyForXFor(el, expression) {\n  el._x_keyExpression = expression;\n}\n\n// packages/alpinejs/src/directives/x-data.js\naddRootSelector(() => `[${prefix(\"data\")}]`);\ndirective(\"data\", skipDuringClone((el, {expression}, {cleanup}) => {\n  expression = expression === \"\" ? \"{}\" : expression;\n  let magicContext = {};\n  injectMagics(magicContext, el);\n  let dataProviderContext = {};\n  injectDataProviders(dataProviderContext, magicContext);\n  let data2 = evaluate(el, expression, {scope: dataProviderContext});\n  if (data2 === void 0)\n    data2 = {};\n  injectMagics(data2, el);\n  let reactiveData = reactive(data2);\n  initInterceptors(reactiveData);\n  let undo = addScopeToNode(el, reactiveData);\n  reactiveData[\"init\"] && evaluate(el, reactiveData[\"init\"]);\n  cleanup(() => {\n    undo();\n    reactiveData[\"destroy\"] && evaluate(el, reactiveData[\"destroy\"]);\n  });\n}));\n\n// packages/alpinejs/src/directives/x-show.js\ndirective(\"show\", (el, {modifiers, expression}, {effect: effect3}) => {\n  let evaluate2 = evaluateLater(el, expression);\n  let hide = () => mutateDom(() => {\n    el.style.display = \"none\";\n    el._x_isShown = false;\n  });\n  let show = () => mutateDom(() => {\n    if (el.style.length === 1 && el.style.display === \"none\") {\n      el.removeAttribute(\"style\");\n    } else {\n      el.style.removeProperty(\"display\");\n    }\n    el._x_isShown = true;\n  });\n  let clickAwayCompatibleShow = () => setTimeout(show);\n  let toggle = once((value) => value ? show() : hide(), (value) => {\n    if (typeof el._x_toggleAndCascadeWithTransitions === \"function\") {\n      el._x_toggleAndCascadeWithTransitions(el, value, show, hide);\n    } else {\n      value ? clickAwayCompatibleShow() : hide();\n    }\n  });\n  let oldValue;\n  let firstTime = true;\n  effect3(() => evaluate2((value) => {\n    if (!firstTime && value === oldValue)\n      return;\n    if (modifiers.includes(\"immediate\"))\n      value ? clickAwayCompatibleShow() : hide();\n    toggle(value);\n    oldValue = value;\n    firstTime = false;\n  }));\n});\n\n// packages/alpinejs/src/directives/x-for.js\ndirective(\"for\", (el, {expression}, {effect: effect3, cleanup}) => {\n  let iteratorNames = parseForExpression(expression);\n  let evaluateItems = evaluateLater(el, iteratorNames.items);\n  let evaluateKey = evaluateLater(el, el._x_keyExpression || \"index\");\n  el._x_prevKeys = [];\n  el._x_lookup = {};\n  effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));\n  cleanup(() => {\n    Object.values(el._x_lookup).forEach((el2) => el2.remove());\n    delete el._x_prevKeys;\n    delete el._x_lookup;\n  });\n});\nfunction loop(el, iteratorNames, evaluateItems, evaluateKey) {\n  let isObject = (i) => typeof i === \"object\" && !Array.isArray(i);\n  let templateEl = el;\n  evaluateItems((items) => {\n    if (isNumeric3(items) && items >= 0) {\n      items = Array.from(Array(items).keys(), (i) => i + 1);\n    }\n    if (items === void 0)\n      items = [];\n    let lookup = el._x_lookup;\n    let prevKeys = el._x_prevKeys;\n    let scopes = [];\n    let keys = [];\n    if (isObject(items)) {\n      items = Object.entries(items).map(([key, value]) => {\n        let scope = getIterationScopeVariables(iteratorNames, value, key, items);\n        evaluateKey((value2) => keys.push(value2), {scope: {index: key, ...scope}});\n        scopes.push(scope);\n      });\n    } else {\n      for (let i = 0; i < items.length; i++) {\n        let scope = getIterationScopeVariables(iteratorNames, items[i], i, items);\n        evaluateKey((value) => keys.push(value), {scope: {index: i, ...scope}});\n        scopes.push(scope);\n      }\n    }\n    let adds = [];\n    let moves = [];\n    let removes = [];\n    let sames = [];\n    for (let i = 0; i < prevKeys.length; i++) {\n      let key = prevKeys[i];\n      if (keys.indexOf(key) === -1)\n        removes.push(key);\n    }\n    prevKeys = prevKeys.filter((key) => !removes.includes(key));\n    let lastKey = \"template\";\n    for (let i = 0; i < keys.length; i++) {\n      let key = keys[i];\n      let prevIndex = prevKeys.indexOf(key);\n      if (prevIndex === -1) {\n        prevKeys.splice(i, 0, key);\n        adds.push([lastKey, i]);\n      } else if (prevIndex !== i) {\n        let keyInSpot = prevKeys.splice(i, 1)[0];\n        let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];\n        prevKeys.splice(i, 0, keyForSpot);\n        prevKeys.splice(prevIndex, 0, keyInSpot);\n        moves.push([keyInSpot, keyForSpot]);\n      } else {\n        sames.push(key);\n      }\n      lastKey = key;\n    }\n    for (let i = 0; i < removes.length; i++) {\n      let key = removes[i];\n      lookup[key].remove();\n      lookup[key] = null;\n      delete lookup[key];\n    }\n    for (let i = 0; i < moves.length; i++) {\n      let [keyInSpot, keyForSpot] = moves[i];\n      let elInSpot = lookup[keyInSpot];\n      let elForSpot = lookup[keyForSpot];\n      let marker = document.createElement(\"div\");\n      mutateDom(() => {\n        elForSpot.after(marker);\n        elInSpot.after(elForSpot);\n        marker.before(elInSpot);\n        marker.remove();\n      });\n      refreshScope(elForSpot, scopes[keys.indexOf(keyForSpot)]);\n    }\n    for (let i = 0; i < adds.length; i++) {\n      let [lastKey2, index] = adds[i];\n      let lastEl = lastKey2 === \"template\" ? templateEl : lookup[lastKey2];\n      let scope = scopes[index];\n      let key = keys[index];\n      let clone2 = document.importNode(templateEl.content, true).firstElementChild;\n      addScopeToNode(clone2, reactive(scope), templateEl);\n      mutateDom(() => {\n        lastEl.after(clone2);\n        initTree(clone2);\n      });\n      if (typeof key === \"object\") {\n        warn(\"x-for key cannot be an object, it must be a string or an integer\", templateEl);\n      }\n      lookup[key] = clone2;\n    }\n    for (let i = 0; i < sames.length; i++) {\n      refreshScope(lookup[sames[i]], scopes[keys.indexOf(sames[i])]);\n    }\n    templateEl._x_prevKeys = keys;\n  });\n}\nfunction parseForExpression(expression) {\n  let forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  let stripParensRE = /^\\s*\\(|\\)\\s*$/g;\n  let forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n  let inMatch = expression.match(forAliasRE);\n  if (!inMatch)\n    return;\n  let res = {};\n  res.items = inMatch[2].trim();\n  let item = inMatch[1].replace(stripParensRE, \"\").trim();\n  let iteratorMatch = item.match(forIteratorRE);\n  if (iteratorMatch) {\n    res.item = item.replace(forIteratorRE, \"\").trim();\n    res.index = iteratorMatch[1].trim();\n    if (iteratorMatch[2]) {\n      res.collection = iteratorMatch[2].trim();\n    }\n  } else {\n    res.item = item;\n  }\n  return res;\n}\nfunction getIterationScopeVariables(iteratorNames, item, index, items) {\n  let scopeVariables = {};\n  if (/^\\[.*\\]$/.test(iteratorNames.item) && Array.isArray(item)) {\n    let names = iteratorNames.item.replace(\"[\", \"\").replace(\"]\", \"\").split(\",\").map((i) => i.trim());\n    names.forEach((name, i) => {\n      scopeVariables[name] = item[i];\n    });\n  } else if (/^\\{.*\\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === \"object\") {\n    let names = iteratorNames.item.replace(\"{\", \"\").replace(\"}\", \"\").split(\",\").map((i) => i.trim());\n    names.forEach((name) => {\n      scopeVariables[name] = item[name];\n    });\n  } else {\n    scopeVariables[iteratorNames.item] = item;\n  }\n  if (iteratorNames.index)\n    scopeVariables[iteratorNames.index] = index;\n  if (iteratorNames.collection)\n    scopeVariables[iteratorNames.collection] = items;\n  return scopeVariables;\n}\nfunction isNumeric3(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\n\n// packages/alpinejs/src/directives/x-ref.js\nfunction handler2() {\n}\nhandler2.inline = (el, {expression}, {cleanup}) => {\n  let root = closestRoot(el);\n  if (!root._x_refs)\n    root._x_refs = {};\n  root._x_refs[expression] = el;\n  cleanup(() => delete root._x_refs[expression]);\n};\ndirective(\"ref\", handler2);\n\n// packages/alpinejs/src/directives/x-if.js\ndirective(\"if\", (el, {expression}, {effect: effect3, cleanup}) => {\n  let evaluate2 = evaluateLater(el, expression);\n  let show = () => {\n    if (el._x_currentIfEl)\n      return el._x_currentIfEl;\n    let clone2 = el.content.cloneNode(true).firstElementChild;\n    addScopeToNode(clone2, {}, el);\n    mutateDom(() => {\n      el.after(clone2);\n      initTree(clone2);\n    });\n    el._x_currentIfEl = clone2;\n    el._x_undoIf = () => {\n      clone2.remove();\n      delete el._x_currentIfEl;\n    };\n    return clone2;\n  };\n  let hide = () => {\n    if (!el._x_undoIf)\n      return;\n    el._x_undoIf();\n    delete el._x_undoIf;\n  };\n  effect3(() => evaluate2((value) => {\n    value ? show() : hide();\n  }));\n  cleanup(() => el._x_undoIf && el._x_undoIf());\n});\n\n// packages/alpinejs/src/directives/x-on.js\nmapAttributes(startingWith(\"@\", into(prefix(\"on:\"))));\ndirective(\"on\", skipDuringClone((el, {value, modifiers, expression}, {cleanup}) => {\n  let evaluate2 = expression ? evaluateLater(el, expression) : () => {\n  };\n  let removeListener = on(el, value, modifiers, (e) => {\n    evaluate2(() => {\n    }, {scope: {$event: e}, params: [e]});\n  });\n  cleanup(() => removeListener());\n}));\n\n// packages/alpinejs/src/index.js\nalpine_default.setEvaluator(normalEvaluator);\nalpine_default.setReactivityEngine({reactive: import_reactivity9.reactive, effect: import_reactivity9.effect, release: import_reactivity9.stop, raw: import_reactivity9.toRaw});\nvar src_default = alpine_default;\n\n// packages/alpinejs/builds/module.js\nvar module_default = src_default;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWxwaW5lanMvZGlzdC9tb2R1bGUuZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsWUFBWTtBQUM5RTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0ZBQStGO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLG1FQUFtRSw2Q0FBNkMsR0FBRyxnQ0FBZ0M7QUFDdFA7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0EsZ0NBQWdDLCtCQUErQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSyxFQUFFLGlEQUFpRCxLQUFLLFNBQVM7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQSxNQUFNLEtBQUssRUFBRSxFQUVWLENBQUM7QUFDSjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZ0RBQWdEO0FBQ2hEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUIseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pELHdCQUF3Qix5QkFBeUIsWUFBWSxJQUFJO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTSxnRUFBZ0UsaUNBQWlDO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZUFBZTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFLLEVBQUUsRUFFVixDQUFDO0FBQ0o7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMEVBQTBFO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbUNBQW1DO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sT0FBTztBQUNkLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLGtCQUFrQjtBQUM1RjtBQUNBO0FBQ0EsNENBQTRDLFNBQVMsR0FBRyxJQUFJO0FBQzVEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEtBQUs7QUFDeEM7QUFDQSw2QkFBNkIsb0NBQW9DO0FBQ2pFLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDLDJDQUEyQzs7QUFFM0MsRUFBRSx5REFBeUQ7QUFDM0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHLFVBQVUsZUFBZSxJQUFJO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHVIQUF1SCxFQUFFLGFBQWE7QUFDdEk7QUFDQTtBQUNBLG9FQUFvRSxrQkFBa0IsNEJBQTRCLHdCQUF3QixxQkFBcUI7QUFDL0osTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEdBQUcsVUFBVSxlQUFlLElBQUk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFdBQVcsWUFBWTtBQUN2QixTQUFTLGdDQUFnQztBQUN6QztBQUNBLEtBQUssR0FBRyxZQUFZO0FBQ3BCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEM7QUFDQTtBQUNBLGdEQUFnRCxlQUFlO0FBQy9EO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNB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TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVLEdBQUcsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixXQUFXLEdBQUcsZ0JBQWdCOztBQUV4RDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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ckIsNkNBQTZDLGlCQUFpQjtBQUM5RDtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXLEdBQUcsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixXQUFXLEdBQUcseUJBQXlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLHNDQUFzQyw2QkFBNkIsR0FBRyxRQUFRO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHLFFBQVEsVUFBVSxjQUFjO0FBQ3hDLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLG9DQUFvQywwSUFBMEk7QUFDOUs7O0FBRUE7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FscGluZWpzL2Rpc3QvbW9kdWxlLmVzbS5qcz8wMjdlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG52YXIgX19jb21tb25KUyA9IChjYWxsYmFjaywgbW9kdWxlKSA9PiAoKSA9PiB7XG4gIGlmICghbW9kdWxlKSB7XG4gICAgbW9kdWxlID0ge2V4cG9ydHM6IHt9fTtcbiAgICBjYWxsYmFjayhtb2R1bGUuZXhwb3J0cywgbW9kdWxlKTtcbiAgfVxuICByZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59O1xudmFyIF9fZXhwb3J0U3RhciA9ICh0YXJnZXQsIG1vZHVsZSwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlICYmIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHtnZXQ6ICgpID0+IG1vZHVsZVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUpID0+IHtcbiAgcmV0dXJuIF9fZXhwb3J0U3RhcihfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUgPyB7Z2V0OiAoKSA9PiBtb2R1bGUuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZX0gOiB7dmFsdWU6IG1vZHVsZSwgZW51bWVyYWJsZTogdHJ1ZX0pKSwgbW9kdWxlKTtcbn07XG5cbi8vIG5vZGVfbW9kdWxlcy9AdnVlL3NoYXJlZC9kaXN0L3NoYXJlZC5janMuanNcbnZhciByZXF1aXJlX3NoYXJlZF9janMgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBmdW5jdGlvbiBtYWtlTWFwKHN0ciwgZXhwZWN0c0xvd2VyQ2FzZSkge1xuICAgIGNvbnN0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3QgbGlzdCA9IHN0ci5zcGxpdChcIixcIik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZSA/ICh2YWwpID0+ICEhbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXSA6ICh2YWwpID0+ICEhbWFwW3ZhbF07XG4gIH1cbiAgdmFyIFBhdGNoRmxhZ05hbWVzID0ge1xuICAgIFsxXTogYFRFWFRgLFxuICAgIFsyXTogYENMQVNTYCxcbiAgICBbNF06IGBTVFlMRWAsXG4gICAgWzhdOiBgUFJPUFNgLFxuICAgIFsxNl06IGBGVUxMX1BST1BTYCxcbiAgICBbMzJdOiBgSFlEUkFURV9FVkVOVFNgLFxuICAgIFs2NF06IGBTVEFCTEVfRlJBR01FTlRgLFxuICAgIFsxMjhdOiBgS0VZRURfRlJBR01FTlRgLFxuICAgIFsyNTZdOiBgVU5LRVlFRF9GUkFHTUVOVGAsXG4gICAgWzUxMl06IGBORUVEX1BBVENIYCxcbiAgICBbMTAyNF06IGBEWU5BTUlDX1NMT1RTYCxcbiAgICBbMjA0OF06IGBERVZfUk9PVF9GUkFHTUVOVGAsXG4gICAgWy0xXTogYEhPSVNURURgLFxuICAgIFstMl06IGBCQUlMYFxuICB9O1xuICB2YXIgc2xvdEZsYWdzVGV4dCA9IHtcbiAgICBbMV06IFwiU1RBQkxFXCIsXG4gICAgWzJdOiBcIkRZTkFNSUNcIixcbiAgICBbM106IFwiRk9SV0FSREVEXCJcbiAgfTtcbiAgdmFyIEdMT0JBTFNfV0hJVEVfTElTVEVEID0gXCJJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLHBhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LE1hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnRcIjtcbiAgdmFyIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKEdMT0JBTFNfV0hJVEVfTElTVEVEKTtcbiAgdmFyIHJhbmdlID0gMjtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUoc291cmNlLCBzdGFydDIgPSAwLCBlbmQgPSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgY29uc3QgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvdW50ICs9IGxpbmVzW2ldLmxlbmd0aCArIDE7XG4gICAgICBpZiAoY291bnQgPj0gc3RhcnQyKSB7XG4gICAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjb25zdCBsaW5lID0gaiArIDE7XG4gICAgICAgICAgcmVzLnB1c2goYCR7bGluZX0ke1wiIFwiLnJlcGVhdChNYXRoLm1heCgzIC0gU3RyaW5nKGxpbmUpLmxlbmd0aCwgMCkpfXwgICR7bGluZXNbal19YCk7XG4gICAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgICAgY29uc3QgcGFkID0gc3RhcnQyIC0gKGNvdW50IC0gbGluZUxlbmd0aCkgKyAxO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoMSwgZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnQyKTtcbiAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgXCIgXCIucmVwZWF0KHBhZCkgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKSwgMSk7XG4gICAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgdmFyIHNwZWNpYWxCb29sZWFuQXR0cnMgPSBgaXRlbXNjb3BlLGFsbG93ZnVsbHNjcmVlbixmb3Jtbm92YWxpZGF0ZSxpc21hcCxub21vZHVsZSxub3ZhbGlkYXRlLHJlYWRvbmx5YDtcbiAgdmFyIGlzU3BlY2lhbEJvb2xlYW5BdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyk7XG4gIHZhciBpc0Jvb2xlYW5BdHRyMiA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMgKyBgLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjb250cm9scyxkZWZhdWx0LGRlZmVyLGRpc2FibGVkLGhpZGRlbixsb29wLG9wZW4scmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLGNoZWNrZWQsbXV0ZWQsbXVsdGlwbGUsc2VsZWN0ZWRgKTtcbiAgdmFyIHVuc2FmZUF0dHJDaGFyUkUgPSAvWz4vPVwiJ1xcdTAwMDlcXHUwMDBhXFx1MDAwY1xcdTAwMjBdLztcbiAgdmFyIGF0dHJWYWxpZGF0aW9uQ2FjaGUgPSB7fTtcbiAgZnVuY3Rpb24gaXNTU1JTYWZlQXR0ck5hbWUobmFtZSkge1xuICAgIGlmIChhdHRyVmFsaWRhdGlvbkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXTtcbiAgICB9XG4gICAgY29uc3QgaXNVbnNhZmUgPSB1bnNhZmVBdHRyQ2hhclJFLnRlc3QobmFtZSk7XG4gICAgaWYgKGlzVW5zYWZlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGB1bnNhZmUgYXR0cmlidXRlIG5hbWU6ICR7bmFtZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV0gPSAhaXNVbnNhZmU7XG4gIH1cbiAgdmFyIHByb3BzVG9BdHRyTWFwID0ge1xuICAgIGFjY2VwdENoYXJzZXQ6IFwiYWNjZXB0LWNoYXJzZXRcIixcbiAgICBjbGFzc05hbWU6IFwiY2xhc3NcIixcbiAgICBodG1sRm9yOiBcImZvclwiLFxuICAgIGh0dHBFcXVpdjogXCJodHRwLWVxdWl2XCJcbiAgfTtcbiAgdmFyIGlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcCA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKGBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50LGJvcmRlci1pbWFnZS1vdXRzZXQsYm9yZGVyLWltYWdlLXNsaWNlLGJvcmRlci1pbWFnZS13aWR0aCxib3gtZmxleCxib3gtZmxleC1ncm91cCxib3gtb3JkaW5hbC1ncm91cCxjb2x1bW4tY291bnQsY29sdW1ucyxmbGV4LGZsZXgtZ3JvdyxmbGV4LXBvc2l0aXZlLGZsZXgtc2hyaW5rLGZsZXgtbmVnYXRpdmUsZmxleC1vcmRlcixncmlkLXJvdyxncmlkLXJvdy1lbmQsZ3JpZC1yb3ctc3BhbixncmlkLXJvdy1zdGFydCxncmlkLWNvbHVtbixncmlkLWNvbHVtbi1lbmQsZ3JpZC1jb2x1bW4tc3BhbixncmlkLWNvbHVtbi1zdGFydCxmb250LXdlaWdodCxsaW5lLWNsYW1wLGxpbmUtaGVpZ2h0LG9wYWNpdHksb3JkZXIsb3JwaGFucyx0YWItc2l6ZSx3aWRvd3Msei1pbmRleCx6b29tLGZpbGwtb3BhY2l0eSxmbG9vZC1vcGFjaXR5LHN0b3Atb3BhY2l0eSxzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LHN0cm9rZS1taXRlcmxpbWl0LHN0cm9rZS1vcGFjaXR5LHN0cm9rZS13aWR0aGApO1xuICB2YXIgaXNLbm93bkF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChgYWNjZXB0LGFjY2VwdC1jaGFyc2V0LGFjY2Vzc2tleSxhY3Rpb24sYWxpZ24sYWxsb3csYWx0LGFzeW5jLGF1dG9jYXBpdGFsaXplLGF1dG9jb21wbGV0ZSxhdXRvZm9jdXMsYXV0b3BsYXksYmFja2dyb3VuZCxiZ2NvbG9yLGJvcmRlcixidWZmZXJlZCxjYXB0dXJlLGNoYWxsZW5nZSxjaGFyc2V0LGNoZWNrZWQsY2l0ZSxjbGFzcyxjb2RlLGNvZGViYXNlLGNvbG9yLGNvbHMsY29sc3Bhbixjb250ZW50LGNvbnRlbnRlZGl0YWJsZSxjb250ZXh0bWVudSxjb250cm9scyxjb29yZHMsY3Jvc3NvcmlnaW4sY3NwLGRhdGEsZGF0ZXRpbWUsZGVjb2RpbmcsZGVmYXVsdCxkZWZlcixkaXIsZGlybmFtZSxkaXNhYmxlZCxkb3dubG9hZCxkcmFnZ2FibGUsZHJvcHpvbmUsZW5jdHlwZSxlbnRlcmtleWhpbnQsZm9yLGZvcm0sZm9ybWFjdGlvbixmb3JtZW5jdHlwZSxmb3JtbWV0aG9kLGZvcm1ub3ZhbGlkYXRlLGZvcm10YXJnZXQsaGVhZGVycyxoZWlnaHQsaGlkZGVuLGhpZ2gsaHJlZixocmVmbGFuZyxodHRwLWVxdWl2LGljb24saWQsaW1wb3J0YW5jZSxpbnRlZ3JpdHksaXNtYXAsaXRlbXByb3Asa2V5dHlwZSxraW5kLGxhYmVsLGxhbmcsbGFuZ3VhZ2UsbG9hZGluZyxsaXN0LGxvb3AsbG93LG1hbmlmZXN0LG1heCxtYXhsZW5ndGgsbWlubGVuZ3RoLG1lZGlhLG1pbixtdWx0aXBsZSxtdXRlZCxuYW1lLG5vdmFsaWRhdGUsb3BlbixvcHRpbXVtLHBhdHRlcm4scGluZyxwbGFjZWhvbGRlcixwb3N0ZXIscHJlbG9hZCxyYWRpb2dyb3VwLHJlYWRvbmx5LHJlZmVycmVycG9saWN5LHJlbCxyZXF1aXJlZCxyZXZlcnNlZCxyb3dzLHJvd3NwYW4sc2FuZGJveCxzY29wZSxzY29wZWQsc2VsZWN0ZWQsc2hhcGUsc2l6ZSxzaXplcyxzbG90LHNwYW4sc3BlbGxjaGVjayxzcmMsc3JjZG9jLHNyY2xhbmcsc3Jjc2V0LHN0YXJ0LHN0ZXAsc3R5bGUsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHJhbnNsYXRlLHR5cGUsdXNlbWFwLHZhbHVlLHdpZHRoLHdyYXBgKTtcbiAgZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUodmFsdWUpIHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTdHlsZShpc1N0cmluZyhpdGVtKSA/IHBhcnNlU3RyaW5nU3R5bGUoaXRlbSkgOiBpdGVtKTtcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxpemVkKSB7XG4gICAgICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZWRba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgdmFyIGxpc3REZWxpbWl0ZXJSRSA9IC87KD8hW14oXSpcXCkpL2c7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlclJFID0gLzooLispLztcbiAgZnVuY3Rpb24gcGFyc2VTdHJpbmdTdHlsZShjc3NUZXh0KSB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyUkUpLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIGNvbnN0IHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXJSRSk7XG4gICAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXRbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlKHN0eWxlcykge1xuICAgIGxldCByZXQgPSBcIlwiO1xuICAgIGlmICghc3R5bGVzKSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzdHlsZXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV07XG4gICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0ga2V5LnN0YXJ0c1dpdGgoYC0tYCkgPyBrZXkgOiBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIGlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcChub3JtYWxpemVkS2V5KSkge1xuICAgICAgICByZXQgKz0gYCR7bm9ybWFsaXplZEtleX06JHt2YWx1ZX07YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBub3JtYWxpemVDbGFzcyh2YWx1ZSkge1xuICAgIGxldCByZXMgPSBcIlwiO1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHJlcyA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUNsYXNzKHZhbHVlW2ldKTtcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICByZXMgKz0gbm9ybWFsaXplZCArIFwiIFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWVbbmFtZV0pIHtcbiAgICAgICAgICByZXMgKz0gbmFtZSArIFwiIFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXMudHJpbSgpO1xuICB9XG4gIHZhciBIVE1MX1RBR1MgPSBcImh0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbixkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsc3VtbWFyeSx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdFwiO1xuICB2YXIgU1ZHX1RBR1MgPSBcInN2ZyxhbmltYXRlLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxjaXJjbGUsY2xpcFBhdGgsY29sb3ItcHJvZmlsZSxkZWZzLGRlc2MsZGlzY2FyZCxlbGxpcHNlLGZlQmxlbmQsZmVDb2xvck1hdHJpeCxmZUNvbXBvbmVudFRyYW5zZmVyLGZlQ29tcG9zaXRlLGZlQ29udm9sdmVNYXRyaXgsZmVEaWZmdXNlTGlnaHRpbmcsZmVEaXNwbGFjZW1lbnRNYXAsZmVEaXN0YW5jZUxpZ2h0LGZlRHJvcFNoYWRvdyxmZUZsb29kLGZlRnVuY0EsZmVGdW5jQixmZUZ1bmNHLGZlRnVuY1IsZmVHYXVzc2lhbkJsdXIsZmVJbWFnZSxmZU1lcmdlLGZlTWVyZ2VOb2RlLGZlTW9ycGhvbG9neSxmZU9mZnNldCxmZVBvaW50TGlnaHQsZmVTcGVjdWxhckxpZ2h0aW5nLGZlU3BvdExpZ2h0LGZlVGlsZSxmZVR1cmJ1bGVuY2UsZmlsdGVyLGZvcmVpZ25PYmplY3QsZyxoYXRjaCxoYXRjaHBhdGgsaW1hZ2UsbGluZSxsaW5lYXJHcmFkaWVudCxtYXJrZXIsbWFzayxtZXNoLG1lc2hncmFkaWVudCxtZXNocGF0Y2gsbWVzaHJvdyxtZXRhZGF0YSxtcGF0aCxwYXRoLHBhdHRlcm4scG9seWdvbixwb2x5bGluZSxyYWRpYWxHcmFkaWVudCxyZWN0LHNldCxzb2xpZGNvbG9yLHN0b3Asc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRQYXRoLHRpdGxlLHRzcGFuLHVua25vd24sdXNlLHZpZXdcIjtcbiAgdmFyIFZPSURfVEFHUyA9IFwiYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxocixpbWcsaW5wdXQsbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnJcIjtcbiAgdmFyIGlzSFRNTFRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKEhUTUxfVEFHUyk7XG4gIHZhciBpc1NWR1RhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFNWR19UQUdTKTtcbiAgdmFyIGlzVm9pZFRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFZPSURfVEFHUyk7XG4gIHZhciBlc2NhcGVSRSA9IC9bXCInJjw+XS87XG4gIGZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gICAgY29uc3Qgc3RyID0gXCJcIiArIHN0cmluZztcbiAgICBjb25zdCBtYXRjaCA9IGVzY2FwZVJFLmV4ZWMoc3RyKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBsZXQgaHRtbCA9IFwiXCI7XG4gICAgbGV0IGVzY2FwZWQ7XG4gICAgbGV0IGluZGV4O1xuICAgIGxldCBsYXN0SW5kZXggPSAwO1xuICAgIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgIGVzY2FwZWQgPSBcIiZxdW90O1wiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgIGVzY2FwZWQgPSBcIiZhbXA7XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgZXNjYXBlZCA9IFwiJiMzOTtcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2MDpcbiAgICAgICAgICBlc2NhcGVkID0gXCImbHQ7XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNjI6XG4gICAgICAgICAgZXNjYXBlZCA9IFwiJmd0O1wiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgICAgaHRtbCArPSBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgaHRtbCArPSBlc2NhcGVkO1xuICAgIH1cbiAgICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbiAgfVxuICB2YXIgY29tbWVudFN0cmlwUkUgPSAvXi0/Pnw8IS0tfC0tPnwtLSE+fDwhLSQvZztcbiAgZnVuY3Rpb24gZXNjYXBlSHRtbENvbW1lbnQoc3JjKSB7XG4gICAgcmV0dXJuIHNyYy5yZXBsYWNlKGNvbW1lbnRTdHJpcFJFLCBcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGVxdWFsID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgZXF1YWwgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVxdWFsID0gbG9vc2VFcXVhbChhW2ldLCBiW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGVxdWFsO1xuICB9XG4gIGZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGFWYWxpZFR5cGUgPSBpc0RhdGUoYSk7XG4gICAgbGV0IGJWYWxpZFR5cGUgPSBpc0RhdGUoYik7XG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKSA6IGZhbHNlO1xuICAgIH1cbiAgICBhVmFsaWRUeXBlID0gaXNBcnJheShhKTtcbiAgICBiVmFsaWRUeXBlID0gaXNBcnJheShiKTtcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIDogZmFsc2U7XG4gICAgfVxuICAgIGFWYWxpZFR5cGUgPSBpc09iamVjdChhKTtcbiAgICBiVmFsaWRUeXBlID0gaXNPYmplY3QoYik7XG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgICAgaWYgKCFhVmFsaWRUeXBlIHx8ICFiVmFsaWRUeXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhhKS5sZW5ndGg7XG4gICAgICBjb25zdCBiS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYikubGVuZ3RoO1xuICAgICAgaWYgKGFLZXlzQ291bnQgIT09IGJLZXlzQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgICAgICBjb25zdCBhSGFzS2V5ID0gYS5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgICBjb25zdCBiSGFzS2V5ID0gYi5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgICBpZiAoYUhhc0tleSAmJiAhYkhhc0tleSB8fCAhYUhhc0tleSAmJiBiSGFzS2V5IHx8ICFsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG4gIH1cbiAgZnVuY3Rpb24gbG9vc2VJbmRleE9mKGFyciwgdmFsKSB7XG4gICAgcmV0dXJuIGFyci5maW5kSW5kZXgoKGl0ZW0pID0+IGxvb3NlRXF1YWwoaXRlbSwgdmFsKSk7XG4gIH1cbiAgdmFyIHRvRGlzcGxheVN0cmluZyA9ICh2YWwpID0+IHtcbiAgICByZXR1cm4gdmFsID09IG51bGwgPyBcIlwiIDogaXNPYmplY3QodmFsKSA/IEpTT04uc3RyaW5naWZ5KHZhbCwgcmVwbGFjZXIsIDIpIDogU3RyaW5nKHZhbCk7XG4gIH07XG4gIHZhciByZXBsYWNlciA9IChfa2V5LCB2YWwpID0+IHtcbiAgICBpZiAoaXNNYXAodmFsKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW2BNYXAoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwuZW50cmllcygpXS5yZWR1Y2UoKGVudHJpZXMsIFtrZXksIHZhbDJdKSA9PiB7XG4gICAgICAgICAgZW50cmllc1tgJHtrZXl9ID0+YF0gPSB2YWwyO1xuICAgICAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgICAgICB9LCB7fSlcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpc1NldCh2YWwpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbYFNldCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC52YWx1ZXMoKV1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpICYmICFpc0FycmF5KHZhbCkgJiYgIWlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmV0dXJuIFN0cmluZyh2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9O1xuICB2YXIgYmFiZWxQYXJzZXJEZWZhdWx0UGx1Z2lucyA9IFtcbiAgICBcImJpZ0ludFwiLFxuICAgIFwib3B0aW9uYWxDaGFpbmluZ1wiLFxuICAgIFwibnVsbGlzaENvYWxlc2NpbmdPcGVyYXRvclwiXG4gIF07XG4gIHZhciBFTVBUWV9PQkogPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgdmFyIEVNUFRZX0FSUiA9IE9iamVjdC5mcmVlemUoW10pO1xuICB2YXIgTk9PUCA9ICgpID0+IHtcbiAgfTtcbiAgdmFyIE5PID0gKCkgPT4gZmFsc2U7XG4gIHZhciBvblJFID0gL15vblteYS16XS87XG4gIHZhciBpc09uID0gKGtleSkgPT4gb25SRS50ZXN0KGtleSk7XG4gIHZhciBpc01vZGVsTGlzdGVuZXIgPSAoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aChcIm9uVXBkYXRlOlwiKTtcbiAgdmFyIGV4dGVuZCA9IE9iamVjdC5hc3NpZ247XG4gIHZhciByZW1vdmUgPSAoYXJyLCBlbCkgPT4ge1xuICAgIGNvbnN0IGkgPSBhcnIuaW5kZXhPZihlbCk7XG4gICAgaWYgKGkgPiAtMSkge1xuICAgICAgYXJyLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH07XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4gIHZhciBpc01hcCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgTWFwXVwiO1xuICB2YXIgaXNTZXQgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IFNldF1cIjtcbiAgdmFyIGlzRGF0ZSA9ICh2YWwpID0+IHZhbCBpbnN0YW5jZW9mIERhdGU7XG4gIHZhciBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiO1xuICB2YXIgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiO1xuICB2YXIgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN5bWJvbFwiO1xuICB2YXIgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcbiAgICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC50aGVuKSAmJiBpc0Z1bmN0aW9uKHZhbC5jYXRjaCk7XG4gIH07XG4gIHZhciBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gIHZhciB0b1R5cGVTdHJpbmcgPSAodmFsdWUpID0+IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB2YXIgdG9SYXdUeXBlID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHRvVHlwZVN0cmluZyh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xuICB9O1xuICB2YXIgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xuICB2YXIgaXNJbnRlZ2VyS2V5ID0gKGtleSkgPT4gaXNTdHJpbmcoa2V5KSAmJiBrZXkgIT09IFwiTmFOXCIgJiYga2V5WzBdICE9PSBcIi1cIiAmJiBcIlwiICsgcGFyc2VJbnQoa2V5LCAxMCkgPT09IGtleTtcbiAgdmFyIGlzUmVzZXJ2ZWRQcm9wID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXCIsa2V5LHJlZixvblZub2RlQmVmb3JlTW91bnQsb25Wbm9kZU1vdW50ZWQsb25Wbm9kZUJlZm9yZVVwZGF0ZSxvblZub2RlVXBkYXRlZCxvblZub2RlQmVmb3JlVW5tb3VudCxvblZub2RlVW5tb3VudGVkXCIpO1xuICB2YXIgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gKHN0cikgPT4ge1xuICAgICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcbiAgICB9O1xuICB9O1xuICB2YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbiAgdmFyIGNhbWVsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiBjID8gYy50b1VwcGVyQ2FzZSgpIDogXCJcIik7XG4gIH0pO1xuICB2YXIgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xuICB2YXIgaHlwaGVuYXRlID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG4gIHZhciBjYXBpdGFsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSkpO1xuICB2YXIgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIgPyBgb24ke2NhcGl0YWxpemUoc3RyKX1gIDogYGApO1xuICB2YXIgaGFzQ2hhbmdlZCA9ICh2YWx1ZSwgb2xkVmFsdWUpID0+IHZhbHVlICE9PSBvbGRWYWx1ZSAmJiAodmFsdWUgPT09IHZhbHVlIHx8IG9sZFZhbHVlID09PSBvbGRWYWx1ZSk7XG4gIHZhciBpbnZva2VBcnJheUZucyA9IChmbnMsIGFyZykgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmbnNbaV0oYXJnKTtcbiAgICB9XG4gIH07XG4gIHZhciBkZWYgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH07XG4gIHZhciB0b051bWJlciA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG4gIH07XG4gIHZhciBfZ2xvYmFsVGhpcztcbiAgdmFyIGdldEdsb2JhbFRoaXMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaGlzIHx8IChfZ2xvYmFsVGhpcyA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pO1xuICB9O1xuICBleHBvcnRzLkVNUFRZX0FSUiA9IEVNUFRZX0FSUjtcbiAgZXhwb3J0cy5FTVBUWV9PQkogPSBFTVBUWV9PQko7XG4gIGV4cG9ydHMuTk8gPSBOTztcbiAgZXhwb3J0cy5OT09QID0gTk9PUDtcbiAgZXhwb3J0cy5QYXRjaEZsYWdOYW1lcyA9IFBhdGNoRmxhZ05hbWVzO1xuICBleHBvcnRzLmJhYmVsUGFyc2VyRGVmYXVsdFBsdWdpbnMgPSBiYWJlbFBhcnNlckRlZmF1bHRQbHVnaW5zO1xuICBleHBvcnRzLmNhbWVsaXplID0gY2FtZWxpemU7XG4gIGV4cG9ydHMuY2FwaXRhbGl6ZSA9IGNhcGl0YWxpemU7XG4gIGV4cG9ydHMuZGVmID0gZGVmO1xuICBleHBvcnRzLmVzY2FwZUh0bWwgPSBlc2NhcGVIdG1sO1xuICBleHBvcnRzLmVzY2FwZUh0bWxDb21tZW50ID0gZXNjYXBlSHRtbENvbW1lbnQ7XG4gIGV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xuICBleHBvcnRzLmdlbmVyYXRlQ29kZUZyYW1lID0gZ2VuZXJhdGVDb2RlRnJhbWU7XG4gIGV4cG9ydHMuZ2V0R2xvYmFsVGhpcyA9IGdldEdsb2JhbFRoaXM7XG4gIGV4cG9ydHMuaGFzQ2hhbmdlZCA9IGhhc0NoYW5nZWQ7XG4gIGV4cG9ydHMuaGFzT3duID0gaGFzT3duO1xuICBleHBvcnRzLmh5cGhlbmF0ZSA9IGh5cGhlbmF0ZTtcbiAgZXhwb3J0cy5pbnZva2VBcnJheUZucyA9IGludm9rZUFycmF5Rm5zO1xuICBleHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuICBleHBvcnRzLmlzQm9vbGVhbkF0dHIgPSBpc0Jvb2xlYW5BdHRyMjtcbiAgZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG4gIGV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gIGV4cG9ydHMuaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gaXNHbG9iYWxseVdoaXRlbGlzdGVkO1xuICBleHBvcnRzLmlzSFRNTFRhZyA9IGlzSFRNTFRhZztcbiAgZXhwb3J0cy5pc0ludGVnZXJLZXkgPSBpc0ludGVnZXJLZXk7XG4gIGV4cG9ydHMuaXNLbm93bkF0dHIgPSBpc0tub3duQXR0cjtcbiAgZXhwb3J0cy5pc01hcCA9IGlzTWFwO1xuICBleHBvcnRzLmlzTW9kZWxMaXN0ZW5lciA9IGlzTW9kZWxMaXN0ZW5lcjtcbiAgZXhwb3J0cy5pc05vVW5pdE51bWVyaWNTdHlsZVByb3AgPSBpc05vVW5pdE51bWVyaWNTdHlsZVByb3A7XG4gIGV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbiAgZXhwb3J0cy5pc09uID0gaXNPbjtcbiAgZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG4gIGV4cG9ydHMuaXNSZXNlcnZlZFByb3AgPSBpc1Jlc2VydmVkUHJvcDtcbiAgZXhwb3J0cy5pc1NTUlNhZmVBdHRyTmFtZSA9IGlzU1NSU2FmZUF0dHJOYW1lO1xuICBleHBvcnRzLmlzU1ZHVGFnID0gaXNTVkdUYWc7XG4gIGV4cG9ydHMuaXNTZXQgPSBpc1NldDtcbiAgZXhwb3J0cy5pc1NwZWNpYWxCb29sZWFuQXR0ciA9IGlzU3BlY2lhbEJvb2xlYW5BdHRyO1xuICBleHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG4gIGV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcbiAgZXhwb3J0cy5pc1ZvaWRUYWcgPSBpc1ZvaWRUYWc7XG4gIGV4cG9ydHMubG9vc2VFcXVhbCA9IGxvb3NlRXF1YWw7XG4gIGV4cG9ydHMubG9vc2VJbmRleE9mID0gbG9vc2VJbmRleE9mO1xuICBleHBvcnRzLm1ha2VNYXAgPSBtYWtlTWFwO1xuICBleHBvcnRzLm5vcm1hbGl6ZUNsYXNzID0gbm9ybWFsaXplQ2xhc3M7XG4gIGV4cG9ydHMubm9ybWFsaXplU3R5bGUgPSBub3JtYWxpemVTdHlsZTtcbiAgZXhwb3J0cy5vYmplY3RUb1N0cmluZyA9IG9iamVjdFRvU3RyaW5nO1xuICBleHBvcnRzLnBhcnNlU3RyaW5nU3R5bGUgPSBwYXJzZVN0cmluZ1N0eWxlO1xuICBleHBvcnRzLnByb3BzVG9BdHRyTWFwID0gcHJvcHNUb0F0dHJNYXA7XG4gIGV4cG9ydHMucmVtb3ZlID0gcmVtb3ZlO1xuICBleHBvcnRzLnNsb3RGbGFnc1RleHQgPSBzbG90RmxhZ3NUZXh0O1xuICBleHBvcnRzLnN0cmluZ2lmeVN0eWxlID0gc3RyaW5naWZ5U3R5bGU7XG4gIGV4cG9ydHMudG9EaXNwbGF5U3RyaW5nID0gdG9EaXNwbGF5U3RyaW5nO1xuICBleHBvcnRzLnRvSGFuZGxlcktleSA9IHRvSGFuZGxlcktleTtcbiAgZXhwb3J0cy50b051bWJlciA9IHRvTnVtYmVyO1xuICBleHBvcnRzLnRvUmF3VHlwZSA9IHRvUmF3VHlwZTtcbiAgZXhwb3J0cy50b1R5cGVTdHJpbmcgPSB0b1R5cGVTdHJpbmc7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0B2dWUvc2hhcmVkL2luZGV4LmpzXG52YXIgcmVxdWlyZV9zaGFyZWQgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIGlmIChmYWxzZSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfc2hhcmVkX2NqcygpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0B2dWUvcmVhY3Rpdml0eS9kaXN0L3JlYWN0aXZpdHkuY2pzLmpzXG52YXIgcmVxdWlyZV9yZWFjdGl2aXR5X2NqcyA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIHZhciBzaGFyZWQgPSByZXF1aXJlX3NoYXJlZCgpO1xuICB2YXIgdGFyZ2V0TWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgdmFyIGVmZmVjdFN0YWNrID0gW107XG4gIHZhciBhY3RpdmVFZmZlY3Q7XG4gIHZhciBJVEVSQVRFX0tFWSA9IFN5bWJvbChcIml0ZXJhdGVcIik7XG4gIHZhciBNQVBfS0VZX0lURVJBVEVfS0VZID0gU3ltYm9sKFwiTWFwIGtleSBpdGVyYXRlXCIpO1xuICBmdW5jdGlvbiBpc0VmZmVjdChmbikge1xuICAgIHJldHVybiBmbiAmJiBmbi5faXNFZmZlY3QgPT09IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gZWZmZWN0Myhmbiwgb3B0aW9ucyA9IHNoYXJlZC5FTVBUWV9PQkopIHtcbiAgICBpZiAoaXNFZmZlY3QoZm4pKSB7XG4gICAgICBmbiA9IGZuLnJhdztcbiAgICB9XG4gICAgY29uc3QgZWZmZWN0NCA9IGNyZWF0ZVJlYWN0aXZlRWZmZWN0KGZuLCBvcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMubGF6eSkge1xuICAgICAgZWZmZWN0NCgpO1xuICAgIH1cbiAgICByZXR1cm4gZWZmZWN0NDtcbiAgfVxuICBmdW5jdGlvbiBzdG9wMihlZmZlY3Q0KSB7XG4gICAgaWYgKGVmZmVjdDQuYWN0aXZlKSB7XG4gICAgICBjbGVhbnVwKGVmZmVjdDQpO1xuICAgICAgaWYgKGVmZmVjdDQub3B0aW9ucy5vblN0b3ApIHtcbiAgICAgICAgZWZmZWN0NC5vcHRpb25zLm9uU3RvcCgpO1xuICAgICAgfVxuICAgICAgZWZmZWN0NC5hY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgdmFyIHVpZCA9IDA7XG4gIGZ1bmN0aW9uIGNyZWF0ZVJlYWN0aXZlRWZmZWN0KGZuLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZWZmZWN0NCA9IGZ1bmN0aW9uIHJlYWN0aXZlRWZmZWN0KCkge1xuICAgICAgaWYgKCFlZmZlY3Q0LmFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH1cbiAgICAgIGlmICghZWZmZWN0U3RhY2suaW5jbHVkZXMoZWZmZWN0NCkpIHtcbiAgICAgICAgY2xlYW51cChlZmZlY3Q0KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlbmFibGVUcmFja2luZygpO1xuICAgICAgICAgIGVmZmVjdFN0YWNrLnB1c2goZWZmZWN0NCk7XG4gICAgICAgICAgYWN0aXZlRWZmZWN0ID0gZWZmZWN0NDtcbiAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBlZmZlY3RTdGFjay5wb3AoKTtcbiAgICAgICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICAgICAgYWN0aXZlRWZmZWN0ID0gZWZmZWN0U3RhY2tbZWZmZWN0U3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGVmZmVjdDQuaWQgPSB1aWQrKztcbiAgICBlZmZlY3Q0LmFsbG93UmVjdXJzZSA9ICEhb3B0aW9ucy5hbGxvd1JlY3Vyc2U7XG4gICAgZWZmZWN0NC5faXNFZmZlY3QgPSB0cnVlO1xuICAgIGVmZmVjdDQuYWN0aXZlID0gdHJ1ZTtcbiAgICBlZmZlY3Q0LnJhdyA9IGZuO1xuICAgIGVmZmVjdDQuZGVwcyA9IFtdO1xuICAgIGVmZmVjdDQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIGVmZmVjdDQ7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYW51cChlZmZlY3Q0KSB7XG4gICAgY29uc3Qge2RlcHN9ID0gZWZmZWN0NDtcbiAgICBpZiAoZGVwcy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZXBzW2ldLmRlbGV0ZShlZmZlY3Q0KTtcbiAgICAgIH1cbiAgICAgIGRlcHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cbiAgdmFyIHNob3VsZFRyYWNrID0gdHJ1ZTtcbiAgdmFyIHRyYWNrU3RhY2sgPSBbXTtcbiAgZnVuY3Rpb24gcGF1c2VUcmFja2luZygpIHtcbiAgICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xuICAgIHNob3VsZFRyYWNrID0gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gZW5hYmxlVHJhY2tpbmcoKSB7XG4gICAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcbiAgICBzaG91bGRUcmFjayA9IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gcmVzZXRUcmFja2luZygpIHtcbiAgICBjb25zdCBsYXN0ID0gdHJhY2tTdGFjay5wb3AoKTtcbiAgICBzaG91bGRUcmFjayA9IGxhc3QgPT09IHZvaWQgMCA/IHRydWUgOiBsYXN0O1xuICB9XG4gIGZ1bmN0aW9uIHRyYWNrKHRhcmdldCwgdHlwZSwga2V5KSB7XG4gICAgaWYgKCFzaG91bGRUcmFjayB8fCBhY3RpdmVFZmZlY3QgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcbiAgICBpZiAoIWRlcHNNYXApIHtcbiAgICAgIHRhcmdldE1hcC5zZXQodGFyZ2V0LCBkZXBzTWFwID0gbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgbGV0IGRlcCA9IGRlcHNNYXAuZ2V0KGtleSk7XG4gICAgaWYgKCFkZXApIHtcbiAgICAgIGRlcHNNYXAuc2V0KGtleSwgZGVwID0gbmV3IFNldCgpKTtcbiAgICB9XG4gICAgaWYgKCFkZXAuaGFzKGFjdGl2ZUVmZmVjdCkpIHtcbiAgICAgIGRlcC5hZGQoYWN0aXZlRWZmZWN0KTtcbiAgICAgIGFjdGl2ZUVmZmVjdC5kZXBzLnB1c2goZGVwKTtcbiAgICAgIGlmIChhY3RpdmVFZmZlY3Qub3B0aW9ucy5vblRyYWNrKSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdC5vcHRpb25zLm9uVHJhY2soe1xuICAgICAgICAgIGVmZmVjdDogYWN0aXZlRWZmZWN0LFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGtleVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJpZ2dlcih0YXJnZXQsIHR5cGUsIGtleSwgbmV3VmFsdWUsIG9sZFZhbHVlLCBvbGRUYXJnZXQpIHtcbiAgICBjb25zdCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICAgIGlmICghZGVwc01hcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZmZlY3RzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGFkZDIgPSAoZWZmZWN0c1RvQWRkKSA9PiB7XG4gICAgICBpZiAoZWZmZWN0c1RvQWRkKSB7XG4gICAgICAgIGVmZmVjdHNUb0FkZC5mb3JFYWNoKChlZmZlY3Q0KSA9PiB7XG4gICAgICAgICAgaWYgKGVmZmVjdDQgIT09IGFjdGl2ZUVmZmVjdCB8fCBlZmZlY3Q0LmFsbG93UmVjdXJzZSkge1xuICAgICAgICAgICAgZWZmZWN0cy5hZGQoZWZmZWN0NCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICh0eXBlID09PSBcImNsZWFyXCIpIHtcbiAgICAgIGRlcHNNYXAuZm9yRWFjaChhZGQyKTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJsZW5ndGhcIiAmJiBzaGFyZWQuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICBkZXBzTWFwLmZvckVhY2goKGRlcCwga2V5MikgPT4ge1xuICAgICAgICBpZiAoa2V5MiA9PT0gXCJsZW5ndGhcIiB8fCBrZXkyID49IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgYWRkMihkZXApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGtleSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGFkZDIoZGVwc01hcC5nZXQoa2V5KSk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICAgIGlmICghc2hhcmVkLmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgICAgYWRkMihkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgaWYgKHNoYXJlZC5pc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgIGFkZDIoZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcmVkLmlzSW50ZWdlcktleShrZXkpKSB7XG4gICAgICAgICAgICBhZGQyKGRlcHNNYXAuZ2V0KFwibGVuZ3RoXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgICAgICBpZiAoIXNoYXJlZC5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgIGFkZDIoZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICAgIGlmIChzaGFyZWQuaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgICBhZGQyKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzZXRcIjpcbiAgICAgICAgICBpZiAoc2hhcmVkLmlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgIGFkZDIoZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJ1biA9IChlZmZlY3Q0KSA9PiB7XG4gICAgICBpZiAoZWZmZWN0NC5vcHRpb25zLm9uVHJpZ2dlcikge1xuICAgICAgICBlZmZlY3Q0Lm9wdGlvbnMub25UcmlnZ2VyKHtcbiAgICAgICAgICBlZmZlY3Q6IGVmZmVjdDQsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgIG9sZFZhbHVlLFxuICAgICAgICAgIG9sZFRhcmdldFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChlZmZlY3Q0Lm9wdGlvbnMuc2NoZWR1bGVyKSB7XG4gICAgICAgIGVmZmVjdDQub3B0aW9ucy5zY2hlZHVsZXIoZWZmZWN0NCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZmZlY3Q0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBlZmZlY3RzLmZvckVhY2gocnVuKTtcbiAgfVxuICB2YXIgaXNOb25UcmFja2FibGVLZXlzID0gLyogQF9fUFVSRV9fICovIHNoYXJlZC5tYWtlTWFwKGBfX3Byb3RvX18sX192X2lzUmVmLF9faXNWdWVgKTtcbiAgdmFyIGJ1aWx0SW5TeW1ib2xzID0gbmV3IFNldChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhTeW1ib2wpLm1hcCgoa2V5KSA9PiBTeW1ib2xba2V5XSkuZmlsdGVyKHNoYXJlZC5pc1N5bWJvbCkpO1xuICB2YXIgZ2V0MiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVHZXR0ZXIoKTtcbiAgdmFyIHNoYWxsb3dHZXQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlR2V0dGVyKGZhbHNlLCB0cnVlKTtcbiAgdmFyIHJlYWRvbmx5R2V0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUdldHRlcih0cnVlKTtcbiAgdmFyIHNoYWxsb3dSZWFkb25seUdldCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVHZXR0ZXIodHJ1ZSwgdHJ1ZSk7XG4gIHZhciBhcnJheUluc3RydW1lbnRhdGlvbnMgPSB7fTtcbiAgW1wiaW5jbHVkZXNcIiwgXCJpbmRleE9mXCIsIFwibGFzdEluZGV4T2ZcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3QgbWV0aG9kID0gQXJyYXkucHJvdG90eXBlW2tleV07XG4gICAgYXJyYXlJbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBjb25zdCBhcnIgPSB0b1JhdzIodGhpcyk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRyYWNrKGFyciwgXCJnZXRcIiwgaSArIFwiXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzID0gbWV0aG9kLmFwcGx5KGFyciwgYXJncyk7XG4gICAgICBpZiAocmVzID09PSAtMSB8fCByZXMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkoYXJyLCBhcmdzLm1hcCh0b1JhdzIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIFtcInB1c2hcIiwgXCJwb3BcIiwgXCJzaGlmdFwiLCBcInVuc2hpZnRcIiwgXCJzcGxpY2VcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3QgbWV0aG9kID0gQXJyYXkucHJvdG90eXBlW2tleV07XG4gICAgYXJyYXlJbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICBjb25zdCByZXMgPSBtZXRob2QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gIH0pO1xuICBmdW5jdGlvbiBjcmVhdGVHZXR0ZXIoaXNSZWFkb25seTIgPSBmYWxzZSwgc2hhbGxvdyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGdldDModGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XG4gICAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIpIHtcbiAgICAgICAgcmV0dXJuICFpc1JlYWRvbmx5MjtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIpIHtcbiAgICAgICAgcmV0dXJuIGlzUmVhZG9ubHkyO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiICYmIHJlY2VpdmVyID09PSAoaXNSZWFkb25seTIgPyBzaGFsbG93ID8gc2hhbGxvd1JlYWRvbmx5TWFwIDogcmVhZG9ubHlNYXAgOiBzaGFsbG93ID8gc2hhbGxvd1JlYWN0aXZlTWFwIDogcmVhY3RpdmVNYXApLmdldCh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gc2hhcmVkLmlzQXJyYXkodGFyZ2V0KTtcbiAgICAgIGlmICghaXNSZWFkb25seTIgJiYgdGFyZ2V0SXNBcnJheSAmJiBzaGFyZWQuaGFzT3duKGFycmF5SW5zdHJ1bWVudGF0aW9ucywga2V5KSkge1xuICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoYXJyYXlJbnN0cnVtZW50YXRpb25zLCBrZXksIHJlY2VpdmVyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlcyA9IFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcik7XG4gICAgICBpZiAoc2hhcmVkLmlzU3ltYm9sKGtleSkgPyBidWlsdEluU3ltYm9scy5oYXMoa2V5KSA6IGlzTm9uVHJhY2thYmxlS2V5cyhrZXkpKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgICBpZiAoIWlzUmVhZG9ubHkyKSB7XG4gICAgICAgIHRyYWNrKHRhcmdldCwgXCJnZXRcIiwga2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChzaGFsbG93KSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgICBpZiAoaXNSZWYocmVzKSkge1xuICAgICAgICBjb25zdCBzaG91bGRVbndyYXAgPSAhdGFyZ2V0SXNBcnJheSB8fCAhc2hhcmVkLmlzSW50ZWdlcktleShrZXkpO1xuICAgICAgICByZXR1cm4gc2hvdWxkVW53cmFwID8gcmVzLnZhbHVlIDogcmVzO1xuICAgICAgfVxuICAgICAgaWYgKHNoYXJlZC5pc09iamVjdChyZXMpKSB7XG4gICAgICAgIHJldHVybiBpc1JlYWRvbmx5MiA/IHJlYWRvbmx5KHJlcykgOiByZWFjdGl2ZTMocmVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgfVxuICB2YXIgc2V0MiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTZXR0ZXIoKTtcbiAgdmFyIHNoYWxsb3dTZXQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlU2V0dGVyKHRydWUpO1xuICBmdW5jdGlvbiBjcmVhdGVTZXR0ZXIoc2hhbGxvdyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNldDModGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgbGV0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgICBpZiAoIXNoYWxsb3cpIHtcbiAgICAgICAgdmFsdWUgPSB0b1JhdzIodmFsdWUpO1xuICAgICAgICBvbGRWYWx1ZSA9IHRvUmF3MihvbGRWYWx1ZSk7XG4gICAgICAgIGlmICghc2hhcmVkLmlzQXJyYXkodGFyZ2V0KSAmJiBpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGhhZEtleSA9IHNoYXJlZC5pc0FycmF5KHRhcmdldCkgJiYgc2hhcmVkLmlzSW50ZWdlcktleShrZXkpID8gTnVtYmVyKGtleSkgPCB0YXJnZXQubGVuZ3RoIDogc2hhcmVkLmhhc093bih0YXJnZXQsIGtleSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICAgIGlmICh0YXJnZXQgPT09IHRvUmF3MihyZWNlaXZlcikpIHtcbiAgICAgICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcmVkLmhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICAgIGNvbnN0IGhhZEtleSA9IHNoYXJlZC5oYXNPd24odGFyZ2V0LCBrZXkpO1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSk7XG4gICAgaWYgKHJlc3VsdCAmJiBoYWRLZXkpIHtcbiAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiLCBrZXksIHZvaWQgMCwgb2xkVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIGhhcyh0YXJnZXQsIGtleSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuaGFzKHRhcmdldCwga2V5KTtcbiAgICBpZiAoIXNoYXJlZC5pc1N5bWJvbChrZXkpIHx8ICFidWlsdEluU3ltYm9scy5oYXMoa2V5KSkge1xuICAgICAgdHJhY2sodGFyZ2V0LCBcImhhc1wiLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIG93bktleXModGFyZ2V0KSB7XG4gICAgdHJhY2sodGFyZ2V0LCBcIml0ZXJhdGVcIiwgc2hhcmVkLmlzQXJyYXkodGFyZ2V0KSA/IFwibGVuZ3RoXCIgOiBJVEVSQVRFX0tFWSk7XG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICB9XG4gIHZhciBtdXRhYmxlSGFuZGxlcnMgPSB7XG4gICAgZ2V0OiBnZXQyLFxuICAgIHNldDogc2V0MixcbiAgICBkZWxldGVQcm9wZXJ0eSxcbiAgICBoYXMsXG4gICAgb3duS2V5c1xuICB9O1xuICB2YXIgcmVhZG9ubHlIYW5kbGVycyA9IHtcbiAgICBnZXQ6IHJlYWRvbmx5R2V0LFxuICAgIHNldCh0YXJnZXQsIGtleSkge1xuICAgICAge1xuICAgICAgICBjb25zb2xlLndhcm4oYFNldCBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0YXJnZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICAgICAge1xuICAgICAgICBjb25zb2xlLndhcm4oYERlbGV0ZSBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0YXJnZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuICB2YXIgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMgPSBzaGFyZWQuZXh0ZW5kKHt9LCBtdXRhYmxlSGFuZGxlcnMsIHtcbiAgICBnZXQ6IHNoYWxsb3dHZXQsXG4gICAgc2V0OiBzaGFsbG93U2V0XG4gIH0pO1xuICB2YXIgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMgPSBzaGFyZWQuZXh0ZW5kKHt9LCByZWFkb25seUhhbmRsZXJzLCB7XG4gICAgZ2V0OiBzaGFsbG93UmVhZG9ubHlHZXRcbiAgfSk7XG4gIHZhciB0b1JlYWN0aXZlID0gKHZhbHVlKSA9PiBzaGFyZWQuaXNPYmplY3QodmFsdWUpID8gcmVhY3RpdmUzKHZhbHVlKSA6IHZhbHVlO1xuICB2YXIgdG9SZWFkb25seSA9ICh2YWx1ZSkgPT4gc2hhcmVkLmlzT2JqZWN0KHZhbHVlKSA/IHJlYWRvbmx5KHZhbHVlKSA6IHZhbHVlO1xuICB2YXIgdG9TaGFsbG93ID0gKHZhbHVlKSA9PiB2YWx1ZTtcbiAgdmFyIGdldFByb3RvID0gKHYpID0+IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yodik7XG4gIGZ1bmN0aW9uIGdldCQxKHRhcmdldCwga2V5LCBpc1JlYWRvbmx5MiA9IGZhbHNlLCBpc1NoYWxsb3cgPSBmYWxzZSkge1xuICAgIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIl07XG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcyKHRhcmdldCk7XG4gICAgY29uc3QgcmF3S2V5ID0gdG9SYXcyKGtleSk7XG4gICAgaWYgKGtleSAhPT0gcmF3S2V5KSB7XG4gICAgICAhaXNSZWFkb25seTIgJiYgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiLCBrZXkpO1xuICAgIH1cbiAgICAhaXNSZWFkb25seTIgJiYgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiLCByYXdLZXkpO1xuICAgIGNvbnN0IHtoYXM6IGhhczJ9ID0gZ2V0UHJvdG8ocmF3VGFyZ2V0KTtcbiAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seTIgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICBpZiAoaGFzMi5jYWxsKHJhd1RhcmdldCwga2V5KSkge1xuICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChrZXkpKTtcbiAgICB9IGVsc2UgaWYgKGhhczIuY2FsbChyYXdUYXJnZXQsIHJhd0tleSkpIHtcbiAgICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQocmF3S2V5KSk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQgIT09IHJhd1RhcmdldCkge1xuICAgICAgdGFyZ2V0LmdldChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoYXMkMShrZXksIGlzUmVhZG9ubHkyID0gZmFsc2UpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1JhdzIodGFyZ2V0KTtcbiAgICBjb25zdCByYXdLZXkgPSB0b1JhdzIoa2V5KTtcbiAgICBpZiAoa2V5ICE9PSByYXdLZXkpIHtcbiAgICAgICFpc1JlYWRvbmx5MiAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIsIGtleSk7XG4gICAgfVxuICAgICFpc1JlYWRvbmx5MiAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIsIHJhd0tleSk7XG4gICAgcmV0dXJuIGtleSA9PT0gcmF3S2V5ID8gdGFyZ2V0LmhhcyhrZXkpIDogdGFyZ2V0LmhhcyhrZXkpIHx8IHRhcmdldC5oYXMocmF3S2V5KTtcbiAgfVxuICBmdW5jdGlvbiBzaXplKHRhcmdldCwgaXNSZWFkb25seTIgPSBmYWxzZSkge1xuICAgIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIl07XG4gICAgIWlzUmVhZG9ubHkyICYmIHRyYWNrKHRvUmF3Mih0YXJnZXQpLCBcIml0ZXJhdGVcIiwgSVRFUkFURV9LRVkpO1xuICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIFwic2l6ZVwiLCB0YXJnZXQpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHZhbHVlID0gdG9SYXcyKHZhbHVlKTtcbiAgICBjb25zdCB0YXJnZXQgPSB0b1JhdzIodGhpcyk7XG4gICAgY29uc3QgcHJvdG8gPSBnZXRQcm90byh0YXJnZXQpO1xuICAgIGNvbnN0IGhhZEtleSA9IHByb3RvLmhhcy5jYWxsKHRhcmdldCwgdmFsdWUpO1xuICAgIGlmICghaGFkS2V5KSB7XG4gICAgICB0YXJnZXQuYWRkKHZhbHVlKTtcbiAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCB2YWx1ZSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmdW5jdGlvbiBzZXQkMShrZXksIHZhbHVlKSB7XG4gICAgdmFsdWUgPSB0b1JhdzIodmFsdWUpO1xuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3Mih0aGlzKTtcbiAgICBjb25zdCB7aGFzOiBoYXMyLCBnZXQ6IGdldDN9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgICBsZXQgaGFkS2V5ID0gaGFzMi5jYWxsKHRhcmdldCwga2V5KTtcbiAgICBpZiAoIWhhZEtleSkge1xuICAgICAga2V5ID0gdG9SYXcyKGtleSk7XG4gICAgICBoYWRLZXkgPSBoYXMyLmNhbGwodGFyZ2V0LCBrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhczIsIGtleSk7XG4gICAgfVxuICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0My5jYWxsKHRhcmdldCwga2V5KTtcbiAgICB0YXJnZXQuc2V0KGtleSwgdmFsdWUpO1xuICAgIGlmICghaGFkS2V5KSB7XG4gICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwga2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChzaGFyZWQuaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiwga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmdW5jdGlvbiBkZWxldGVFbnRyeShrZXkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0b1JhdzIodGhpcyk7XG4gICAgY29uc3Qge2hhczogaGFzMiwgZ2V0OiBnZXQzfSA9IGdldFByb3RvKHRhcmdldCk7XG4gICAgbGV0IGhhZEtleSA9IGhhczIuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgIGtleSA9IHRvUmF3MihrZXkpO1xuICAgICAgaGFkS2V5ID0gaGFzMi5jYWxsKHRhcmdldCwga2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMyLCBrZXkpO1xuICAgIH1cbiAgICBjb25zdCBvbGRWYWx1ZSA9IGdldDMgPyBnZXQzLmNhbGwodGFyZ2V0LCBrZXkpIDogdm9pZCAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5kZWxldGUoa2V5KTtcbiAgICBpZiAoaGFkS2V5KSB7XG4gICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiwga2V5LCB2b2lkIDAsIG9sZFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0b1JhdzIodGhpcyk7XG4gICAgY29uc3QgaGFkSXRlbXMgPSB0YXJnZXQuc2l6ZSAhPT0gMDtcbiAgICBjb25zdCBvbGRUYXJnZXQgPSBzaGFyZWQuaXNNYXAodGFyZ2V0KSA/IG5ldyBNYXAodGFyZ2V0KSA6IG5ldyBTZXQodGFyZ2V0KTtcbiAgICBjb25zdCByZXN1bHQgPSB0YXJnZXQuY2xlYXIoKTtcbiAgICBpZiAoaGFkSXRlbXMpIHtcbiAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImNsZWFyXCIsIHZvaWQgMCwgdm9pZCAwLCBvbGRUYXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUZvckVhY2goaXNSZWFkb25seTIsIGlzU2hhbGxvdykge1xuICAgIHJldHVybiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBjb25zdCBvYnNlcnZlZCA9IHRoaXM7XG4gICAgICBjb25zdCB0YXJnZXQgPSBvYnNlcnZlZFtcIl9fdl9yYXdcIl07XG4gICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1JhdzIodGFyZ2V0KTtcbiAgICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5MiA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICAgICAgIWlzUmVhZG9ubHkyICYmIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIsIElURVJBVEVfS0VZKTtcbiAgICAgIHJldHVybiB0YXJnZXQuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB3cmFwKHZhbHVlKSwgd3JhcChrZXkpLCBvYnNlcnZlZCk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgaXNSZWFkb25seTIsIGlzU2hhbGxvdykge1xuICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcbiAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3Mih0YXJnZXQpO1xuICAgICAgY29uc3QgdGFyZ2V0SXNNYXAgPSBzaGFyZWQuaXNNYXAocmF3VGFyZ2V0KTtcbiAgICAgIGNvbnN0IGlzUGFpciA9IG1ldGhvZCA9PT0gXCJlbnRyaWVzXCIgfHwgbWV0aG9kID09PSBTeW1ib2wuaXRlcmF0b3IgJiYgdGFyZ2V0SXNNYXA7XG4gICAgICBjb25zdCBpc0tleU9ubHkgPSBtZXRob2QgPT09IFwia2V5c1wiICYmIHRhcmdldElzTWFwO1xuICAgICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRhcmdldFttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkyID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgICAhaXNSZWFkb25seTIgJiYgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiwgaXNLZXlPbmx5ID8gTUFQX0tFWV9JVEVSQVRFX0tFWSA6IElURVJBVEVfS0VZKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgY29uc3Qge3ZhbHVlLCBkb25lfSA9IGlubmVySXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIHJldHVybiBkb25lID8ge3ZhbHVlLCBkb25lfSA6IHtcbiAgICAgICAgICAgIHZhbHVlOiBpc1BhaXIgPyBbd3JhcCh2YWx1ZVswXSksIHdyYXAodmFsdWVbMV0pXSA6IHdyYXAodmFsdWUpLFxuICAgICAgICAgICAgZG9uZVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlUmVhZG9ubHlNZXRob2QodHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICB7XG4gICAgICAgIGNvbnN0IGtleSA9IGFyZ3NbMF0gPyBgb24ga2V5IFwiJHthcmdzWzBdfVwiIGAgOiBgYDtcbiAgICAgICAgY29uc29sZS53YXJuKGAke3NoYXJlZC5jYXBpdGFsaXplKHR5cGUpfSBvcGVyYXRpb24gJHtrZXl9ZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdG9SYXcyKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlID09PSBcImRlbGV0ZVwiID8gZmFsc2UgOiB0aGlzO1xuICAgIH07XG4gIH1cbiAgdmFyIG11dGFibGVJbnN0cnVtZW50YXRpb25zID0ge1xuICAgIGdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXkpO1xuICAgIH0sXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gc2l6ZSh0aGlzKTtcbiAgICB9LFxuICAgIGhhczogaGFzJDEsXG4gICAgYWRkLFxuICAgIHNldDogc2V0JDEsXG4gICAgZGVsZXRlOiBkZWxldGVFbnRyeSxcbiAgICBjbGVhcixcbiAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCBmYWxzZSlcbiAgfTtcbiAgdmFyIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zID0ge1xuICAgIGdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXksIGZhbHNlLCB0cnVlKTtcbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIHNpemUodGhpcyk7XG4gICAgfSxcbiAgICBoYXM6IGhhcyQxLFxuICAgIGFkZCxcbiAgICBzZXQ6IHNldCQxLFxuICAgIGRlbGV0ZTogZGVsZXRlRW50cnksXG4gICAgY2xlYXIsXG4gICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaChmYWxzZSwgdHJ1ZSlcbiAgfTtcbiAgdmFyIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA9IHtcbiAgICBnZXQoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCB0cnVlKTtcbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICBoYXMoa2V5KSB7XG4gICAgICByZXR1cm4gaGFzJDEuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xuICAgIH0sXG4gICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiKSxcbiAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIpLFxuICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiksXG4gICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIiksXG4gICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCBmYWxzZSlcbiAgfTtcbiAgdmFyIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnMgPSB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfSxcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiBzaXplKHRoaXMsIHRydWUpO1xuICAgIH0sXG4gICAgaGFzKGtleSkge1xuICAgICAgcmV0dXJuIGhhcyQxLmNhbGwodGhpcywga2V5LCB0cnVlKTtcbiAgICB9LFxuICAgIGFkZDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJhZGRcIiksXG4gICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiKSxcbiAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIpLFxuICAgIGNsZWFyOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImNsZWFyXCIpLFxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2godHJ1ZSwgdHJ1ZSlcbiAgfTtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kcyA9IFtcImtleXNcIiwgXCJ2YWx1ZXNcIiwgXCJlbnRyaWVzXCIsIFN5bWJvbC5pdGVyYXRvcl07XG4gIGl0ZXJhdG9yTWV0aG9kcy5mb3JFYWNoKChtZXRob2QpID0+IHtcbiAgICBtdXRhYmxlSW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBmYWxzZSwgZmFsc2UpO1xuICAgIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCB0cnVlLCBmYWxzZSk7XG4gICAgc2hhbGxvd0luc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgZmFsc2UsIHRydWUpO1xuICAgIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgdHJ1ZSwgdHJ1ZSk7XG4gIH0pO1xuICBmdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoaXNSZWFkb25seTIsIHNoYWxsb3cpIHtcbiAgICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0gc2hhbGxvdyA/IGlzUmVhZG9ubHkyID8gc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA6IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zIDogaXNSZWFkb25seTIgPyByZWFkb25seUluc3RydW1lbnRhdGlvbnMgOiBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucztcbiAgICByZXR1cm4gKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFjdGl2ZVwiKSB7XG4gICAgICAgIHJldHVybiAhaXNSZWFkb25seTI7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiKSB7XG4gICAgICAgIHJldHVybiBpc1JlYWRvbmx5MjtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIikge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHNoYXJlZC5oYXNPd24oaW5zdHJ1bWVudGF0aW9ucywga2V5KSAmJiBrZXkgaW4gdGFyZ2V0ID8gaW5zdHJ1bWVudGF0aW9ucyA6IHRhcmdldCwga2V5LCByZWNlaXZlcik7XG4gICAgfTtcbiAgfVxuICB2YXIgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgICBnZXQ6IGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgZmFsc2UpXG4gIH07XG4gIHZhciBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICAgIGdldDogY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCB0cnVlKVxuICB9O1xuICB2YXIgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gICAgZ2V0OiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgZmFsc2UpXG4gIH07XG4gIHZhciBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gICAgZ2V0OiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgdHJ1ZSlcbiAgfTtcbiAgZnVuY3Rpb24gY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMyLCBrZXkpIHtcbiAgICBjb25zdCByYXdLZXkgPSB0b1JhdzIoa2V5KTtcbiAgICBpZiAocmF3S2V5ICE9PSBrZXkgJiYgaGFzMi5jYWxsKHRhcmdldCwgcmF3S2V5KSkge1xuICAgICAgY29uc3QgdHlwZSA9IHNoYXJlZC50b1Jhd1R5cGUodGFyZ2V0KTtcbiAgICAgIGNvbnNvbGUud2FybihgUmVhY3RpdmUgJHt0eXBlfSBjb250YWlucyBib3RoIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIG9mIHRoZSBzYW1lIG9iamVjdCR7dHlwZSA9PT0gYE1hcGAgPyBgIGFzIGtleXNgIDogYGB9LCB3aGljaCBjYW4gbGVhZCB0byBpbmNvbnNpc3RlbmNpZXMuIEF2b2lkIGRpZmZlcmVudGlhdGluZyBiZXR3ZWVuIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIG9mIGFuIG9iamVjdCBhbmQgb25seSB1c2UgdGhlIHJlYWN0aXZlIHZlcnNpb24gaWYgcG9zc2libGUuYCk7XG4gICAgfVxuICB9XG4gIHZhciByZWFjdGl2ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gIHZhciBzaGFsbG93UmVhY3RpdmVNYXAgPSBuZXcgV2Vha01hcCgpO1xuICB2YXIgcmVhZG9ubHlNYXAgPSBuZXcgV2Vha01hcCgpO1xuICB2YXIgc2hhbGxvd1JlYWRvbmx5TWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgZnVuY3Rpb24gdGFyZ2V0VHlwZU1hcChyYXdUeXBlKSB7XG4gICAgc3dpdGNoIChyYXdUeXBlKSB7XG4gICAgICBjYXNlIFwiT2JqZWN0XCI6XG4gICAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBjYXNlIFwiTWFwXCI6XG4gICAgICBjYXNlIFwiU2V0XCI6XG4gICAgICBjYXNlIFwiV2Vha01hcFwiOlxuICAgICAgY2FzZSBcIldlYWtTZXRcIjpcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VGFyZ2V0VHlwZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZVtcIl9fdl9za2lwXCJdIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSA/IDAgOiB0YXJnZXRUeXBlTWFwKHNoYXJlZC50b1Jhd1R5cGUodmFsdWUpKTtcbiAgfVxuICBmdW5jdGlvbiByZWFjdGl2ZTModGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldCAmJiB0YXJnZXRbXCJfX3ZfaXNSZWFkb25seVwiXSkge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgZmFsc2UsIG11dGFibGVIYW5kbGVycywgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycywgcmVhY3RpdmVNYXApO1xuICB9XG4gIGZ1bmN0aW9uIHNoYWxsb3dSZWFjdGl2ZSh0YXJnZXQpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBmYWxzZSwgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMsIHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMsIHNoYWxsb3dSZWFjdGl2ZU1hcCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVhZG9ubHkodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgdHJ1ZSwgcmVhZG9ubHlIYW5kbGVycywgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsIHJlYWRvbmx5TWFwKTtcbiAgfVxuICBmdW5jdGlvbiBzaGFsbG93UmVhZG9ubHkodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgdHJ1ZSwgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMsIHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycywgc2hhbGxvd1JlYWRvbmx5TWFwKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGlzUmVhZG9ubHkyLCBiYXNlSGFuZGxlcnMsIGNvbGxlY3Rpb25IYW5kbGVycywgcHJveHlNYXApIHtcbiAgICBpZiAoIXNoYXJlZC5pc09iamVjdCh0YXJnZXQpKSB7XG4gICAgICB7XG4gICAgICAgIGNvbnNvbGUud2FybihgdmFsdWUgY2Fubm90IGJlIG1hZGUgcmVhY3RpdmU6ICR7U3RyaW5nKHRhcmdldCl9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBpZiAodGFyZ2V0W1wiX192X3Jhd1wiXSAmJiAhKGlzUmVhZG9ubHkyICYmIHRhcmdldFtcIl9fdl9pc1JlYWN0aXZlXCJdKSkge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdQcm94eSA9IHByb3h5TWFwLmdldCh0YXJnZXQpO1xuICAgIGlmIChleGlzdGluZ1Byb3h5KSB7XG4gICAgICByZXR1cm4gZXhpc3RpbmdQcm94eTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0VHlwZSA9IGdldFRhcmdldFR5cGUodGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0VHlwZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkodGFyZ2V0LCB0YXJnZXRUeXBlID09PSAyID8gY29sbGVjdGlvbkhhbmRsZXJzIDogYmFzZUhhbmRsZXJzKTtcbiAgICBwcm94eU1hcC5zZXQodGFyZ2V0LCBwcm94eSk7XG4gICAgcmV0dXJuIHByb3h5O1xuICB9XG4gIGZ1bmN0aW9uIGlzUmVhY3RpdmUyKHZhbHVlKSB7XG4gICAgaWYgKGlzUmVhZG9ubHkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gaXNSZWFjdGl2ZTIodmFsdWVbXCJfX3ZfcmF3XCJdKTtcbiAgICB9XG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhY3RpdmVcIl0pO1xuICB9XG4gIGZ1bmN0aW9uIGlzUmVhZG9ubHkodmFsdWUpIHtcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFkb25seVwiXSk7XG4gIH1cbiAgZnVuY3Rpb24gaXNQcm94eSh2YWx1ZSkge1xuICAgIHJldHVybiBpc1JlYWN0aXZlMih2YWx1ZSkgfHwgaXNSZWFkb25seSh2YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdG9SYXcyKG9ic2VydmVkKSB7XG4gICAgcmV0dXJuIG9ic2VydmVkICYmIHRvUmF3MihvYnNlcnZlZFtcIl9fdl9yYXdcIl0pIHx8IG9ic2VydmVkO1xuICB9XG4gIGZ1bmN0aW9uIG1hcmtSYXcodmFsdWUpIHtcbiAgICBzaGFyZWQuZGVmKHZhbHVlLCBcIl9fdl9za2lwXCIsIHRydWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgY29udmVydCA9ICh2YWwpID0+IHNoYXJlZC5pc09iamVjdCh2YWwpID8gcmVhY3RpdmUzKHZhbCkgOiB2YWw7XG4gIGZ1bmN0aW9uIGlzUmVmKHIpIHtcbiAgICByZXR1cm4gQm9vbGVhbihyICYmIHIuX192X2lzUmVmID09PSB0cnVlKTtcbiAgfVxuICBmdW5jdGlvbiByZWYodmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiBzaGFsbG93UmVmKHZhbHVlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgdHJ1ZSk7XG4gIH1cbiAgdmFyIFJlZkltcGwgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoX3Jhd1ZhbHVlLCBfc2hhbGxvdyA9IGZhbHNlKSB7XG4gICAgICB0aGlzLl9yYXdWYWx1ZSA9IF9yYXdWYWx1ZTtcbiAgICAgIHRoaXMuX3NoYWxsb3cgPSBfc2hhbGxvdztcbiAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3ZhbHVlID0gX3NoYWxsb3cgPyBfcmF3VmFsdWUgOiBjb252ZXJ0KF9yYXdWYWx1ZSk7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgIHRyYWNrKHRvUmF3Mih0aGlzKSwgXCJnZXRcIiwgXCJ2YWx1ZVwiKTtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgICAgaWYgKHNoYXJlZC5oYXNDaGFuZ2VkKHRvUmF3MihuZXdWYWwpLCB0aGlzLl9yYXdWYWx1ZSkpIHtcbiAgICAgICAgdGhpcy5fcmF3VmFsdWUgPSBuZXdWYWw7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5fc2hhbGxvdyA/IG5ld1ZhbCA6IGNvbnZlcnQobmV3VmFsKTtcbiAgICAgICAgdHJpZ2dlcih0b1JhdzIodGhpcyksIFwic2V0XCIsIFwidmFsdWVcIiwgbmV3VmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZihyYXdWYWx1ZSwgc2hhbGxvdyA9IGZhbHNlKSB7XG4gICAgaWYgKGlzUmVmKHJhd1ZhbHVlKSkge1xuICAgICAgcmV0dXJuIHJhd1ZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZkltcGwocmF3VmFsdWUsIHNoYWxsb3cpO1xuICB9XG4gIGZ1bmN0aW9uIHRyaWdnZXJSZWYocmVmMikge1xuICAgIHRyaWdnZXIodG9SYXcyKHJlZjIpLCBcInNldFwiLCBcInZhbHVlXCIsIHJlZjIudmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIHVucmVmKHJlZjIpIHtcbiAgICByZXR1cm4gaXNSZWYocmVmMikgPyByZWYyLnZhbHVlIDogcmVmMjtcbiAgfVxuICB2YXIgc2hhbGxvd1Vud3JhcEhhbmRsZXJzID0ge1xuICAgIGdldDogKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4gdW5yZWYoUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSksXG4gICAgc2V0OiAodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikgPT4ge1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICAgIGlmIChpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIHByb3h5UmVmcyhvYmplY3RXaXRoUmVmcykge1xuICAgIHJldHVybiBpc1JlYWN0aXZlMihvYmplY3RXaXRoUmVmcykgPyBvYmplY3RXaXRoUmVmcyA6IG5ldyBQcm94eShvYmplY3RXaXRoUmVmcywgc2hhbGxvd1Vud3JhcEhhbmRsZXJzKTtcbiAgfVxuICB2YXIgQ3VzdG9tUmVmSW1wbCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3J5KSB7XG4gICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XG4gICAgICBjb25zdCB7Z2V0OiBnZXQzLCBzZXQ6IHNldDN9ID0gZmFjdG9yeSgoKSA9PiB0cmFjayh0aGlzLCBcImdldFwiLCBcInZhbHVlXCIpLCAoKSA9PiB0cmlnZ2VyKHRoaXMsIFwic2V0XCIsIFwidmFsdWVcIikpO1xuICAgICAgdGhpcy5fZ2V0ID0gZ2V0MztcbiAgICAgIHRoaXMuX3NldCA9IHNldDM7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXQoKTtcbiAgICB9XG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgICAgdGhpcy5fc2V0KG5ld1ZhbCk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBjdXN0b21SZWYoZmFjdG9yeSkge1xuICAgIHJldHVybiBuZXcgQ3VzdG9tUmVmSW1wbChmYWN0b3J5KTtcbiAgfVxuICBmdW5jdGlvbiB0b1JlZnMob2JqZWN0KSB7XG4gICAgaWYgKCFpc1Byb3h5KG9iamVjdCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihgdG9SZWZzKCkgZXhwZWN0cyBhIHJlYWN0aXZlIG9iamVjdCBidXQgcmVjZWl2ZWQgYSBwbGFpbiBvbmUuYCk7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHNoYXJlZC5pc0FycmF5KG9iamVjdCkgPyBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCkgOiB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgIHJldFtrZXldID0gdG9SZWYob2JqZWN0LCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIHZhciBPYmplY3RSZWZJbXBsID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKF9vYmplY3QsIF9rZXkpIHtcbiAgICAgIHRoaXMuX29iamVjdCA9IF9vYmplY3Q7XG4gICAgICB0aGlzLl9rZXkgPSBfa2V5O1xuICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqZWN0W3RoaXMuX2tleV07XG4gICAgfVxuICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcbiAgICAgIHRoaXMuX29iamVjdFt0aGlzLl9rZXldID0gbmV3VmFsO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gdG9SZWYob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNSZWYob2JqZWN0W2tleV0pID8gb2JqZWN0W2tleV0gOiBuZXcgT2JqZWN0UmVmSW1wbChvYmplY3QsIGtleSk7XG4gIH1cbiAgdmFyIENvbXB1dGVkUmVmSW1wbCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihnZXR0ZXIsIF9zZXR0ZXIsIGlzUmVhZG9ubHkyKSB7XG4gICAgICB0aGlzLl9zZXR0ZXIgPSBfc2V0dGVyO1xuICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgICAgdGhpcy5lZmZlY3QgPSBlZmZlY3QzKGdldHRlciwge1xuICAgICAgICBsYXp5OiB0cnVlLFxuICAgICAgICBzY2hlZHVsZXI6ICgpID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2RpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0cmlnZ2VyKHRvUmF3Mih0aGlzKSwgXCJzZXRcIiwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpc1tcIl9fdl9pc1JlYWRvbmx5XCJdID0gaXNSZWFkb25seTI7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgIGNvbnN0IHNlbGYyID0gdG9SYXcyKHRoaXMpO1xuICAgICAgaWYgKHNlbGYyLl9kaXJ0eSkge1xuICAgICAgICBzZWxmMi5fdmFsdWUgPSB0aGlzLmVmZmVjdCgpO1xuICAgICAgICBzZWxmMi5fZGlydHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRyYWNrKHNlbGYyLCBcImdldFwiLCBcInZhbHVlXCIpO1xuICAgICAgcmV0dXJuIHNlbGYyLl92YWx1ZTtcbiAgICB9XG4gICAgc2V0IHZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXR0ZXIobmV3VmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gY29tcHV0ZWQoZ2V0dGVyT3JPcHRpb25zKSB7XG4gICAgbGV0IGdldHRlcjtcbiAgICBsZXQgc2V0dGVyO1xuICAgIGlmIChzaGFyZWQuaXNGdW5jdGlvbihnZXR0ZXJPck9wdGlvbnMpKSB7XG4gICAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnM7XG4gICAgICBzZXR0ZXIgPSAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIldyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHZhbHVlIGlzIHJlYWRvbmx5XCIpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLmdldDtcbiAgICAgIHNldHRlciA9IGdldHRlck9yT3B0aW9ucy5zZXQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29tcHV0ZWRSZWZJbXBsKGdldHRlciwgc2V0dGVyLCBzaGFyZWQuaXNGdW5jdGlvbihnZXR0ZXJPck9wdGlvbnMpIHx8ICFnZXR0ZXJPck9wdGlvbnMuc2V0KTtcbiAgfVxuICBleHBvcnRzLklURVJBVEVfS0VZID0gSVRFUkFURV9LRVk7XG4gIGV4cG9ydHMuY29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgZXhwb3J0cy5jdXN0b21SZWYgPSBjdXN0b21SZWY7XG4gIGV4cG9ydHMuZWZmZWN0ID0gZWZmZWN0MztcbiAgZXhwb3J0cy5lbmFibGVUcmFja2luZyA9IGVuYWJsZVRyYWNraW5nO1xuICBleHBvcnRzLmlzUHJveHkgPSBpc1Byb3h5O1xuICBleHBvcnRzLmlzUmVhY3RpdmUgPSBpc1JlYWN0aXZlMjtcbiAgZXhwb3J0cy5pc1JlYWRvbmx5ID0gaXNSZWFkb25seTtcbiAgZXhwb3J0cy5pc1JlZiA9IGlzUmVmO1xuICBleHBvcnRzLm1hcmtSYXcgPSBtYXJrUmF3O1xuICBleHBvcnRzLnBhdXNlVHJhY2tpbmcgPSBwYXVzZVRyYWNraW5nO1xuICBleHBvcnRzLnByb3h5UmVmcyA9IHByb3h5UmVmcztcbiAgZXhwb3J0cy5yZWFjdGl2ZSA9IHJlYWN0aXZlMztcbiAgZXhwb3J0cy5yZWFkb25seSA9IHJlYWRvbmx5O1xuICBleHBvcnRzLnJlZiA9IHJlZjtcbiAgZXhwb3J0cy5yZXNldFRyYWNraW5nID0gcmVzZXRUcmFja2luZztcbiAgZXhwb3J0cy5zaGFsbG93UmVhY3RpdmUgPSBzaGFsbG93UmVhY3RpdmU7XG4gIGV4cG9ydHMuc2hhbGxvd1JlYWRvbmx5ID0gc2hhbGxvd1JlYWRvbmx5O1xuICBleHBvcnRzLnNoYWxsb3dSZWYgPSBzaGFsbG93UmVmO1xuICBleHBvcnRzLnN0b3AgPSBzdG9wMjtcbiAgZXhwb3J0cy50b1JhdyA9IHRvUmF3MjtcbiAgZXhwb3J0cy50b1JlZiA9IHRvUmVmO1xuICBleHBvcnRzLnRvUmVmcyA9IHRvUmVmcztcbiAgZXhwb3J0cy50cmFjayA9IHRyYWNrO1xuICBleHBvcnRzLnRyaWdnZXIgPSB0cmlnZ2VyO1xuICBleHBvcnRzLnRyaWdnZXJSZWYgPSB0cmlnZ2VyUmVmO1xuICBleHBvcnRzLnVucmVmID0gdW5yZWY7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0B2dWUvcmVhY3Rpdml0eS9pbmRleC5qc1xudmFyIHJlcXVpcmVfcmVhY3Rpdml0eSA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZSkgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgaWYgKGZhbHNlKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZV9yZWFjdGl2aXR5X2NqcygpO1xuICB9XG59KTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3NjaGVkdWxlci5qc1xudmFyIGZsdXNoUGVuZGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgcXVldWUgPSBbXTtcbmZ1bmN0aW9uIHNjaGVkdWxlcihjYWxsYmFjaykge1xuICBxdWV1ZUpvYihjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBxdWV1ZUpvYihqb2IpIHtcbiAgaWYgKCFxdWV1ZS5pbmNsdWRlcyhqb2IpKVxuICAgIHF1ZXVlLnB1c2goam9iKTtcbiAgcXVldWVGbHVzaCgpO1xufVxuZnVuY3Rpb24gcXVldWVGbHVzaCgpIHtcbiAgaWYgKCFmbHVzaGluZyAmJiAhZmx1c2hQZW5kaW5nKSB7XG4gICAgZmx1c2hQZW5kaW5nID0gdHJ1ZTtcbiAgICBxdWV1ZU1pY3JvdGFzayhmbHVzaEpvYnMpO1xuICB9XG59XG5mdW5jdGlvbiBmbHVzaEpvYnMoKSB7XG4gIGZsdXNoUGVuZGluZyA9IGZhbHNlO1xuICBmbHVzaGluZyA9IHRydWU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXSgpO1xuICB9XG4gIHF1ZXVlLmxlbmd0aCA9IDA7XG4gIGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9yZWFjdGl2aXR5LmpzXG52YXIgcmVhY3RpdmU7XG52YXIgZWZmZWN0O1xudmFyIHJlbGVhc2U7XG52YXIgcmF3O1xudmFyIHNob3VsZFNjaGVkdWxlID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVFZmZlY3RTY2hlZHVsaW5nKGNhbGxiYWNrKSB7XG4gIHNob3VsZFNjaGVkdWxlID0gZmFsc2U7XG4gIGNhbGxiYWNrKCk7XG4gIHNob3VsZFNjaGVkdWxlID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNldFJlYWN0aXZpdHlFbmdpbmUoZW5naW5lKSB7XG4gIHJlYWN0aXZlID0gZW5naW5lLnJlYWN0aXZlO1xuICByZWxlYXNlID0gZW5naW5lLnJlbGVhc2U7XG4gIGVmZmVjdCA9IChjYWxsYmFjaykgPT4gZW5naW5lLmVmZmVjdChjYWxsYmFjaywge3NjaGVkdWxlcjogKHRhc2spID0+IHtcbiAgICBpZiAoc2hvdWxkU2NoZWR1bGUpIHtcbiAgICAgIHNjaGVkdWxlcih0YXNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFzaygpO1xuICAgIH1cbiAgfX0pO1xuICByYXcgPSBlbmdpbmUucmF3O1xufVxuZnVuY3Rpb24gb3ZlcnJpZGVFZmZlY3Qob3ZlcnJpZGUpIHtcbiAgZWZmZWN0ID0gb3ZlcnJpZGU7XG59XG5mdW5jdGlvbiBlbGVtZW50Qm91bmRFZmZlY3QoZWwpIHtcbiAgbGV0IGNsZWFudXAgPSAoKSA9PiB7XG4gIH07XG4gIGxldCB3cmFwcGVkRWZmZWN0ID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgbGV0IGVmZmVjdFJlZmVyZW5jZSA9IGVmZmVjdChjYWxsYmFjayk7XG4gICAgaWYgKCFlbC5feF9lZmZlY3RzKSB7XG4gICAgICBlbC5feF9lZmZlY3RzID0gbmV3IFNldCgpO1xuICAgICAgZWwuX3hfcnVuRWZmZWN0cyA9ICgpID0+IHtcbiAgICAgICAgZWwuX3hfZWZmZWN0cy5mb3JFYWNoKChpKSA9PiBpKCkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZWwuX3hfZWZmZWN0cy5hZGQoZWZmZWN0UmVmZXJlbmNlKTtcbiAgICBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgaWYgKGVmZmVjdFJlZmVyZW5jZSA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm47XG4gICAgICBlbC5feF9lZmZlY3RzLmRlbGV0ZShlZmZlY3RSZWZlcmVuY2UpO1xuICAgICAgcmVsZWFzZShlZmZlY3RSZWZlcmVuY2UpO1xuICAgIH07XG4gIH07XG4gIHJldHVybiBbd3JhcHBlZEVmZmVjdCwgKCkgPT4ge1xuICAgIGNsZWFudXAoKTtcbiAgfV07XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tdXRhdGlvbi5qc1xudmFyIG9uQXR0cmlidXRlQWRkZWRzID0gW107XG52YXIgb25FbFJlbW92ZWRzID0gW107XG52YXIgb25FbEFkZGVkcyA9IFtdO1xuZnVuY3Rpb24gb25FbEFkZGVkKGNhbGxiYWNrKSB7XG4gIG9uRWxBZGRlZHMucHVzaChjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBvbkVsUmVtb3ZlZChjYWxsYmFjaykge1xuICBvbkVsUmVtb3ZlZHMucHVzaChjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBvbkF0dHJpYnV0ZXNBZGRlZChjYWxsYmFjaykge1xuICBvbkF0dHJpYnV0ZUFkZGVkcy5wdXNoKGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIG9uQXR0cmlidXRlUmVtb3ZlZChlbCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgaWYgKCFlbC5feF9hdHRyaWJ1dGVDbGVhbnVwcylcbiAgICBlbC5feF9hdHRyaWJ1dGVDbGVhbnVwcyA9IHt9O1xuICBpZiAoIWVsLl94X2F0dHJpYnV0ZUNsZWFudXBzW25hbWVdKVxuICAgIGVsLl94X2F0dHJpYnV0ZUNsZWFudXBzW25hbWVdID0gW107XG4gIGVsLl94X2F0dHJpYnV0ZUNsZWFudXBzW25hbWVdLnB1c2goY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gY2xlYW51cEF0dHJpYnV0ZXMoZWwsIG5hbWVzKSB7XG4gIGlmICghZWwuX3hfYXR0cmlidXRlQ2xlYW51cHMpXG4gICAgcmV0dXJuO1xuICBPYmplY3QuZW50cmllcyhlbC5feF9hdHRyaWJ1dGVDbGVhbnVwcykuZm9yRWFjaCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuICAgIGlmIChuYW1lcyA9PT0gdm9pZCAwIHx8IG5hbWVzLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKChpKSA9PiBpKCkpO1xuICAgICAgZGVsZXRlIGVsLl94X2F0dHJpYnV0ZUNsZWFudXBzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59XG52YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihvbk11dGF0ZSk7XG52YXIgY3VycmVudGx5T2JzZXJ2aW5nID0gZmFsc2U7XG5mdW5jdGlvbiBzdGFydE9ic2VydmluZ011dGF0aW9ucygpIHtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge3N1YnRyZWU6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgYXR0cmlidXRlczogdHJ1ZSwgYXR0cmlidXRlT2xkVmFsdWU6IHRydWV9KTtcbiAgY3VycmVudGx5T2JzZXJ2aW5nID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHN0b3BPYnNlcnZpbmdNdXRhdGlvbnMoKSB7XG4gIGZsdXNoT2JzZXJ2ZXIoKTtcbiAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICBjdXJyZW50bHlPYnNlcnZpbmcgPSBmYWxzZTtcbn1cbnZhciByZWNvcmRRdWV1ZSA9IFtdO1xudmFyIHdpbGxQcm9jZXNzUmVjb3JkUXVldWUgPSBmYWxzZTtcbmZ1bmN0aW9uIGZsdXNoT2JzZXJ2ZXIoKSB7XG4gIHJlY29yZFF1ZXVlID0gcmVjb3JkUXVldWUuY29uY2F0KG9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xuICBpZiAocmVjb3JkUXVldWUubGVuZ3RoICYmICF3aWxsUHJvY2Vzc1JlY29yZFF1ZXVlKSB7XG4gICAgd2lsbFByb2Nlc3NSZWNvcmRRdWV1ZSA9IHRydWU7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgcHJvY2Vzc1JlY29yZFF1ZXVlKCk7XG4gICAgICB3aWxsUHJvY2Vzc1JlY29yZFF1ZXVlID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NSZWNvcmRRdWV1ZSgpIHtcbiAgb25NdXRhdGUocmVjb3JkUXVldWUpO1xuICByZWNvcmRRdWV1ZS5sZW5ndGggPSAwO1xufVxuZnVuY3Rpb24gbXV0YXRlRG9tKGNhbGxiYWNrKSB7XG4gIGlmICghY3VycmVudGx5T2JzZXJ2aW5nKVxuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICBzdG9wT2JzZXJ2aW5nTXV0YXRpb25zKCk7XG4gIGxldCByZXN1bHQgPSBjYWxsYmFjaygpO1xuICBzdGFydE9ic2VydmluZ011dGF0aW9ucygpO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIGlzQ29sbGVjdGluZyA9IGZhbHNlO1xudmFyIGRlZmVycmVkTXV0YXRpb25zID0gW107XG5mdW5jdGlvbiBkZWZlck11dGF0aW9ucygpIHtcbiAgaXNDb2xsZWN0aW5nID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGZsdXNoQW5kU3RvcERlZmVycmluZ011dGF0aW9ucygpIHtcbiAgaXNDb2xsZWN0aW5nID0gZmFsc2U7XG4gIG9uTXV0YXRlKGRlZmVycmVkTXV0YXRpb25zKTtcbiAgZGVmZXJyZWRNdXRhdGlvbnMgPSBbXTtcbn1cbmZ1bmN0aW9uIG9uTXV0YXRlKG11dGF0aW9ucykge1xuICBpZiAoaXNDb2xsZWN0aW5nKSB7XG4gICAgZGVmZXJyZWRNdXRhdGlvbnMgPSBkZWZlcnJlZE11dGF0aW9ucy5jb25jYXQobXV0YXRpb25zKTtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGFkZGVkTm9kZXMgPSBbXTtcbiAgbGV0IHJlbW92ZWROb2RlcyA9IFtdO1xuICBsZXQgYWRkZWRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICBsZXQgcmVtb3ZlZEF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG11dGF0aW9uc1tpXS50YXJnZXQuX3hfaWdub3JlTXV0YXRpb25PYnNlcnZlcilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmIChtdXRhdGlvbnNbaV0udHlwZSA9PT0gXCJjaGlsZExpc3RcIikge1xuICAgICAgbXV0YXRpb25zW2ldLmFkZGVkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBhZGRlZE5vZGVzLnB1c2gobm9kZSkpO1xuICAgICAgbXV0YXRpb25zW2ldLnJlbW92ZWROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSAxICYmIHJlbW92ZWROb2Rlcy5wdXNoKG5vZGUpKTtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9uc1tpXS50eXBlID09PSBcImF0dHJpYnV0ZXNcIikge1xuICAgICAgbGV0IGVsID0gbXV0YXRpb25zW2ldLnRhcmdldDtcbiAgICAgIGxldCBuYW1lID0gbXV0YXRpb25zW2ldLmF0dHJpYnV0ZU5hbWU7XG4gICAgICBsZXQgb2xkVmFsdWUgPSBtdXRhdGlvbnNbaV0ub2xkVmFsdWU7XG4gICAgICBsZXQgYWRkID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWFkZGVkQXR0cmlidXRlcy5oYXMoZWwpKVxuICAgICAgICAgIGFkZGVkQXR0cmlidXRlcy5zZXQoZWwsIFtdKTtcbiAgICAgICAgYWRkZWRBdHRyaWJ1dGVzLmdldChlbCkucHVzaCh7bmFtZSwgdmFsdWU6IGVsLmdldEF0dHJpYnV0ZShuYW1lKX0pO1xuICAgICAgfTtcbiAgICAgIGxldCByZW1vdmUgPSAoKSA9PiB7XG4gICAgICAgIGlmICghcmVtb3ZlZEF0dHJpYnV0ZXMuaGFzKGVsKSlcbiAgICAgICAgICByZW1vdmVkQXR0cmlidXRlcy5zZXQoZWwsIFtdKTtcbiAgICAgICAgcmVtb3ZlZEF0dHJpYnV0ZXMuZ2V0KGVsKS5wdXNoKG5hbWUpO1xuICAgICAgfTtcbiAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUobmFtZSkgJiYgb2xkVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgYWRkKCk7XG4gICAgICB9IGVsc2UgaWYgKGVsLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgYWRkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVtb3ZlZEF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cnMsIGVsKSA9PiB7XG4gICAgY2xlYW51cEF0dHJpYnV0ZXMoZWwsIGF0dHJzKTtcbiAgfSk7XG4gIGFkZGVkQXR0cmlidXRlcy5mb3JFYWNoKChhdHRycywgZWwpID0+IHtcbiAgICBvbkF0dHJpYnV0ZUFkZGVkcy5mb3JFYWNoKChpKSA9PiBpKGVsLCBhdHRycykpO1xuICB9KTtcbiAgYWRkZWROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgbm9kZS5feF9pZ25vcmVTZWxmID0gdHJ1ZTtcbiAgICBub2RlLl94X2lnbm9yZSA9IHRydWU7XG4gIH0pO1xuICBmb3IgKGxldCBub2RlIG9mIGFkZGVkTm9kZXMpIHtcbiAgICBpZiAocmVtb3ZlZE5vZGVzLmluY2x1ZGVzKG5vZGUpKVxuICAgICAgY29udGludWU7XG4gICAgZGVsZXRlIG5vZGUuX3hfaWdub3JlU2VsZjtcbiAgICBkZWxldGUgbm9kZS5feF9pZ25vcmU7XG4gICAgb25FbEFkZGVkcy5mb3JFYWNoKChpKSA9PiBpKG5vZGUpKTtcbiAgICBub2RlLl94X2lnbm9yZSA9IHRydWU7XG4gICAgbm9kZS5feF9pZ25vcmVTZWxmID0gdHJ1ZTtcbiAgfVxuICBhZGRlZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICBkZWxldGUgbm9kZS5feF9pZ25vcmVTZWxmO1xuICAgIGRlbGV0ZSBub2RlLl94X2lnbm9yZTtcbiAgfSk7XG4gIGZvciAobGV0IG5vZGUgb2YgcmVtb3ZlZE5vZGVzKSB7XG4gICAgaWYgKGFkZGVkTm9kZXMuaW5jbHVkZXMobm9kZSkpXG4gICAgICBjb250aW51ZTtcbiAgICBvbkVsUmVtb3ZlZHMuZm9yRWFjaCgoaSkgPT4gaShub2RlKSk7XG4gIH1cbiAgYWRkZWROb2RlcyA9IG51bGw7XG4gIHJlbW92ZWROb2RlcyA9IG51bGw7XG4gIGFkZGVkQXR0cmlidXRlcyA9IG51bGw7XG4gIHJlbW92ZWRBdHRyaWJ1dGVzID0gbnVsbDtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3Njb3BlLmpzXG5mdW5jdGlvbiBhZGRTY29wZVRvTm9kZShub2RlLCBkYXRhMiwgcmVmZXJlbmNlTm9kZSkge1xuICBub2RlLl94X2RhdGFTdGFjayA9IFtkYXRhMiwgLi4uY2xvc2VzdERhdGFTdGFjayhyZWZlcmVuY2VOb2RlIHx8IG5vZGUpXTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBub2RlLl94X2RhdGFTdGFjayA9IG5vZGUuX3hfZGF0YVN0YWNrLmZpbHRlcigoaSkgPT4gaSAhPT0gZGF0YTIpO1xuICB9O1xufVxuZnVuY3Rpb24gcmVmcmVzaFNjb3BlKGVsZW1lbnQsIHNjb3BlKSB7XG4gIGxldCBleGlzdGluZ1Njb3BlID0gZWxlbWVudC5feF9kYXRhU3RhY2tbMF07XG4gIE9iamVjdC5lbnRyaWVzKHNjb3BlKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBleGlzdGluZ1Njb3BlW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjbG9zZXN0RGF0YVN0YWNrKG5vZGUpIHtcbiAgaWYgKG5vZGUuX3hfZGF0YVN0YWNrKVxuICAgIHJldHVybiBub2RlLl94X2RhdGFTdGFjaztcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSBcImZ1bmN0aW9uXCIgJiYgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICByZXR1cm4gY2xvc2VzdERhdGFTdGFjayhub2RlLmhvc3QpO1xuICB9XG4gIGlmICghbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBjbG9zZXN0RGF0YVN0YWNrKG5vZGUucGFyZW50Tm9kZSk7XG59XG5mdW5jdGlvbiBtZXJnZVByb3hpZXMob2JqZWN0cykge1xuICBsZXQgdGhpc1Byb3h5ID0gbmV3IFByb3h5KHt9LCB7XG4gICAgb3duS2V5czogKCkgPT4ge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChvYmplY3RzLmZsYXRNYXAoKGkpID0+IE9iamVjdC5rZXlzKGkpKSkpO1xuICAgIH0sXG4gICAgaGFzOiAodGFyZ2V0LCBuYW1lKSA9PiB7XG4gICAgICByZXR1cm4gb2JqZWN0cy5zb21lKChvYmopID0+IG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKSk7XG4gICAgfSxcbiAgICBnZXQ6ICh0YXJnZXQsIG5hbWUpID0+IHtcbiAgICAgIHJldHVybiAob2JqZWN0cy5maW5kKChvYmopID0+IHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIGxldCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIG5hbWUpO1xuICAgICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCAmJiBkZXNjcmlwdG9yLmdldC5feF9hbHJlYWR5Qm91bmQgfHwgZGVzY3JpcHRvci5zZXQgJiYgZGVzY3JpcHRvci5zZXQuX3hfYWxyZWFkeUJvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChkZXNjcmlwdG9yLmdldCB8fCBkZXNjcmlwdG9yLnNldCkgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgICBsZXQgZ2V0dGVyID0gZGVzY3JpcHRvci5nZXQ7XG4gICAgICAgICAgICBsZXQgc2V0dGVyID0gZGVzY3JpcHRvci5zZXQ7XG4gICAgICAgICAgICBsZXQgcHJvcGVydHkgPSBkZXNjcmlwdG9yO1xuICAgICAgICAgICAgZ2V0dGVyID0gZ2V0dGVyICYmIGdldHRlci5iaW5kKHRoaXNQcm94eSk7XG4gICAgICAgICAgICBzZXR0ZXIgPSBzZXR0ZXIgJiYgc2V0dGVyLmJpbmQodGhpc1Byb3h5KTtcbiAgICAgICAgICAgIGlmIChnZXR0ZXIpXG4gICAgICAgICAgICAgIGdldHRlci5feF9hbHJlYWR5Qm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHNldHRlcilcbiAgICAgICAgICAgICAgc2V0dGVyLl94X2FscmVhZHlCb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICAgICAgICAgIC4uLnByb3BlcnR5LFxuICAgICAgICAgICAgICBnZXQ6IGdldHRlcixcbiAgICAgICAgICAgICAgc2V0OiBzZXR0ZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KSB8fCB7fSlbbmFtZV07XG4gICAgfSxcbiAgICBzZXQ6ICh0YXJnZXQsIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICBsZXQgY2xvc2VzdE9iamVjdFdpdGhLZXkgPSBvYmplY3RzLmZpbmQoKG9iaikgPT4gb2JqLmhhc093blByb3BlcnR5KG5hbWUpKTtcbiAgICAgIGlmIChjbG9zZXN0T2JqZWN0V2l0aEtleSkge1xuICAgICAgICBjbG9zZXN0T2JqZWN0V2l0aEtleVtuYW1lXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0c1tvYmplY3RzLmxlbmd0aCAtIDFdW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGhpc1Byb3h5O1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvaW50ZXJjZXB0b3IuanNcbmZ1bmN0aW9uIGluaXRJbnRlcmNlcHRvcnMoZGF0YTIpIHtcbiAgbGV0IGlzT2JqZWN0ID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWwpICYmIHZhbCAhPT0gbnVsbDtcbiAgbGV0IHJlY3Vyc2UgPSAob2JqLCBiYXNlUGF0aCA9IFwiXCIpID0+IHtcbiAgICBPYmplY3QuZW50cmllcyhPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopKS5mb3JFYWNoKChba2V5LCB7dmFsdWUsIGVudW1lcmFibGV9XSkgPT4ge1xuICAgICAgaWYgKGVudW1lcmFibGUgPT09IGZhbHNlIHx8IHZhbHVlID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBwYXRoID0gYmFzZVBhdGggPT09IFwiXCIgPyBrZXkgOiBgJHtiYXNlUGF0aH0uJHtrZXl9YDtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUuX3hfaW50ZXJjZXB0b3IpIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZS5pbml0aWFsaXplKGRhdGEyLCBwYXRoLCBrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZSAhPT0gb2JqICYmICEodmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICAgIHJlY3Vyc2UodmFsdWUsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiByZWN1cnNlKGRhdGEyKTtcbn1cbmZ1bmN0aW9uIGludGVyY2VwdG9yKGNhbGxiYWNrLCBtdXRhdGVPYmogPSAoKSA9PiB7XG59KSB7XG4gIGxldCBvYmogPSB7XG4gICAgaW5pdGlhbFZhbHVlOiB2b2lkIDAsXG4gICAgX3hfaW50ZXJjZXB0b3I6IHRydWUsXG4gICAgaW5pdGlhbGl6ZShkYXRhMiwgcGF0aCwga2V5KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5pbml0aWFsVmFsdWUsICgpID0+IGdldChkYXRhMiwgcGF0aCksICh2YWx1ZSkgPT4gc2V0KGRhdGEyLCBwYXRoLCB2YWx1ZSksIHBhdGgsIGtleSk7XG4gICAgfVxuICB9O1xuICBtdXRhdGVPYmoob2JqKTtcbiAgcmV0dXJuIChpbml0aWFsVmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIGluaXRpYWxWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBpbml0aWFsVmFsdWUgIT09IG51bGwgJiYgaW5pdGlhbFZhbHVlLl94X2ludGVyY2VwdG9yKSB7XG4gICAgICBsZXQgaW5pdGlhbGl6ZSA9IG9iai5pbml0aWFsaXplLmJpbmQob2JqKTtcbiAgICAgIG9iai5pbml0aWFsaXplID0gKGRhdGEyLCBwYXRoLCBrZXkpID0+IHtcbiAgICAgICAgbGV0IGlubmVyVmFsdWUgPSBpbml0aWFsVmFsdWUuaW5pdGlhbGl6ZShkYXRhMiwgcGF0aCwga2V5KTtcbiAgICAgICAgb2JqLmluaXRpYWxWYWx1ZSA9IGlubmVyVmFsdWU7XG4gICAgICAgIHJldHVybiBpbml0aWFsaXplKGRhdGEyLCBwYXRoLCBrZXkpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqLmluaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldChvYmosIHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguc3BsaXQoXCIuXCIpLnJlZHVjZSgoY2FycnksIHNlZ21lbnQpID0+IGNhcnJ5W3NlZ21lbnRdLCBvYmopO1xufVxuZnVuY3Rpb24gc2V0KG9iaiwgcGF0aCwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiKVxuICAgIHBhdGggPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAxKVxuICAgIG9ialtwYXRoWzBdXSA9IHZhbHVlO1xuICBlbHNlIGlmIChwYXRoLmxlbmd0aCA9PT0gMClcbiAgICB0aHJvdyBlcnJvcjtcbiAgZWxzZSB7XG4gICAgaWYgKG9ialtwYXRoWzBdXSlcbiAgICAgIHJldHVybiBzZXQob2JqW3BhdGhbMF1dLCBwYXRoLnNsaWNlKDEpLCB2YWx1ZSk7XG4gICAgZWxzZSB7XG4gICAgICBvYmpbcGF0aFswXV0gPSB7fTtcbiAgICAgIHJldHVybiBzZXQob2JqW3BhdGhbMF1dLCBwYXRoLnNsaWNlKDEpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MuanNcbnZhciBtYWdpY3MgPSB7fTtcbmZ1bmN0aW9uIG1hZ2ljKG5hbWUsIGNhbGxiYWNrKSB7XG4gIG1hZ2ljc1tuYW1lXSA9IGNhbGxiYWNrO1xufVxuZnVuY3Rpb24gaW5qZWN0TWFnaWNzKG9iaiwgZWwpIHtcbiAgT2JqZWN0LmVudHJpZXMobWFnaWNzKS5mb3JFYWNoKChbbmFtZSwgY2FsbGJhY2tdKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgYCQke25hbWV9YCwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZWwsIHtBbHBpbmU6IGFscGluZV9kZWZhdWx0LCBpbnRlcmNlcHRvcn0pO1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2JqO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvZXJyb3IuanNcbmZ1bmN0aW9uIHRyeUNhdGNoKGVsLCBleHByZXNzaW9uLCBjYWxsYmFjaywgLi4uYXJncykge1xuICB0cnkge1xuICAgIHJldHVybiBjYWxsYmFjayguLi5hcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIGVsLCBleHByZXNzaW9uKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyb3IyLCBlbCwgZXhwcmVzc2lvbiA9IHZvaWQgMCkge1xuICBPYmplY3QuYXNzaWduKGVycm9yMiwge2VsLCBleHByZXNzaW9ufSk7XG4gIGNvbnNvbGUud2FybihgQWxwaW5lIEV4cHJlc3Npb24gRXJyb3I6ICR7ZXJyb3IyLm1lc3NhZ2V9XG5cbiR7ZXhwcmVzc2lvbiA/ICdFeHByZXNzaW9uOiBcIicgKyBleHByZXNzaW9uICsgJ1wiXFxuXFxuJyA6IFwiXCJ9YCwgZWwpO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0aHJvdyBlcnJvcjI7XG4gIH0sIDApO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZXZhbHVhdG9yLmpzXG5mdW5jdGlvbiBldmFsdWF0ZShlbCwgZXhwcmVzc2lvbiwgZXh0cmFzID0ge30pIHtcbiAgbGV0IHJlc3VsdDtcbiAgZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbikoKHZhbHVlKSA9PiByZXN1bHQgPSB2YWx1ZSwgZXh0cmFzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlTGF0ZXIoLi4uYXJncykge1xuICByZXR1cm4gdGhlRXZhbHVhdG9yRnVuY3Rpb24oLi4uYXJncyk7XG59XG52YXIgdGhlRXZhbHVhdG9yRnVuY3Rpb24gPSBub3JtYWxFdmFsdWF0b3I7XG5mdW5jdGlvbiBzZXRFdmFsdWF0b3IobmV3RXZhbHVhdG9yKSB7XG4gIHRoZUV2YWx1YXRvckZ1bmN0aW9uID0gbmV3RXZhbHVhdG9yO1xufVxuZnVuY3Rpb24gbm9ybWFsRXZhbHVhdG9yKGVsLCBleHByZXNzaW9uKSB7XG4gIGxldCBvdmVycmlkZGVuTWFnaWNzID0ge307XG4gIGluamVjdE1hZ2ljcyhvdmVycmlkZGVuTWFnaWNzLCBlbCk7XG4gIGxldCBkYXRhU3RhY2sgPSBbb3ZlcnJpZGRlbk1hZ2ljcywgLi4uY2xvc2VzdERhdGFTdGFjayhlbCldO1xuICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBnZW5lcmF0ZUV2YWx1YXRvckZyb21GdW5jdGlvbihkYXRhU3RhY2ssIGV4cHJlc3Npb24pO1xuICB9XG4gIGxldCBldmFsdWF0b3IgPSBnZW5lcmF0ZUV2YWx1YXRvckZyb21TdHJpbmcoZGF0YVN0YWNrLCBleHByZXNzaW9uLCBlbCk7XG4gIHJldHVybiB0cnlDYXRjaC5iaW5kKG51bGwsIGVsLCBleHByZXNzaW9uLCBldmFsdWF0b3IpO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVFdmFsdWF0b3JGcm9tRnVuY3Rpb24oZGF0YVN0YWNrLCBmdW5jKSB7XG4gIHJldHVybiAocmVjZWl2ZXIgPSAoKSA9PiB7XG4gIH0sIHtzY29wZSA9IHt9LCBwYXJhbXMgPSBbXX0gPSB7fSkgPT4ge1xuICAgIGxldCByZXN1bHQgPSBmdW5jLmFwcGx5KG1lcmdlUHJveGllcyhbc2NvcGUsIC4uLmRhdGFTdGFja10pLCBwYXJhbXMpO1xuICAgIHJ1bklmVHlwZU9mRnVuY3Rpb24ocmVjZWl2ZXIsIHJlc3VsdCk7XG4gIH07XG59XG52YXIgZXZhbHVhdG9yTWVtbyA9IHt9O1xuZnVuY3Rpb24gZ2VuZXJhdGVGdW5jdGlvbkZyb21TdHJpbmcoZXhwcmVzc2lvbiwgZWwpIHtcbiAgaWYgKGV2YWx1YXRvck1lbW9bZXhwcmVzc2lvbl0pIHtcbiAgICByZXR1cm4gZXZhbHVhdG9yTWVtb1tleHByZXNzaW9uXTtcbiAgfVxuICBsZXQgQXN5bmNGdW5jdGlvbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhc3luYyBmdW5jdGlvbigpIHtcbiAgfSkuY29uc3RydWN0b3I7XG4gIGxldCByaWdodFNpZGVTYWZlRXhwcmVzc2lvbiA9IC9eW1xcblxcc10qaWYuKlxcKC4qXFwpLy50ZXN0KGV4cHJlc3Npb24pIHx8IC9eKGxldHxjb25zdClcXHMvLnRlc3QoZXhwcmVzc2lvbikgPyBgKCgpID0+IHsgJHtleHByZXNzaW9ufSB9KSgpYCA6IGV4cHJlc3Npb247XG4gIGNvbnN0IHNhZmVBc3luY0Z1bmN0aW9uID0gKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IEFzeW5jRnVuY3Rpb24oW1wiX19zZWxmXCIsIFwic2NvcGVcIl0sIGB3aXRoIChzY29wZSkgeyBfX3NlbGYucmVzdWx0ID0gJHtyaWdodFNpZGVTYWZlRXhwcmVzc2lvbn0gfTsgX19zZWxmLmZpbmlzaGVkID0gdHJ1ZTsgcmV0dXJuIF9fc2VsZi5yZXN1bHQ7YCk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlcnJvcjIsIGVsLCBleHByZXNzaW9uKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gIH07XG4gIGxldCBmdW5jID0gc2FmZUFzeW5jRnVuY3Rpb24oKTtcbiAgZXZhbHVhdG9yTWVtb1tleHByZXNzaW9uXSA9IGZ1bmM7XG4gIHJldHVybiBmdW5jO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVFdmFsdWF0b3JGcm9tU3RyaW5nKGRhdGFTdGFjaywgZXhwcmVzc2lvbiwgZWwpIHtcbiAgbGV0IGZ1bmMgPSBnZW5lcmF0ZUZ1bmN0aW9uRnJvbVN0cmluZyhleHByZXNzaW9uLCBlbCk7XG4gIHJldHVybiAocmVjZWl2ZXIgPSAoKSA9PiB7XG4gIH0sIHtzY29wZSA9IHt9LCBwYXJhbXMgPSBbXX0gPSB7fSkgPT4ge1xuICAgIGZ1bmMucmVzdWx0ID0gdm9pZCAwO1xuICAgIGZ1bmMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICBsZXQgY29tcGxldGVTY29wZSA9IG1lcmdlUHJveGllcyhbc2NvcGUsIC4uLmRhdGFTdGFja10pO1xuICAgIGlmICh0eXBlb2YgZnVuYyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBsZXQgcHJvbWlzZSA9IGZ1bmMoZnVuYywgY29tcGxldGVTY29wZSkuY2F0Y2goKGVycm9yMikgPT4gaGFuZGxlRXJyb3IoZXJyb3IyLCBlbCwgZXhwcmVzc2lvbikpO1xuICAgICAgaWYgKGZ1bmMuZmluaXNoZWQpIHtcbiAgICAgICAgcnVuSWZUeXBlT2ZGdW5jdGlvbihyZWNlaXZlciwgZnVuYy5yZXN1bHQsIGNvbXBsZXRlU2NvcGUsIHBhcmFtcywgZWwpO1xuICAgICAgICBmdW5jLnJlc3VsdCA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2UudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgcnVuSWZUeXBlT2ZGdW5jdGlvbihyZWNlaXZlciwgcmVzdWx0LCBjb21wbGV0ZVNjb3BlLCBwYXJhbXMsIGVsKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycm9yMikgPT4gaGFuZGxlRXJyb3IoZXJyb3IyLCBlbCwgZXhwcmVzc2lvbikpLmZpbmFsbHkoKCkgPT4gZnVuYy5yZXN1bHQgPSB2b2lkIDApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJ1bklmVHlwZU9mRnVuY3Rpb24ocmVjZWl2ZXIsIHZhbHVlLCBzY29wZSwgcGFyYW1zLCBlbCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBsZXQgcmVzdWx0ID0gdmFsdWUuYXBwbHkoc2NvcGUsIHBhcmFtcyk7XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHJlc3VsdC50aGVuKChpKSA9PiBydW5JZlR5cGVPZkZ1bmN0aW9uKHJlY2VpdmVyLCBpLCBzY29wZSwgcGFyYW1zKSkuY2F0Y2goKGVycm9yMikgPT4gaGFuZGxlRXJyb3IoZXJyb3IyLCBlbCwgdmFsdWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjZWl2ZXIocmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVjZWl2ZXIodmFsdWUpO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzLmpzXG52YXIgcHJlZml4QXNTdHJpbmcgPSBcIngtXCI7XG5mdW5jdGlvbiBwcmVmaXgoc3ViamVjdCA9IFwiXCIpIHtcbiAgcmV0dXJuIHByZWZpeEFzU3RyaW5nICsgc3ViamVjdDtcbn1cbmZ1bmN0aW9uIHNldFByZWZpeChuZXdQcmVmaXgpIHtcbiAgcHJlZml4QXNTdHJpbmcgPSBuZXdQcmVmaXg7XG59XG52YXIgZGlyZWN0aXZlSGFuZGxlcnMgPSB7fTtcbmZ1bmN0aW9uIGRpcmVjdGl2ZShuYW1lLCBjYWxsYmFjaykge1xuICBkaXJlY3RpdmVIYW5kbGVyc1tuYW1lXSA9IGNhbGxiYWNrO1xufVxuZnVuY3Rpb24gZGlyZWN0aXZlcyhlbCwgYXR0cmlidXRlcywgb3JpZ2luYWxBdHRyaWJ1dGVPdmVycmlkZSkge1xuICBsZXQgdHJhbnNmb3JtZWRBdHRyaWJ1dGVNYXAgPSB7fTtcbiAgbGV0IGRpcmVjdGl2ZXMyID0gQXJyYXkuZnJvbShhdHRyaWJ1dGVzKS5tYXAodG9UcmFuc2Zvcm1lZEF0dHJpYnV0ZXMoKG5ld05hbWUsIG9sZE5hbWUpID0+IHRyYW5zZm9ybWVkQXR0cmlidXRlTWFwW25ld05hbWVdID0gb2xkTmFtZSkpLmZpbHRlcihvdXROb25BbHBpbmVBdHRyaWJ1dGVzKS5tYXAodG9QYXJzZWREaXJlY3RpdmVzKHRyYW5zZm9ybWVkQXR0cmlidXRlTWFwLCBvcmlnaW5hbEF0dHJpYnV0ZU92ZXJyaWRlKSkuc29ydChieVByaW9yaXR5KTtcbiAgcmV0dXJuIGRpcmVjdGl2ZXMyLm1hcCgoZGlyZWN0aXZlMikgPT4ge1xuICAgIHJldHVybiBnZXREaXJlY3RpdmVIYW5kbGVyKGVsLCBkaXJlY3RpdmUyKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhdHRyaWJ1dGVzT25seShhdHRyaWJ1dGVzKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGF0dHJpYnV0ZXMpLm1hcCh0b1RyYW5zZm9ybWVkQXR0cmlidXRlcygpKS5maWx0ZXIoKGF0dHIpID0+ICFvdXROb25BbHBpbmVBdHRyaWJ1dGVzKGF0dHIpKTtcbn1cbnZhciBpc0RlZmVycmluZ0hhbmRsZXJzID0gZmFsc2U7XG52YXIgZGlyZWN0aXZlSGFuZGxlclN0YWNrcyA9IG5ldyBNYXAoKTtcbnZhciBjdXJyZW50SGFuZGxlclN0YWNrS2V5ID0gU3ltYm9sKCk7XG5mdW5jdGlvbiBkZWZlckhhbmRsaW5nRGlyZWN0aXZlcyhjYWxsYmFjaykge1xuICBpc0RlZmVycmluZ0hhbmRsZXJzID0gdHJ1ZTtcbiAgbGV0IGtleSA9IFN5bWJvbCgpO1xuICBjdXJyZW50SGFuZGxlclN0YWNrS2V5ID0ga2V5O1xuICBkaXJlY3RpdmVIYW5kbGVyU3RhY2tzLnNldChrZXksIFtdKTtcbiAgbGV0IGZsdXNoSGFuZGxlcnMgPSAoKSA9PiB7XG4gICAgd2hpbGUgKGRpcmVjdGl2ZUhhbmRsZXJTdGFja3MuZ2V0KGtleSkubGVuZ3RoKVxuICAgICAgZGlyZWN0aXZlSGFuZGxlclN0YWNrcy5nZXQoa2V5KS5zaGlmdCgpKCk7XG4gICAgZGlyZWN0aXZlSGFuZGxlclN0YWNrcy5kZWxldGUoa2V5KTtcbiAgfTtcbiAgbGV0IHN0b3BEZWZlcnJpbmcgPSAoKSA9PiB7XG4gICAgaXNEZWZlcnJpbmdIYW5kbGVycyA9IGZhbHNlO1xuICAgIGZsdXNoSGFuZGxlcnMoKTtcbiAgfTtcbiAgY2FsbGJhY2soZmx1c2hIYW5kbGVycyk7XG4gIHN0b3BEZWZlcnJpbmcoKTtcbn1cbmZ1bmN0aW9uIGdldERpcmVjdGl2ZUhhbmRsZXIoZWwsIGRpcmVjdGl2ZTIpIHtcbiAgbGV0IG5vb3AgPSAoKSA9PiB7XG4gIH07XG4gIGxldCBoYW5kbGVyMyA9IGRpcmVjdGl2ZUhhbmRsZXJzW2RpcmVjdGl2ZTIudHlwZV0gfHwgbm9vcDtcbiAgbGV0IGNsZWFudXBzID0gW107XG4gIGxldCBjbGVhbnVwID0gKGNhbGxiYWNrKSA9PiBjbGVhbnVwcy5wdXNoKGNhbGxiYWNrKTtcbiAgbGV0IFtlZmZlY3QzLCBjbGVhbnVwRWZmZWN0XSA9IGVsZW1lbnRCb3VuZEVmZmVjdChlbCk7XG4gIGNsZWFudXBzLnB1c2goY2xlYW51cEVmZmVjdCk7XG4gIGxldCB1dGlsaXRpZXMgPSB7XG4gICAgQWxwaW5lOiBhbHBpbmVfZGVmYXVsdCxcbiAgICBlZmZlY3Q6IGVmZmVjdDMsXG4gICAgY2xlYW51cCxcbiAgICBldmFsdWF0ZUxhdGVyOiBldmFsdWF0ZUxhdGVyLmJpbmQoZXZhbHVhdGVMYXRlciwgZWwpLFxuICAgIGV2YWx1YXRlOiBldmFsdWF0ZS5iaW5kKGV2YWx1YXRlLCBlbClcbiAgfTtcbiAgbGV0IGRvQ2xlYW51cCA9ICgpID0+IGNsZWFudXBzLmZvckVhY2goKGkpID0+IGkoKSk7XG4gIG9uQXR0cmlidXRlUmVtb3ZlZChlbCwgZGlyZWN0aXZlMi5vcmlnaW5hbCwgZG9DbGVhbnVwKTtcbiAgbGV0IGZ1bGxIYW5kbGVyID0gKCkgPT4ge1xuICAgIGlmIChlbC5feF9pZ25vcmUgfHwgZWwuX3hfaWdub3JlU2VsZilcbiAgICAgIHJldHVybjtcbiAgICBoYW5kbGVyMy5pbmxpbmUgJiYgaGFuZGxlcjMuaW5saW5lKGVsLCBkaXJlY3RpdmUyLCB1dGlsaXRpZXMpO1xuICAgIGhhbmRsZXIzID0gaGFuZGxlcjMuYmluZChoYW5kbGVyMywgZWwsIGRpcmVjdGl2ZTIsIHV0aWxpdGllcyk7XG4gICAgaXNEZWZlcnJpbmdIYW5kbGVycyA/IGRpcmVjdGl2ZUhhbmRsZXJTdGFja3MuZ2V0KGN1cnJlbnRIYW5kbGVyU3RhY2tLZXkpLnB1c2goaGFuZGxlcjMpIDogaGFuZGxlcjMoKTtcbiAgfTtcbiAgZnVsbEhhbmRsZXIucnVuQ2xlYW51cHMgPSBkb0NsZWFudXA7XG4gIHJldHVybiBmdWxsSGFuZGxlcjtcbn1cbnZhciBzdGFydGluZ1dpdGggPSAoc3ViamVjdCwgcmVwbGFjZW1lbnQpID0+ICh7bmFtZSwgdmFsdWV9KSA9PiB7XG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoc3ViamVjdCkpXG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZShzdWJqZWN0LCByZXBsYWNlbWVudCk7XG4gIHJldHVybiB7bmFtZSwgdmFsdWV9O1xufTtcbnZhciBpbnRvID0gKGkpID0+IGk7XG5mdW5jdGlvbiB0b1RyYW5zZm9ybWVkQXR0cmlidXRlcyhjYWxsYmFjayA9ICgpID0+IHtcbn0pIHtcbiAgcmV0dXJuICh7bmFtZSwgdmFsdWV9KSA9PiB7XG4gICAgbGV0IHtuYW1lOiBuZXdOYW1lLCB2YWx1ZTogbmV3VmFsdWV9ID0gYXR0cmlidXRlVHJhbnNmb3JtZXJzLnJlZHVjZSgoY2FycnksIHRyYW5zZm9ybSkgPT4ge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybShjYXJyeSk7XG4gICAgfSwge25hbWUsIHZhbHVlfSk7XG4gICAgaWYgKG5ld05hbWUgIT09IG5hbWUpXG4gICAgICBjYWxsYmFjayhuZXdOYW1lLCBuYW1lKTtcbiAgICByZXR1cm4ge25hbWU6IG5ld05hbWUsIHZhbHVlOiBuZXdWYWx1ZX07XG4gIH07XG59XG52YXIgYXR0cmlidXRlVHJhbnNmb3JtZXJzID0gW107XG5mdW5jdGlvbiBtYXBBdHRyaWJ1dGVzKGNhbGxiYWNrKSB7XG4gIGF0dHJpYnV0ZVRyYW5zZm9ybWVycy5wdXNoKGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIG91dE5vbkFscGluZUF0dHJpYnV0ZXMoe25hbWV9KSB7XG4gIHJldHVybiBhbHBpbmVBdHRyaWJ1dGVSZWdleCgpLnRlc3QobmFtZSk7XG59XG52YXIgYWxwaW5lQXR0cmlidXRlUmVnZXggPSAoKSA9PiBuZXcgUmVnRXhwKGBeJHtwcmVmaXhBc1N0cmluZ30oW146Xi5dKylcXFxcYmApO1xuZnVuY3Rpb24gdG9QYXJzZWREaXJlY3RpdmVzKHRyYW5zZm9ybWVkQXR0cmlidXRlTWFwLCBvcmlnaW5hbEF0dHJpYnV0ZU92ZXJyaWRlKSB7XG4gIHJldHVybiAoe25hbWUsIHZhbHVlfSkgPT4ge1xuICAgIGxldCB0eXBlTWF0Y2ggPSBuYW1lLm1hdGNoKGFscGluZUF0dHJpYnV0ZVJlZ2V4KCkpO1xuICAgIGxldCB2YWx1ZU1hdGNoID0gbmFtZS5tYXRjaCgvOihbYS16QS1aMC05XFwtOl0rKS8pO1xuICAgIGxldCBtb2RpZmllcnMgPSBuYW1lLm1hdGNoKC9cXC5bXi5cXF1dKyg/PVteXFxdXSokKS9nKSB8fCBbXTtcbiAgICBsZXQgb3JpZ2luYWwgPSBvcmlnaW5hbEF0dHJpYnV0ZU92ZXJyaWRlIHx8IHRyYW5zZm9ybWVkQXR0cmlidXRlTWFwW25hbWVdIHx8IG5hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHR5cGVNYXRjaCA/IHR5cGVNYXRjaFsxXSA6IG51bGwsXG4gICAgICB2YWx1ZTogdmFsdWVNYXRjaCA/IHZhbHVlTWF0Y2hbMV0gOiBudWxsLFxuICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnMubWFwKChpKSA9PiBpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKSxcbiAgICAgIGV4cHJlc3Npb246IHZhbHVlLFxuICAgICAgb3JpZ2luYWxcbiAgICB9O1xuICB9O1xufVxudmFyIERFRkFVTFQgPSBcIkRFRkFVTFRcIjtcbnZhciBkaXJlY3RpdmVPcmRlciA9IFtcbiAgXCJpZ25vcmVcIixcbiAgXCJyZWZcIixcbiAgXCJkYXRhXCIsXG4gIFwiYmluZFwiLFxuICBcImluaXRcIixcbiAgXCJmb3JcIixcbiAgXCJtb2RlbFwiLFxuICBcInRyYW5zaXRpb25cIixcbiAgXCJzaG93XCIsXG4gIFwiaWZcIixcbiAgREVGQVVMVCxcbiAgXCJlbGVtZW50XCJcbl07XG5mdW5jdGlvbiBieVByaW9yaXR5KGEsIGIpIHtcbiAgbGV0IHR5cGVBID0gZGlyZWN0aXZlT3JkZXIuaW5kZXhPZihhLnR5cGUpID09PSAtMSA/IERFRkFVTFQgOiBhLnR5cGU7XG4gIGxldCB0eXBlQiA9IGRpcmVjdGl2ZU9yZGVyLmluZGV4T2YoYi50eXBlKSA9PT0gLTEgPyBERUZBVUxUIDogYi50eXBlO1xuICByZXR1cm4gZGlyZWN0aXZlT3JkZXIuaW5kZXhPZih0eXBlQSkgLSBkaXJlY3RpdmVPcmRlci5pbmRleE9mKHR5cGVCKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL2Rpc3BhdGNoLmpzXG5mdW5jdGlvbiBkaXNwYXRjaChlbCwgbmFtZSwgZGV0YWlsID0ge30pIHtcbiAgZWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQobmFtZSwge1xuICAgIGRldGFpbCxcbiAgICBidWJibGVzOiB0cnVlLFxuICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgIGNhbmNlbGFibGU6IHRydWVcbiAgfSkpO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbmV4dFRpY2suanNcbnZhciB0aWNrU3RhY2sgPSBbXTtcbnZhciBpc0hvbGRpbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIG5leHRUaWNrKGNhbGxiYWNrKSB7XG4gIHRpY2tTdGFjay5wdXNoKGNhbGxiYWNrKTtcbiAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgIGlzSG9sZGluZyB8fCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlbGVhc2VOZXh0VGlja3MoKTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZWxlYXNlTmV4dFRpY2tzKCkge1xuICBpc0hvbGRpbmcgPSBmYWxzZTtcbiAgd2hpbGUgKHRpY2tTdGFjay5sZW5ndGgpXG4gICAgdGlja1N0YWNrLnNoaWZ0KCkoKTtcbn1cbmZ1bmN0aW9uIGhvbGROZXh0VGlja3MoKSB7XG4gIGlzSG9sZGluZyA9IHRydWU7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy93YWxrLmpzXG5mdW5jdGlvbiB3YWxrKGVsLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09IFwiZnVuY3Rpb25cIiAmJiBlbCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICBBcnJheS5mcm9tKGVsLmNoaWxkcmVuKS5mb3JFYWNoKChlbDIpID0+IHdhbGsoZWwyLCBjYWxsYmFjaykpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc2tpcCA9IGZhbHNlO1xuICBjYWxsYmFjayhlbCwgKCkgPT4gc2tpcCA9IHRydWUpO1xuICBpZiAoc2tpcClcbiAgICByZXR1cm47XG4gIGxldCBub2RlID0gZWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgd2Fsayhub2RlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgIG5vZGUgPSBub2RlLm5leHRFbGVtZW50U2libGluZztcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvd2Fybi5qc1xuZnVuY3Rpb24gd2FybihtZXNzYWdlLCAuLi5hcmdzKSB7XG4gIGNvbnNvbGUud2FybihgQWxwaW5lIFdhcm5pbmc6ICR7bWVzc2FnZX1gLCAuLi5hcmdzKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2xpZmVjeWNsZS5qc1xuZnVuY3Rpb24gc3RhcnQoKSB7XG4gIGlmICghZG9jdW1lbnQuYm9keSlcbiAgICB3YXJuKFwiVW5hYmxlIHRvIGluaXRpYWxpemUuIFRyeWluZyB0byBsb2FkIEFscGluZSBiZWZvcmUgYDxib2R5PmAgaXMgYXZhaWxhYmxlLiBEaWQgeW91IGZvcmdldCB0byBhZGQgYGRlZmVyYCBpbiBBbHBpbmUncyBgPHNjcmlwdD5gIHRhZz9cIik7XG4gIGRpc3BhdGNoKGRvY3VtZW50LCBcImFscGluZTppbml0XCIpO1xuICBkaXNwYXRjaChkb2N1bWVudCwgXCJhbHBpbmU6aW5pdGlhbGl6aW5nXCIpO1xuICBzdGFydE9ic2VydmluZ011dGF0aW9ucygpO1xuICBvbkVsQWRkZWQoKGVsKSA9PiBpbml0VHJlZShlbCwgd2FsaykpO1xuICBvbkVsUmVtb3ZlZCgoZWwpID0+IG5leHRUaWNrKCgpID0+IGRlc3Ryb3lUcmVlKGVsKSkpO1xuICBvbkF0dHJpYnV0ZXNBZGRlZCgoZWwsIGF0dHJzKSA9PiB7XG4gICAgZGlyZWN0aXZlcyhlbCwgYXR0cnMpLmZvckVhY2goKGhhbmRsZSkgPT4gaGFuZGxlKCkpO1xuICB9KTtcbiAgbGV0IG91dE5lc3RlZENvbXBvbmVudHMgPSAoZWwpID0+ICFjbG9zZXN0Um9vdChlbC5wYXJlbnRFbGVtZW50LCB0cnVlKTtcbiAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGFsbFNlbGVjdG9ycygpKSkuZmlsdGVyKG91dE5lc3RlZENvbXBvbmVudHMpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgaW5pdFRyZWUoZWwpO1xuICB9KTtcbiAgZGlzcGF0Y2goZG9jdW1lbnQsIFwiYWxwaW5lOmluaXRpYWxpemVkXCIpO1xufVxudmFyIHJvb3RTZWxlY3RvckNhbGxiYWNrcyA9IFtdO1xudmFyIGluaXRTZWxlY3RvckNhbGxiYWNrcyA9IFtdO1xuZnVuY3Rpb24gcm9vdFNlbGVjdG9ycygpIHtcbiAgcmV0dXJuIHJvb3RTZWxlY3RvckNhbGxiYWNrcy5tYXAoKGZuKSA9PiBmbigpKTtcbn1cbmZ1bmN0aW9uIGFsbFNlbGVjdG9ycygpIHtcbiAgcmV0dXJuIHJvb3RTZWxlY3RvckNhbGxiYWNrcy5jb25jYXQoaW5pdFNlbGVjdG9yQ2FsbGJhY2tzKS5tYXAoKGZuKSA9PiBmbigpKTtcbn1cbmZ1bmN0aW9uIGFkZFJvb3RTZWxlY3RvcihzZWxlY3RvckNhbGxiYWNrKSB7XG4gIHJvb3RTZWxlY3RvckNhbGxiYWNrcy5wdXNoKHNlbGVjdG9yQ2FsbGJhY2spO1xufVxuZnVuY3Rpb24gYWRkSW5pdFNlbGVjdG9yKHNlbGVjdG9yQ2FsbGJhY2spIHtcbiAgaW5pdFNlbGVjdG9yQ2FsbGJhY2tzLnB1c2goc2VsZWN0b3JDYWxsYmFjayk7XG59XG5mdW5jdGlvbiBjbG9zZXN0Um9vdChlbCwgaW5jbHVkZUluaXRTZWxlY3RvcnMgPSBmYWxzZSkge1xuICBpZiAoIWVsKVxuICAgIHJldHVybjtcbiAgY29uc3Qgc2VsZWN0b3JzID0gaW5jbHVkZUluaXRTZWxlY3RvcnMgPyBhbGxTZWxlY3RvcnMoKSA6IHJvb3RTZWxlY3RvcnMoKTtcbiAgaWYgKHNlbGVjdG9ycy5zb21lKChzZWxlY3RvcikgPT4gZWwubWF0Y2hlcyhzZWxlY3RvcikpKVxuICAgIHJldHVybiBlbDtcbiAgaWYgKCFlbC5wYXJlbnRFbGVtZW50KVxuICAgIHJldHVybjtcbiAgcmV0dXJuIGNsb3Nlc3RSb290KGVsLnBhcmVudEVsZW1lbnQsIGluY2x1ZGVJbml0U2VsZWN0b3JzKTtcbn1cbmZ1bmN0aW9uIGlzUm9vdChlbCkge1xuICByZXR1cm4gcm9vdFNlbGVjdG9ycygpLnNvbWUoKHNlbGVjdG9yKSA9PiBlbC5tYXRjaGVzKHNlbGVjdG9yKSk7XG59XG5mdW5jdGlvbiBpbml0VHJlZShlbCwgd2Fsa2VyID0gd2Fsaykge1xuICBkZWZlckhhbmRsaW5nRGlyZWN0aXZlcygoKSA9PiB7XG4gICAgd2Fsa2VyKGVsLCAoZWwyLCBza2lwKSA9PiB7XG4gICAgICBkaXJlY3RpdmVzKGVsMiwgZWwyLmF0dHJpYnV0ZXMpLmZvckVhY2goKGhhbmRsZSkgPT4gaGFuZGxlKCkpO1xuICAgICAgZWwyLl94X2lnbm9yZSAmJiBza2lwKCk7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZGVzdHJveVRyZWUocm9vdCkge1xuICB3YWxrKHJvb3QsIChlbCkgPT4gY2xlYW51cEF0dHJpYnV0ZXMoZWwpKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL2NsYXNzZXMuanNcbmZ1bmN0aW9uIHNldENsYXNzZXMoZWwsIHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzZXRDbGFzc2VzRnJvbVN0cmluZyhlbCwgdmFsdWUuam9pbihcIiBcIikpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzZXRDbGFzc2VzRnJvbU9iamVjdChlbCwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHNldENsYXNzZXMoZWwsIHZhbHVlKCkpO1xuICB9XG4gIHJldHVybiBzZXRDbGFzc2VzRnJvbVN0cmluZyhlbCwgdmFsdWUpO1xufVxuZnVuY3Rpb24gc2V0Q2xhc3Nlc0Zyb21TdHJpbmcoZWwsIGNsYXNzU3RyaW5nKSB7XG4gIGxldCBzcGxpdCA9IChjbGFzc1N0cmluZzIpID0+IGNsYXNzU3RyaW5nMi5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pO1xuICBsZXQgbWlzc2luZ0NsYXNzZXMgPSAoY2xhc3NTdHJpbmcyKSA9PiBjbGFzc1N0cmluZzIuc3BsaXQoXCIgXCIpLmZpbHRlcigoaSkgPT4gIWVsLmNsYXNzTGlzdC5jb250YWlucyhpKSkuZmlsdGVyKEJvb2xlYW4pO1xuICBsZXQgYWRkQ2xhc3Nlc0FuZFJldHVyblVuZG8gPSAoY2xhc3NlcykgPT4ge1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3Nlcyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3Nlcyk7XG4gICAgfTtcbiAgfTtcbiAgY2xhc3NTdHJpbmcgPSBjbGFzc1N0cmluZyA9PT0gdHJ1ZSA/IGNsYXNzU3RyaW5nID0gXCJcIiA6IGNsYXNzU3RyaW5nIHx8IFwiXCI7XG4gIHJldHVybiBhZGRDbGFzc2VzQW5kUmV0dXJuVW5kbyhtaXNzaW5nQ2xhc3NlcyhjbGFzc1N0cmluZykpO1xufVxuZnVuY3Rpb24gc2V0Q2xhc3Nlc0Zyb21PYmplY3QoZWwsIGNsYXNzT2JqZWN0KSB7XG4gIGxldCBzcGxpdCA9IChjbGFzc1N0cmluZykgPT4gY2xhc3NTdHJpbmcuc3BsaXQoXCIgXCIpLmZpbHRlcihCb29sZWFuKTtcbiAgbGV0IGZvckFkZCA9IE9iamVjdC5lbnRyaWVzKGNsYXNzT2JqZWN0KS5mbGF0TWFwKChbY2xhc3NTdHJpbmcsIGJvb2xdKSA9PiBib29sID8gc3BsaXQoY2xhc3NTdHJpbmcpIDogZmFsc2UpLmZpbHRlcihCb29sZWFuKTtcbiAgbGV0IGZvclJlbW92ZSA9IE9iamVjdC5lbnRyaWVzKGNsYXNzT2JqZWN0KS5mbGF0TWFwKChbY2xhc3NTdHJpbmcsIGJvb2xdKSA9PiAhYm9vbCA/IHNwbGl0KGNsYXNzU3RyaW5nKSA6IGZhbHNlKS5maWx0ZXIoQm9vbGVhbik7XG4gIGxldCBhZGRlZCA9IFtdO1xuICBsZXQgcmVtb3ZlZCA9IFtdO1xuICBmb3JSZW1vdmUuZm9yRWFjaCgoaSkgPT4ge1xuICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoaSkpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoaSk7XG4gICAgICByZW1vdmVkLnB1c2goaSk7XG4gICAgfVxuICB9KTtcbiAgZm9yQWRkLmZvckVhY2goKGkpID0+IHtcbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5jb250YWlucyhpKSkge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChpKTtcbiAgICAgIGFkZGVkLnB1c2goaSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICByZW1vdmVkLmZvckVhY2goKGkpID0+IGVsLmNsYXNzTGlzdC5hZGQoaSkpO1xuICAgIGFkZGVkLmZvckVhY2goKGkpID0+IGVsLmNsYXNzTGlzdC5yZW1vdmUoaSkpO1xuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvc3R5bGVzLmpzXG5mdW5jdGlvbiBzZXRTdHlsZXMoZWwsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc2V0U3R5bGVzRnJvbU9iamVjdChlbCwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBzZXRTdHlsZXNGcm9tU3RyaW5nKGVsLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRTdHlsZXNGcm9tT2JqZWN0KGVsLCB2YWx1ZSkge1xuICBsZXQgcHJldmlvdXNTdHlsZXMgPSB7fTtcbiAgT2JqZWN0LmVudHJpZXModmFsdWUpLmZvckVhY2goKFtrZXksIHZhbHVlMl0pID0+IHtcbiAgICBwcmV2aW91c1N0eWxlc1trZXldID0gZWwuc3R5bGVba2V5XTtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShrZWJhYkNhc2Uoa2V5KSwgdmFsdWUyKTtcbiAgfSk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmIChlbC5zdHlsZS5sZW5ndGggPT09IDApIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgc2V0U3R5bGVzKGVsLCBwcmV2aW91c1N0eWxlcyk7XG4gIH07XG59XG5mdW5jdGlvbiBzZXRTdHlsZXNGcm9tU3RyaW5nKGVsLCB2YWx1ZSkge1xuICBsZXQgY2FjaGUgPSBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCB2YWx1ZSk7XG4gIGVsLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIHZhbHVlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBjYWNoZSk7XG4gIH07XG59XG5mdW5jdGlvbiBrZWJhYkNhc2Uoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9vbmNlLmpzXG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrLCBmYWxsYmFjayA9ICgpID0+IHtcbn0pIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC10cmFuc2l0aW9uLmpzXG5kaXJlY3RpdmUoXCJ0cmFuc2l0aW9uXCIsIChlbCwge3ZhbHVlLCBtb2RpZmllcnMsIGV4cHJlc3Npb259LCB7ZXZhbHVhdGU6IGV2YWx1YXRlMn0pID0+IHtcbiAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSBcImZ1bmN0aW9uXCIpXG4gICAgZXhwcmVzc2lvbiA9IGV2YWx1YXRlMihleHByZXNzaW9uKTtcbiAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgcmVnaXN0ZXJUcmFuc2l0aW9uc0Zyb21IZWxwZXIoZWwsIG1vZGlmaWVycywgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJlZ2lzdGVyVHJhbnNpdGlvbnNGcm9tQ2xhc3NTdHJpbmcoZWwsIGV4cHJlc3Npb24sIHZhbHVlKTtcbiAgfVxufSk7XG5mdW5jdGlvbiByZWdpc3RlclRyYW5zaXRpb25zRnJvbUNsYXNzU3RyaW5nKGVsLCBjbGFzc1N0cmluZywgc3RhZ2UpIHtcbiAgcmVnaXN0ZXJUcmFuc2l0aW9uT2JqZWN0KGVsLCBzZXRDbGFzc2VzLCBcIlwiKTtcbiAgbGV0IGRpcmVjdGl2ZVN0b3JhZ2VNYXAgPSB7XG4gICAgZW50ZXI6IChjbGFzc2VzKSA9PiB7XG4gICAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyLmR1cmluZyA9IGNsYXNzZXM7XG4gICAgfSxcbiAgICBcImVudGVyLXN0YXJ0XCI6IChjbGFzc2VzKSA9PiB7XG4gICAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyLnN0YXJ0ID0gY2xhc3NlcztcbiAgICB9LFxuICAgIFwiZW50ZXItZW5kXCI6IChjbGFzc2VzKSA9PiB7XG4gICAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyLmVuZCA9IGNsYXNzZXM7XG4gICAgfSxcbiAgICBsZWF2ZTogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuZHVyaW5nID0gY2xhc3NlcztcbiAgICB9LFxuICAgIFwibGVhdmUtc3RhcnRcIjogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuc3RhcnQgPSBjbGFzc2VzO1xuICAgIH0sXG4gICAgXCJsZWF2ZS1lbmRcIjogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuZW5kID0gY2xhc3NlcztcbiAgICB9XG4gIH07XG4gIGRpcmVjdGl2ZVN0b3JhZ2VNYXBbc3RhZ2VdKGNsYXNzU3RyaW5nKTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyVHJhbnNpdGlvbnNGcm9tSGVscGVyKGVsLCBtb2RpZmllcnMsIHN0YWdlKSB7XG4gIHJlZ2lzdGVyVHJhbnNpdGlvbk9iamVjdChlbCwgc2V0U3R5bGVzKTtcbiAgbGV0IGRvZXNudFNwZWNpZnkgPSAhbW9kaWZpZXJzLmluY2x1ZGVzKFwiaW5cIikgJiYgIW1vZGlmaWVycy5pbmNsdWRlcyhcIm91dFwiKSAmJiAhc3RhZ2U7XG4gIGxldCB0cmFuc2l0aW9uaW5nSW4gPSBkb2VzbnRTcGVjaWZ5IHx8IG1vZGlmaWVycy5pbmNsdWRlcyhcImluXCIpIHx8IFtcImVudGVyXCJdLmluY2x1ZGVzKHN0YWdlKTtcbiAgbGV0IHRyYW5zaXRpb25pbmdPdXQgPSBkb2VzbnRTcGVjaWZ5IHx8IG1vZGlmaWVycy5pbmNsdWRlcyhcIm91dFwiKSB8fCBbXCJsZWF2ZVwiXS5pbmNsdWRlcyhzdGFnZSk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJpblwiKSAmJiAhZG9lc250U3BlY2lmeSkge1xuICAgIG1vZGlmaWVycyA9IG1vZGlmaWVycy5maWx0ZXIoKGksIGluZGV4KSA9PiBpbmRleCA8IG1vZGlmaWVycy5pbmRleE9mKFwib3V0XCIpKTtcbiAgfVxuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwib3V0XCIpICYmICFkb2VzbnRTcGVjaWZ5KSB7XG4gICAgbW9kaWZpZXJzID0gbW9kaWZpZXJzLmZpbHRlcigoaSwgaW5kZXgpID0+IGluZGV4ID4gbW9kaWZpZXJzLmluZGV4T2YoXCJvdXRcIikpO1xuICB9XG4gIGxldCB3YW50c0FsbCA9ICFtb2RpZmllcnMuaW5jbHVkZXMoXCJvcGFjaXR5XCIpICYmICFtb2RpZmllcnMuaW5jbHVkZXMoXCJzY2FsZVwiKTtcbiAgbGV0IHdhbnRzT3BhY2l0eSA9IHdhbnRzQWxsIHx8IG1vZGlmaWVycy5pbmNsdWRlcyhcIm9wYWNpdHlcIik7XG4gIGxldCB3YW50c1NjYWxlID0gd2FudHNBbGwgfHwgbW9kaWZpZXJzLmluY2x1ZGVzKFwic2NhbGVcIik7XG4gIGxldCBvcGFjaXR5VmFsdWUgPSB3YW50c09wYWNpdHkgPyAwIDogMTtcbiAgbGV0IHNjYWxlVmFsdWUgPSB3YW50c1NjYWxlID8gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwic2NhbGVcIiwgOTUpIC8gMTAwIDogMTtcbiAgbGV0IGRlbGF5ID0gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwiZGVsYXlcIiwgMCk7XG4gIGxldCBvcmlnaW4gPSBtb2RpZmllclZhbHVlKG1vZGlmaWVycywgXCJvcmlnaW5cIiwgXCJjZW50ZXJcIik7XG4gIGxldCBwcm9wZXJ0eSA9IFwib3BhY2l0eSwgdHJhbnNmb3JtXCI7XG4gIGxldCBkdXJhdGlvbkluID0gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwiZHVyYXRpb25cIiwgMTUwKSAvIDFlMztcbiAgbGV0IGR1cmF0aW9uT3V0ID0gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwiZHVyYXRpb25cIiwgNzUpIC8gMWUzO1xuICBsZXQgZWFzaW5nID0gYGN1YmljLWJlemllcigwLjQsIDAuMCwgMC4yLCAxKWA7XG4gIGlmICh0cmFuc2l0aW9uaW5nSW4pIHtcbiAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyLmR1cmluZyA9IHtcbiAgICAgIHRyYW5zZm9ybU9yaWdpbjogb3JpZ2luLFxuICAgICAgdHJhbnNpdGlvbkRlbGF5OiBkZWxheSxcbiAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogcHJvcGVydHksXG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGAke2R1cmF0aW9uSW59c2AsXG4gICAgICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGVhc2luZ1xuICAgIH07XG4gICAgZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5zdGFydCA9IHtcbiAgICAgIG9wYWNpdHk6IG9wYWNpdHlWYWx1ZSxcbiAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7c2NhbGVWYWx1ZX0pYFxuICAgIH07XG4gICAgZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5lbmQgPSB7XG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoMSlgXG4gICAgfTtcbiAgfVxuICBpZiAodHJhbnNpdGlvbmluZ091dCkge1xuICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuZHVyaW5nID0ge1xuICAgICAgdHJhbnNmb3JtT3JpZ2luOiBvcmlnaW4sXG4gICAgICB0cmFuc2l0aW9uRGVsYXk6IGRlbGF5LFxuICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiBwcm9wZXJ0eSxcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogYCR7ZHVyYXRpb25PdXR9c2AsXG4gICAgICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGVhc2luZ1xuICAgIH07XG4gICAgZWwuX3hfdHJhbnNpdGlvbi5sZWF2ZS5zdGFydCA9IHtcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICB0cmFuc2Zvcm06IGBzY2FsZSgxKWBcbiAgICB9O1xuICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuZW5kID0ge1xuICAgICAgb3BhY2l0eTogb3BhY2l0eVZhbHVlLFxuICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoJHtzY2FsZVZhbHVlfSlgXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJUcmFuc2l0aW9uT2JqZWN0KGVsLCBzZXRGdW5jdGlvbiwgZGVmYXVsdFZhbHVlID0ge30pIHtcbiAgaWYgKCFlbC5feF90cmFuc2l0aW9uKVxuICAgIGVsLl94X3RyYW5zaXRpb24gPSB7XG4gICAgICBlbnRlcjoge2R1cmluZzogZGVmYXVsdFZhbHVlLCBzdGFydDogZGVmYXVsdFZhbHVlLCBlbmQ6IGRlZmF1bHRWYWx1ZX0sXG4gICAgICBsZWF2ZToge2R1cmluZzogZGVmYXVsdFZhbHVlLCBzdGFydDogZGVmYXVsdFZhbHVlLCBlbmQ6IGRlZmF1bHRWYWx1ZX0sXG4gICAgICBpbihiZWZvcmUgPSAoKSA9PiB7XG4gICAgICB9LCBhZnRlciA9ICgpID0+IHtcbiAgICAgIH0pIHtcbiAgICAgICAgdHJhbnNpdGlvbihlbCwgc2V0RnVuY3Rpb24sIHtcbiAgICAgICAgICBkdXJpbmc6IHRoaXMuZW50ZXIuZHVyaW5nLFxuICAgICAgICAgIHN0YXJ0OiB0aGlzLmVudGVyLnN0YXJ0LFxuICAgICAgICAgIGVuZDogdGhpcy5lbnRlci5lbmRcbiAgICAgICAgfSwgYmVmb3JlLCBhZnRlcik7XG4gICAgICB9LFxuICAgICAgb3V0KGJlZm9yZSA9ICgpID0+IHtcbiAgICAgIH0sIGFmdGVyID0gKCkgPT4ge1xuICAgICAgfSkge1xuICAgICAgICB0cmFuc2l0aW9uKGVsLCBzZXRGdW5jdGlvbiwge1xuICAgICAgICAgIGR1cmluZzogdGhpcy5sZWF2ZS5kdXJpbmcsXG4gICAgICAgICAgc3RhcnQ6IHRoaXMubGVhdmUuc3RhcnQsXG4gICAgICAgICAgZW5kOiB0aGlzLmxlYXZlLmVuZFxuICAgICAgICB9LCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgIH1cbiAgICB9O1xufVxud2luZG93LkVsZW1lbnQucHJvdG90eXBlLl94X3RvZ2dsZUFuZENhc2NhZGVXaXRoVHJhbnNpdGlvbnMgPSBmdW5jdGlvbihlbCwgdmFsdWUsIHNob3csIGhpZGUpIHtcbiAgbGV0IGNsaWNrQXdheUNvbXBhdGlibGVTaG93ID0gKCkgPT4ge1xuICAgIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJ2aXNpYmxlXCIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2hvdykgOiBzZXRUaW1lb3V0KHNob3cpO1xuICB9O1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoZWwuX3hfdHJhbnNpdGlvbiAmJiAoZWwuX3hfdHJhbnNpdGlvbi5lbnRlciB8fCBlbC5feF90cmFuc2l0aW9uLmxlYXZlKSkge1xuICAgICAgZWwuX3hfdHJhbnNpdGlvbi5lbnRlciAmJiAoT2JqZWN0LmVudHJpZXMoZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5kdXJpbmcpLmxlbmd0aCB8fCBPYmplY3QuZW50cmllcyhlbC5feF90cmFuc2l0aW9uLmVudGVyLnN0YXJ0KS5sZW5ndGggfHwgT2JqZWN0LmVudHJpZXMoZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5lbmQpLmxlbmd0aCkgPyBlbC5feF90cmFuc2l0aW9uLmluKHNob3cpIDogY2xpY2tBd2F5Q29tcGF0aWJsZVNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuX3hfdHJhbnNpdGlvbiA/IGVsLl94X3RyYW5zaXRpb24uaW4oc2hvdykgOiBjbGlja0F3YXlDb21wYXRpYmxlU2hvdygpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgZWwuX3hfaGlkZVByb21pc2UgPSBlbC5feF90cmFuc2l0aW9uID8gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGVsLl94X3RyYW5zaXRpb24ub3V0KCgpID0+IHtcbiAgICB9LCAoKSA9PiByZXNvbHZlKGhpZGUpKTtcbiAgICBlbC5feF90cmFuc2l0aW9uaW5nLmJlZm9yZUNhbmNlbCgoKSA9PiByZWplY3Qoe2lzRnJvbUNhbmNlbGxlZFRyYW5zaXRpb246IHRydWV9KSk7XG4gIH0pIDogUHJvbWlzZS5yZXNvbHZlKGhpZGUpO1xuICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgbGV0IGNsb3Nlc3QgPSBjbG9zZXN0SGlkZShlbCk7XG4gICAgaWYgKGNsb3Nlc3QpIHtcbiAgICAgIGlmICghY2xvc2VzdC5feF9oaWRlQ2hpbGRyZW4pXG4gICAgICAgIGNsb3Nlc3QuX3hfaGlkZUNoaWxkcmVuID0gW107XG4gICAgICBjbG9zZXN0Ll94X2hpZGVDaGlsZHJlbi5wdXNoKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBsZXQgaGlkZUFmdGVyQ2hpbGRyZW4gPSAoZWwyKSA9PiB7XG4gICAgICAgICAgbGV0IGNhcnJ5ID0gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgZWwyLl94X2hpZGVQcm9taXNlLFxuICAgICAgICAgICAgLi4uKGVsMi5feF9oaWRlQ2hpbGRyZW4gfHwgW10pLm1hcChoaWRlQWZ0ZXJDaGlsZHJlbilcbiAgICAgICAgICBdKS50aGVuKChbaV0pID0+IGkoKSk7XG4gICAgICAgICAgZGVsZXRlIGVsMi5feF9oaWRlUHJvbWlzZTtcbiAgICAgICAgICBkZWxldGUgZWwyLl94X2hpZGVDaGlsZHJlbjtcbiAgICAgICAgICByZXR1cm4gY2Fycnk7XG4gICAgICAgIH07XG4gICAgICAgIGhpZGVBZnRlckNoaWxkcmVuKGVsKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIGlmICghZS5pc0Zyb21DYW5jZWxsZWRUcmFuc2l0aW9uKVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcbmZ1bmN0aW9uIGNsb3Nlc3RIaWRlKGVsKSB7XG4gIGxldCBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICBpZiAoIXBhcmVudClcbiAgICByZXR1cm47XG4gIHJldHVybiBwYXJlbnQuX3hfaGlkZVByb21pc2UgPyBwYXJlbnQgOiBjbG9zZXN0SGlkZShwYXJlbnQpO1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbihlbCwgc2V0RnVuY3Rpb24sIHtkdXJpbmcsIHN0YXJ0OiBzdGFydDIsIGVuZH0gPSB7fSwgYmVmb3JlID0gKCkgPT4ge1xufSwgYWZ0ZXIgPSAoKSA9PiB7XG59KSB7XG4gIGlmIChlbC5feF90cmFuc2l0aW9uaW5nKVxuICAgIGVsLl94X3RyYW5zaXRpb25pbmcuY2FuY2VsKCk7XG4gIGlmIChPYmplY3Qua2V5cyhkdXJpbmcpLmxlbmd0aCA9PT0gMCAmJiBPYmplY3Qua2V5cyhzdGFydDIpLmxlbmd0aCA9PT0gMCAmJiBPYmplY3Qua2V5cyhlbmQpLmxlbmd0aCA9PT0gMCkge1xuICAgIGJlZm9yZSgpO1xuICAgIGFmdGVyKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCB1bmRvU3RhcnQsIHVuZG9EdXJpbmcsIHVuZG9FbmQ7XG4gIHBlcmZvcm1UcmFuc2l0aW9uKGVsLCB7XG4gICAgc3RhcnQoKSB7XG4gICAgICB1bmRvU3RhcnQgPSBzZXRGdW5jdGlvbihlbCwgc3RhcnQyKTtcbiAgICB9LFxuICAgIGR1cmluZygpIHtcbiAgICAgIHVuZG9EdXJpbmcgPSBzZXRGdW5jdGlvbihlbCwgZHVyaW5nKTtcbiAgICB9LFxuICAgIGJlZm9yZSxcbiAgICBlbmQoKSB7XG4gICAgICB1bmRvU3RhcnQoKTtcbiAgICAgIHVuZG9FbmQgPSBzZXRGdW5jdGlvbihlbCwgZW5kKTtcbiAgICB9LFxuICAgIGFmdGVyLFxuICAgIGNsZWFudXAoKSB7XG4gICAgICB1bmRvRHVyaW5nKCk7XG4gICAgICB1bmRvRW5kKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBlcmZvcm1UcmFuc2l0aW9uKGVsLCBzdGFnZXMpIHtcbiAgbGV0IGludGVycnVwdGVkLCByZWFjaGVkQmVmb3JlLCByZWFjaGVkRW5kO1xuICBsZXQgZmluaXNoID0gb25jZSgoKSA9PiB7XG4gICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgIGludGVycnVwdGVkID0gdHJ1ZTtcbiAgICAgIGlmICghcmVhY2hlZEJlZm9yZSlcbiAgICAgICAgc3RhZ2VzLmJlZm9yZSgpO1xuICAgICAgaWYgKCFyZWFjaGVkRW5kKSB7XG4gICAgICAgIHN0YWdlcy5lbmQoKTtcbiAgICAgICAgcmVsZWFzZU5leHRUaWNrcygpO1xuICAgICAgfVxuICAgICAgc3RhZ2VzLmFmdGVyKCk7XG4gICAgICBpZiAoZWwuaXNDb25uZWN0ZWQpXG4gICAgICAgIHN0YWdlcy5jbGVhbnVwKCk7XG4gICAgICBkZWxldGUgZWwuX3hfdHJhbnNpdGlvbmluZztcbiAgICB9KTtcbiAgfSk7XG4gIGVsLl94X3RyYW5zaXRpb25pbmcgPSB7XG4gICAgYmVmb3JlQ2FuY2VsczogW10sXG4gICAgYmVmb3JlQ2FuY2VsKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmJlZm9yZUNhbmNlbHMucHVzaChjYWxsYmFjayk7XG4gICAgfSxcbiAgICBjYW5jZWw6IG9uY2UoZnVuY3Rpb24oKSB7XG4gICAgICB3aGlsZSAodGhpcy5iZWZvcmVDYW5jZWxzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmJlZm9yZUNhbmNlbHMuc2hpZnQoKSgpO1xuICAgICAgfVxuICAgICAgO1xuICAgICAgZmluaXNoKCk7XG4gICAgfSksXG4gICAgZmluaXNoXG4gIH07XG4gIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgc3RhZ2VzLnN0YXJ0KCk7XG4gICAgc3RhZ2VzLmR1cmluZygpO1xuICB9KTtcbiAgaG9sZE5leHRUaWNrcygpO1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIGlmIChpbnRlcnJ1cHRlZClcbiAgICAgIHJldHVybjtcbiAgICBsZXQgZHVyYXRpb24gPSBOdW1iZXIoZ2V0Q29tcHV0ZWRTdHlsZShlbCkudHJhbnNpdGlvbkR1cmF0aW9uLnJlcGxhY2UoLywuKi8sIFwiXCIpLnJlcGxhY2UoXCJzXCIsIFwiXCIpKSAqIDFlMztcbiAgICBsZXQgZGVsYXkgPSBOdW1iZXIoZ2V0Q29tcHV0ZWRTdHlsZShlbCkudHJhbnNpdGlvbkRlbGF5LnJlcGxhY2UoLywuKi8sIFwiXCIpLnJlcGxhY2UoXCJzXCIsIFwiXCIpKSAqIDFlMztcbiAgICBpZiAoZHVyYXRpb24gPT09IDApXG4gICAgICBkdXJhdGlvbiA9IE51bWJlcihnZXRDb21wdXRlZFN0eWxlKGVsKS5hbmltYXRpb25EdXJhdGlvbi5yZXBsYWNlKFwic1wiLCBcIlwiKSkgKiAxZTM7XG4gICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgIHN0YWdlcy5iZWZvcmUoKTtcbiAgICB9KTtcbiAgICByZWFjaGVkQmVmb3JlID0gdHJ1ZTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgaWYgKGludGVycnVwdGVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgICBzdGFnZXMuZW5kKCk7XG4gICAgICB9KTtcbiAgICAgIHJlbGVhc2VOZXh0VGlja3MoKTtcbiAgICAgIHNldFRpbWVvdXQoZWwuX3hfdHJhbnNpdGlvbmluZy5maW5pc2gsIGR1cmF0aW9uICsgZGVsYXkpO1xuICAgICAgcmVhY2hlZEVuZCA9IHRydWU7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIGtleSwgZmFsbGJhY2spIHtcbiAgaWYgKG1vZGlmaWVycy5pbmRleE9mKGtleSkgPT09IC0xKVxuICAgIHJldHVybiBmYWxsYmFjaztcbiAgY29uc3QgcmF3VmFsdWUgPSBtb2RpZmllcnNbbW9kaWZpZXJzLmluZGV4T2Yoa2V5KSArIDFdO1xuICBpZiAoIXJhd1ZhbHVlKVxuICAgIHJldHVybiBmYWxsYmFjaztcbiAgaWYgKGtleSA9PT0gXCJzY2FsZVwiKSB7XG4gICAgaWYgKGlzTmFOKHJhd1ZhbHVlKSlcbiAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgfVxuICBpZiAoa2V5ID09PSBcImR1cmF0aW9uXCIpIHtcbiAgICBsZXQgbWF0Y2ggPSByYXdWYWx1ZS5tYXRjaCgvKFswLTldKyltcy8pO1xuICAgIGlmIChtYXRjaClcbiAgICAgIHJldHVybiBtYXRjaFsxXTtcbiAgfVxuICBpZiAoa2V5ID09PSBcIm9yaWdpblwiKSB7XG4gICAgaWYgKFtcInRvcFwiLCBcInJpZ2h0XCIsIFwibGVmdFwiLCBcImNlbnRlclwiLCBcImJvdHRvbVwiXS5pbmNsdWRlcyhtb2RpZmllcnNbbW9kaWZpZXJzLmluZGV4T2Yoa2V5KSArIDJdKSkge1xuICAgICAgcmV0dXJuIFtyYXdWYWx1ZSwgbW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKGtleSkgKyAyXV0uam9pbihcIiBcIik7XG4gICAgfVxuICB9XG4gIHJldHVybiByYXdWYWx1ZTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2Nsb25lLmpzXG52YXIgaXNDbG9uaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBza2lwRHVyaW5nQ2xvbmUoY2FsbGJhY2ssIGZhbGxiYWNrID0gKCkgPT4ge1xufSkge1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IGlzQ2xvbmluZyA/IGZhbGxiYWNrKC4uLmFyZ3MpIDogY2FsbGJhY2soLi4uYXJncyk7XG59XG5mdW5jdGlvbiBjbG9uZShvbGRFbCwgbmV3RWwpIHtcbiAgaWYgKCFuZXdFbC5feF9kYXRhU3RhY2spXG4gICAgbmV3RWwuX3hfZGF0YVN0YWNrID0gb2xkRWwuX3hfZGF0YVN0YWNrO1xuICBpc0Nsb25pbmcgPSB0cnVlO1xuICBkb250UmVnaXN0ZXJSZWFjdGl2ZVNpZGVFZmZlY3RzKCgpID0+IHtcbiAgICBjbG9uZVRyZWUobmV3RWwpO1xuICB9KTtcbiAgaXNDbG9uaW5nID0gZmFsc2U7XG59XG5mdW5jdGlvbiBjbG9uZVRyZWUoZWwpIHtcbiAgbGV0IGhhc1J1blRocm91Z2hGaXJzdEVsID0gZmFsc2U7XG4gIGxldCBzaGFsbG93V2Fsa2VyID0gKGVsMiwgY2FsbGJhY2spID0+IHtcbiAgICB3YWxrKGVsMiwgKGVsMywgc2tpcCkgPT4ge1xuICAgICAgaWYgKGhhc1J1blRocm91Z2hGaXJzdEVsICYmIGlzUm9vdChlbDMpKVxuICAgICAgICByZXR1cm4gc2tpcCgpO1xuICAgICAgaGFzUnVuVGhyb3VnaEZpcnN0RWwgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soZWwzLCBza2lwKTtcbiAgICB9KTtcbiAgfTtcbiAgaW5pdFRyZWUoZWwsIHNoYWxsb3dXYWxrZXIpO1xufVxuZnVuY3Rpb24gZG9udFJlZ2lzdGVyUmVhY3RpdmVTaWRlRWZmZWN0cyhjYWxsYmFjaykge1xuICBsZXQgY2FjaGUgPSBlZmZlY3Q7XG4gIG92ZXJyaWRlRWZmZWN0KChjYWxsYmFjazIsIGVsKSA9PiB7XG4gICAgbGV0IHN0b3JlZEVmZmVjdCA9IGNhY2hlKGNhbGxiYWNrMik7XG4gICAgcmVsZWFzZShzdG9yZWRFZmZlY3QpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgfTtcbiAgfSk7XG4gIGNhbGxiYWNrKCk7XG4gIG92ZXJyaWRlRWZmZWN0KGNhY2hlKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL2RlYm91bmNlLmpzXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0KSB7XG4gIHZhciB0aW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH07XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL3Rocm90dGxlLmpzXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCBsaW1pdCkge1xuICBsZXQgaW5UaHJvdHRsZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGxldCBjb250ZXh0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICBpZiAoIWluVGhyb3R0bGUpIHtcbiAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpblRocm90dGxlID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gaW5UaHJvdHRsZSA9IGZhbHNlLCBsaW1pdCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvcGx1Z2luLmpzXG5mdW5jdGlvbiBwbHVnaW4oY2FsbGJhY2spIHtcbiAgY2FsbGJhY2soYWxwaW5lX2RlZmF1bHQpO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvc3RvcmUuanNcbnZhciBzdG9yZXMgPSB7fTtcbnZhciBpc1JlYWN0aXZlID0gZmFsc2U7XG5mdW5jdGlvbiBzdG9yZShuYW1lLCB2YWx1ZSkge1xuICBpZiAoIWlzUmVhY3RpdmUpIHtcbiAgICBzdG9yZXMgPSByZWFjdGl2ZShzdG9yZXMpO1xuICAgIGlzUmVhY3RpdmUgPSB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHN0b3Jlc1tuYW1lXTtcbiAgfVxuICBzdG9yZXNbbmFtZV0gPSB2YWx1ZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eShcImluaXRcIikgJiYgdHlwZW9mIHZhbHVlLmluaXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHN0b3Jlc1tuYW1lXS5pbml0KCk7XG4gIH1cbiAgaW5pdEludGVyY2VwdG9ycyhzdG9yZXNbbmFtZV0pO1xufVxuZnVuY3Rpb24gZ2V0U3RvcmVzKCkge1xuICByZXR1cm4gc3RvcmVzO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGF0YXMuanNcbnZhciBkYXRhcyA9IHt9O1xuZnVuY3Rpb24gZGF0YShuYW1lLCBjYWxsYmFjaykge1xuICBkYXRhc1tuYW1lXSA9IGNhbGxiYWNrO1xufVxuZnVuY3Rpb24gaW5qZWN0RGF0YVByb3ZpZGVycyhvYmosIGNvbnRleHQpIHtcbiAgT2JqZWN0LmVudHJpZXMoZGF0YXMpLmZvckVhY2goKFtuYW1lLCBjYWxsYmFja10pID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5iaW5kKGNvbnRleHQpKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2JqO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvYWxwaW5lLmpzXG52YXIgQWxwaW5lID0ge1xuICBnZXQgcmVhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHJlYWN0aXZlO1xuICB9LFxuICBnZXQgcmVsZWFzZSgpIHtcbiAgICByZXR1cm4gcmVsZWFzZTtcbiAgfSxcbiAgZ2V0IGVmZmVjdCgpIHtcbiAgICByZXR1cm4gZWZmZWN0O1xuICB9LFxuICBnZXQgcmF3KCkge1xuICAgIHJldHVybiByYXc7XG4gIH0sXG4gIHZlcnNpb246IFwiMy41LjJcIixcbiAgZmx1c2hBbmRTdG9wRGVmZXJyaW5nTXV0YXRpb25zLFxuICBkaXNhYmxlRWZmZWN0U2NoZWR1bGluZyxcbiAgc2V0UmVhY3Rpdml0eUVuZ2luZSxcbiAgY2xvc2VzdERhdGFTdGFjayxcbiAgc2tpcER1cmluZ0Nsb25lLFxuICBhZGRSb290U2VsZWN0b3IsXG4gIGRlZmVyTXV0YXRpb25zLFxuICBtYXBBdHRyaWJ1dGVzLFxuICBldmFsdWF0ZUxhdGVyLFxuICBzZXRFdmFsdWF0b3IsXG4gIG1lcmdlUHJveGllcyxcbiAgY2xvc2VzdFJvb3QsXG4gIGludGVyY2VwdG9yLFxuICB0cmFuc2l0aW9uLFxuICBzZXRTdHlsZXMsXG4gIG11dGF0ZURvbSxcbiAgZGlyZWN0aXZlLFxuICB0aHJvdHRsZSxcbiAgZGVib3VuY2UsXG4gIGV2YWx1YXRlLFxuICBpbml0VHJlZSxcbiAgbmV4dFRpY2ssXG4gIHByZWZpeDogc2V0UHJlZml4LFxuICBwbHVnaW4sXG4gIG1hZ2ljLFxuICBzdG9yZSxcbiAgc3RhcnQsXG4gIGNsb25lLFxuICBkYXRhXG59O1xudmFyIGFscGluZV9kZWZhdWx0ID0gQWxwaW5lO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvaW5kZXguanNcbnZhciBpbXBvcnRfcmVhY3Rpdml0eTkgPSBfX3RvTW9kdWxlKHJlcXVpcmVfcmVhY3Rpdml0eSgpKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy8kbmV4dFRpY2suanNcbm1hZ2ljKFwibmV4dFRpY2tcIiwgKCkgPT4gbmV4dFRpY2spO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbWFnaWNzLyRkaXNwYXRjaC5qc1xubWFnaWMoXCJkaXNwYXRjaFwiLCAoZWwpID0+IGRpc3BhdGNoLmJpbmQoZGlzcGF0Y2gsIGVsKSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJHdhdGNoLmpzXG5tYWdpYyhcIndhdGNoXCIsIChlbCkgPT4gKGtleSwgY2FsbGJhY2spID0+IHtcbiAgbGV0IGV2YWx1YXRlMiA9IGV2YWx1YXRlTGF0ZXIoZWwsIGtleSk7XG4gIGxldCBmaXJzdFRpbWUgPSB0cnVlO1xuICBsZXQgb2xkVmFsdWU7XG4gIGVmZmVjdCgoKSA9PiBldmFsdWF0ZTIoKHZhbHVlKSA9PiB7XG4gICAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LmRhdGFzZXQudGhyb3dBd2F5ID0gdmFsdWU7XG4gICAgaWYgKCFmaXJzdFRpbWUpIHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgY2FsbGJhY2sodmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgb2xkVmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbGRWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgfSkpO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJHN0b3JlLmpzXG5tYWdpYyhcInN0b3JlXCIsIGdldFN0b3Jlcyk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJGRhdGEuanNcbm1hZ2ljKFwiZGF0YVwiLCAoZWwpID0+IHtcbiAgcmV0dXJuIG1lcmdlUHJveGllcyhjbG9zZXN0RGF0YVN0YWNrKGVsKSk7XG59KTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy8kcm9vdC5qc1xubWFnaWMoXCJyb290XCIsIChlbCkgPT4gY2xvc2VzdFJvb3QoZWwpKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy8kcmVmcy5qc1xubWFnaWMoXCJyZWZzXCIsIChlbCkgPT4ge1xuICBpZiAoZWwuX3hfcmVmc19wcm94eSlcbiAgICByZXR1cm4gZWwuX3hfcmVmc19wcm94eTtcbiAgZWwuX3hfcmVmc19wcm94eSA9IG1lcmdlUHJveGllcyhnZXRBcnJheU9mUmVmT2JqZWN0KGVsKSk7XG4gIHJldHVybiBlbC5feF9yZWZzX3Byb3h5O1xufSk7XG5mdW5jdGlvbiBnZXRBcnJheU9mUmVmT2JqZWN0KGVsKSB7XG4gIGxldCByZWZPYmplY3RzID0gW107XG4gIGxldCBjdXJyZW50RWwgPSBlbDtcbiAgd2hpbGUgKGN1cnJlbnRFbCkge1xuICAgIGlmIChjdXJyZW50RWwuX3hfcmVmcylcbiAgICAgIHJlZk9iamVjdHMucHVzaChjdXJyZW50RWwuX3hfcmVmcyk7XG4gICAgY3VycmVudEVsID0gY3VycmVudEVsLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIHJlZk9iamVjdHM7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJGVsLmpzXG5tYWdpYyhcImVsXCIsIChlbCkgPT4gZWwpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWlnbm9yZS5qc1xudmFyIGhhbmRsZXIgPSAoKSA9PiB7XG59O1xuaGFuZGxlci5pbmxpbmUgPSAoZWwsIHttb2RpZmllcnN9LCB7Y2xlYW51cH0pID0+IHtcbiAgbW9kaWZpZXJzLmluY2x1ZGVzKFwic2VsZlwiKSA/IGVsLl94X2lnbm9yZVNlbGYgPSB0cnVlIDogZWwuX3hfaWdub3JlID0gdHJ1ZTtcbiAgY2xlYW51cCgoKSA9PiB7XG4gICAgbW9kaWZpZXJzLmluY2x1ZGVzKFwic2VsZlwiKSA/IGRlbGV0ZSBlbC5feF9pZ25vcmVTZWxmIDogZGVsZXRlIGVsLl94X2lnbm9yZTtcbiAgfSk7XG59O1xuZGlyZWN0aXZlKFwiaWdub3JlXCIsIGhhbmRsZXIpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWVmZmVjdC5qc1xuZGlyZWN0aXZlKFwiZWZmZWN0XCIsIChlbCwge2V4cHJlc3Npb259LCB7ZWZmZWN0OiBlZmZlY3QzfSkgPT4gZWZmZWN0MyhldmFsdWF0ZUxhdGVyKGVsLCBleHByZXNzaW9uKSkpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvYmluZC5qc1xuZnVuY3Rpb24gYmluZChlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycyA9IFtdKSB7XG4gIGlmICghZWwuX3hfYmluZGluZ3MpXG4gICAgZWwuX3hfYmluZGluZ3MgPSByZWFjdGl2ZSh7fSk7XG4gIGVsLl94X2JpbmRpbmdzW25hbWVdID0gdmFsdWU7XG4gIG5hbWUgPSBtb2RpZmllcnMuaW5jbHVkZXMoXCJjYW1lbFwiKSA/IGNhbWVsQ2FzZShuYW1lKSA6IG5hbWU7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgYmluZElucHV0VmFsdWUoZWwsIHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgYmluZFN0eWxlcyhlbCwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICBiaW5kQ2xhc3NlcyhlbCwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJpbmRBdHRyaWJ1dGUoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5mdW5jdGlvbiBiaW5kSW5wdXRWYWx1ZShlbCwgdmFsdWUpIHtcbiAgaWYgKGVsLnR5cGUgPT09IFwicmFkaW9cIikge1xuICAgIGlmIChlbC5hdHRyaWJ1dGVzLnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIGVsLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGlmICh3aW5kb3cuZnJvbU1vZGVsKSB7XG4gICAgICBlbC5jaGVja2VkID0gY2hlY2tlZEF0dHJMb29zZUNvbXBhcmUoZWwudmFsdWUsIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZWwudHlwZSA9PT0gXCJjaGVja2JveFwiKSB7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICBlbC52YWx1ZSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoIU51bWJlci5pc0ludGVnZXIodmFsdWUpICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwiYm9vbGVhblwiICYmICFbbnVsbCwgdm9pZCAwXS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgIGVsLnZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSB2YWx1ZS5zb21lKCh2YWwpID0+IGNoZWNrZWRBdHRyTG9vc2VDb21wYXJlKHZhbCwgZWwudmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSAhIXZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChlbC50YWdOYW1lID09PSBcIlNFTEVDVFwiKSB7XG4gICAgdXBkYXRlU2VsZWN0KGVsLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVsLnZhbHVlID09PSB2YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBlbC52YWx1ZSA9IHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBiaW5kQ2xhc3NlcyhlbCwgdmFsdWUpIHtcbiAgaWYgKGVsLl94X3VuZG9BZGRlZENsYXNzZXMpXG4gICAgZWwuX3hfdW5kb0FkZGVkQ2xhc3NlcygpO1xuICBlbC5feF91bmRvQWRkZWRDbGFzc2VzID0gc2V0Q2xhc3NlcyhlbCwgdmFsdWUpO1xufVxuZnVuY3Rpb24gYmluZFN0eWxlcyhlbCwgdmFsdWUpIHtcbiAgaWYgKGVsLl94X3VuZG9BZGRlZFN0eWxlcylcbiAgICBlbC5feF91bmRvQWRkZWRTdHlsZXMoKTtcbiAgZWwuX3hfdW5kb0FkZGVkU3R5bGVzID0gc2V0U3R5bGVzKGVsLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBiaW5kQXR0cmlidXRlKGVsLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAoW251bGwsIHZvaWQgMCwgZmFsc2VdLmluY2x1ZGVzKHZhbHVlKSAmJiBhdHRyaWJ1dGVTaG91bGRudEJlUHJlc2VydmVkSWZGYWxzeShuYW1lKSkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNCb29sZWFuQXR0cihuYW1lKSlcbiAgICAgIHZhbHVlID0gbmFtZTtcbiAgICBzZXRJZkNoYW5nZWQoZWwsIG5hbWUsIHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0SWZDaGFuZ2VkKGVsLCBhdHRyTmFtZSwgdmFsdWUpIHtcbiAgaWYgKGVsLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkgIT0gdmFsdWUpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlU2VsZWN0KGVsLCB2YWx1ZSkge1xuICBjb25zdCBhcnJheVdyYXBwZWRWYWx1ZSA9IFtdLmNvbmNhdCh2YWx1ZSkubWFwKCh2YWx1ZTIpID0+IHtcbiAgICByZXR1cm4gdmFsdWUyICsgXCJcIjtcbiAgfSk7XG4gIEFycmF5LmZyb20oZWwub3B0aW9ucykuZm9yRWFjaCgob3B0aW9uKSA9PiB7XG4gICAgb3B0aW9uLnNlbGVjdGVkID0gYXJyYXlXcmFwcGVkVmFsdWUuaW5jbHVkZXMob3B0aW9uLnZhbHVlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjYW1lbENhc2Uoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oXFx3KS9nLCAobWF0Y2gsIGNoYXIpID0+IGNoYXIudG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBjaGVja2VkQXR0ckxvb3NlQ29tcGFyZSh2YWx1ZUEsIHZhbHVlQikge1xuICByZXR1cm4gdmFsdWVBID09IHZhbHVlQjtcbn1cbmZ1bmN0aW9uIGlzQm9vbGVhbkF0dHIoYXR0ck5hbWUpIHtcbiAgY29uc3QgYm9vbGVhbkF0dHJpYnV0ZXMgPSBbXG4gICAgXCJkaXNhYmxlZFwiLFxuICAgIFwiY2hlY2tlZFwiLFxuICAgIFwicmVxdWlyZWRcIixcbiAgICBcInJlYWRvbmx5XCIsXG4gICAgXCJoaWRkZW5cIixcbiAgICBcIm9wZW5cIixcbiAgICBcInNlbGVjdGVkXCIsXG4gICAgXCJhdXRvZm9jdXNcIixcbiAgICBcIml0ZW1zY29wZVwiLFxuICAgIFwibXVsdGlwbGVcIixcbiAgICBcIm5vdmFsaWRhdGVcIixcbiAgICBcImFsbG93ZnVsbHNjcmVlblwiLFxuICAgIFwiYWxsb3dwYXltZW50cmVxdWVzdFwiLFxuICAgIFwiZm9ybW5vdmFsaWRhdGVcIixcbiAgICBcImF1dG9wbGF5XCIsXG4gICAgXCJjb250cm9sc1wiLFxuICAgIFwibG9vcFwiLFxuICAgIFwibXV0ZWRcIixcbiAgICBcInBsYXlzaW5saW5lXCIsXG4gICAgXCJkZWZhdWx0XCIsXG4gICAgXCJpc21hcFwiLFxuICAgIFwicmV2ZXJzZWRcIixcbiAgICBcImFzeW5jXCIsXG4gICAgXCJkZWZlclwiLFxuICAgIFwibm9tb2R1bGVcIlxuICBdO1xuICByZXR1cm4gYm9vbGVhbkF0dHJpYnV0ZXMuaW5jbHVkZXMoYXR0ck5hbWUpO1xufVxuZnVuY3Rpb24gYXR0cmlidXRlU2hvdWxkbnRCZVByZXNlcnZlZElmRmFsc3kobmFtZSkge1xuICByZXR1cm4gIVtcImFyaWEtcHJlc3NlZFwiLCBcImFyaWEtY2hlY2tlZFwiLCBcImFyaWEtZXhwYW5kZWRcIl0uaW5jbHVkZXMobmFtZSk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9vbi5qc1xuZnVuY3Rpb24gb24oZWwsIGV2ZW50LCBtb2RpZmllcnMsIGNhbGxiYWNrKSB7XG4gIGxldCBsaXN0ZW5lclRhcmdldCA9IGVsO1xuICBsZXQgaGFuZGxlcjMgPSAoZSkgPT4gY2FsbGJhY2soZSk7XG4gIGxldCBvcHRpb25zID0ge307XG4gIGxldCB3cmFwSGFuZGxlciA9IChjYWxsYmFjazIsIHdyYXBwZXIpID0+IChlKSA9PiB3cmFwcGVyKGNhbGxiYWNrMiwgZSk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJkb3RcIikpXG4gICAgZXZlbnQgPSBkb3RTeW50YXgoZXZlbnQpO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiY2FtZWxcIikpXG4gICAgZXZlbnQgPSBjYW1lbENhc2UyKGV2ZW50KTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInBhc3NpdmVcIikpXG4gICAgb3B0aW9ucy5wYXNzaXZlID0gdHJ1ZTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcImNhcHR1cmVcIikpXG4gICAgb3B0aW9ucy5jYXB0dXJlID0gdHJ1ZTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcIndpbmRvd1wiKSlcbiAgICBsaXN0ZW5lclRhcmdldCA9IHdpbmRvdztcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcImRvY3VtZW50XCIpKVxuICAgIGxpc3RlbmVyVGFyZ2V0ID0gZG9jdW1lbnQ7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJwcmV2ZW50XCIpKVxuICAgIGhhbmRsZXIzID0gd3JhcEhhbmRsZXIoaGFuZGxlcjMsIChuZXh0LCBlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBuZXh0KGUpO1xuICAgIH0pO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwic3RvcFwiKSlcbiAgICBoYW5kbGVyMyA9IHdyYXBIYW5kbGVyKGhhbmRsZXIzLCAobmV4dCwgZSkgPT4ge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIG5leHQoZSk7XG4gICAgfSk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJzZWxmXCIpKVxuICAgIGhhbmRsZXIzID0gd3JhcEhhbmRsZXIoaGFuZGxlcjMsIChuZXh0LCBlKSA9PiB7XG4gICAgICBlLnRhcmdldCA9PT0gZWwgJiYgbmV4dChlKTtcbiAgICB9KTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcImF3YXlcIikgfHwgbW9kaWZpZXJzLmluY2x1ZGVzKFwib3V0c2lkZVwiKSkge1xuICAgIGxpc3RlbmVyVGFyZ2V0ID0gZG9jdW1lbnQ7XG4gICAgaGFuZGxlcjMgPSB3cmFwSGFuZGxlcihoYW5kbGVyMywgKG5leHQsIGUpID0+IHtcbiAgICAgIGlmIChlbC5jb250YWlucyhlLnRhcmdldCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChlbC5vZmZzZXRXaWR0aCA8IDEgJiYgZWwub2Zmc2V0SGVpZ2h0IDwgMSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKGVsLl94X2lzU2hvd24gPT09IGZhbHNlKVxuICAgICAgICByZXR1cm47XG4gICAgICBuZXh0KGUpO1xuICAgIH0pO1xuICB9XG4gIGhhbmRsZXIzID0gd3JhcEhhbmRsZXIoaGFuZGxlcjMsIChuZXh0LCBlKSA9PiB7XG4gICAgaWYgKGlzS2V5RXZlbnQoZXZlbnQpKSB7XG4gICAgICBpZiAoaXNMaXN0ZW5pbmdGb3JBU3BlY2lmaWNLZXlUaGF0SGFzbnRCZWVuUHJlc3NlZChlLCBtb2RpZmllcnMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgbmV4dChlKTtcbiAgfSk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJkZWJvdW5jZVwiKSkge1xuICAgIGxldCBuZXh0TW9kaWZpZXIgPSBtb2RpZmllcnNbbW9kaWZpZXJzLmluZGV4T2YoXCJkZWJvdW5jZVwiKSArIDFdIHx8IFwiaW52YWxpZC13YWl0XCI7XG4gICAgbGV0IHdhaXQgPSBpc051bWVyaWMobmV4dE1vZGlmaWVyLnNwbGl0KFwibXNcIilbMF0pID8gTnVtYmVyKG5leHRNb2RpZmllci5zcGxpdChcIm1zXCIpWzBdKSA6IDI1MDtcbiAgICBoYW5kbGVyMyA9IGRlYm91bmNlKGhhbmRsZXIzLCB3YWl0KTtcbiAgfVxuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwidGhyb3R0bGVcIikpIHtcbiAgICBsZXQgbmV4dE1vZGlmaWVyID0gbW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKFwidGhyb3R0bGVcIikgKyAxXSB8fCBcImludmFsaWQtd2FpdFwiO1xuICAgIGxldCB3YWl0ID0gaXNOdW1lcmljKG5leHRNb2RpZmllci5zcGxpdChcIm1zXCIpWzBdKSA/IE51bWJlcihuZXh0TW9kaWZpZXIuc3BsaXQoXCJtc1wiKVswXSkgOiAyNTA7XG4gICAgaGFuZGxlcjMgPSB0aHJvdHRsZShoYW5kbGVyMywgd2FpdCk7XG4gIH1cbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcIm9uY2VcIikpIHtcbiAgICBoYW5kbGVyMyA9IHdyYXBIYW5kbGVyKGhhbmRsZXIzLCAobmV4dCwgZSkgPT4ge1xuICAgICAgbmV4dChlKTtcbiAgICAgIGxpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIzLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICBsaXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyMywgb3B0aW9ucyk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcjMsIG9wdGlvbnMpO1xuICB9O1xufVxuZnVuY3Rpb24gZG90U3ludGF4KHN1YmplY3QpIHtcbiAgcmV0dXJuIHN1YmplY3QucmVwbGFjZSgvLS9nLCBcIi5cIik7XG59XG5mdW5jdGlvbiBjYW1lbENhc2UyKHN1YmplY3QpIHtcbiAgcmV0dXJuIHN1YmplY3QudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tKFxcdykvZywgKG1hdGNoLCBjaGFyKSA9PiBjaGFyLnRvVXBwZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gaXNOdW1lcmljKHN1YmplY3QpIHtcbiAgcmV0dXJuICFBcnJheS5pc0FycmF5KHN1YmplY3QpICYmICFpc05hTihzdWJqZWN0KTtcbn1cbmZ1bmN0aW9uIGtlYmFiQ2FzZTIoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxLSQyXCIpLnJlcGxhY2UoL1tfXFxzXS8sIFwiLVwiKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gaXNLZXlFdmVudChldmVudCkge1xuICByZXR1cm4gW1wia2V5ZG93blwiLCBcImtleXVwXCJdLmluY2x1ZGVzKGV2ZW50KTtcbn1cbmZ1bmN0aW9uIGlzTGlzdGVuaW5nRm9yQVNwZWNpZmljS2V5VGhhdEhhc250QmVlblByZXNzZWQoZSwgbW9kaWZpZXJzKSB7XG4gIGxldCBrZXlNb2RpZmllcnMgPSBtb2RpZmllcnMuZmlsdGVyKChpKSA9PiB7XG4gICAgcmV0dXJuICFbXCJ3aW5kb3dcIiwgXCJkb2N1bWVudFwiLCBcInByZXZlbnRcIiwgXCJzdG9wXCIsIFwib25jZVwiXS5pbmNsdWRlcyhpKTtcbiAgfSk7XG4gIGlmIChrZXlNb2RpZmllcnMuaW5jbHVkZXMoXCJkZWJvdW5jZVwiKSkge1xuICAgIGxldCBkZWJvdW5jZUluZGV4ID0ga2V5TW9kaWZpZXJzLmluZGV4T2YoXCJkZWJvdW5jZVwiKTtcbiAgICBrZXlNb2RpZmllcnMuc3BsaWNlKGRlYm91bmNlSW5kZXgsIGlzTnVtZXJpYygoa2V5TW9kaWZpZXJzW2RlYm91bmNlSW5kZXggKyAxXSB8fCBcImludmFsaWQtd2FpdFwiKS5zcGxpdChcIm1zXCIpWzBdKSA/IDIgOiAxKTtcbiAgfVxuICBpZiAoa2V5TW9kaWZpZXJzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChrZXlNb2RpZmllcnMubGVuZ3RoID09PSAxICYmIGtleVRvTW9kaWZpZXJzKGUua2V5KS5pbmNsdWRlcyhrZXlNb2RpZmllcnNbMF0pKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgc3lzdGVtS2V5TW9kaWZpZXJzID0gW1wiY3RybFwiLCBcInNoaWZ0XCIsIFwiYWx0XCIsIFwibWV0YVwiLCBcImNtZFwiLCBcInN1cGVyXCJdO1xuICBjb25zdCBzZWxlY3RlZFN5c3RlbUtleU1vZGlmaWVycyA9IHN5c3RlbUtleU1vZGlmaWVycy5maWx0ZXIoKG1vZGlmaWVyKSA9PiBrZXlNb2RpZmllcnMuaW5jbHVkZXMobW9kaWZpZXIpKTtcbiAga2V5TW9kaWZpZXJzID0ga2V5TW9kaWZpZXJzLmZpbHRlcigoaSkgPT4gIXNlbGVjdGVkU3lzdGVtS2V5TW9kaWZpZXJzLmluY2x1ZGVzKGkpKTtcbiAgaWYgKHNlbGVjdGVkU3lzdGVtS2V5TW9kaWZpZXJzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBhY3RpdmVseVByZXNzZWRLZXlNb2RpZmllcnMgPSBzZWxlY3RlZFN5c3RlbUtleU1vZGlmaWVycy5maWx0ZXIoKG1vZGlmaWVyKSA9PiB7XG4gICAgICBpZiAobW9kaWZpZXIgPT09IFwiY21kXCIgfHwgbW9kaWZpZXIgPT09IFwic3VwZXJcIilcbiAgICAgICAgbW9kaWZpZXIgPSBcIm1ldGFcIjtcbiAgICAgIHJldHVybiBlW2Ake21vZGlmaWVyfUtleWBdO1xuICAgIH0pO1xuICAgIGlmIChhY3RpdmVseVByZXNzZWRLZXlNb2RpZmllcnMubGVuZ3RoID09PSBzZWxlY3RlZFN5c3RlbUtleU1vZGlmaWVycy5sZW5ndGgpIHtcbiAgICAgIGlmIChrZXlUb01vZGlmaWVycyhlLmtleSkuaW5jbHVkZXMoa2V5TW9kaWZpZXJzWzBdKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGtleVRvTW9kaWZpZXJzKGtleSkge1xuICBpZiAoIWtleSlcbiAgICByZXR1cm4gW107XG4gIGtleSA9IGtlYmFiQ2FzZTIoa2V5KTtcbiAgbGV0IG1vZGlmaWVyVG9LZXlNYXAgPSB7XG4gICAgY3RybDogXCJjb250cm9sXCIsXG4gICAgc2xhc2g6IFwiL1wiLFxuICAgIHNwYWNlOiBcIi1cIixcbiAgICBzcGFjZWJhcjogXCItXCIsXG4gICAgY21kOiBcIm1ldGFcIixcbiAgICBlc2M6IFwiZXNjYXBlXCIsXG4gICAgdXA6IFwiYXJyb3ctdXBcIixcbiAgICBkb3duOiBcImFycm93LWRvd25cIixcbiAgICBsZWZ0OiBcImFycm93LWxlZnRcIixcbiAgICByaWdodDogXCJhcnJvdy1yaWdodFwiLFxuICAgIHBlcmlvZDogXCIuXCIsXG4gICAgZXF1YWw6IFwiPVwiXG4gIH07XG4gIG1vZGlmaWVyVG9LZXlNYXBba2V5XSA9IGtleTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1vZGlmaWVyVG9LZXlNYXApLm1hcCgobW9kaWZpZXIpID0+IHtcbiAgICBpZiAobW9kaWZpZXJUb0tleU1hcFttb2RpZmllcl0gPT09IGtleSlcbiAgICAgIHJldHVybiBtb2RpZmllcjtcbiAgfSkuZmlsdGVyKChtb2RpZmllcikgPT4gbW9kaWZpZXIpO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LW1vZGVsLmpzXG5kaXJlY3RpdmUoXCJtb2RlbFwiLCAoZWwsIHttb2RpZmllcnMsIGV4cHJlc3Npb259LCB7ZWZmZWN0OiBlZmZlY3QzLCBjbGVhbnVwfSkgPT4ge1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbik7XG4gIGxldCBhc3NpZ25tZW50RXhwcmVzc2lvbiA9IGAke2V4cHJlc3Npb259ID0gcmlnaHRTaWRlT2ZFeHByZXNzaW9uKCRldmVudCwgJHtleHByZXNzaW9ufSlgO1xuICBsZXQgZXZhbHVhdGVBc3NpZ25tZW50ID0gZXZhbHVhdGVMYXRlcihlbCwgYXNzaWdubWVudEV4cHJlc3Npb24pO1xuICB2YXIgZXZlbnQgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic2VsZWN0XCIgfHwgW1wiY2hlY2tib3hcIiwgXCJyYWRpb1wiXS5pbmNsdWRlcyhlbC50eXBlKSB8fCBtb2RpZmllcnMuaW5jbHVkZXMoXCJsYXp5XCIpID8gXCJjaGFuZ2VcIiA6IFwiaW5wdXRcIjtcbiAgbGV0IGFzc2lnbWVudEZ1bmN0aW9uID0gZ2VuZXJhdGVBc3NpZ25tZW50RnVuY3Rpb24oZWwsIG1vZGlmaWVycywgZXhwcmVzc2lvbik7XG4gIGxldCByZW1vdmVMaXN0ZW5lciA9IG9uKGVsLCBldmVudCwgbW9kaWZpZXJzLCAoZSkgPT4ge1xuICAgIGV2YWx1YXRlQXNzaWdubWVudCgoKSA9PiB7XG4gICAgfSwge3Njb3BlOiB7XG4gICAgICAkZXZlbnQ6IGUsXG4gICAgICByaWdodFNpZGVPZkV4cHJlc3Npb246IGFzc2lnbWVudEZ1bmN0aW9uXG4gICAgfX0pO1xuICB9KTtcbiAgY2xlYW51cCgoKSA9PiByZW1vdmVMaXN0ZW5lcigpKTtcbiAgbGV0IGV2YWx1YXRlU2V0TW9kZWwgPSBldmFsdWF0ZUxhdGVyKGVsLCBgJHtleHByZXNzaW9ufSA9IF9fcGxhY2Vob2xkZXJgKTtcbiAgZWwuX3hfbW9kZWwgPSB7XG4gICAgZ2V0KCkge1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIGV2YWx1YXRlMigodmFsdWUpID0+IHJlc3VsdCA9IHZhbHVlKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGV2YWx1YXRlU2V0TW9kZWwoKCkgPT4ge1xuICAgICAgfSwge3Njb3BlOiB7X19wbGFjZWhvbGRlcjogdmFsdWV9fSk7XG4gICAgfVxuICB9O1xuICBlbC5feF9mb3JjZU1vZGVsVXBkYXRlID0gKCkgPT4ge1xuICAgIGV2YWx1YXRlMigodmFsdWUpID0+IHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwICYmIGV4cHJlc3Npb24ubWF0Y2goL1xcLi8pKVxuICAgICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICB3aW5kb3cuZnJvbU1vZGVsID0gdHJ1ZTtcbiAgICAgIG11dGF0ZURvbSgoKSA9PiBiaW5kKGVsLCBcInZhbHVlXCIsIHZhbHVlKSk7XG4gICAgICBkZWxldGUgd2luZG93LmZyb21Nb2RlbDtcbiAgICB9KTtcbiAgfTtcbiAgZWZmZWN0MygoKSA9PiB7XG4gICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInVuaW50cnVzaXZlXCIpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuaXNTYW1lTm9kZShlbCkpXG4gICAgICByZXR1cm47XG4gICAgZWwuX3hfZm9yY2VNb2RlbFVwZGF0ZSgpO1xuICB9KTtcbn0pO1xuZnVuY3Rpb24gZ2VuZXJhdGVBc3NpZ25tZW50RnVuY3Rpb24oZWwsIG1vZGlmaWVycywgZXhwcmVzc2lvbikge1xuICBpZiAoZWwudHlwZSA9PT0gXCJyYWRpb1wiKSB7XG4gICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgIGlmICghZWwuaGFzQXR0cmlidXRlKFwibmFtZVwiKSlcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBleHByZXNzaW9uKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gKGV2ZW50LCBjdXJyZW50VmFsdWUpID0+IHtcbiAgICByZXR1cm4gbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEN1c3RvbUV2ZW50ICYmIGV2ZW50LmRldGFpbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBldmVudC5kZXRhaWwgfHwgZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChlbC50eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFZhbHVlKSkge1xuICAgICAgICAgIGxldCBuZXdWYWx1ZSA9IG1vZGlmaWVycy5pbmNsdWRlcyhcIm51bWJlclwiKSA/IHNhZmVQYXJzZU51bWJlcihldmVudC50YXJnZXQudmFsdWUpIDogZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgIHJldHVybiBldmVudC50YXJnZXQuY2hlY2tlZCA/IGN1cnJlbnRWYWx1ZS5jb25jYXQoW25ld1ZhbHVlXSkgOiBjdXJyZW50VmFsdWUuZmlsdGVyKChlbDIpID0+ICFjaGVja2VkQXR0ckxvb3NlQ29tcGFyZTIoZWwyLCBuZXdWYWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBldmVudC50YXJnZXQuY2hlY2tlZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic2VsZWN0XCIgJiYgZWwubXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVycy5pbmNsdWRlcyhcIm51bWJlclwiKSA/IEFycmF5LmZyb20oZXZlbnQudGFyZ2V0LnNlbGVjdGVkT3B0aW9ucykubWFwKChvcHRpb24pID0+IHtcbiAgICAgICAgICBsZXQgcmF3VmFsdWUgPSBvcHRpb24udmFsdWUgfHwgb3B0aW9uLnRleHQ7XG4gICAgICAgICAgcmV0dXJuIHNhZmVQYXJzZU51bWJlcihyYXdWYWx1ZSk7XG4gICAgICAgIH0pIDogQXJyYXkuZnJvbShldmVudC50YXJnZXQuc2VsZWN0ZWRPcHRpb25zKS5tYXAoKG9wdGlvbikgPT4ge1xuICAgICAgICAgIHJldHVybiBvcHRpb24udmFsdWUgfHwgb3B0aW9uLnRleHQ7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHJhd1ZhbHVlID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgICByZXR1cm4gbW9kaWZpZXJzLmluY2x1ZGVzKFwibnVtYmVyXCIpID8gc2FmZVBhcnNlTnVtYmVyKHJhd1ZhbHVlKSA6IG1vZGlmaWVycy5pbmNsdWRlcyhcInRyaW1cIikgPyByYXdWYWx1ZS50cmltKCkgOiByYXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNhZmVQYXJzZU51bWJlcihyYXdWYWx1ZSkge1xuICBsZXQgbnVtYmVyID0gcmF3VmFsdWUgPyBwYXJzZUZsb2F0KHJhd1ZhbHVlKSA6IG51bGw7XG4gIHJldHVybiBpc051bWVyaWMyKG51bWJlcikgPyBudW1iZXIgOiByYXdWYWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrZWRBdHRyTG9vc2VDb21wYXJlMih2YWx1ZUEsIHZhbHVlQikge1xuICByZXR1cm4gdmFsdWVBID09IHZhbHVlQjtcbn1cbmZ1bmN0aW9uIGlzTnVtZXJpYzIoc3ViamVjdCkge1xuICByZXR1cm4gIUFycmF5LmlzQXJyYXkoc3ViamVjdCkgJiYgIWlzTmFOKHN1YmplY3QpO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWNsb2FrLmpzXG5kaXJlY3RpdmUoXCJjbG9ha1wiLCAoZWwpID0+IHF1ZXVlTWljcm90YXNrKCgpID0+IG11dGF0ZURvbSgoKSA9PiBlbC5yZW1vdmVBdHRyaWJ1dGUocHJlZml4KFwiY2xvYWtcIikpKSkpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWluaXQuanNcbmFkZEluaXRTZWxlY3RvcigoKSA9PiBgWyR7cHJlZml4KFwiaW5pdFwiKX1dYCk7XG5kaXJlY3RpdmUoXCJpbml0XCIsIHNraXBEdXJpbmdDbG9uZSgoZWwsIHtleHByZXNzaW9ufSkgPT4ge1xuICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gISFleHByZXNzaW9uLnRyaW0oKSAmJiBldmFsdWF0ZShlbCwgZXhwcmVzc2lvbiwge30sIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gZXZhbHVhdGUoZWwsIGV4cHJlc3Npb24sIHt9LCBmYWxzZSk7XG59KSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtdGV4dC5qc1xuZGlyZWN0aXZlKFwidGV4dFwiLCAoZWwsIHtleHByZXNzaW9ufSwge2VmZmVjdDogZWZmZWN0MywgZXZhbHVhdGVMYXRlcjogZXZhbHVhdGVMYXRlcjJ9KSA9PiB7XG4gIGxldCBldmFsdWF0ZTIgPSBldmFsdWF0ZUxhdGVyMihleHByZXNzaW9uKTtcbiAgZWZmZWN0MygoKSA9PiB7XG4gICAgZXZhbHVhdGUyKCh2YWx1ZSkgPT4ge1xuICAgICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWh0bWwuanNcbmRpcmVjdGl2ZShcImh0bWxcIiwgKGVsLCB7ZXhwcmVzc2lvbn0sIHtlZmZlY3Q6IGVmZmVjdDMsIGV2YWx1YXRlTGF0ZXI6IGV2YWx1YXRlTGF0ZXIyfSkgPT4ge1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcjIoZXhwcmVzc2lvbik7XG4gIGVmZmVjdDMoKCkgPT4ge1xuICAgIGV2YWx1YXRlMigodmFsdWUpID0+IHtcbiAgICAgIGVsLmlubmVySFRNTCA9IHZhbHVlO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWJpbmQuanNcbm1hcEF0dHJpYnV0ZXMoc3RhcnRpbmdXaXRoKFwiOlwiLCBpbnRvKHByZWZpeChcImJpbmQ6XCIpKSkpO1xuZGlyZWN0aXZlKFwiYmluZFwiLCAoZWwsIHt2YWx1ZSwgbW9kaWZpZXJzLCBleHByZXNzaW9uLCBvcmlnaW5hbH0sIHtlZmZlY3Q6IGVmZmVjdDN9KSA9PiB7XG4gIGlmICghdmFsdWUpXG4gICAgcmV0dXJuIGFwcGx5QmluZGluZ3NPYmplY3QoZWwsIGV4cHJlc3Npb24sIG9yaWdpbmFsLCBlZmZlY3QzKTtcbiAgaWYgKHZhbHVlID09PSBcImtleVwiKVxuICAgIHJldHVybiBzdG9yZUtleUZvclhGb3IoZWwsIGV4cHJlc3Npb24pO1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbik7XG4gIGVmZmVjdDMoKCkgPT4gZXZhbHVhdGUyKChyZXN1bHQpID0+IHtcbiAgICBpZiAocmVzdWx0ID09PSB2b2lkIDAgJiYgZXhwcmVzc2lvbi5tYXRjaCgvXFwuLykpXG4gICAgICByZXN1bHQgPSBcIlwiO1xuICAgIG11dGF0ZURvbSgoKSA9PiBiaW5kKGVsLCB2YWx1ZSwgcmVzdWx0LCBtb2RpZmllcnMpKTtcbiAgfSkpO1xufSk7XG5mdW5jdGlvbiBhcHBseUJpbmRpbmdzT2JqZWN0KGVsLCBleHByZXNzaW9uLCBvcmlnaW5hbCwgZWZmZWN0Mykge1xuICBsZXQgZ2V0QmluZGluZ3MgPSBldmFsdWF0ZUxhdGVyKGVsLCBleHByZXNzaW9uKTtcbiAgbGV0IGNsZWFudXBSdW5uZXJzID0gW107XG4gIGVmZmVjdDMoKCkgPT4ge1xuICAgIHdoaWxlIChjbGVhbnVwUnVubmVycy5sZW5ndGgpXG4gICAgICBjbGVhbnVwUnVubmVycy5wb3AoKSgpO1xuICAgIGdldEJpbmRpbmdzKChiaW5kaW5ncykgPT4ge1xuICAgICAgbGV0IGF0dHJpYnV0ZXMgPSBPYmplY3QuZW50cmllcyhiaW5kaW5ncykubWFwKChbbmFtZSwgdmFsdWVdKSA9PiAoe25hbWUsIHZhbHVlfSkpO1xuICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuZmlsdGVyKChhdHRyKSA9PiB7XG4gICAgICAgIHJldHVybiAhKHR5cGVvZiBhdHRyLnZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGF0dHIudmFsdWUpICYmIGF0dHIudmFsdWUgIT09IG51bGwpO1xuICAgICAgfSk7XG4gICAgICBsZXQgc3RhdGljQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXNPbmx5KGF0dHJpYnV0ZXMpO1xuICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMubWFwKChhdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgaWYgKHN0YXRpY0F0dHJpYnV0ZXMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSBhdHRyaWJ1dGUubmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogYHgtYmluZDoke2F0dHJpYnV0ZS5uYW1lfWAsXG4gICAgICAgICAgICB2YWx1ZTogYFwiJHthdHRyaWJ1dGUudmFsdWV9XCJgXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0cmlidXRlO1xuICAgICAgfSk7XG4gICAgICBkaXJlY3RpdmVzKGVsLCBhdHRyaWJ1dGVzLCBvcmlnaW5hbCkubWFwKChoYW5kbGUpID0+IHtcbiAgICAgICAgY2xlYW51cFJ1bm5lcnMucHVzaChoYW5kbGUucnVuQ2xlYW51cHMpO1xuICAgICAgICBoYW5kbGUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHN0b3JlS2V5Rm9yWEZvcihlbCwgZXhwcmVzc2lvbikge1xuICBlbC5feF9rZXlFeHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1kYXRhLmpzXG5hZGRSb290U2VsZWN0b3IoKCkgPT4gYFske3ByZWZpeChcImRhdGFcIil9XWApO1xuZGlyZWN0aXZlKFwiZGF0YVwiLCBza2lwRHVyaW5nQ2xvbmUoKGVsLCB7ZXhwcmVzc2lvbn0sIHtjbGVhbnVwfSkgPT4ge1xuICBleHByZXNzaW9uID0gZXhwcmVzc2lvbiA9PT0gXCJcIiA/IFwie31cIiA6IGV4cHJlc3Npb247XG4gIGxldCBtYWdpY0NvbnRleHQgPSB7fTtcbiAgaW5qZWN0TWFnaWNzKG1hZ2ljQ29udGV4dCwgZWwpO1xuICBsZXQgZGF0YVByb3ZpZGVyQ29udGV4dCA9IHt9O1xuICBpbmplY3REYXRhUHJvdmlkZXJzKGRhdGFQcm92aWRlckNvbnRleHQsIG1hZ2ljQ29udGV4dCk7XG4gIGxldCBkYXRhMiA9IGV2YWx1YXRlKGVsLCBleHByZXNzaW9uLCB7c2NvcGU6IGRhdGFQcm92aWRlckNvbnRleHR9KTtcbiAgaWYgKGRhdGEyID09PSB2b2lkIDApXG4gICAgZGF0YTIgPSB7fTtcbiAgaW5qZWN0TWFnaWNzKGRhdGEyLCBlbCk7XG4gIGxldCByZWFjdGl2ZURhdGEgPSByZWFjdGl2ZShkYXRhMik7XG4gIGluaXRJbnRlcmNlcHRvcnMocmVhY3RpdmVEYXRhKTtcbiAgbGV0IHVuZG8gPSBhZGRTY29wZVRvTm9kZShlbCwgcmVhY3RpdmVEYXRhKTtcbiAgcmVhY3RpdmVEYXRhW1wiaW5pdFwiXSAmJiBldmFsdWF0ZShlbCwgcmVhY3RpdmVEYXRhW1wiaW5pdFwiXSk7XG4gIGNsZWFudXAoKCkgPT4ge1xuICAgIHVuZG8oKTtcbiAgICByZWFjdGl2ZURhdGFbXCJkZXN0cm95XCJdICYmIGV2YWx1YXRlKGVsLCByZWFjdGl2ZURhdGFbXCJkZXN0cm95XCJdKTtcbiAgfSk7XG59KSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtc2hvdy5qc1xuZGlyZWN0aXZlKFwic2hvd1wiLCAoZWwsIHttb2RpZmllcnMsIGV4cHJlc3Npb259LCB7ZWZmZWN0OiBlZmZlY3QzfSkgPT4ge1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbik7XG4gIGxldCBoaWRlID0gKCkgPT4gbXV0YXRlRG9tKCgpID0+IHtcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgZWwuX3hfaXNTaG93biA9IGZhbHNlO1xuICB9KTtcbiAgbGV0IHNob3cgPSAoKSA9PiBtdXRhdGVEb20oKCkgPT4ge1xuICAgIGlmIChlbC5zdHlsZS5sZW5ndGggPT09IDEgJiYgZWwuc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImRpc3BsYXlcIik7XG4gICAgfVxuICAgIGVsLl94X2lzU2hvd24gPSB0cnVlO1xuICB9KTtcbiAgbGV0IGNsaWNrQXdheUNvbXBhdGlibGVTaG93ID0gKCkgPT4gc2V0VGltZW91dChzaG93KTtcbiAgbGV0IHRvZ2dsZSA9IG9uY2UoKHZhbHVlKSA9PiB2YWx1ZSA/IHNob3coKSA6IGhpZGUoKSwgKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBlbC5feF90b2dnbGVBbmRDYXNjYWRlV2l0aFRyYW5zaXRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGVsLl94X3RvZ2dsZUFuZENhc2NhZGVXaXRoVHJhbnNpdGlvbnMoZWwsIHZhbHVlLCBzaG93LCBoaWRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPyBjbGlja0F3YXlDb21wYXRpYmxlU2hvdygpIDogaGlkZSgpO1xuICAgIH1cbiAgfSk7XG4gIGxldCBvbGRWYWx1ZTtcbiAgbGV0IGZpcnN0VGltZSA9IHRydWU7XG4gIGVmZmVjdDMoKCkgPT4gZXZhbHVhdGUyKCh2YWx1ZSkgPT4ge1xuICAgIGlmICghZmlyc3RUaW1lICYmIHZhbHVlID09PSBvbGRWYWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiaW1tZWRpYXRlXCIpKVxuICAgICAgdmFsdWUgPyBjbGlja0F3YXlDb21wYXRpYmxlU2hvdygpIDogaGlkZSgpO1xuICAgIHRvZ2dsZSh2YWx1ZSk7XG4gICAgb2xkVmFsdWUgPSB2YWx1ZTtcbiAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgfSkpO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtZm9yLmpzXG5kaXJlY3RpdmUoXCJmb3JcIiwgKGVsLCB7ZXhwcmVzc2lvbn0sIHtlZmZlY3Q6IGVmZmVjdDMsIGNsZWFudXB9KSA9PiB7XG4gIGxldCBpdGVyYXRvck5hbWVzID0gcGFyc2VGb3JFeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICBsZXQgZXZhbHVhdGVJdGVtcyA9IGV2YWx1YXRlTGF0ZXIoZWwsIGl0ZXJhdG9yTmFtZXMuaXRlbXMpO1xuICBsZXQgZXZhbHVhdGVLZXkgPSBldmFsdWF0ZUxhdGVyKGVsLCBlbC5feF9rZXlFeHByZXNzaW9uIHx8IFwiaW5kZXhcIik7XG4gIGVsLl94X3ByZXZLZXlzID0gW107XG4gIGVsLl94X2xvb2t1cCA9IHt9O1xuICBlZmZlY3QzKCgpID0+IGxvb3AoZWwsIGl0ZXJhdG9yTmFtZXMsIGV2YWx1YXRlSXRlbXMsIGV2YWx1YXRlS2V5KSk7XG4gIGNsZWFudXAoKCkgPT4ge1xuICAgIE9iamVjdC52YWx1ZXMoZWwuX3hfbG9va3VwKS5mb3JFYWNoKChlbDIpID0+IGVsMi5yZW1vdmUoKSk7XG4gICAgZGVsZXRlIGVsLl94X3ByZXZLZXlzO1xuICAgIGRlbGV0ZSBlbC5feF9sb29rdXA7XG4gIH0pO1xufSk7XG5mdW5jdGlvbiBsb29wKGVsLCBpdGVyYXRvck5hbWVzLCBldmFsdWF0ZUl0ZW1zLCBldmFsdWF0ZUtleSkge1xuICBsZXQgaXNPYmplY3QgPSAoaSkgPT4gdHlwZW9mIGkgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoaSk7XG4gIGxldCB0ZW1wbGF0ZUVsID0gZWw7XG4gIGV2YWx1YXRlSXRlbXMoKGl0ZW1zKSA9PiB7XG4gICAgaWYgKGlzTnVtZXJpYzMoaXRlbXMpICYmIGl0ZW1zID49IDApIHtcbiAgICAgIGl0ZW1zID0gQXJyYXkuZnJvbShBcnJheShpdGVtcykua2V5cygpLCAoaSkgPT4gaSArIDEpO1xuICAgIH1cbiAgICBpZiAoaXRlbXMgPT09IHZvaWQgMClcbiAgICAgIGl0ZW1zID0gW107XG4gICAgbGV0IGxvb2t1cCA9IGVsLl94X2xvb2t1cDtcbiAgICBsZXQgcHJldktleXMgPSBlbC5feF9wcmV2S2V5cztcbiAgICBsZXQgc2NvcGVzID0gW107XG4gICAgbGV0IGtleXMgPSBbXTtcbiAgICBpZiAoaXNPYmplY3QoaXRlbXMpKSB7XG4gICAgICBpdGVtcyA9IE9iamVjdC5lbnRyaWVzKGl0ZW1zKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBsZXQgc2NvcGUgPSBnZXRJdGVyYXRpb25TY29wZVZhcmlhYmxlcyhpdGVyYXRvck5hbWVzLCB2YWx1ZSwga2V5LCBpdGVtcyk7XG4gICAgICAgIGV2YWx1YXRlS2V5KCh2YWx1ZTIpID0+IGtleXMucHVzaCh2YWx1ZTIpLCB7c2NvcGU6IHtpbmRleDoga2V5LCAuLi5zY29wZX19KTtcbiAgICAgICAgc2NvcGVzLnB1c2goc2NvcGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHNjb3BlID0gZ2V0SXRlcmF0aW9uU2NvcGVWYXJpYWJsZXMoaXRlcmF0b3JOYW1lcywgaXRlbXNbaV0sIGksIGl0ZW1zKTtcbiAgICAgICAgZXZhbHVhdGVLZXkoKHZhbHVlKSA9PiBrZXlzLnB1c2godmFsdWUpLCB7c2NvcGU6IHtpbmRleDogaSwgLi4uc2NvcGV9fSk7XG4gICAgICAgIHNjb3Blcy5wdXNoKHNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGFkZHMgPSBbXTtcbiAgICBsZXQgbW92ZXMgPSBbXTtcbiAgICBsZXQgcmVtb3ZlcyA9IFtdO1xuICAgIGxldCBzYW1lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBrZXkgPSBwcmV2S2V5c1tpXTtcbiAgICAgIGlmIChrZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpXG4gICAgICAgIHJlbW92ZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBwcmV2S2V5cyA9IHByZXZLZXlzLmZpbHRlcigoa2V5KSA9PiAhcmVtb3Zlcy5pbmNsdWRlcyhrZXkpKTtcbiAgICBsZXQgbGFzdEtleSA9IFwidGVtcGxhdGVcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBrZXkgPSBrZXlzW2ldO1xuICAgICAgbGV0IHByZXZJbmRleCA9IHByZXZLZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgIGlmIChwcmV2SW5kZXggPT09IC0xKSB7XG4gICAgICAgIHByZXZLZXlzLnNwbGljZShpLCAwLCBrZXkpO1xuICAgICAgICBhZGRzLnB1c2goW2xhc3RLZXksIGldKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldkluZGV4ICE9PSBpKSB7XG4gICAgICAgIGxldCBrZXlJblNwb3QgPSBwcmV2S2V5cy5zcGxpY2UoaSwgMSlbMF07XG4gICAgICAgIGxldCBrZXlGb3JTcG90ID0gcHJldktleXMuc3BsaWNlKHByZXZJbmRleCAtIDEsIDEpWzBdO1xuICAgICAgICBwcmV2S2V5cy5zcGxpY2UoaSwgMCwga2V5Rm9yU3BvdCk7XG4gICAgICAgIHByZXZLZXlzLnNwbGljZShwcmV2SW5kZXgsIDAsIGtleUluU3BvdCk7XG4gICAgICAgIG1vdmVzLnB1c2goW2tleUluU3BvdCwga2V5Rm9yU3BvdF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2FtZXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgICAgbGFzdEtleSA9IGtleTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQga2V5ID0gcmVtb3Zlc1tpXTtcbiAgICAgIGxvb2t1cFtrZXldLnJlbW92ZSgpO1xuICAgICAgbG9va3VwW2tleV0gPSBudWxsO1xuICAgICAgZGVsZXRlIGxvb2t1cFtrZXldO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgW2tleUluU3BvdCwga2V5Rm9yU3BvdF0gPSBtb3Zlc1tpXTtcbiAgICAgIGxldCBlbEluU3BvdCA9IGxvb2t1cFtrZXlJblNwb3RdO1xuICAgICAgbGV0IGVsRm9yU3BvdCA9IGxvb2t1cFtrZXlGb3JTcG90XTtcbiAgICAgIGxldCBtYXJrZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgICAgZWxGb3JTcG90LmFmdGVyKG1hcmtlcik7XG4gICAgICAgIGVsSW5TcG90LmFmdGVyKGVsRm9yU3BvdCk7XG4gICAgICAgIG1hcmtlci5iZWZvcmUoZWxJblNwb3QpO1xuICAgICAgICBtYXJrZXIucmVtb3ZlKCk7XG4gICAgICB9KTtcbiAgICAgIHJlZnJlc2hTY29wZShlbEZvclNwb3QsIHNjb3Blc1trZXlzLmluZGV4T2Yoa2V5Rm9yU3BvdCldKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgW2xhc3RLZXkyLCBpbmRleF0gPSBhZGRzW2ldO1xuICAgICAgbGV0IGxhc3RFbCA9IGxhc3RLZXkyID09PSBcInRlbXBsYXRlXCIgPyB0ZW1wbGF0ZUVsIDogbG9va3VwW2xhc3RLZXkyXTtcbiAgICAgIGxldCBzY29wZSA9IHNjb3Blc1tpbmRleF07XG4gICAgICBsZXQga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICBsZXQgY2xvbmUyID0gZG9jdW1lbnQuaW1wb3J0Tm9kZSh0ZW1wbGF0ZUVsLmNvbnRlbnQsIHRydWUpLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgYWRkU2NvcGVUb05vZGUoY2xvbmUyLCByZWFjdGl2ZShzY29wZSksIHRlbXBsYXRlRWwpO1xuICAgICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgICAgbGFzdEVsLmFmdGVyKGNsb25lMik7XG4gICAgICAgIGluaXRUcmVlKGNsb25lMik7XG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHdhcm4oXCJ4LWZvciBrZXkgY2Fubm90IGJlIGFuIG9iamVjdCwgaXQgbXVzdCBiZSBhIHN0cmluZyBvciBhbiBpbnRlZ2VyXCIsIHRlbXBsYXRlRWwpO1xuICAgICAgfVxuICAgICAgbG9va3VwW2tleV0gPSBjbG9uZTI7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlZnJlc2hTY29wZShsb29rdXBbc2FtZXNbaV1dLCBzY29wZXNba2V5cy5pbmRleE9mKHNhbWVzW2ldKV0pO1xuICAgIH1cbiAgICB0ZW1wbGF0ZUVsLl94X3ByZXZLZXlzID0ga2V5cztcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZUZvckV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICBsZXQgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcbiAgbGV0IHN0cmlwUGFyZW5zUkUgPSAvXlxccypcXCh8XFwpXFxzKiQvZztcbiAgbGV0IGZvckFsaWFzUkUgPSAvKFtcXHNcXFNdKj8pXFxzKyg/OmlufG9mKVxccysoW1xcc1xcU10qKS87XG4gIGxldCBpbk1hdGNoID0gZXhwcmVzc2lvbi5tYXRjaChmb3JBbGlhc1JFKTtcbiAgaWYgKCFpbk1hdGNoKVxuICAgIHJldHVybjtcbiAgbGV0IHJlcyA9IHt9O1xuICByZXMuaXRlbXMgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgbGV0IGl0ZW0gPSBpbk1hdGNoWzFdLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgXCJcIikudHJpbSgpO1xuICBsZXQgaXRlcmF0b3JNYXRjaCA9IGl0ZW0ubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgcmVzLml0ZW0gPSBpdGVtLnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgXCJcIikudHJpbSgpO1xuICAgIHJlcy5pbmRleCA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XG4gICAgICByZXMuY29sbGVjdGlvbiA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXMuaXRlbSA9IGl0ZW07XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdldEl0ZXJhdGlvblNjb3BlVmFyaWFibGVzKGl0ZXJhdG9yTmFtZXMsIGl0ZW0sIGluZGV4LCBpdGVtcykge1xuICBsZXQgc2NvcGVWYXJpYWJsZXMgPSB7fTtcbiAgaWYgKC9eXFxbLipcXF0kLy50ZXN0KGl0ZXJhdG9yTmFtZXMuaXRlbSkgJiYgQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgIGxldCBuYW1lcyA9IGl0ZXJhdG9yTmFtZXMuaXRlbS5yZXBsYWNlKFwiW1wiLCBcIlwiKS5yZXBsYWNlKFwiXVwiLCBcIlwiKS5zcGxpdChcIixcIikubWFwKChpKSA9PiBpLnRyaW0oKSk7XG4gICAgbmFtZXMuZm9yRWFjaCgobmFtZSwgaSkgPT4ge1xuICAgICAgc2NvcGVWYXJpYWJsZXNbbmFtZV0gPSBpdGVtW2ldO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKC9eXFx7LipcXH0kLy50ZXN0KGl0ZXJhdG9yTmFtZXMuaXRlbSkgJiYgIUFycmF5LmlzQXJyYXkoaXRlbSkgJiYgdHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIpIHtcbiAgICBsZXQgbmFtZXMgPSBpdGVyYXRvck5hbWVzLml0ZW0ucmVwbGFjZShcIntcIiwgXCJcIikucmVwbGFjZShcIn1cIiwgXCJcIikuc3BsaXQoXCIsXCIpLm1hcCgoaSkgPT4gaS50cmltKCkpO1xuICAgIG5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIHNjb3BlVmFyaWFibGVzW25hbWVdID0gaXRlbVtuYW1lXTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzY29wZVZhcmlhYmxlc1tpdGVyYXRvck5hbWVzLml0ZW1dID0gaXRlbTtcbiAgfVxuICBpZiAoaXRlcmF0b3JOYW1lcy5pbmRleClcbiAgICBzY29wZVZhcmlhYmxlc1tpdGVyYXRvck5hbWVzLmluZGV4XSA9IGluZGV4O1xuICBpZiAoaXRlcmF0b3JOYW1lcy5jb2xsZWN0aW9uKVxuICAgIHNjb3BlVmFyaWFibGVzW2l0ZXJhdG9yTmFtZXMuY29sbGVjdGlvbl0gPSBpdGVtcztcbiAgcmV0dXJuIHNjb3BlVmFyaWFibGVzO1xufVxuZnVuY3Rpb24gaXNOdW1lcmljMyhzdWJqZWN0KSB7XG4gIHJldHVybiAhQXJyYXkuaXNBcnJheShzdWJqZWN0KSAmJiAhaXNOYU4oc3ViamVjdCk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtcmVmLmpzXG5mdW5jdGlvbiBoYW5kbGVyMigpIHtcbn1cbmhhbmRsZXIyLmlubGluZSA9IChlbCwge2V4cHJlc3Npb259LCB7Y2xlYW51cH0pID0+IHtcbiAgbGV0IHJvb3QgPSBjbG9zZXN0Um9vdChlbCk7XG4gIGlmICghcm9vdC5feF9yZWZzKVxuICAgIHJvb3QuX3hfcmVmcyA9IHt9O1xuICByb290Ll94X3JlZnNbZXhwcmVzc2lvbl0gPSBlbDtcbiAgY2xlYW51cCgoKSA9PiBkZWxldGUgcm9vdC5feF9yZWZzW2V4cHJlc3Npb25dKTtcbn07XG5kaXJlY3RpdmUoXCJyZWZcIiwgaGFuZGxlcjIpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWlmLmpzXG5kaXJlY3RpdmUoXCJpZlwiLCAoZWwsIHtleHByZXNzaW9ufSwge2VmZmVjdDogZWZmZWN0MywgY2xlYW51cH0pID0+IHtcbiAgbGV0IGV2YWx1YXRlMiA9IGV2YWx1YXRlTGF0ZXIoZWwsIGV4cHJlc3Npb24pO1xuICBsZXQgc2hvdyA9ICgpID0+IHtcbiAgICBpZiAoZWwuX3hfY3VycmVudElmRWwpXG4gICAgICByZXR1cm4gZWwuX3hfY3VycmVudElmRWw7XG4gICAgbGV0IGNsb25lMiA9IGVsLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpLmZpcnN0RWxlbWVudENoaWxkO1xuICAgIGFkZFNjb3BlVG9Ob2RlKGNsb25lMiwge30sIGVsKTtcbiAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgZWwuYWZ0ZXIoY2xvbmUyKTtcbiAgICAgIGluaXRUcmVlKGNsb25lMik7XG4gICAgfSk7XG4gICAgZWwuX3hfY3VycmVudElmRWwgPSBjbG9uZTI7XG4gICAgZWwuX3hfdW5kb0lmID0gKCkgPT4ge1xuICAgICAgY2xvbmUyLnJlbW92ZSgpO1xuICAgICAgZGVsZXRlIGVsLl94X2N1cnJlbnRJZkVsO1xuICAgIH07XG4gICAgcmV0dXJuIGNsb25lMjtcbiAgfTtcbiAgbGV0IGhpZGUgPSAoKSA9PiB7XG4gICAgaWYgKCFlbC5feF91bmRvSWYpXG4gICAgICByZXR1cm47XG4gICAgZWwuX3hfdW5kb0lmKCk7XG4gICAgZGVsZXRlIGVsLl94X3VuZG9JZjtcbiAgfTtcbiAgZWZmZWN0MygoKSA9PiBldmFsdWF0ZTIoKHZhbHVlKSA9PiB7XG4gICAgdmFsdWUgPyBzaG93KCkgOiBoaWRlKCk7XG4gIH0pKTtcbiAgY2xlYW51cCgoKSA9PiBlbC5feF91bmRvSWYgJiYgZWwuX3hfdW5kb0lmKCkpO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtb24uanNcbm1hcEF0dHJpYnV0ZXMoc3RhcnRpbmdXaXRoKFwiQFwiLCBpbnRvKHByZWZpeChcIm9uOlwiKSkpKTtcbmRpcmVjdGl2ZShcIm9uXCIsIHNraXBEdXJpbmdDbG9uZSgoZWwsIHt2YWx1ZSwgbW9kaWZpZXJzLCBleHByZXNzaW9ufSwge2NsZWFudXB9KSA9PiB7XG4gIGxldCBldmFsdWF0ZTIgPSBleHByZXNzaW9uID8gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbikgOiAoKSA9PiB7XG4gIH07XG4gIGxldCByZW1vdmVMaXN0ZW5lciA9IG9uKGVsLCB2YWx1ZSwgbW9kaWZpZXJzLCAoZSkgPT4ge1xuICAgIGV2YWx1YXRlMigoKSA9PiB7XG4gICAgfSwge3Njb3BlOiB7JGV2ZW50OiBlfSwgcGFyYW1zOiBbZV19KTtcbiAgfSk7XG4gIGNsZWFudXAoKCkgPT4gcmVtb3ZlTGlzdGVuZXIoKSk7XG59KSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9pbmRleC5qc1xuYWxwaW5lX2RlZmF1bHQuc2V0RXZhbHVhdG9yKG5vcm1hbEV2YWx1YXRvcik7XG5hbHBpbmVfZGVmYXVsdC5zZXRSZWFjdGl2aXR5RW5naW5lKHtyZWFjdGl2ZTogaW1wb3J0X3JlYWN0aXZpdHk5LnJlYWN0aXZlLCBlZmZlY3Q6IGltcG9ydF9yZWFjdGl2aXR5OS5lZmZlY3QsIHJlbGVhc2U6IGltcG9ydF9yZWFjdGl2aXR5OS5zdG9wLCByYXc6IGltcG9ydF9yZWFjdGl2aXR5OS50b1Jhd30pO1xudmFyIHNyY19kZWZhdWx0ID0gYWxwaW5lX2RlZmF1bHQ7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL2J1aWxkcy9tb2R1bGUuanNcbnZhciBtb2R1bGVfZGVmYXVsdCA9IHNyY19kZWZhdWx0O1xuZXhwb3J0IHtcbiAgbW9kdWxlX2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/alpinejs/dist/module.esm.js\n");

/***/ }),

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var flowbite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! flowbite */ \"./node_modules/flowbite/dist/flowbite.js\");\n/* harmony import */ var flowbite__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(flowbite__WEBPACK_IMPORTED_MODULE_0__);\n__webpack_require__(/*! ./datepicker */ \"./resources/js/datepicker.js\");\n\n__webpack_require__(/*! ./components */ \"./resources/js/components.js\");\n\n__webpack_require__(/*! ./bootstrap */ \"./resources/js/bootstrap.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvYXBwLmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBQSxtQkFBTyxDQUFDLGtEQUFELENBQVA7O0FBQ0FBLG1CQUFPLENBQUMsa0RBQUQsQ0FBUDs7QUFDQUEsbUJBQU8sQ0FBQyxnREFBRCxDQUFQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2FwcC5qcz9jZWQ2Il0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4vZGF0ZXBpY2tlcicpO1xyXG5yZXF1aXJlKCcuL2NvbXBvbmVudHMnKTtcclxucmVxdWlyZSgnLi9ib290c3RyYXAnKTtcclxuaW1wb3J0ICdmbG93Yml0ZSc7Il0sIm5hbWVzIjpbInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/app.js\n");

/***/ }),

/***/ "./resources/js/bootstrap.js":
/*!***********************************!*\
  !*** ./resources/js/bootstrap.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var alpinejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alpinejs */ \"./node_modules/alpinejs/dist/module.esm.js\");\n/* harmony import */ var _alpinejs_focus__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @alpinejs/focus */ \"./node_modules/@alpinejs/focus/dist/module.esm.js\");\n/**\r\n * Echo exposes an expressive API for subscribing to channels and listening\r\n * for events that are broadcast by Laravel. Echo and event broadcasting\r\n * allows your team to easily build robust real-time web applications.\r\n */\n// import Echo from 'laravel-echo'\n// window.Pusher = require('pusher-js');\n// window.Echo = new Echo({\n//     broadcaster: 'pusher',\n//     key: process.env.MIX_PUSHER_APP_KEY,\n//     cluster: process.env.MIX_PUSHER_APP_CLUSTER,\n//     forceTLS: true\n// });\n\n\nwindow.Alpine = alpinejs__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\nalpinejs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].plugin(_alpinejs_focus__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\nalpinejs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].start();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvYm9vdHN0cmFwLmpzLmpzIiwibWFwcGluZ3MiOiI7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBRSxNQUFNLENBQUNGLE1BQVAsR0FBZ0JBLGdEQUFoQjtBQUVBQSx1REFBQSxDQUFjQyx1REFBZDtBQUNBRCxzREFBQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9ib290c3RyYXAuanM/NmRlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuLyoqXHJcbiAqIEVjaG8gZXhwb3NlcyBhbiBleHByZXNzaXZlIEFQSSBmb3Igc3Vic2NyaWJpbmcgdG8gY2hhbm5lbHMgYW5kIGxpc3RlbmluZ1xyXG4gKiBmb3IgZXZlbnRzIHRoYXQgYXJlIGJyb2FkY2FzdCBieSBMYXJhdmVsLiBFY2hvIGFuZCBldmVudCBicm9hZGNhc3RpbmdcclxuICogYWxsb3dzIHlvdXIgdGVhbSB0byBlYXNpbHkgYnVpbGQgcm9idXN0IHJlYWwtdGltZSB3ZWIgYXBwbGljYXRpb25zLlxyXG4gKi9cclxuXHJcbi8vIGltcG9ydCBFY2hvIGZyb20gJ2xhcmF2ZWwtZWNobydcclxuXHJcbi8vIHdpbmRvdy5QdXNoZXIgPSByZXF1aXJlKCdwdXNoZXItanMnKTtcclxuXHJcbi8vIHdpbmRvdy5FY2hvID0gbmV3IEVjaG8oe1xyXG4vLyAgICAgYnJvYWRjYXN0ZXI6ICdwdXNoZXInLFxyXG4vLyAgICAga2V5OiBwcm9jZXNzLmVudi5NSVhfUFVTSEVSX0FQUF9LRVksXHJcbi8vICAgICBjbHVzdGVyOiBwcm9jZXNzLmVudi5NSVhfUFVTSEVSX0FQUF9DTFVTVEVSLFxyXG4vLyAgICAgZm9yY2VUTFM6IHRydWVcclxuLy8gfSk7XHJcblxyXG5cclxuaW1wb3J0IEFscGluZSBmcm9tICdhbHBpbmVqcyc7XHJcbmltcG9ydCBmb2N1cyBmcm9tICdAYWxwaW5lanMvZm9jdXMnXHJcblxyXG5cclxud2luZG93LkFscGluZSA9IEFscGluZTtcclxuXHJcbkFscGluZS5wbHVnaW4oZm9jdXMpO1xyXG5BbHBpbmUuc3RhcnQoKTtcclxuXHJcblxyXG5cclxuIl0sIm5hbWVzIjpbIkFscGluZSIsImZvY3VzIiwid2luZG93IiwicGx1Z2luIiwic3RhcnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/bootstrap.js\n");

/***/ }),

/***/ "./resources/js/components.js":
/*!************************************!*\
  !*** ./resources/js/components.js ***!
  \************************************/
/***/ (() => {

eval("function _defineEnumerableProperties(obj, descs) { for (var key in descs) { var desc = descs[key]; desc.configurable = desc.enumerable = true; if (\"value\" in desc) desc.writable = true; Object.defineProperty(obj, key, desc); } if (Object.getOwnPropertySymbols) { var objectSymbols = Object.getOwnPropertySymbols(descs); for (var i = 0; i < objectSymbols.length; i++) { var sym = objectSymbols[i]; var desc = descs[sym]; desc.configurable = desc.enumerable = true; if (\"value\" in desc) desc.writable = true; Object.defineProperty(obj, sym, desc); } } return obj; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// main components\nwindow.Components = {}, window.Components.listbox = function (t) {\n  var _ref, _objectSpread2, _mutatorMap;\n\n  return _objectSpread((_objectSpread2 = {\n    init: function init() {\n      var _this = this;\n\n      this.optionCount = this.$refs.listbox.children.length, this.$watch(\"activeIndex\", function (t) {\n        _this.open && (null !== _this.activeIndex ? _this.activeDescendant = _this.$refs.listbox.children[_this.activeIndex].id : _this.activeDescendant = \"\");\n      });\n    },\n    activeDescendant: null,\n    optionCount: null,\n    open: !1,\n    activeIndex: null,\n    selectedIndex: 0,\n\n    get active() {\n      return this.items[this.activeIndex];\n    }\n\n  }, _ref = t.modelName || \"selected\", _mutatorMap = {}, _mutatorMap[_ref] = _mutatorMap[_ref] || {}, _mutatorMap[_ref].get = function () {\n    return this.items[this.selectedIndex];\n  }, _defineProperty(_objectSpread2, \"choose\", function choose(t) {\n    this.selectedIndex = t, this.open = !1;\n  }), _defineProperty(_objectSpread2, \"onButtonClick\", function onButtonClick() {\n    var _this2 = this;\n\n    this.open || (this.activeIndex = this.selectedIndex, this.open = !0, this.$nextTick(function () {\n      _this2.$refs.listbox.focus(), _this2.$refs.listbox.children[_this2.activeIndex].scrollIntoView({\n        block: \"nearest\"\n      });\n    }));\n  }), _defineProperty(_objectSpread2, \"onOptionSelect\", function onOptionSelect() {\n    null !== this.activeIndex && (this.selectedIndex = this.activeIndex), this.open = !1, this.$refs.button.focus();\n  }), _defineProperty(_objectSpread2, \"onEscape\", function onEscape() {\n    this.open = !1, this.$refs.button.focus();\n  }), _defineProperty(_objectSpread2, \"onArrowUp\", function onArrowUp() {\n    this.activeIndex = this.activeIndex - 1 < 0 ? this.optionCount - 1 : this.activeIndex - 1, this.$refs.listbox.children[this.activeIndex].scrollIntoView({\n      block: \"nearest\"\n    });\n  }), _defineProperty(_objectSpread2, \"onArrowDown\", function onArrowDown() {\n    this.activeIndex = this.activeIndex + 1 > this.optionCount - 1 ? 0 : this.activeIndex + 1, this.$refs.listbox.children[this.activeIndex].scrollIntoView({\n      block: \"nearest\"\n    });\n  }), _defineEnumerableProperties(_objectSpread2, _mutatorMap), _objectSpread2), t);\n}, window.Components.menu = function () {\n  var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    open: !1\n  };\n  return {\n    init: function init() {\n      var _this3 = this;\n\n      this.items = Array.from(this.$el.querySelectorAll('[role=\"menuitem\"]')), this.$watch(\"open\", function () {\n        _this3.open && (_this3.activeIndex = -1);\n      });\n    },\n    activeDescendant: null,\n    activeIndex: null,\n    items: null,\n    open: t.open,\n    focusButton: function focusButton() {\n      this.$refs.button.focus();\n    },\n    onButtonClick: function onButtonClick() {\n      var _this4 = this;\n\n      this.open = !this.open, this.open && this.$nextTick(function () {\n        _this4.$refs[\"menu-items\"].focus();\n      });\n    },\n    onButtonEnter: function onButtonEnter() {\n      var _this5 = this;\n\n      this.open = !this.open, this.open && (this.activeIndex = 0, this.activeDescendant = this.items[this.activeIndex].id, this.$nextTick(function () {\n        _this5.$refs[\"menu-items\"].focus();\n      }));\n    },\n    onArrowUp: function onArrowUp() {\n      if (!this.open) return this.open = !0, this.activeIndex = this.items.length - 1, void (this.activeDescendant = this.items[this.activeIndex].id);\n      0 !== this.activeIndex && (this.activeIndex = -1 === this.activeIndex ? this.items.length - 1 : this.activeIndex - 1, this.activeDescendant = this.items[this.activeIndex].id);\n    },\n    onArrowDown: function onArrowDown() {\n      if (!this.open) return this.open = !0, this.activeIndex = 0, void (this.activeDescendant = this.items[this.activeIndex].id);\n      this.activeIndex !== this.items.length - 1 && (this.activeIndex = this.activeIndex + 1, this.activeDescendant = this.items[this.activeIndex].id);\n    },\n    onClickAway: function onClickAway(t) {\n      if (this.open) {\n        var e = [\"[contentEditable=true]\", \"[tabindex]\", \"a[href]\", \"area[href]\", \"button:not([disabled])\", \"iframe\", \"input:not([disabled])\", \"select:not([disabled])\", \"textarea:not([disabled])\"].map(function (t) {\n          return \"\".concat(t, \":not([tabindex='-1'])\");\n        }).join(\",\");\n        this.open = !1, t.target.closest(e) || this.focusButton();\n      }\n    }\n  };\n}, window.Components.popoverGroup = function () {\n  return {\n    __type: \"popoverGroup\",\n    init: function init() {\n      var _this6 = this;\n\n      var t = function t(e) {\n        document.body.contains(_this6.$el) ? e.target instanceof Element && !_this6.$el.contains(e.target) && window.dispatchEvent(new CustomEvent(\"close-popover-group\", {\n          detail: _this6.$el\n        })) : window.removeEventListener(\"focus\", t, !0);\n      };\n\n      window.addEventListener(\"focus\", t, !0);\n    }\n  };\n}, window.Components.popover = function () {\n  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref2$open = _ref2.open,\n      t = _ref2$open === void 0 ? !1 : _ref2$open,\n      _ref2$focus = _ref2.focus,\n      e = _ref2$focus === void 0 ? !1 : _ref2$focus;\n\n  var i = [\"[contentEditable=true]\", \"[tabindex]\", \"a[href]\", \"area[href]\", \"button:not([disabled])\", \"iframe\", \"input:not([disabled])\", \"select:not([disabled])\", \"textarea:not([disabled])\"].map(function (t) {\n    return \"\".concat(t, \":not([tabindex='-1'])\");\n  }).join(\",\");\n  return {\n    __type: \"popover\",\n    open: t,\n    init: function init() {\n      var _this7 = this;\n\n      e && this.$watch(\"open\", function (t) {\n        t && _this7.$nextTick(function () {\n          !function (t) {\n            var e = Array.from(t.querySelectorAll(i));\n            !function t(i) {\n              void 0 !== i && (i.focus({\n                preventScroll: !0\n              }), document.activeElement !== i && t(e[e.indexOf(i) + 1]));\n            }(e[0]);\n          }(_this7.$refs.panel);\n        });\n      });\n\n      var t = function t(i) {\n        if (!document.body.contains(_this7.$el)) return void window.removeEventListener(\"focus\", t, !0);\n        var n = e ? _this7.$refs.panel : _this7.$el;\n\n        if (_this7.open && i.target instanceof Element && !n.contains(i.target)) {\n          var _t = _this7.$el;\n\n          for (; _t.parentNode;) {\n            if (_t = _t.parentNode, _t.__x instanceof _this7.constructor) {\n              if (\"popoverGroup\" === _t.__x.$data.__type) return;\n              if (\"popover\" === _t.__x.$data.__type) break;\n            }\n          }\n\n          _this7.open = !1;\n        }\n      };\n\n      window.addEventListener(\"focus\", t, !0);\n    },\n    onEscape: function onEscape() {\n      this.open = !1, this.restoreEl && this.restoreEl.focus();\n    },\n    onClosePopoverGroup: function onClosePopoverGroup(t) {\n      t.detail.contains(this.$el) && (this.open = !1);\n    },\n    toggle: function toggle(t) {\n      this.open = !this.open, this.open ? this.restoreEl = t.currentTarget : this.restoreEl && this.restoreEl.focus();\n    }\n  };\n}, window.Components.radioGroup = function () {\n  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref3$initialCheckedI = _ref3.initialCheckedIndex,\n      t = _ref3$initialCheckedI === void 0 ? 0 : _ref3$initialCheckedI;\n\n  return {\n    value: void 0,\n    init: function init() {\n      var _Array$from$t;\n\n      this.value = (_Array$from$t = Array.from(this.$el.querySelectorAll(\"input\"))[t]) === null || _Array$from$t === void 0 ? void 0 : _Array$from$t.value;\n    }\n  };\n}, window.Components.desc = function () {\n  var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref4$open = _ref4.open,\n      t = _ref4$open === void 0 ? 1 : _ref4$open;\n\n  return {\n    __type: \"desc\",\n    open: t\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy5qcz9kM2UwIl0sIm5hbWVzIjpbIndpbmRvdyIsIkNvbXBvbmVudHMiLCJsaXN0Ym94IiwidCIsImluaXQiLCJvcHRpb25Db3VudCIsIiRyZWZzIiwiY2hpbGRyZW4iLCJsZW5ndGgiLCIkd2F0Y2giLCJvcGVuIiwiYWN0aXZlSW5kZXgiLCJhY3RpdmVEZXNjZW5kYW50IiwiaWQiLCJzZWxlY3RlZEluZGV4IiwiYWN0aXZlIiwiaXRlbXMiLCJtb2RlbE5hbWUiLCIkbmV4dFRpY2siLCJmb2N1cyIsInNjcm9sbEludG9WaWV3IiwiYmxvY2siLCJidXR0b24iLCJtZW51IiwiQXJyYXkiLCJmcm9tIiwiJGVsIiwicXVlcnlTZWxlY3RvckFsbCIsImZvY3VzQnV0dG9uIiwib25CdXR0b25DbGljayIsIm9uQnV0dG9uRW50ZXIiLCJvbkFycm93VXAiLCJvbkFycm93RG93biIsIm9uQ2xpY2tBd2F5IiwiZSIsIm1hcCIsImpvaW4iLCJ0YXJnZXQiLCJjbG9zZXN0IiwicG9wb3Zlckdyb3VwIiwiX190eXBlIiwiZG9jdW1lbnQiLCJib2R5IiwiY29udGFpbnMiLCJFbGVtZW50IiwiZGlzcGF0Y2hFdmVudCIsIkN1c3RvbUV2ZW50IiwiZGV0YWlsIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJwb3BvdmVyIiwiaSIsInByZXZlbnRTY3JvbGwiLCJhY3RpdmVFbGVtZW50IiwiaW5kZXhPZiIsInBhbmVsIiwibiIsInBhcmVudE5vZGUiLCJfX3giLCJjb25zdHJ1Y3RvciIsIiRkYXRhIiwib25Fc2NhcGUiLCJyZXN0b3JlRWwiLCJvbkNsb3NlUG9wb3Zlckdyb3VwIiwidG9nZ2xlIiwiY3VycmVudFRhcmdldCIsInJhZGlvR3JvdXAiLCJpbml0aWFsQ2hlY2tlZEluZGV4IiwidmFsdWUiLCJkZXNjIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNBO0FBQ0FBLE1BQU0sQ0FB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QW9DTztBQUNOLFdBQUtPLElBQUwsR0FBWSxDQUFDLEtBQUtBLElBQWxCLEVBQXdCLEtBQUtBLElBQUwsR0FBWSxLQUFLb0QsU0FBTCxHQUFpQjNELENBQUMsQ0FBQzhELGFBQS9CLEdBQStDLEtBQUtILFNBQUwsSUFBa0IsS0FBS0EsU0FBTCxDQUFlM0MsS0FBZixFQUF6RjtBQUNIO0FBdENFLEdBQVA7QUF3Q0gsQ0FuSkQsRUFxSkFuQixNQUFNLENBQUNDLFVBQVAsQ0FBa0JpRSxVQUFsQixHQUErQixZQUE4QztBQUFBLGtGQUFKLEVBQUk7QUFBQSxvQ0FBbkNDLG1CQUFtQztBQUFBLE1BQWRoRSxDQUFjLHNDQUFWLENBQVU7O0FBQ3pFLFNBQU87QUFDSGlFLElBQUFBLEtBQUssRUFBRSxLQUFLLENBRFQ7QUFFSGhFLElBQUFBLElBRkcsa0JBRUk7QUFBQTs7QUFDSCxXQUFLZ0UsS0FBTCxvQkFBYTVDLEtBQUssQ0FBQ0MsSUFBTixDQUFXLEtBQUtDLEdBQUwsQ0FBU0MsZ0JBQVQsQ0FBMEIsT0FBMUIsQ0FBWCxFQUErQ3hCLENBQS9DLENBQWIsa0RBQWEsY0FBbURpRSxLQUFoRTtBQUNIO0FBSkUsR0FBUDtBQU1ILENBNUpELEVBOEpBcEUsTUFBTSxDQUFDQyxVQUFQLENBQWtCb0UsSUFBbEIsR0FBeUIsWUFBK0I7QUFBQSxrRkFBSixFQUFJO0FBQUEseUJBQXBCM0QsSUFBb0I7QUFBQSxNQUFkUCxDQUFjLDJCQUFWLENBQVU7O0FBQ3BELFNBQU87QUFDSHFDLElBQUFBLE1BQU0sRUFBRSxNQURMO0FBRUg5QixJQUFBQSxJQUFJLEVBQUVQO0FBRkgsR0FBUDtBQUlILENBbktEIiwic291cmNlc0NvbnRlbnQiOlsiXHJcbi8vIG1haW4gY29tcG9uZW50c1xyXG53aW5kb3cuQ29tcG9uZW50cyA9IHt9LCBcclxuXHJcbndpbmRvdy5Db21wb25lbnRzLmxpc3Rib3ggPSBmdW5jdGlvbih0KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGluaXQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uQ291bnQgPSB0aGlzLiRyZWZzLmxpc3Rib3guY2hpbGRyZW4ubGVuZ3RoLCB0aGlzLiR3YXRjaChcImFjdGl2ZUluZGV4XCIsICh0ID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3BlbiAmJiAobnVsbCAhPT0gdGhpcy5hY3RpdmVJbmRleCA/IHRoaXMuYWN0aXZlRGVzY2VuZGFudCA9IHRoaXMuJHJlZnMubGlzdGJveC5jaGlsZHJlblt0aGlzLmFjdGl2ZUluZGV4XS5pZCA6IHRoaXMuYWN0aXZlRGVzY2VuZGFudCA9IFwiXCIpXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWN0aXZlRGVzY2VuZGFudDogbnVsbCxcclxuICAgICAgICBvcHRpb25Db3VudDogbnVsbCxcclxuICAgICAgICBvcGVuOiAhMSxcclxuICAgICAgICBhY3RpdmVJbmRleDogbnVsbCxcclxuICAgICAgICBzZWxlY3RlZEluZGV4OiAwLFxyXG4gICAgICAgIGdldCBhY3RpdmUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zW3RoaXMuYWN0aXZlSW5kZXhdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgW3QubW9kZWxOYW1lIHx8IFwic2VsZWN0ZWRcIl0oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zW3RoaXMuc2VsZWN0ZWRJbmRleF1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNob29zZSh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHQsIHRoaXMub3BlbiA9ICExXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkJ1dHRvbkNsaWNrKCkge1xyXG4gICAgICAgICAgICB0aGlzLm9wZW4gfHwgKHRoaXMuYWN0aXZlSW5kZXggPSB0aGlzLnNlbGVjdGVkSW5kZXgsIHRoaXMub3BlbiA9ICEwLCB0aGlzLiRuZXh0VGljaygoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kcmVmcy5saXN0Ym94LmZvY3VzKCksIHRoaXMuJHJlZnMubGlzdGJveC5jaGlsZHJlblt0aGlzLmFjdGl2ZUluZGV4XS5zY3JvbGxJbnRvVmlldyh7XHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KSkpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk9wdGlvblNlbGVjdCgpIHtcclxuICAgICAgICAgICAgbnVsbCAhPT0gdGhpcy5hY3RpdmVJbmRleCAmJiAodGhpcy5zZWxlY3RlZEluZGV4ID0gdGhpcy5hY3RpdmVJbmRleCksIHRoaXMub3BlbiA9ICExLCB0aGlzLiRyZWZzLmJ1dHRvbi5mb2N1cygpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkVzY2FwZSgpIHtcclxuICAgICAgICAgICAgdGhpcy5vcGVuID0gITEsIHRoaXMuJHJlZnMuYnV0dG9uLmZvY3VzKClcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQXJyb3dVcCgpIHtcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmVJbmRleCA9IHRoaXMuYWN0aXZlSW5kZXggLSAxIDwgMCA/IHRoaXMub3B0aW9uQ291bnQgLSAxIDogdGhpcy5hY3RpdmVJbmRleCAtIDEsIHRoaXMuJHJlZnMubGlzdGJveC5jaGlsZHJlblt0aGlzLmFjdGl2ZUluZGV4XS5zY3JvbGxJbnRvVmlldyh7XHJcbiAgICAgICAgICAgICAgICBibG9jazogXCJuZWFyZXN0XCJcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQXJyb3dEb3duKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUluZGV4ID0gdGhpcy5hY3RpdmVJbmRleCArIDEgPiB0aGlzLm9wdGlvbkNvdW50IC0gMSA/IDAgOiB0aGlzLmFjdGl2ZUluZGV4ICsgMSwgdGhpcy4kcmVmcy5saXN0Ym94LmNoaWxkcmVuW3RoaXMuYWN0aXZlSW5kZXhdLnNjcm9sbEludG9WaWV3KHtcclxuICAgICAgICAgICAgICAgIGJsb2NrOiBcIm5lYXJlc3RcIlxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLi4udFxyXG4gICAgfVxyXG59LCBcclxuXHJcbndpbmRvdy5Db21wb25lbnRzLm1lbnUgPSBmdW5jdGlvbih0ID0geyBvcGVuOiAhMSB9KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGluaXQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXRlbXMgPSBBcnJheS5mcm9tKHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tyb2xlPVwibWVudWl0ZW1cIl0nKSksIHRoaXMuJHdhdGNoKFwib3BlblwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuICYmICh0aGlzLmFjdGl2ZUluZGV4ID0gLTEpXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWN0aXZlRGVzY2VuZGFudDogbnVsbCxcclxuICAgICAgICBhY3RpdmVJbmRleDogbnVsbCxcclxuICAgICAgICBpdGVtczogbnVsbCxcclxuICAgICAgICBvcGVuOiB0Lm9wZW4sXHJcbiAgICAgICAgZm9jdXNCdXR0b24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJHJlZnMuYnV0dG9uLmZvY3VzKClcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQnV0dG9uQ2xpY2soKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3BlbiA9ICF0aGlzLm9wZW4sIHRoaXMub3BlbiAmJiB0aGlzLiRuZXh0VGljaygoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kcmVmc1tcIm1lbnUtaXRlbXNcIl0uZm9jdXMoKVxyXG4gICAgICAgICAgICB9KSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQnV0dG9uRW50ZXIoKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3BlbiA9ICF0aGlzLm9wZW4sIHRoaXMub3BlbiAmJiAodGhpcy5hY3RpdmVJbmRleCA9IDAsIHRoaXMuYWN0aXZlRGVzY2VuZGFudCA9IHRoaXMuaXRlbXNbdGhpcy5hY3RpdmVJbmRleF0uaWQsIHRoaXMuJG5leHRUaWNrKCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRyZWZzW1wibWVudS1pdGVtc1wiXS5mb2N1cygpXHJcbiAgICAgICAgICAgIH0pKSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQXJyb3dVcCgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wZW4pIHJldHVybiB0aGlzLm9wZW4gPSAhMCwgdGhpcy5hY3RpdmVJbmRleCA9IHRoaXMuaXRlbXMubGVuZ3RoIC0gMSwgdm9pZCh0aGlzLmFjdGl2ZURlc2NlbmRhbnQgPSB0aGlzLml0ZW1zW3RoaXMuYWN0aXZlSW5kZXhdLmlkKTtcclxuICAgICAgICAgICAgMCAhPT0gdGhpcy5hY3RpdmVJbmRleCAmJiAodGhpcy5hY3RpdmVJbmRleCA9IC0xID09PSB0aGlzLmFjdGl2ZUluZGV4ID8gdGhpcy5pdGVtcy5sZW5ndGggLSAxIDogdGhpcy5hY3RpdmVJbmRleCAtIDEsIHRoaXMuYWN0aXZlRGVzY2VuZGFudCA9IHRoaXMuaXRlbXNbdGhpcy5hY3RpdmVJbmRleF0uaWQpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkFycm93RG93bigpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wZW4pIHJldHVybiB0aGlzLm9wZW4gPSAhMCwgdGhpcy5hY3RpdmVJbmRleCA9IDAsIHZvaWQodGhpcy5hY3RpdmVEZXNjZW5kYW50ID0gdGhpcy5pdGVtc1t0aGlzLmFjdGl2ZUluZGV4XS5pZCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSW5kZXggIT09IHRoaXMuaXRlbXMubGVuZ3RoIC0gMSAmJiAodGhpcy5hY3RpdmVJbmRleCA9IHRoaXMuYWN0aXZlSW5kZXggKyAxLCB0aGlzLmFjdGl2ZURlc2NlbmRhbnQgPSB0aGlzLml0ZW1zW3RoaXMuYWN0aXZlSW5kZXhdLmlkKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25DbGlja0F3YXkodCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcGVuKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gW1wiW2NvbnRlbnRFZGl0YWJsZT10cnVlXVwiLCBcIlt0YWJpbmRleF1cIiwgXCJhW2hyZWZdXCIsIFwiYXJlYVtocmVmXVwiLCBcImJ1dHRvbjpub3QoW2Rpc2FibGVkXSlcIiwgXCJpZnJhbWVcIiwgXCJpbnB1dDpub3QoW2Rpc2FibGVkXSlcIiwgXCJzZWxlY3Q6bm90KFtkaXNhYmxlZF0pXCIsIFwidGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pXCJdLm1hcCgodCA9PiBgJHt0fTpub3QoW3RhYmluZGV4PSctMSddKWApKS5qb2luKFwiLFwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3BlbiA9ICExLCB0LnRhcmdldC5jbG9zZXN0KGUpIHx8IHRoaXMuZm9jdXNCdXR0b24oKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59LCBcclxuXHJcbndpbmRvdy5Db21wb25lbnRzLnBvcG92ZXJHcm91cCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBfX3R5cGU6IFwicG9wb3Zlckdyb3VwXCIsXHJcbiAgICAgICAgaW5pdCgpIHtcclxuICAgICAgICAgICAgbGV0IHQgPSBlID0+IHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY29udGFpbnModGhpcy4kZWwpID8gZS50YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50ICYmICF0aGlzLiRlbC5jb250YWlucyhlLnRhcmdldCkgJiYgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiY2xvc2UtcG9wb3Zlci1ncm91cFwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB0aGlzLiRlbFxyXG4gICAgICAgICAgICAgICAgfSkpIDogd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0LCAhMClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0LCAhMClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0sIFxyXG5cclxud2luZG93LkNvbXBvbmVudHMucG9wb3ZlciA9IGZ1bmN0aW9uKHsgb3BlbjogdCA9ICExLCBmb2N1czogZSA9ICExIH0gPSB7fSkge1xyXG4gICAgY29uc3QgaSA9IFtcIltjb250ZW50RWRpdGFibGU9dHJ1ZV1cIiwgXCJbdGFiaW5kZXhdXCIsIFwiYVtocmVmXVwiLCBcImFyZWFbaHJlZl1cIiwgXCJidXR0b246bm90KFtkaXNhYmxlZF0pXCIsIFwiaWZyYW1lXCIsIFwiaW5wdXQ6bm90KFtkaXNhYmxlZF0pXCIsIFwic2VsZWN0Om5vdChbZGlzYWJsZWRdKVwiLCBcInRleHRhcmVhOm5vdChbZGlzYWJsZWRdKVwiXS5tYXAoKHQgPT4gYCR7dH06bm90KFt0YWJpbmRleD0nLTEnXSlgKSkuam9pbihcIixcIik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIF9fdHlwZTogXCJwb3BvdmVyXCIsXHJcbiAgICAgICAgb3BlbjogdCxcclxuICAgICAgICBpbml0KCkge1xyXG4gICAgICAgICAgICBlICYmIHRoaXMuJHdhdGNoKFwib3BlblwiLCAodCA9PiB7XHJcbiAgICAgICAgICAgICAgICB0ICYmIHRoaXMuJG5leHRUaWNrKCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgISBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBBcnJheS5mcm9tKHQucXVlcnlTZWxlY3RvckFsbChpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICEgZnVuY3Rpb24gdChpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGkgJiYgKGkuZm9jdXMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnRTY3JvbGw6ICEwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gaSAmJiB0KGVbZS5pbmRleE9mKGkpICsgMV0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KGVbMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgfSh0aGlzLiRyZWZzLnBhbmVsKVxyXG4gICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgbGV0IHQgPSBpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLiRlbCkpIHJldHVybiB2b2lkIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdCwgITApO1xyXG4gICAgICAgICAgICAgICAgbGV0IG4gPSBlID8gdGhpcy4kcmVmcy5wYW5lbCA6IHRoaXMuJGVsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3BlbiAmJiBpLnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgIW4uY29udGFpbnMoaS50YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHQgPSB0aGlzLiRlbDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgdC5wYXJlbnROb2RlOylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgPSB0LnBhcmVudE5vZGUsIHQuX194IGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwicG9wb3Zlckdyb3VwXCIgPT09IHQuX194LiRkYXRhLl9fdHlwZSkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwicG9wb3ZlclwiID09PSB0Ll9feC4kZGF0YS5fX3R5cGUpIGJyZWFrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gdGhpcy5vcGVuID0gITFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0LCAhMClcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uRXNjYXBlKCkge1xyXG4gICAgICAgICAgICB0aGlzLm9wZW4gPSAhMSwgdGhpcy5yZXN0b3JlRWwgJiYgdGhpcy5yZXN0b3JlRWwuZm9jdXMoKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25DbG9zZVBvcG92ZXJHcm91cCh0KSB7XHJcbiAgICAgICAgICAgIHQuZGV0YWlsLmNvbnRhaW5zKHRoaXMuJGVsKSAmJiAodGhpcy5vcGVuID0gITEpXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b2dnbGUodCkge1xyXG4gICAgICAgICAgICB0aGlzLm9wZW4gPSAhdGhpcy5vcGVuLCB0aGlzLm9wZW4gPyB0aGlzLnJlc3RvcmVFbCA9IHQuY3VycmVudFRhcmdldCA6IHRoaXMucmVzdG9yZUVsICYmIHRoaXMucmVzdG9yZUVsLmZvY3VzKClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0sXHJcblxyXG53aW5kb3cuQ29tcG9uZW50cy5yYWRpb0dyb3VwID0gZnVuY3Rpb24oeyBpbml0aWFsQ2hlY2tlZEluZGV4OiB0ID0gMCB9ID0ge30pIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmFsdWU6IHZvaWQgMCxcclxuICAgICAgICBpbml0KCkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gQXJyYXkuZnJvbSh0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRcIikpW3RdPy52YWx1ZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSwgXHJcblxyXG53aW5kb3cuQ29tcG9uZW50cy5kZXNjID0gZnVuY3Rpb24oeyBvcGVuOiB0ID0gMSB9ID0ge30pIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgX190eXBlOiBcImRlc2NcIixcclxuICAgICAgICBvcGVuOiB0XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG4iXSwiZmlsZSI6Ii4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMuanMuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components.js\n");

/***/ }),

/***/ "./resources/js/datepicker.js":
/*!************************************!*\
  !*** ./resources/js/datepicker.js ***!
  \************************************/
/***/ (() => {

eval("function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/******/\n(function () {\n  // webpackBootstrap\n\n  /******/\n  \"use strict\";\n\n  var __webpack_exports__ = {};\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/lib/utils.js\n\n  function hasProperty(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n\n  function lastItemOf(arr) {\n    return arr[arr.length - 1];\n  } // push only the items not included in the array\n\n\n  function pushUnique(arr) {\n    for (var _len = arguments.length, items = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      items[_key - 1] = arguments[_key];\n    }\n\n    items.forEach(function (item) {\n      if (arr.includes(item)) {\n        return;\n      }\n\n      arr.push(item);\n    });\n    return arr;\n  }\n\n  function stringToArray(str, separator) {\n    // convert empty string to an empty array\n    return str ? str.split(separator) : [];\n  }\n\n  function isInRange(testVal, min, max) {\n    var minOK = min === undefined || testVal >= min;\n    var maxOK = max === undefined || testVal <= max;\n    return minOK && maxOK;\n  }\n\n  function limitToRange(val, min, max) {\n    if (val < min) {\n      return min;\n    }\n\n    if (val > max) {\n      return max;\n    }\n\n    return val;\n  }\n\n  function createTagRepeat(tagName, repeat) {\n    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var html = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';\n    var openTagSrc = Object.keys(attributes).reduce(function (src, attr) {\n      var val = attributes[attr];\n\n      if (typeof val === 'function') {\n        val = val(index);\n      }\n\n      return \"\".concat(src, \" \").concat(attr, \"=\\\"\").concat(val, \"\\\"\");\n    }, tagName);\n    html += \"<\".concat(openTagSrc, \"></\").concat(tagName, \">\");\n    var next = index + 1;\n    return next < repeat ? createTagRepeat(tagName, repeat, attributes, next, html) : html;\n  } // Remove the spacing surrounding tags for HTML parser not to create text nodes\n  // before/after elements\n\n\n  function optimizeTemplateHTML(html) {\n    return html.replace(/>\\s+/g, '>').replace(/\\s+</, '<');\n  }\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/lib/date.js\n\n  function stripTime(timeValue) {\n    return new Date(timeValue).setHours(0, 0, 0, 0);\n  }\n\n  function today() {\n    return new Date().setHours(0, 0, 0, 0);\n  } // Get the time value of the start of given date or year, month and day\n\n\n  function dateValue() {\n    switch (arguments.length) {\n      case 0:\n        return today();\n\n      case 1:\n        return stripTime(arguments.length <= 0 ? undefined : arguments[0]);\n    } // use setFullYear() to keep 2-digit year from being mapped to 1900-1999\n\n\n    var newDate = new Date(0);\n    newDate.setFullYear.apply(newDate, arguments);\n    return newDate.setHours(0, 0, 0, 0);\n  }\n\n  function addDays(date, amount) {\n    var newDate = new Date(date);\n    return newDate.setDate(newDate.getDate() + amount);\n  }\n\n  function addWeeks(date, amount) {\n    return addDays(date, amount * 7);\n  }\n\n  function addMonths(date, amount) {\n    // If the day of the date is not in the new month, the last day of the new\n    // month will be returned. e.g. Jan 31 + 1 month  Feb 28 (not Mar 03)\n    var newDate = new Date(date);\n    var monthsToSet = newDate.getMonth() + amount;\n    var expectedMonth = monthsToSet % 12;\n\n    if (expectedMonth < 0) {\n      expectedMonth += 12;\n    }\n\n    var time = newDate.setMonth(monthsToSet);\n    return newDate.getMonth() !== expectedMonth ? newDate.setDate(0) : time;\n  }\n\n  function addYears(date, amount) {\n    // If the date is Feb 29 and the new year is not a leap year, Feb 28 of the\n    // new year will be returned.\n    var newDate = new Date(date);\n    var expectedMonth = newDate.getMonth();\n    var time = newDate.setFullYear(newDate.getFullYear() + amount);\n    return expectedMonth === 1 && newDate.getMonth() === 2 ? newDate.setDate(0) : time;\n  } // Calculate the distance bettwen 2 days of the week\n\n\n  function dayDiff(day, from) {\n    return (day - from + 7) % 7;\n  } // Get the date of the specified day of the week of given base date\n\n\n  function dayOfTheWeekOf(baseDate, dayOfWeek) {\n    var weekStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var baseDay = new Date(baseDate).getDay();\n    return addDays(baseDate, dayDiff(dayOfWeek, weekStart) - dayDiff(baseDay, weekStart));\n  } // Get the ISO week of a date\n\n\n  function getWeek(date) {\n    // start of ISO week is Monday\n    var thuOfTheWeek = dayOfTheWeekOf(date, 4, 1); // 1st week == the week where the 4th of January is in\n\n    var firstThu = dayOfTheWeekOf(new Date(thuOfTheWeek).setMonth(0, 4), 4, 1);\n    return Math.round((thuOfTheWeek - firstThu) / 604800000) + 1;\n  } // Get the start year of the period of years that includes given date\n  // years: length of the year period\n\n\n  function startOfYearPeriod(date, years) {\n    /* @see https://en.wikipedia.org/wiki/Year_zero#ISO_8601 */\n    var year = new Date(date).getFullYear();\n    return Math.floor(year / years) * years;\n  }\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/lib/date-format.js\n  // pattern for format parts\n\n  var reFormatTokens = /dd?|DD?|mm?|MM?|yy?(?:yy)?/; // pattern for non date parts\n\n  var reNonDateParts = /[\\s!-/:-@[-`{-~]+/; // cache for persed formats\n\n  var knownFormats = {}; // parse funtions for date parts\n\n  var parseFns = {\n    y: function y(date, year) {\n      return new Date(date).setFullYear(parseInt(year, 10));\n    },\n    m: function m(date, month, locale) {\n      var newDate = new Date(date);\n      var monthIndex = parseInt(month, 10) - 1;\n\n      if (isNaN(monthIndex)) {\n        if (!month) {\n          return NaN;\n        }\n\n        var monthName = month.toLowerCase();\n\n        var compareNames = function compareNames(name) {\n          return name.toLowerCase().startsWith(monthName);\n        }; // compare with both short and full names because some locales have periods\n        // in the short names (not equal to the first X letters of the full names)\n\n\n        monthIndex = locale.monthsShort.findIndex(compareNames);\n\n        if (monthIndex < 0) {\n          monthIndex = locale.months.findIndex(compareNames);\n        }\n\n        if (monthIndex < 0) {\n          return NaN;\n        }\n      }\n\n      newDate.setMonth(monthIndex);\n      return newDate.getMonth() !== normalizeMonth(monthIndex) ? newDate.setDate(0) : newDate.getTime();\n    },\n    d: function d(date, day) {\n      return new Date(date).setDate(parseInt(day, 10));\n    }\n  }; // format functions for date parts\n\n  var formatFns = {\n    d: function d(date) {\n      return date.getDate();\n    },\n    dd: function dd(date) {\n      return padZero(date.getDate(), 2);\n    },\n    D: function D(date, locale) {\n      return locale.daysShort[date.getDay()];\n    },\n    DD: function DD(date, locale) {\n      return locale.days[date.getDay()];\n    },\n    m: function m(date) {\n      return date.getMonth() + 1;\n    },\n    mm: function mm(date) {\n      return padZero(date.getMonth() + 1, 2);\n    },\n    M: function M(date, locale) {\n      return locale.monthsShort[date.getMonth()];\n    },\n    MM: function MM(date, locale) {\n      return locale.months[date.getMonth()];\n    },\n    y: function y(date) {\n      return date.getFullYear();\n    },\n    yy: function yy(date) {\n      return padZero(date.getFullYear(), 2).slice(-2);\n    },\n    yyyy: function yyyy(date) {\n      return padZero(date.getFullYear(), 4);\n    }\n  }; // get month index in normal range (0 - 11) from any number\n\n  function normalizeMonth(monthIndex) {\n    return monthIndex > -1 ? monthIndex % 12 : normalizeMonth(monthIndex + 12);\n  }\n\n  function padZero(num, length) {\n    return num.toString().padStart(length, '0');\n  }\n\n  function parseFormatString(format) {\n    if (typeof format !== 'string') {\n      throw new Error(\"Invalid date format.\");\n    }\n\n    if (format in knownFormats) {\n      return knownFormats[format];\n    } // sprit the format string into parts and seprators\n\n\n    var separators = format.split(reFormatTokens);\n    var parts = format.match(new RegExp(reFormatTokens, 'g'));\n\n    if (separators.length === 0 || !parts) {\n      throw new Error(\"Invalid date format.\");\n    } // collect format functions used in the format\n\n\n    var partFormatters = parts.map(function (token) {\n      return formatFns[token];\n    }); // collect parse function keys used in the format\n    // iterate over parseFns' keys in order to keep the order of the keys.\n\n    var partParserKeys = Object.keys(parseFns).reduce(function (keys, key) {\n      var token = parts.find(function (part) {\n        return part[0] !== 'D' && part[0].toLowerCase() === key;\n      });\n\n      if (token) {\n        keys.push(key);\n      }\n\n      return keys;\n    }, []);\n    return knownFormats[format] = {\n      parser: function parser(dateStr, locale) {\n        var dateParts = dateStr.split(reNonDateParts).reduce(function (dtParts, part, index) {\n          if (part.length > 0 && parts[index]) {\n            var token = parts[index][0];\n\n            if (token === 'M') {\n              dtParts.m = part;\n            } else if (token !== 'D') {\n              dtParts[token] = part;\n            }\n          }\n\n          return dtParts;\n        }, {}); // iterate over partParserkeys so that the parsing is made in the oder\n        // of year, month and day to prevent the day parser from correcting last\n        // day of month wrongly\n\n        return partParserKeys.reduce(function (origDate, key) {\n          var newDate = parseFns[key](origDate, dateParts[key], locale); // ingnore the part failed to parse\n\n          return isNaN(newDate) ? origDate : newDate;\n        }, today());\n      },\n      formatter: function formatter(date, locale) {\n        var dateStr = partFormatters.reduce(function (str, fn, index) {\n          return str += \"\".concat(separators[index]).concat(fn(date, locale));\n        }, ''); // separators' length is always parts' length + 1,\n\n        return dateStr += lastItemOf(separators);\n      }\n    };\n  }\n\n  function _parseDate(dateStr, format, locale) {\n    if (dateStr instanceof Date || typeof dateStr === 'number') {\n      var date = stripTime(dateStr);\n      return isNaN(date) ? undefined : date;\n    }\n\n    if (!dateStr) {\n      return undefined;\n    }\n\n    if (dateStr === 'today') {\n      return today();\n    }\n\n    if (format && format.toValue) {\n      var _date = format.toValue(dateStr, format, locale);\n\n      return isNaN(_date) ? undefined : stripTime(_date);\n    }\n\n    return parseFormatString(format).parser(dateStr, locale);\n  }\n\n  function _formatDate(date, format, locale) {\n    if (isNaN(date) || !date && date !== 0) {\n      return '';\n    }\n\n    var dateObj = typeof date === 'number' ? new Date(date) : date;\n\n    if (format.toDisplay) {\n      return format.toDisplay(dateObj, format, locale);\n    }\n\n    return parseFormatString(format).formatter(dateObj, locale);\n  }\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/lib/event.js\n\n  var listenerRegistry = new WeakMap();\n  var _EventTarget$prototyp = EventTarget.prototype,\n      addEventListener = _EventTarget$prototyp.addEventListener,\n      removeEventListener = _EventTarget$prototyp.removeEventListener; // Register event listeners to a key object\n  // listeners: array of listener definitions;\n  //   - each definition must be a flat array of event target and the arguments\n  //     used to call addEventListener() on the target\n\n  function registerListeners(keyObj, listeners) {\n    var registered = listenerRegistry.get(keyObj);\n\n    if (!registered) {\n      registered = [];\n      listenerRegistry.set(keyObj, registered);\n    }\n\n    listeners.forEach(function (listener) {\n      addEventListener.call.apply(addEventListener, _toConsumableArray(listener));\n      registered.push(listener);\n    });\n  }\n\n  function unregisterListeners(keyObj) {\n    var listeners = listenerRegistry.get(keyObj);\n\n    if (!listeners) {\n      return;\n    }\n\n    listeners.forEach(function (listener) {\n      removeEventListener.call.apply(removeEventListener, _toConsumableArray(listener));\n    });\n    listenerRegistry[\"delete\"](keyObj);\n  } // Event.composedPath() polyfill for Edge\n  // based on https://gist.github.com/kleinfreund/e9787d73776c0e3750dcfcdc89f100ec\n\n\n  if (!Event.prototype.composedPath) {\n    var getComposedPath = function getComposedPath(node) {\n      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      path.push(node);\n      var parent;\n\n      if (node.parentNode) {\n        parent = node.parentNode;\n      } else if (node.host) {\n        // ShadowRoot\n        parent = node.host;\n      } else if (node.defaultView) {\n        // Document\n        parent = node.defaultView;\n      }\n\n      return parent ? getComposedPath(parent, path) : path;\n    };\n\n    Event.prototype.composedPath = function () {\n      return getComposedPath(this.target);\n    };\n  }\n\n  function findFromPath(path, criteria, currentTarget) {\n    var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var el = path[index];\n\n    if (criteria(el)) {\n      return el;\n    } else if (el === currentTarget || !el.parentElement) {\n      // stop when reaching currentTarget or <html>\n      return;\n    }\n\n    return findFromPath(path, criteria, currentTarget, index + 1);\n  } // Search for the actual target of a delegated event\n\n\n  function findElementInEventPath(ev, selector) {\n    var criteria = typeof selector === 'function' ? selector : function (el) {\n      return el.matches(selector);\n    };\n    return findFromPath(ev.composedPath(), criteria, ev.currentTarget);\n  }\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/i18n/base-locales.js\n  // default locales\n\n  var locales = {\n    en: {\n      days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n      daysShort: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n      daysMin: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"],\n      months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n      monthsShort: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n      today: \"Today\",\n      clear: \"Clear\",\n      titleFormat: \"MM y\"\n    }\n  };\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/options/defaultOptions.js\n  // config options updatable by setOptions() and their default values\n\n  var defaultOptions = {\n    autohide: false,\n    beforeShowDay: null,\n    beforeShowDecade: null,\n    beforeShowMonth: null,\n    beforeShowYear: null,\n    calendarWeeks: false,\n    clearBtn: false,\n    dateDelimiter: ',',\n    datesDisabled: [],\n    daysOfWeekDisabled: [],\n    daysOfWeekHighlighted: [],\n    defaultViewDate: undefined,\n    // placeholder, defaults to today() by the program\n    disableTouchKeyboard: false,\n    format: 'mm/dd/yyyy',\n    language: 'en',\n    maxDate: null,\n    maxNumberOfDates: 1,\n    maxView: 3,\n    minDate: null,\n    nextArrow: '<svg class=\"w-4 h-4\" fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" d=\"M12.293 5.293a1 1 0 011.414 0l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-2.293-2.293a1 1 0 010-1.414z\" clip-rule=\"evenodd\"></path></svg>',\n    orientation: 'auto',\n    pickLevel: 0,\n    prevArrow: '<svg class=\"w-4 h-4\" fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" d=\"M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z\" clip-rule=\"evenodd\"></path></svg>',\n    showDaysOfWeek: true,\n    showOnClick: true,\n    showOnFocus: true,\n    startView: 0,\n    title: '',\n    todayBtn: false,\n    todayBtnMode: 0,\n    todayHighlight: false,\n    updateOnBlur: true,\n    weekStart: 0\n  };\n  /* harmony default export */\n\n  var options_defaultOptions = defaultOptions;\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/lib/dom.js\n\n  var range = document.createRange();\n\n  function parseHTML(html) {\n    return range.createContextualFragment(html);\n  } // equivalent to jQuery's :visble\n\n\n  function isVisible(el) {\n    return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length);\n  }\n\n  function hideElement(el) {\n    if (el.style.display === 'none') {\n      return;\n    } // back up the existing display setting in data-style-display\n\n\n    if (el.style.display) {\n      el.dataset.styleDisplay = el.style.display;\n    }\n\n    el.style.display = 'none';\n  }\n\n  function showElement(el) {\n    if (el.style.display !== 'none') {\n      return;\n    }\n\n    if (el.dataset.styleDisplay) {\n      // restore backed-up dispay property\n      el.style.display = el.dataset.styleDisplay;\n      delete el.dataset.styleDisplay;\n    } else {\n      el.style.display = '';\n    }\n  }\n\n  function emptyChildNodes(el) {\n    if (el.firstChild) {\n      el.removeChild(el.firstChild);\n      emptyChildNodes(el);\n    }\n  }\n\n  function replaceChildNodes(el, newChildNodes) {\n    emptyChildNodes(el);\n\n    if (newChildNodes instanceof DocumentFragment) {\n      el.appendChild(newChildNodes);\n    } else if (typeof newChildNodes === 'string') {\n      el.appendChild(parseHTML(newChildNodes));\n    } else if (typeof newChildNodes.forEach === 'function') {\n      newChildNodes.forEach(function (node) {\n        el.appendChild(node);\n      });\n    }\n  }\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/options/processOptions.js\n\n  var defaultLang = options_defaultOptions.language,\n      defaultFormat = options_defaultOptions.format,\n      defaultWeekStart = options_defaultOptions.weekStart; // Reducer function to filter out invalid day-of-week from the input\n\n  function sanitizeDOW(dow, day) {\n    return dow.length < 6 && day >= 0 && day < 7 ? pushUnique(dow, day) : dow;\n  }\n\n  function calcEndOfWeek(startOfWeek) {\n    return (startOfWeek + 6) % 7;\n  } // validate input date. if invalid, fallback to the original value\n\n\n  function validateDate(value, format, locale, origValue) {\n    var date = _parseDate(value, format, locale);\n\n    return date !== undefined ? date : origValue;\n  } // Validate viewId. if invalid, fallback to the original value\n\n\n  function validateViewId(value, origValue) {\n    var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;\n    var viewId = parseInt(value, 10);\n    return viewId >= 0 && viewId <= max ? viewId : origValue;\n  } // Create Datepicker configuration to set\n\n\n  function processOptions(options, datepicker) {\n    var inOpts = Object.assign({}, options);\n    var config = {};\n    var locales = datepicker.constructor.locales;\n\n    var _ref = datepicker.config || {},\n        format = _ref.format,\n        language = _ref.language,\n        locale = _ref.locale,\n        maxDate = _ref.maxDate,\n        maxView = _ref.maxView,\n        minDate = _ref.minDate,\n        pickLevel = _ref.pickLevel,\n        startView = _ref.startView,\n        weekStart = _ref.weekStart;\n\n    if (inOpts.language) {\n      var lang;\n\n      if (inOpts.language !== language) {\n        if (locales[inOpts.language]) {\n          lang = inOpts.language;\n        } else {\n          // Check if langauge + region tag can fallback to the one without\n          // region (e.g. fr-CA  fr)\n          lang = inOpts.language.split('-')[0];\n\n          if (locales[lang] === undefined) {\n            lang = false;\n          }\n        }\n      }\n\n      delete inOpts.language;\n\n      if (lang) {\n        language = config.language = lang; // update locale as well when updating language\n\n        var origLocale = locale || locales[defaultLang]; // use default language's properties for the fallback\n\n        locale = Object.assign({\n          format: defaultFormat,\n          weekStart: defaultWeekStart\n        }, locales[defaultLang]);\n\n        if (language !== defaultLang) {\n          Object.assign(locale, locales[language]);\n        }\n\n        config.locale = locale; // if format and/or weekStart are the same as old locale's defaults,\n        // update them to new locale's defaults\n\n        if (format === origLocale.format) {\n          format = config.format = locale.format;\n        }\n\n        if (weekStart === origLocale.weekStart) {\n          weekStart = config.weekStart = locale.weekStart;\n          config.weekEnd = calcEndOfWeek(locale.weekStart);\n        }\n      }\n    }\n\n    if (inOpts.format) {\n      var hasToDisplay = typeof inOpts.format.toDisplay === 'function';\n      var hasToValue = typeof inOpts.format.toValue === 'function';\n      var validFormatString = reFormatTokens.test(inOpts.format);\n\n      if (hasToDisplay && hasToValue || validFormatString) {\n        format = config.format = inOpts.format;\n      }\n\n      delete inOpts.format;\n    } //*** dates ***//\n    // while min and maxDate for \"no limit\" in the options are better to be null\n    // (especially when updating), the ones in the config have to be undefined\n    // because null is treated as 0 (= unix epoch) when comparing with time value\n\n\n    var minDt = minDate;\n    var maxDt = maxDate;\n\n    if (inOpts.minDate !== undefined) {\n      minDt = inOpts.minDate === null ? dateValue(0, 0, 1) // set 0000-01-01 to prevent negative values for year\n      : validateDate(inOpts.minDate, format, locale, minDt);\n      delete inOpts.minDate;\n    }\n\n    if (inOpts.maxDate !== undefined) {\n      maxDt = inOpts.maxDate === null ? undefined : validateDate(inOpts.maxDate, format, locale, maxDt);\n      delete inOpts.maxDate;\n    }\n\n    if (maxDt < minDt) {\n      minDate = config.minDate = maxDt;\n      maxDate = config.maxDate = minDt;\n    } else {\n      if (minDate !== minDt) {\n        minDate = config.minDate = minDt;\n      }\n\n      if (maxDate !== maxDt) {\n        maxDate = config.maxDate = maxDt;\n      }\n    }\n\n    if (inOpts.datesDisabled) {\n      config.datesDisabled = inOpts.datesDisabled.reduce(function (dates, dt) {\n        var date = _parseDate(dt, format, locale);\n\n        return date !== undefined ? pushUnique(dates, date) : dates;\n      }, []);\n      delete inOpts.datesDisabled;\n    }\n\n    if (inOpts.defaultViewDate !== undefined) {\n      var viewDate = _parseDate(inOpts.defaultViewDate, format, locale);\n\n      if (viewDate !== undefined) {\n        config.defaultViewDate = viewDate;\n      }\n\n      delete inOpts.defaultViewDate;\n    } //*** days of week ***//\n\n\n    if (inOpts.weekStart !== undefined) {\n      var wkStart = Number(inOpts.weekStart) % 7;\n\n      if (!isNaN(wkStart)) {\n        weekStart = config.weekStart = wkStart;\n        config.weekEnd = calcEndOfWeek(wkStart);\n      }\n\n      delete inOpts.weekStart;\n    }\n\n    if (inOpts.daysOfWeekDisabled) {\n      config.daysOfWeekDisabled = inOpts.daysOfWeekDisabled.reduce(sanitizeDOW, []);\n      delete inOpts.daysOfWeekDisabled;\n    }\n\n    if (inOpts.daysOfWeekHighlighted) {\n      config.daysOfWeekHighlighted = inOpts.daysOfWeekHighlighted.reduce(sanitizeDOW, []);\n      delete inOpts.daysOfWeekHighlighted;\n    } //*** multi date ***//\n\n\n    if (inOpts.maxNumberOfDates !== undefined) {\n      var maxNumberOfDates = parseInt(inOpts.maxNumberOfDates, 10);\n\n      if (maxNumberOfDates >= 0) {\n        config.maxNumberOfDates = maxNumberOfDates;\n        config.multidate = maxNumberOfDates !== 1;\n      }\n\n      delete inOpts.maxNumberOfDates;\n    }\n\n    if (inOpts.dateDelimiter) {\n      config.dateDelimiter = String(inOpts.dateDelimiter);\n      delete inOpts.dateDelimiter;\n    } //*** pick level & view ***//\n\n\n    var newPickLevel = pickLevel;\n\n    if (inOpts.pickLevel !== undefined) {\n      newPickLevel = validateViewId(inOpts.pickLevel, 2);\n      delete inOpts.pickLevel;\n    }\n\n    if (newPickLevel !== pickLevel) {\n      pickLevel = config.pickLevel = newPickLevel;\n    }\n\n    var newMaxView = maxView;\n\n    if (inOpts.maxView !== undefined) {\n      newMaxView = validateViewId(inOpts.maxView, maxView);\n      delete inOpts.maxView;\n    } // ensure max view >= pick level\n\n\n    newMaxView = pickLevel > newMaxView ? pickLevel : newMaxView;\n\n    if (newMaxView !== maxView) {\n      maxView = config.maxView = newMaxView;\n    }\n\n    var newStartView = startView;\n\n    if (inOpts.startView !== undefined) {\n      newStartView = validateViewId(inOpts.startView, newStartView);\n      delete inOpts.startView;\n    } // ensure pick level <= start view <= max view\n\n\n    if (newStartView < pickLevel) {\n      newStartView = pickLevel;\n    } else if (newStartView > maxView) {\n      newStartView = maxView;\n    }\n\n    if (newStartView !== startView) {\n      config.startView = newStartView;\n    } //*** template ***//\n\n\n    if (inOpts.prevArrow) {\n      var prevArrow = parseHTML(inOpts.prevArrow);\n\n      if (prevArrow.childNodes.length > 0) {\n        config.prevArrow = prevArrow.childNodes;\n      }\n\n      delete inOpts.prevArrow;\n    }\n\n    if (inOpts.nextArrow) {\n      var nextArrow = parseHTML(inOpts.nextArrow);\n\n      if (nextArrow.childNodes.length > 0) {\n        config.nextArrow = nextArrow.childNodes;\n      }\n\n      delete inOpts.nextArrow;\n    } //*** misc ***//\n\n\n    if (inOpts.disableTouchKeyboard !== undefined) {\n      config.disableTouchKeyboard = 'ontouchstart' in document && !!inOpts.disableTouchKeyboard;\n      delete inOpts.disableTouchKeyboard;\n    }\n\n    if (inOpts.orientation) {\n      var orientation = inOpts.orientation.toLowerCase().split(/\\s+/g);\n      config.orientation = {\n        x: orientation.find(function (x) {\n          return x === 'left' || x === 'right';\n        }) || 'auto',\n        y: orientation.find(function (y) {\n          return y === 'top' || y === 'bottom';\n        }) || 'auto'\n      };\n      delete inOpts.orientation;\n    }\n\n    if (inOpts.todayBtnMode !== undefined) {\n      switch (inOpts.todayBtnMode) {\n        case 0:\n        case 1:\n          config.todayBtnMode = inOpts.todayBtnMode;\n      }\n\n      delete inOpts.todayBtnMode;\n    } //*** copy the rest ***//\n\n\n    Object.keys(inOpts).forEach(function (key) {\n      if (inOpts[key] !== undefined && hasProperty(options_defaultOptions, key)) {\n        config[key] = inOpts[key];\n      }\n    });\n    return config;\n  }\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/picker/templates/pickerTemplate.js\n\n  var pickerTemplate = optimizeTemplateHTML(\"<div class=\\\"datepicker hidden\\\">\\n  <div class=\\\"datepicker-picker inline-block rounded-lg bg-white dark:bg-gray-700 shadow-lg p-4\\\">\\n    <div class=\\\"datepicker-header\\\">\\n      <div class=\\\"datepicker-title bg-white dark:bg-gray-700 dark:text-white px-2 py-3 text-center font-semibold\\\"></div>\\n      <div class=\\\"datepicker-controls flex justify-between mb-2\\\">\\n        <button type=\\\"button\\\" class=\\\"bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 prev-btn\\\"></button>\\n        <button type=\\\"button\\\" class=\\\"text-sm rounded-lg text-gray-900 dark:text-white bg-white dark:bg-gray-700 font-semibold py-2.5 px-5 hover:bg-gray-100 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-200 view-switch\\\"></button>\\n        <button type=\\\"button\\\" class=\\\"bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 next-btn\\\"></button>\\n      </div>\\n    </div>\\n    <div class=\\\"datepicker-main p-1\\\"></div>\\n    <div class=\\\"datepicker-footer\\\">\\n      <div class=\\\"datepicker-controls flex space-x-2 mt-2\\\">\\n        <button type=\\\"button\\\" class=\\\"%buttonClass% today-btn text-white bg-blue-700 dark:bg-blue-600 hover:bg-blue-800 dark:hover:bg-blue-700 focus:ring-4 focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2\\\"></button>\\n        <button type=\\\"button\\\" class=\\\"%buttonClass% clear-btn text-gray-900 dark:text-white bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-600 focus:ring-4 focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2\\\"></button>\\n      </div>\\n    </div>\\n  </div>\\n</div>\");\n  /* harmony default export */\n\n  var templates_pickerTemplate = pickerTemplate;\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/picker/templates/daysTemplate.js\n\n  var daysTemplate = optimizeTemplateHTML(\"<div class=\\\"days\\\">\\n  <div class=\\\"days-of-week grid grid-cols-7 mb-1\\\">\".concat(createTagRepeat('span', 7, {\n    \"class\": 'dow block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm'\n  }), \"</div>\\n  <div class=\\\"datepicker-grid w-64 grid grid-cols-7\\\">\").concat(createTagRepeat('span', 42, {\n    \"class\": 'block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400'\n  }), \"</div>\\n</div>\"));\n  /* harmony default export */\n\n  var templates_daysTemplate = daysTemplate;\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/picker/templates/calendarWeeksTemplate.js\n\n  var calendarWeeksTemplate = optimizeTemplateHTML(\"<div class=\\\"calendar-weeks\\\">\\n  <div class=\\\"days-of-week flex\\\"><span class=\\\"dow h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400\\\"></span></div>\\n  <div class=\\\"weeks\\\">\".concat(createTagRepeat('span', 6, {\n    \"class\": 'week block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm'\n  }), \"</div>\\n</div>\"));\n  /* harmony default export */\n\n  var templates_calendarWeeksTemplate = calendarWeeksTemplate;\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/picker/views/View.js\n  // Base class of the view classes\n\n  var View = /*#__PURE__*/function () {\n    function View(picker, config) {\n      _classCallCheck(this, View);\n\n      Object.assign(this, config, {\n        picker: picker,\n        element: parseHTML(\"<div class=\\\"datepicker-view flex\\\"></div>\").firstChild,\n        selected: []\n      });\n      this.init(this.picker.datepicker.config);\n    }\n\n    _createClass(View, [{\n      key: \"init\",\n      value: function init(options) {\n        if (options.pickLevel !== undefined) {\n          this.isMinView = this.id === options.pickLevel;\n        }\n\n        this.setOptions(options);\n        this.updateFocus();\n        this.updateSelection();\n      } // Execute beforeShow() callback and apply the result to the element\n      // args:\n      // - current - current value on the iteration on view rendering\n      // - timeValue - time value of the date to pass to beforeShow()\n\n    }, {\n      key: \"performBeforeHook\",\n      value: function performBeforeHook(el, current, timeValue) {\n        var result = this.beforeShow(new Date(timeValue));\n\n        switch (_typeof(result)) {\n          case 'boolean':\n            result = {\n              enabled: result\n            };\n            break;\n\n          case 'string':\n            result = {\n              classes: result\n            };\n        }\n\n        if (result) {\n          if (result.enabled === false) {\n            el.classList.add('disabled');\n            pushUnique(this.disabled, current);\n          }\n\n          if (result.classes) {\n            var _el$classList;\n\n            var extraClasses = result.classes.split(/\\s+/);\n\n            (_el$classList = el.classList).add.apply(_el$classList, _toConsumableArray(extraClasses));\n\n            if (extraClasses.includes('disabled')) {\n              pushUnique(this.disabled, current);\n            }\n          }\n\n          if (result.content) {\n            replaceChildNodes(el, result.content);\n          }\n        }\n      }\n    }]);\n\n    return View;\n  }();\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/picker/views/DaysView.js\n\n  var DaysView = /*#__PURE__*/function (_View) {\n    _inherits(DaysView, _View);\n\n    var _super = _createSuper(DaysView);\n\n    function DaysView(picker) {\n      _classCallCheck(this, DaysView);\n\n      return _super.call(this, picker, {\n        id: 0,\n        name: 'days',\n        cellClass: 'day'\n      });\n    }\n\n    _createClass(DaysView, [{\n      key: \"init\",\n      value: function init(options) {\n        var onConstruction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (onConstruction) {\n          var inner = parseHTML(templates_daysTemplate).firstChild;\n          this.dow = inner.firstChild;\n          this.grid = inner.lastChild;\n          this.element.appendChild(inner);\n        }\n\n        _get(_getPrototypeOf(DaysView.prototype), \"init\", this).call(this, options);\n      }\n    }, {\n      key: \"setOptions\",\n      value: function setOptions(options) {\n        var _this = this;\n\n        var updateDOW;\n\n        if (hasProperty(options, 'minDate')) {\n          this.minDate = options.minDate;\n        }\n\n        if (hasProperty(options, 'maxDate')) {\n          this.maxDate = options.maxDate;\n        }\n\n        if (options.datesDisabled) {\n          this.datesDisabled = options.datesDisabled;\n        }\n\n        if (options.daysOfWeekDisabled) {\n          this.daysOfWeekDisabled = options.daysOfWeekDisabled;\n          updateDOW = true;\n        }\n\n        if (options.daysOfWeekHighlighted) {\n          this.daysOfWeekHighlighted = options.daysOfWeekHighlighted;\n        }\n\n        if (options.todayHighlight !== undefined) {\n          this.todayHighlight = options.todayHighlight;\n        }\n\n        if (options.weekStart !== undefined) {\n          this.weekStart = options.weekStart;\n          this.weekEnd = options.weekEnd;\n          updateDOW = true;\n        }\n\n        if (options.locale) {\n          var locale = this.locale = options.locale;\n          this.dayNames = locale.daysMin;\n          this.switchLabelFormat = locale.titleFormat;\n          updateDOW = true;\n        }\n\n        if (options.beforeShowDay !== undefined) {\n          this.beforeShow = typeof options.beforeShowDay === 'function' ? options.beforeShowDay : undefined;\n        }\n\n        if (options.calendarWeeks !== undefined) {\n          if (options.calendarWeeks && !this.calendarWeeks) {\n            var weeksElem = parseHTML(templates_calendarWeeksTemplate).firstChild;\n            this.calendarWeeks = {\n              element: weeksElem,\n              dow: weeksElem.firstChild,\n              weeks: weeksElem.lastChild\n            };\n            this.element.insertBefore(weeksElem, this.element.firstChild);\n          } else if (this.calendarWeeks && !options.calendarWeeks) {\n            this.element.removeChild(this.calendarWeeks.element);\n            this.calendarWeeks = null;\n          }\n        }\n\n        if (options.showDaysOfWeek !== undefined) {\n          if (options.showDaysOfWeek) {\n            showElement(this.dow);\n\n            if (this.calendarWeeks) {\n              showElement(this.calendarWeeks.dow);\n            }\n          } else {\n            hideElement(this.dow);\n\n            if (this.calendarWeeks) {\n              hideElement(this.calendarWeeks.dow);\n            }\n          }\n        } // update days-of-week when locale, daysOfweekDisabled or weekStart is changed\n\n\n        if (updateDOW) {\n          Array.from(this.dow.children).forEach(function (el, index) {\n            var dow = (_this.weekStart + index) % 7;\n            el.textContent = _this.dayNames[dow];\n            el.className = _this.daysOfWeekDisabled.includes(dow) ? 'dow disabled text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400 cursor-not-allowed' : 'dow text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400';\n          });\n        }\n      } // Apply update on the focused date to view's settings\n\n    }, {\n      key: \"updateFocus\",\n      value: function updateFocus() {\n        var viewDate = new Date(this.picker.viewDate);\n        var viewYear = viewDate.getFullYear();\n        var viewMonth = viewDate.getMonth();\n        var firstOfMonth = dateValue(viewYear, viewMonth, 1);\n        var start = dayOfTheWeekOf(firstOfMonth, this.weekStart, this.weekStart);\n        this.first = firstOfMonth;\n        this.last = dateValue(viewYear, viewMonth + 1, 0);\n        this.start = start;\n        this.focused = this.picker.viewDate;\n      } // Apply update on the selected dates to view's settings\n\n    }, {\n      key: \"updateSelection\",\n      value: function updateSelection() {\n        var _this$picker$datepick = this.picker.datepicker,\n            dates = _this$picker$datepick.dates,\n            rangepicker = _this$picker$datepick.rangepicker;\n        this.selected = dates;\n\n        if (rangepicker) {\n          this.range = rangepicker.dates;\n        }\n      } // Update the entire view UI\n\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this2 = this;\n\n        // update today marker on ever render\n        this.today = this.todayHighlight ? today() : undefined; // refresh disabled dates on every render in order to clear the ones added\n        // by beforeShow hook at previous render\n\n        this.disabled = _toConsumableArray(this.datesDisabled);\n\n        var switchLabel = _formatDate(this.focused, this.switchLabelFormat, this.locale);\n\n        this.picker.setViewSwitchLabel(switchLabel);\n        this.picker.setPrevBtnDisabled(this.first <= this.minDate);\n        this.picker.setNextBtnDisabled(this.last >= this.maxDate);\n\n        if (this.calendarWeeks) {\n          // start of the UTC week (Monday) of the 1st of the month\n          var startOfWeek = dayOfTheWeekOf(this.first, 1, 1);\n          Array.from(this.calendarWeeks.weeks.children).forEach(function (el, index) {\n            el.textContent = getWeek(addWeeks(startOfWeek, index));\n          });\n        }\n\n        Array.from(this.grid.children).forEach(function (el, index) {\n          var classList = el.classList;\n          var current = addDays(_this2.start, index);\n          var date = new Date(current);\n          var day = date.getDay();\n          el.className = \"datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm \".concat(_this2.cellClass);\n          el.dataset.date = current;\n          el.textContent = date.getDate();\n\n          if (current < _this2.first) {\n            classList.add('prev', 'text-gray-500', 'dark:text-white');\n          } else if (current > _this2.last) {\n            classList.add('next', 'text-gray-500', 'dark:text-white');\n          }\n\n          if (_this2.today === current) {\n            classList.add('today', 'bg-gray-100', 'dark:bg-gray-600', 'dark:bg-gray-600');\n          }\n\n          if (current < _this2.minDate || current > _this2.maxDate || _this2.disabled.includes(current)) {\n            classList.add('disabled', 'cursor-not-allowed');\n          }\n\n          if (_this2.daysOfWeekDisabled.includes(day)) {\n            classList.add('disabled', 'cursor-not-allowed');\n            pushUnique(_this2.disabled, current);\n          }\n\n          if (_this2.daysOfWeekHighlighted.includes(day)) {\n            classList.add('highlighted');\n          }\n\n          if (_this2.range) {\n            var _this2$range = _slicedToArray(_this2.range, 2),\n                rangeStart = _this2$range[0],\n                rangeEnd = _this2$range[1];\n\n            if (current > rangeStart && current < rangeEnd) {\n              classList.add('range', 'bg-gray-200', 'dark:bg-gray-600');\n              classList.remove('rounded-lg', 'rounded-l-lg', 'rounded-r-lg');\n            }\n\n            if (current === rangeStart) {\n              classList.add('range-start', 'bg-gray-100', 'dark:bg-gray-600', 'rounded-l-lg');\n              classList.remove('rounded-lg', 'rounded-r-lg');\n            }\n\n            if (current === rangeEnd) {\n              classList.add('range-end', 'bg-gray-100', 'dark:bg-gray-600', 'rounded-r-lg');\n              classList.remove('rounded-lg', 'rounded-l-lg');\n            }\n          }\n\n          if (_this2.selected.includes(current)) {\n            classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');\n            classList.remove('text-gray-900', 'text-gray-500', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');\n          }\n\n          if (current === _this2.focused) {\n            classList.add('focused');\n          }\n\n          if (_this2.beforeShow) {\n            _this2.performBeforeHook(el, current, current);\n          }\n        });\n      } // Update the view UI by applying the changes of selected and focused items\n\n    }, {\n      key: \"refresh\",\n      value: function refresh() {\n        var _this3 = this;\n\n        var _ref2 = this.range || [],\n            _ref3 = _slicedToArray(_ref2, 2),\n            rangeStart = _ref3[0],\n            rangeEnd = _ref3[1];\n\n        this.grid.querySelectorAll('.range, .range-start, .range-end, .selected, .focused').forEach(function (el) {\n          el.classList.remove('range', 'range-start', 'range-end', 'selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white', 'focused', 'bg-gray-100', 'dark:bg-gray-600');\n          el.classList.add('text-gray-900', 'rounded-lg', 'dark:text-white');\n        });\n        Array.from(this.grid.children).forEach(function (el) {\n          var current = Number(el.dataset.date);\n          var classList = el.classList;\n\n          if (current > rangeStart && current < rangeEnd) {\n            classList.add('range', 'bg-gray-200', 'dark:bg-gray-600');\n            classList.remove('rounded-lg');\n          }\n\n          if (current === rangeStart) {\n            classList.add('range-start', 'bg-gray-200', 'dark:bg-gray-600', 'rounded-l-lg');\n            classList.remove('rounded-lg', 'rounded-r-lg');\n          }\n\n          if (current === rangeEnd) {\n            classList.add('range-end', 'bg-gray-200', 'dark:bg-gray-600', 'rounded-r-lg');\n            classList.remove('rounded-lg', 'rounded-l-lg');\n          }\n\n          if (_this3.selected.includes(current)) {\n            classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');\n            classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');\n          }\n\n          if (current === _this3.focused) {\n            classList.add('focused', 'bg-gray-100', 'dark:bg-gray-600');\n          }\n        });\n      } // Update the view UI by applying the change of focused item\n\n    }, {\n      key: \"refreshFocus\",\n      value: function refreshFocus() {\n        var index = Math.round((this.focused - this.start) / 86400000);\n        this.grid.querySelectorAll('.focused').forEach(function (el) {\n          el.classList.remove('focused', 'bg-gray-100', 'dark:bg-gray-600');\n        });\n        this.grid.children[index].classList.add('focused', 'bg-gray-100', 'dark:bg-gray-600');\n      }\n    }]);\n\n    return DaysView;\n  }(View);\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/picker/views/MonthsView.js\n\n  function computeMonthRange(range, thisYear) {\n    if (!range || !range[0] || !range[1]) {\n      return;\n    }\n\n    var _range = _slicedToArray(range, 2),\n        _range$ = _slicedToArray(_range[0], 2),\n        startY = _range$[0],\n        startM = _range$[1],\n        _range$2 = _slicedToArray(_range[1], 2),\n        endY = _range$2[0],\n        endM = _range$2[1];\n\n    if (startY > thisYear || endY < thisYear) {\n      return;\n    }\n\n    return [startY === thisYear ? startM : -1, endY === thisYear ? endM : 12];\n  }\n\n  var MonthsView = /*#__PURE__*/function (_View2) {\n    _inherits(MonthsView, _View2);\n\n    var _super2 = _createSuper(MonthsView);\n\n    function MonthsView(picker) {\n      _classCallCheck(this, MonthsView);\n\n      return _super2.call(this, picker, {\n        id: 1,\n        name: 'months',\n        cellClass: 'month'\n      });\n    }\n\n    _createClass(MonthsView, [{\n      key: \"init\",\n      value: function init(options) {\n        var onConstruction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (onConstruction) {\n          this.grid = this.element;\n          this.element.classList.add('months', 'datepicker-grid', 'w-64', 'grid', 'grid-cols-4');\n          this.grid.appendChild(parseHTML(createTagRepeat('span', 12, {\n            'data-month': function dataMonth(ix) {\n              return ix;\n            }\n          })));\n        }\n\n        _get(_getPrototypeOf(MonthsView.prototype), \"init\", this).call(this, options);\n      }\n    }, {\n      key: \"setOptions\",\n      value: function setOptions(options) {\n        if (options.locale) {\n          this.monthNames = options.locale.monthsShort;\n        }\n\n        if (hasProperty(options, 'minDate')) {\n          if (options.minDate === undefined) {\n            this.minYear = this.minMonth = this.minDate = undefined;\n          } else {\n            var minDateObj = new Date(options.minDate);\n            this.minYear = minDateObj.getFullYear();\n            this.minMonth = minDateObj.getMonth();\n            this.minDate = minDateObj.setDate(1);\n          }\n        }\n\n        if (hasProperty(options, 'maxDate')) {\n          if (options.maxDate === undefined) {\n            this.maxYear = this.maxMonth = this.maxDate = undefined;\n          } else {\n            var maxDateObj = new Date(options.maxDate);\n            this.maxYear = maxDateObj.getFullYear();\n            this.maxMonth = maxDateObj.getMonth();\n            this.maxDate = dateValue(this.maxYear, this.maxMonth + 1, 0);\n          }\n        }\n\n        if (options.beforeShowMonth !== undefined) {\n          this.beforeShow = typeof options.beforeShowMonth === 'function' ? options.beforeShowMonth : undefined;\n        }\n      } // Update view's settings to reflect the viewDate set on the picker\n\n    }, {\n      key: \"updateFocus\",\n      value: function updateFocus() {\n        var viewDate = new Date(this.picker.viewDate);\n        this.year = viewDate.getFullYear();\n        this.focused = viewDate.getMonth();\n      } // Update view's settings to reflect the selected dates\n\n    }, {\n      key: \"updateSelection\",\n      value: function updateSelection() {\n        var _this$picker$datepick2 = this.picker.datepicker,\n            dates = _this$picker$datepick2.dates,\n            rangepicker = _this$picker$datepick2.rangepicker;\n        this.selected = dates.reduce(function (selected, timeValue) {\n          var date = new Date(timeValue);\n          var year = date.getFullYear();\n          var month = date.getMonth();\n\n          if (selected[year] === undefined) {\n            selected[year] = [month];\n          } else {\n            pushUnique(selected[year], month);\n          }\n\n          return selected;\n        }, {});\n\n        if (rangepicker && rangepicker.dates) {\n          this.range = rangepicker.dates.map(function (timeValue) {\n            var date = new Date(timeValue);\n            return isNaN(date) ? undefined : [date.getFullYear(), date.getMonth()];\n          });\n        }\n      } // Update the entire view UI\n\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this4 = this;\n\n        // refresh disabled months on every render in order to clear the ones added\n        // by beforeShow hook at previous render\n        this.disabled = [];\n        this.picker.setViewSwitchLabel(this.year);\n        this.picker.setPrevBtnDisabled(this.year <= this.minYear);\n        this.picker.setNextBtnDisabled(this.year >= this.maxYear);\n        var selected = this.selected[this.year] || [];\n        var yrOutOfRange = this.year < this.minYear || this.year > this.maxYear;\n        var isMinYear = this.year === this.minYear;\n        var isMaxYear = this.year === this.maxYear;\n        var range = computeMonthRange(this.range, this.year);\n        Array.from(this.grid.children).forEach(function (el, index) {\n          var classList = el.classList;\n          var date = dateValue(_this4.year, index, 1);\n          el.className = \"datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm \".concat(_this4.cellClass);\n\n          if (_this4.isMinView) {\n            el.dataset.date = date;\n          } // reset text on every render to clear the custom content set\n          // by beforeShow hook at previous render\n\n\n          el.textContent = _this4.monthNames[index];\n\n          if (yrOutOfRange || isMinYear && index < _this4.minMonth || isMaxYear && index > _this4.maxMonth) {\n            classList.add('disabled');\n          }\n\n          if (range) {\n            var _range2 = _slicedToArray(range, 2),\n                rangeStart = _range2[0],\n                rangeEnd = _range2[1];\n\n            if (index > rangeStart && index < rangeEnd) {\n              classList.add('range');\n            }\n\n            if (index === rangeStart) {\n              classList.add('range-start');\n            }\n\n            if (index === rangeEnd) {\n              classList.add('range-end');\n            }\n          }\n\n          if (selected.includes(index)) {\n            classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');\n            classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');\n          }\n\n          if (index === _this4.focused) {\n            classList.add('focused', 'bg-gray-100', 'dark:bg-gray-600');\n          }\n\n          if (_this4.beforeShow) {\n            _this4.performBeforeHook(el, index, date);\n          }\n        });\n      } // Update the view UI by applying the changes of selected and focused items\n\n    }, {\n      key: \"refresh\",\n      value: function refresh() {\n        var _this5 = this;\n\n        var selected = this.selected[this.year] || [];\n\n        var _ref4 = computeMonthRange(this.range, this.year) || [],\n            _ref5 = _slicedToArray(_ref4, 2),\n            rangeStart = _ref5[0],\n            rangeEnd = _ref5[1];\n\n        this.grid.querySelectorAll('.range, .range-start, .range-end, .selected, .focused').forEach(function (el) {\n          el.classList.remove('range', 'range-start', 'range-end', 'selected', 'bg-blue-700', 'dark:bg-blue-600', 'dark:text-white', 'text-white', 'focused', 'bg-gray-100', 'dark:bg-gray-600');\n          el.classList.add('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');\n        });\n        Array.from(this.grid.children).forEach(function (el, index) {\n          var classList = el.classList;\n\n          if (index > rangeStart && index < rangeEnd) {\n            classList.add('range');\n          }\n\n          if (index === rangeStart) {\n            classList.add('range-start');\n          }\n\n          if (index === rangeEnd) {\n            classList.add('range-end');\n          }\n\n          if (selected.includes(index)) {\n            classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');\n            classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');\n          }\n\n          if (index === _this5.focused) {\n            classList.add('focused', 'bg-gray-100', 'dark:bg-gray-600');\n          }\n        });\n      } // Update the view UI by applying the change of focused item\n\n    }, {\n      key: \"refreshFocus\",\n      value: function refreshFocus() {\n        this.grid.querySelectorAll('.focused').forEach(function (el) {\n          el.classList.remove('focused', 'bg-gray-100'), 'dark:bg-gray-600';\n        });\n        this.grid.children[this.focused].classList.add('focused', 'bg-gray-100', 'dark:bg-gray-600');\n      }\n    }]);\n\n    return MonthsView;\n  }(View);\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/picker/views/YearsView.js\n\n  function toTitleCase(word) {\n    return _toConsumableArray(word).reduce(function (str, ch, ix) {\n      return str += ix ? ch : ch.toUpperCase();\n    }, '');\n  } // Class representing the years and decades view elements\n\n\n  var YearsView = /*#__PURE__*/function (_View3) {\n    _inherits(YearsView, _View3);\n\n    var _super3 = _createSuper(YearsView);\n\n    function YearsView(picker, config) {\n      _classCallCheck(this, YearsView);\n\n      return _super3.call(this, picker, config);\n    }\n\n    _createClass(YearsView, [{\n      key: \"init\",\n      value: function init(options) {\n        var onConstruction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (onConstruction) {\n          this.navStep = this.step * 10;\n          this.beforeShowOption = \"beforeShow\".concat(toTitleCase(this.cellClass));\n          this.grid = this.element;\n          this.element.classList.add(this.name, 'datepicker-grid', 'w-64', 'grid', 'grid-cols-4');\n          this.grid.appendChild(parseHTML(createTagRepeat('span', 12)));\n        }\n\n        _get(_getPrototypeOf(YearsView.prototype), \"init\", this).call(this, options);\n      }\n    }, {\n      key: \"setOptions\",\n      value: function setOptions(options) {\n        if (hasProperty(options, 'minDate')) {\n          if (options.minDate === undefined) {\n            this.minYear = this.minDate = undefined;\n          } else {\n            this.minYear = startOfYearPeriod(options.minDate, this.step);\n            this.minDate = dateValue(this.minYear, 0, 1);\n          }\n        }\n\n        if (hasProperty(options, 'maxDate')) {\n          if (options.maxDate === undefined) {\n            this.maxYear = this.maxDate = undefined;\n          } else {\n            this.maxYear = startOfYearPeriod(options.maxDate, this.step);\n            this.maxDate = dateValue(this.maxYear, 11, 31);\n          }\n        }\n\n        if (options[this.beforeShowOption] !== undefined) {\n          var beforeShow = options[this.beforeShowOption];\n          this.beforeShow = typeof beforeShow === 'function' ? beforeShow : undefined;\n        }\n      } // Update view's settings to reflect the viewDate set on the picker\n\n    }, {\n      key: \"updateFocus\",\n      value: function updateFocus() {\n        var viewDate = new Date(this.picker.viewDate);\n        var first = startOfYearPeriod(viewDate, this.navStep);\n        var last = first + 9 * this.step;\n        this.first = first;\n        this.last = last;\n        this.start = first - this.step;\n        this.focused = startOfYearPeriod(viewDate, this.step);\n      } // Update view's settings to reflect the selected dates\n\n    }, {\n      key: \"updateSelection\",\n      value: function updateSelection() {\n        var _this6 = this;\n\n        var _this$picker$datepick3 = this.picker.datepicker,\n            dates = _this$picker$datepick3.dates,\n            rangepicker = _this$picker$datepick3.rangepicker;\n        this.selected = dates.reduce(function (years, timeValue) {\n          return pushUnique(years, startOfYearPeriod(timeValue, _this6.step));\n        }, []);\n\n        if (rangepicker && rangepicker.dates) {\n          this.range = rangepicker.dates.map(function (timeValue) {\n            if (timeValue !== undefined) {\n              return startOfYearPeriod(timeValue, _this6.step);\n            }\n          });\n        }\n      } // Update the entire view UI\n\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this7 = this;\n\n        // refresh disabled years on every render in order to clear the ones added\n        // by beforeShow hook at previous render\n        this.disabled = [];\n        this.picker.setViewSwitchLabel(\"\".concat(this.first, \"-\").concat(this.last));\n        this.picker.setPrevBtnDisabled(this.first <= this.minYear);\n        this.picker.setNextBtnDisabled(this.last >= this.maxYear);\n        Array.from(this.grid.children).forEach(function (el, index) {\n          var classList = el.classList;\n          var current = _this7.start + index * _this7.step;\n          var date = dateValue(current, 0, 1);\n          el.className = \"datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm \".concat(_this7.cellClass);\n\n          if (_this7.isMinView) {\n            el.dataset.date = date;\n          }\n\n          el.textContent = el.dataset.year = current;\n\n          if (index === 0) {\n            classList.add('prev');\n          } else if (index === 11) {\n            classList.add('next');\n          }\n\n          if (current < _this7.minYear || current > _this7.maxYear) {\n            classList.add('disabled');\n          }\n\n          if (_this7.range) {\n            var _this7$range = _slicedToArray(_this7.range, 2),\n                rangeStart = _this7$range[0],\n                rangeEnd = _this7$range[1];\n\n            if (current > rangeStart && current < rangeEnd) {\n              classList.add('range');\n            }\n\n            if (current === rangeStart) {\n              classList.add('range-start');\n            }\n\n            if (current === rangeEnd) {\n              classList.add('range-end');\n            }\n          }\n\n          if (_this7.selected.includes(current)) {\n            classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');\n            classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');\n          }\n\n          if (current === _this7.focused) {\n            classList.add('focused', 'bg-gray-100', 'dark:bg-gray-600');\n          }\n\n          if (_this7.beforeShow) {\n            _this7.performBeforeHook(el, current, date);\n          }\n        });\n      } // Update the view UI by applying the changes of selected and focused items\n\n    }, {\n      key: \"refresh\",\n      value: function refresh() {\n        var _this8 = this;\n\n        var _ref6 = this.range || [],\n            _ref7 = _slicedToArray(_ref6, 2),\n            rangeStart = _ref7[0],\n            rangeEnd = _ref7[1];\n\n        this.grid.querySelectorAll('.range, .range-start, .range-end, .selected, .focused').forEach(function (el) {\n          el.classList.remove('range', 'range-start', 'range-end', 'selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white', 'focused', 'bg-gray-100', 'dark:bg-gray-600');\n        });\n        Array.from(this.grid.children).forEach(function (el) {\n          var current = Number(el.textContent);\n          var classList = el.classList;\n\n          if (current > rangeStart && current < rangeEnd) {\n            classList.add('range');\n          }\n\n          if (current === rangeStart) {\n            classList.add('range-start');\n          }\n\n          if (current === rangeEnd) {\n            classList.add('range-end');\n          }\n\n          if (_this8.selected.includes(current)) {\n            classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');\n            classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');\n          }\n\n          if (current === _this8.focused) {\n            classList.add('focused', 'bg-gray-100', 'dark:bg-gray-600');\n          }\n        });\n      } // Update the view UI by applying the change of focused item\n\n    }, {\n      key: \"refreshFocus\",\n      value: function refreshFocus() {\n        var index = Math.round((this.focused - this.start) / this.step);\n        this.grid.querySelectorAll('.focused').forEach(function (el) {\n          el.classList.remove('focused', 'bg-gray-100', 'dark:bg-gray-600');\n        });\n        this.grid.children[index].classList.add('focused', 'bg-gray-100', 'dark:bg-gray-600');\n      }\n    }]);\n\n    return YearsView;\n  }(View);\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/events/functions.js\n\n  function triggerDatepickerEvent(datepicker, type) {\n    var detail = {\n      date: datepicker.getDate(),\n      viewDate: new Date(datepicker.picker.viewDate),\n      viewId: datepicker.picker.currentView.id,\n      datepicker: datepicker\n    };\n    datepicker.element.dispatchEvent(new CustomEvent(type, {\n      detail: detail\n    }));\n  } // direction: -1 (to previous), 1 (to next)\n\n\n  function goToPrevOrNext(datepicker, direction) {\n    var _datepicker$config = datepicker.config,\n        minDate = _datepicker$config.minDate,\n        maxDate = _datepicker$config.maxDate;\n    var _datepicker$picker = datepicker.picker,\n        currentView = _datepicker$picker.currentView,\n        viewDate = _datepicker$picker.viewDate;\n    var newViewDate;\n\n    switch (currentView.id) {\n      case 0:\n        newViewDate = addMonths(viewDate, direction);\n        break;\n\n      case 1:\n        newViewDate = addYears(viewDate, direction);\n        break;\n\n      default:\n        newViewDate = addYears(viewDate, direction * currentView.navStep);\n    }\n\n    newViewDate = limitToRange(newViewDate, minDate, maxDate);\n    datepicker.picker.changeFocus(newViewDate).render();\n  }\n\n  function switchView(datepicker) {\n    var viewId = datepicker.picker.currentView.id;\n\n    if (viewId === datepicker.config.maxView) {\n      return;\n    }\n\n    datepicker.picker.changeView(viewId + 1).render();\n  }\n\n  function unfocus(datepicker) {\n    if (datepicker.config.updateOnBlur) {\n      datepicker.update({\n        autohide: true\n      });\n    } else {\n      datepicker.refresh('input');\n      datepicker.hide();\n    }\n  }\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/events/pickerListeners.js\n\n  function goToSelectedMonthOrYear(datepicker, selection) {\n    var picker = datepicker.picker;\n    var viewDate = new Date(picker.viewDate);\n    var viewId = picker.currentView.id;\n    var newDate = viewId === 1 ? addMonths(viewDate, selection - viewDate.getMonth()) : addYears(viewDate, selection - viewDate.getFullYear());\n    picker.changeFocus(newDate).changeView(viewId - 1).render();\n  }\n\n  function onClickTodayBtn(datepicker) {\n    var picker = datepicker.picker;\n    var currentDate = today();\n\n    if (datepicker.config.todayBtnMode === 1) {\n      if (datepicker.config.autohide) {\n        datepicker.setDate(currentDate);\n        return;\n      }\n\n      datepicker.setDate(currentDate, {\n        render: false\n      });\n      picker.update();\n    }\n\n    if (picker.viewDate !== currentDate) {\n      picker.changeFocus(currentDate);\n    }\n\n    picker.changeView(0).render();\n  }\n\n  function onClickClearBtn(datepicker) {\n    datepicker.setDate({\n      clear: true\n    });\n  }\n\n  function onClickViewSwitch(datepicker) {\n    switchView(datepicker);\n  }\n\n  function onClickPrevBtn(datepicker) {\n    goToPrevOrNext(datepicker, -1);\n  }\n\n  function onClickNextBtn(datepicker) {\n    goToPrevOrNext(datepicker, 1);\n  } // For the picker's main block to delegete the events from `datepicker-cell`s\n\n\n  function onClickView(datepicker, ev) {\n    var target = findElementInEventPath(ev, '.datepicker-cell');\n\n    if (!target || target.classList.contains('disabled')) {\n      return;\n    }\n\n    var _datepicker$picker$cu = datepicker.picker.currentView,\n        id = _datepicker$picker$cu.id,\n        isMinView = _datepicker$picker$cu.isMinView;\n\n    if (isMinView) {\n      datepicker.setDate(Number(target.dataset.date));\n    } else if (id === 1) {\n      goToSelectedMonthOrYear(datepicker, Number(target.dataset.month));\n    } else {\n      goToSelectedMonthOrYear(datepicker, Number(target.dataset.year));\n    }\n  }\n\n  function onClickPicker(datepicker) {\n    if (!datepicker.inline && !datepicker.config.disableTouchKeyboard) {\n      datepicker.inputField.focus();\n    }\n  }\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/picker/Picker.js\n\n  function processPickerOptions(picker, options) {\n    if (options.title !== undefined) {\n      if (options.title) {\n        picker.controls.title.textContent = options.title;\n        showElement(picker.controls.title);\n      } else {\n        picker.controls.title.textContent = '';\n        hideElement(picker.controls.title);\n      }\n    }\n\n    if (options.prevArrow) {\n      var prevBtn = picker.controls.prevBtn;\n      emptyChildNodes(prevBtn);\n      options.prevArrow.forEach(function (node) {\n        prevBtn.appendChild(node.cloneNode(true));\n      });\n    }\n\n    if (options.nextArrow) {\n      var nextBtn = picker.controls.nextBtn;\n      emptyChildNodes(nextBtn);\n      options.nextArrow.forEach(function (node) {\n        nextBtn.appendChild(node.cloneNode(true));\n      });\n    }\n\n    if (options.locale) {\n      picker.controls.todayBtn.textContent = options.locale.today;\n      picker.controls.clearBtn.textContent = options.locale.clear;\n    }\n\n    if (options.todayBtn !== undefined) {\n      if (options.todayBtn) {\n        showElement(picker.controls.todayBtn);\n      } else {\n        hideElement(picker.controls.todayBtn);\n      }\n    }\n\n    if (hasProperty(options, 'minDate') || hasProperty(options, 'maxDate')) {\n      var _picker$datepicker$co = picker.datepicker.config,\n          minDate = _picker$datepicker$co.minDate,\n          maxDate = _picker$datepicker$co.maxDate;\n      picker.controls.todayBtn.disabled = !isInRange(today(), minDate, maxDate);\n    }\n\n    if (options.clearBtn !== undefined) {\n      if (options.clearBtn) {\n        showElement(picker.controls.clearBtn);\n      } else {\n        hideElement(picker.controls.clearBtn);\n      }\n    }\n  } // Compute view date to reset, which will be...\n  // - the last item of the selected dates or defaultViewDate if no selection\n  // - limitted to minDate or maxDate if it exceeds the range\n\n\n  function computeResetViewDate(datepicker) {\n    var dates = datepicker.dates,\n        config = datepicker.config;\n    var viewDate = dates.length > 0 ? lastItemOf(dates) : config.defaultViewDate;\n    return limitToRange(viewDate, config.minDate, config.maxDate);\n  } // Change current view's view date\n\n\n  function setViewDate(picker, newDate) {\n    var oldViewDate = new Date(picker.viewDate);\n    var newViewDate = new Date(newDate);\n    var _picker$currentView = picker.currentView,\n        id = _picker$currentView.id,\n        year = _picker$currentView.year,\n        first = _picker$currentView.first,\n        last = _picker$currentView.last;\n    var viewYear = newViewDate.getFullYear();\n    picker.viewDate = newDate;\n\n    if (viewYear !== oldViewDate.getFullYear()) {\n      triggerDatepickerEvent(picker.datepicker, 'changeYear');\n    }\n\n    if (newViewDate.getMonth() !== oldViewDate.getMonth()) {\n      triggerDatepickerEvent(picker.datepicker, 'changeMonth');\n    } // return whether the new date is in different period on time from the one\n    // displayed in the current view\n    // when true, the view needs to be re-rendered on the next UI refresh.\n\n\n    switch (id) {\n      case 0:\n        return newDate < first || newDate > last;\n\n      case 1:\n        return viewYear !== year;\n\n      default:\n        return viewYear < first || viewYear > last;\n    }\n  }\n\n  function getTextDirection(el) {\n    return window.getComputedStyle(el).direction;\n  } // Class representing the picker UI\n\n\n  var Picker = /*#__PURE__*/function () {\n    function Picker(datepicker) {\n      _classCallCheck(this, Picker);\n\n      this.datepicker = datepicker;\n      var template = templates_pickerTemplate.replace(/%buttonClass%/g, datepicker.config.buttonClass);\n      var element = this.element = parseHTML(template).firstChild;\n\n      var _element$firstChild$c = _slicedToArray(element.firstChild.children, 3),\n          header = _element$firstChild$c[0],\n          main = _element$firstChild$c[1],\n          footer = _element$firstChild$c[2];\n\n      var title = header.firstElementChild;\n\n      var _header$lastElementCh = _slicedToArray(header.lastElementChild.children, 3),\n          prevBtn = _header$lastElementCh[0],\n          viewSwitch = _header$lastElementCh[1],\n          nextBtn = _header$lastElementCh[2];\n\n      var _footer$firstChild$ch = _slicedToArray(footer.firstChild.children, 2),\n          todayBtn = _footer$firstChild$ch[0],\n          clearBtn = _footer$firstChild$ch[1];\n\n      var controls = {\n        title: title,\n        prevBtn: prevBtn,\n        viewSwitch: viewSwitch,\n        nextBtn: nextBtn,\n        todayBtn: todayBtn,\n        clearBtn: clearBtn\n      };\n      this.main = main;\n      this.controls = controls;\n      var elementClass = datepicker.inline ? 'inline' : 'dropdown';\n      element.classList.add(\"datepicker-\".concat(elementClass));\n      elementClass === 'dropdown' ? element.classList.add('dropdown', 'absolute', 'top-0', 'left-0', 'z-20', 'pt-2') : null;\n      processPickerOptions(this, datepicker.config);\n      this.viewDate = computeResetViewDate(datepicker); // set up event listeners\n\n      registerListeners(datepicker, [[element, 'click', onClickPicker.bind(null, datepicker), {\n        capture: true\n      }], [main, 'click', onClickView.bind(null, datepicker)], [controls.viewSwitch, 'click', onClickViewSwitch.bind(null, datepicker)], [controls.prevBtn, 'click', onClickPrevBtn.bind(null, datepicker)], [controls.nextBtn, 'click', onClickNextBtn.bind(null, datepicker)], [controls.todayBtn, 'click', onClickTodayBtn.bind(null, datepicker)], [controls.clearBtn, 'click', onClickClearBtn.bind(null, datepicker)]]); // set up views\n\n      this.views = [new DaysView(this), new MonthsView(this), new YearsView(this, {\n        id: 2,\n        name: 'years',\n        cellClass: 'year',\n        step: 1\n      }), new YearsView(this, {\n        id: 3,\n        name: 'decades',\n        cellClass: 'decade',\n        step: 10\n      })];\n      this.currentView = this.views[datepicker.config.startView];\n      this.currentView.render();\n      this.main.appendChild(this.currentView.element);\n      datepicker.config.container.appendChild(this.element);\n    }\n\n    _createClass(Picker, [{\n      key: \"setOptions\",\n      value: function setOptions(options) {\n        processPickerOptions(this, options);\n        this.views.forEach(function (view) {\n          view.init(options, false);\n        });\n        this.currentView.render();\n      }\n    }, {\n      key: \"detach\",\n      value: function detach() {\n        this.datepicker.config.container.removeChild(this.element);\n      }\n    }, {\n      key: \"show\",\n      value: function show() {\n        if (this.active) {\n          return;\n        }\n\n        this.element.classList.add('active', 'block');\n        this.element.classList.remove('hidden');\n        this.active = true;\n        var datepicker = this.datepicker;\n\n        if (!datepicker.inline) {\n          // ensure picker's direction matches input's\n          var inputDirection = getTextDirection(datepicker.inputField);\n\n          if (inputDirection !== getTextDirection(datepicker.config.container)) {\n            this.element.dir = inputDirection;\n          } else if (this.element.dir) {\n            this.element.removeAttribute('dir');\n          }\n\n          this.place();\n\n          if (datepicker.config.disableTouchKeyboard) {\n            datepicker.inputField.blur();\n          }\n        }\n\n        triggerDatepickerEvent(datepicker, 'show');\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        if (!this.active) {\n          return;\n        }\n\n        this.datepicker.exitEditMode();\n        this.element.classList.remove('active', 'block');\n        this.element.classList.add('active', 'block', 'hidden');\n        this.active = false;\n        triggerDatepickerEvent(this.datepicker, 'hide');\n      }\n    }, {\n      key: \"place\",\n      value: function place() {\n        var _this$element = this.element,\n            classList = _this$element.classList,\n            style = _this$element.style;\n        var _this$datepicker = this.datepicker,\n            config = _this$datepicker.config,\n            inputField = _this$datepicker.inputField;\n        var container = config.container;\n\n        var _this$element$getBoun = this.element.getBoundingClientRect(),\n            calendarWidth = _this$element$getBoun.width,\n            calendarHeight = _this$element$getBoun.height;\n\n        var _container$getBoundin = container.getBoundingClientRect(),\n            containerLeft = _container$getBoundin.left,\n            containerTop = _container$getBoundin.top,\n            containerWidth = _container$getBoundin.width;\n\n        var _inputField$getBoundi = inputField.getBoundingClientRect(),\n            inputLeft = _inputField$getBoundi.left,\n            inputTop = _inputField$getBoundi.top,\n            inputWidth = _inputField$getBoundi.width,\n            inputHeight = _inputField$getBoundi.height;\n\n        var _config$orientation = config.orientation,\n            orientX = _config$orientation.x,\n            orientY = _config$orientation.y;\n        var scrollTop;\n        var left;\n        var top;\n\n        if (container === document.body) {\n          scrollTop = window.scrollY;\n          left = inputLeft + window.scrollX;\n          top = inputTop + scrollTop;\n        } else {\n          scrollTop = container.scrollTop;\n          left = inputLeft - containerLeft;\n          top = inputTop - containerTop + scrollTop;\n        }\n\n        if (orientX === 'auto') {\n          if (left < 0) {\n            // align to the left and move into visible area if input's left edge < window's\n            orientX = 'left';\n            left = 10;\n          } else if (left + calendarWidth > containerWidth) {\n            // align to the right if canlendar's right edge > container's\n            orientX = 'right';\n          } else {\n            orientX = getTextDirection(inputField) === 'rtl' ? 'right' : 'left';\n          }\n        }\n\n        if (orientX === 'right') {\n          left -= calendarWidth - inputWidth;\n        }\n\n        if (orientY === 'auto') {\n          orientY = top - calendarHeight < scrollTop ? 'bottom' : 'top';\n        }\n\n        if (orientY === 'top') {\n          top -= calendarHeight;\n        } else {\n          top += inputHeight;\n        }\n\n        classList.remove('datepicker-orient-top', 'datepicker-orient-bottom', 'datepicker-orient-right', 'datepicker-orient-left');\n        classList.add(\"datepicker-orient-\".concat(orientY), \"datepicker-orient-\".concat(orientX));\n        style.top = top ? \"\".concat(top, \"px\") : top;\n        style.left = left ? \"\".concat(left, \"px\") : left;\n      }\n    }, {\n      key: \"setViewSwitchLabel\",\n      value: function setViewSwitchLabel(labelText) {\n        this.controls.viewSwitch.textContent = labelText;\n      }\n    }, {\n      key: \"setPrevBtnDisabled\",\n      value: function setPrevBtnDisabled(disabled) {\n        this.controls.prevBtn.disabled = disabled;\n      }\n    }, {\n      key: \"setNextBtnDisabled\",\n      value: function setNextBtnDisabled(disabled) {\n        this.controls.nextBtn.disabled = disabled;\n      }\n    }, {\n      key: \"changeView\",\n      value: function changeView(viewId) {\n        var oldView = this.currentView;\n        var newView = this.views[viewId];\n\n        if (newView.id !== oldView.id) {\n          this.currentView = newView;\n          this._renderMethod = 'render';\n          triggerDatepickerEvent(this.datepicker, 'changeView');\n          this.main.replaceChild(newView.element, oldView.element);\n        }\n\n        return this;\n      } // Change the focused date (view date)\n\n    }, {\n      key: \"changeFocus\",\n      value: function changeFocus(newViewDate) {\n        this._renderMethod = setViewDate(this, newViewDate) ? 'render' : 'refreshFocus';\n        this.views.forEach(function (view) {\n          view.updateFocus();\n        });\n        return this;\n      } // Apply the change of the selected dates\n\n    }, {\n      key: \"update\",\n      value: function update() {\n        var newViewDate = computeResetViewDate(this.datepicker);\n        this._renderMethod = setViewDate(this, newViewDate) ? 'render' : 'refresh';\n        this.views.forEach(function (view) {\n          view.updateFocus();\n          view.updateSelection();\n        });\n        return this;\n      } // Refresh the picker UI\n\n    }, {\n      key: \"render\",\n      value: function render() {\n        var quickRender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var renderMethod = quickRender && this._renderMethod || 'render';\n        delete this._renderMethod;\n        this.currentView[renderMethod]();\n      }\n    }]);\n\n    return Picker;\n  }();\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/events/inputFieldListeners.js\n  // Find the closest date that doesn't meet the condition for unavailable date\n  // Returns undefined if no available date is found\n  // addFn: function to calculate the next date\n  //   - args: time value, amount\n  // increase: amount to pass to addFn\n  // testFn: function to test the unavailablity of the date\n  //   - args: time value; retun: true if unavailable\n\n  function findNextAvailableOne(date, addFn, increase, testFn, min, max) {\n    if (!isInRange(date, min, max)) {\n      return;\n    }\n\n    if (testFn(date)) {\n      var newDate = addFn(date, increase);\n      return findNextAvailableOne(newDate, addFn, increase, testFn, min, max);\n    }\n\n    return date;\n  } // direction: -1 (left/up), 1 (right/down)\n  // vertical: true for up/down, false for left/right\n\n\n  function moveByArrowKey(datepicker, ev, direction, vertical) {\n    var picker = datepicker.picker;\n    var currentView = picker.currentView;\n    var step = currentView.step || 1;\n    var viewDate = picker.viewDate;\n    var addFn;\n    var testFn;\n\n    switch (currentView.id) {\n      case 0:\n        if (vertical) {\n          viewDate = addDays(viewDate, direction * 7);\n        } else if (ev.ctrlKey || ev.metaKey) {\n          viewDate = addYears(viewDate, direction);\n        } else {\n          viewDate = addDays(viewDate, direction);\n        }\n\n        addFn = addDays;\n\n        testFn = function testFn(date) {\n          return currentView.disabled.includes(date);\n        };\n\n        break;\n\n      case 1:\n        viewDate = addMonths(viewDate, vertical ? direction * 4 : direction);\n        addFn = addMonths;\n\n        testFn = function testFn(date) {\n          var dt = new Date(date);\n          var year = currentView.year,\n              disabled = currentView.disabled;\n          return dt.getFullYear() === year && disabled.includes(dt.getMonth());\n        };\n\n        break;\n\n      default:\n        viewDate = addYears(viewDate, direction * (vertical ? 4 : 1) * step);\n        addFn = addYears;\n\n        testFn = function testFn(date) {\n          return currentView.disabled.includes(startOfYearPeriod(date, step));\n        };\n\n    }\n\n    viewDate = findNextAvailableOne(viewDate, addFn, direction < 0 ? -step : step, testFn, currentView.minDate, currentView.maxDate);\n\n    if (viewDate !== undefined) {\n      picker.changeFocus(viewDate).render();\n    }\n  }\n\n  function onKeydown(datepicker, ev) {\n    if (ev.key === 'Tab') {\n      unfocus(datepicker);\n      return;\n    }\n\n    var picker = datepicker.picker;\n    var _picker$currentView2 = picker.currentView,\n        id = _picker$currentView2.id,\n        isMinView = _picker$currentView2.isMinView;\n\n    if (!picker.active) {\n      switch (ev.key) {\n        case 'ArrowDown':\n        case 'Escape':\n          picker.show();\n          break;\n\n        case 'Enter':\n          datepicker.update();\n          break;\n\n        default:\n          return;\n      }\n    } else if (datepicker.editMode) {\n      switch (ev.key) {\n        case 'Escape':\n          picker.hide();\n          break;\n\n        case 'Enter':\n          datepicker.exitEditMode({\n            update: true,\n            autohide: datepicker.config.autohide\n          });\n          break;\n\n        default:\n          return;\n      }\n    } else {\n      switch (ev.key) {\n        case 'Escape':\n          picker.hide();\n          break;\n\n        case 'ArrowLeft':\n          if (ev.ctrlKey || ev.metaKey) {\n            goToPrevOrNext(datepicker, -1);\n          } else if (ev.shiftKey) {\n            datepicker.enterEditMode();\n            return;\n          } else {\n            moveByArrowKey(datepicker, ev, -1, false);\n          }\n\n          break;\n\n        case 'ArrowRight':\n          if (ev.ctrlKey || ev.metaKey) {\n            goToPrevOrNext(datepicker, 1);\n          } else if (ev.shiftKey) {\n            datepicker.enterEditMode();\n            return;\n          } else {\n            moveByArrowKey(datepicker, ev, 1, false);\n          }\n\n          break;\n\n        case 'ArrowUp':\n          if (ev.ctrlKey || ev.metaKey) {\n            switchView(datepicker);\n          } else if (ev.shiftKey) {\n            datepicker.enterEditMode();\n            return;\n          } else {\n            moveByArrowKey(datepicker, ev, -1, true);\n          }\n\n          break;\n\n        case 'ArrowDown':\n          if (ev.shiftKey && !ev.ctrlKey && !ev.metaKey) {\n            datepicker.enterEditMode();\n            return;\n          }\n\n          moveByArrowKey(datepicker, ev, 1, true);\n          break;\n\n        case 'Enter':\n          if (isMinView) {\n            datepicker.setDate(picker.viewDate);\n          } else {\n            picker.changeView(id - 1).render();\n          }\n\n          break;\n\n        case 'Backspace':\n        case 'Delete':\n          datepicker.enterEditMode();\n          return;\n\n        default:\n          if (ev.key.length === 1 && !ev.ctrlKey && !ev.metaKey) {\n            datepicker.enterEditMode();\n          }\n\n          return;\n      }\n    }\n\n    ev.preventDefault();\n    ev.stopPropagation();\n  }\n\n  function onFocus(datepicker) {\n    if (datepicker.config.showOnFocus && !datepicker._showing) {\n      datepicker.show();\n    }\n  } // for the prevention for entering edit mode while getting focus on click\n\n\n  function onMousedown(datepicker, ev) {\n    var el = ev.target;\n\n    if (datepicker.picker.active || datepicker.config.showOnClick) {\n      el._active = el === document.activeElement;\n      el._clicking = setTimeout(function () {\n        delete el._active;\n        delete el._clicking;\n      }, 2000);\n    }\n  }\n\n  function onClickInput(datepicker, ev) {\n    var el = ev.target;\n\n    if (!el._clicking) {\n      return;\n    }\n\n    clearTimeout(el._clicking);\n    delete el._clicking;\n\n    if (el._active) {\n      datepicker.enterEditMode();\n    }\n\n    delete el._active;\n\n    if (datepicker.config.showOnClick) {\n      datepicker.show();\n    }\n  }\n\n  function onPaste(datepicker, ev) {\n    if (ev.clipboardData.types.includes('text/plain')) {\n      datepicker.enterEditMode();\n    }\n  }\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/events/otherListeners.js\n  // for the `document` to delegate the events from outside the picker/input field\n\n  function onClickOutside(datepicker, ev) {\n    var element = datepicker.element;\n\n    if (element !== document.activeElement) {\n      return;\n    }\n\n    var pickerElem = datepicker.picker.element;\n\n    if (findElementInEventPath(ev, function (el) {\n      return el === element || el === pickerElem;\n    })) {\n      return;\n    }\n\n    unfocus(datepicker);\n  }\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/Datepicker.js\n\n  function stringifyDates(dates, config) {\n    return dates.map(function (dt) {\n      return _formatDate(dt, config.format, config.locale);\n    }).join(config.dateDelimiter);\n  } // parse input dates and create an array of time values for selection\n  // returns undefined if there are no valid dates in inputDates\n  // when origDates (current selection) is passed, the function works to mix\n  // the input dates into the current selection\n\n\n  function processInputDates(datepicker, inputDates) {\n    var clear = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var config = datepicker.config,\n        origDates = datepicker.dates,\n        rangepicker = datepicker.rangepicker;\n\n    if (inputDates.length === 0) {\n      // empty input is considered valid unless origiDates is passed\n      return clear ? [] : undefined;\n    }\n\n    var rangeEnd = rangepicker && datepicker === rangepicker.datepickers[1];\n    var newDates = inputDates.reduce(function (dates, dt) {\n      var date = _parseDate(dt, config.format, config.locale);\n\n      if (date === undefined) {\n        return dates;\n      }\n\n      if (config.pickLevel > 0) {\n        // adjust to 1st of the month/Jan 1st of the year\n        // or to the last day of the monh/Dec 31st of the year if the datepicker\n        // is the range-end picker of a rangepicker\n        var _dt = new Date(date);\n\n        if (config.pickLevel === 1) {\n          date = rangeEnd ? _dt.setMonth(_dt.getMonth() + 1, 0) : _dt.setDate(1);\n        } else {\n          date = rangeEnd ? _dt.setFullYear(_dt.getFullYear() + 1, 0, 0) : _dt.setMonth(0, 1);\n        }\n      }\n\n      if (isInRange(date, config.minDate, config.maxDate) && !dates.includes(date) && !config.datesDisabled.includes(date) && !config.daysOfWeekDisabled.includes(new Date(date).getDay())) {\n        dates.push(date);\n      }\n\n      return dates;\n    }, []);\n\n    if (newDates.length === 0) {\n      return;\n    }\n\n    if (config.multidate && !clear) {\n      // get the synmetric difference between origDates and newDates\n      newDates = newDates.reduce(function (dates, date) {\n        if (!origDates.includes(date)) {\n          dates.push(date);\n        }\n\n        return dates;\n      }, origDates.filter(function (date) {\n        return !newDates.includes(date);\n      }));\n    } // do length check always because user can input multiple dates regardless of the mode\n\n\n    return config.maxNumberOfDates && newDates.length > config.maxNumberOfDates ? newDates.slice(config.maxNumberOfDates * -1) : newDates;\n  } // refresh the UI elements\n  // modes: 1: input only, 2, picker only, 3 both\n\n\n  function refreshUI(datepicker) {\n    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n    var quickRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var config = datepicker.config,\n        picker = datepicker.picker,\n        inputField = datepicker.inputField;\n\n    if (mode & 2) {\n      var newView = picker.active ? config.pickLevel : config.startView;\n      picker.update().changeView(newView).render(quickRender);\n    }\n\n    if (mode & 1 && inputField) {\n      inputField.value = stringifyDates(datepicker.dates, config);\n    }\n  }\n\n  function _setDate(datepicker, inputDates, options) {\n    var clear = options.clear,\n        render = options.render,\n        autohide = options.autohide;\n\n    if (render === undefined) {\n      render = true;\n    }\n\n    if (!render) {\n      autohide = false;\n    } else if (autohide === undefined) {\n      autohide = datepicker.config.autohide;\n    }\n\n    var newDates = processInputDates(datepicker, inputDates, clear);\n\n    if (!newDates) {\n      return;\n    }\n\n    if (newDates.toString() !== datepicker.dates.toString()) {\n      datepicker.dates = newDates;\n      refreshUI(datepicker, render ? 3 : 1);\n      triggerDatepickerEvent(datepicker, 'changeDate');\n    } else {\n      refreshUI(datepicker, 1);\n    }\n\n    if (autohide) {\n      datepicker.hide();\n    }\n  }\n  /**\r\n   * Class representing a date picker\r\n   */\n\n\n  var Datepicker = /*#__PURE__*/function () {\n    /**\r\n     * Create a date picker\r\n     * @param  {Element} element - element to bind a date picker\r\n     * @param  {Object} [options] - config options\r\n     * @param  {DateRangePicker} [rangepicker] - DateRangePicker instance the\r\n     * date picker belongs to. Use this only when creating date picker as a part\r\n     * of date range picker\r\n     */\n    function Datepicker(element) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var rangepicker = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n      _classCallCheck(this, Datepicker);\n\n      element.datepicker = this;\n      this.element = element; // set up config\n\n      var config = this.config = Object.assign({\n        buttonClass: options.buttonClass && String(options.buttonClass) || 'button',\n        container: document.body,\n        defaultViewDate: today(),\n        maxDate: undefined,\n        minDate: undefined\n      }, processOptions(options_defaultOptions, this));\n      this._options = options;\n      Object.assign(config, processOptions(options, this)); // configure by type\n\n      var inline = this.inline = element.tagName !== 'INPUT';\n      var inputField;\n      var initialDates;\n\n      if (inline) {\n        config.container = element;\n        initialDates = stringToArray(element.dataset.date, config.dateDelimiter);\n        delete element.dataset.date;\n      } else {\n        var container = options.container ? document.querySelector(options.container) : null;\n\n        if (container) {\n          config.container = container;\n        }\n\n        inputField = this.inputField = element;\n        inputField.classList.add('datepicker-input');\n        initialDates = stringToArray(inputField.value, config.dateDelimiter);\n      }\n\n      if (rangepicker) {\n        // check validiry\n        var index = rangepicker.inputs.indexOf(inputField);\n        var datepickers = rangepicker.datepickers;\n\n        if (index < 0 || index > 1 || !Array.isArray(datepickers)) {\n          throw Error('Invalid rangepicker object.');\n        } // attach itaelf to the rangepicker here so that processInputDates() can\n        // determine if this is the range-end picker of the rangepicker while\n        // setting inital values when pickLevel > 0\n\n\n        datepickers[index] = this; // add getter for rangepicker\n\n        Object.defineProperty(this, 'rangepicker', {\n          get: function get() {\n            return rangepicker;\n          }\n        });\n      } // set initial dates\n\n\n      this.dates = []; // process initial value\n\n      var inputDateValues = processInputDates(this, initialDates);\n\n      if (inputDateValues && inputDateValues.length > 0) {\n        this.dates = inputDateValues;\n      }\n\n      if (inputField) {\n        inputField.value = stringifyDates(this.dates, config);\n      }\n\n      var picker = this.picker = new Picker(this);\n\n      if (inline) {\n        this.show();\n      } else {\n        // set up event listeners in other modes\n        var onMousedownDocument = onClickOutside.bind(null, this);\n        var listeners = [[inputField, 'keydown', onKeydown.bind(null, this)], [inputField, 'focus', onFocus.bind(null, this)], [inputField, 'mousedown', onMousedown.bind(null, this)], [inputField, 'click', onClickInput.bind(null, this)], [inputField, 'paste', onPaste.bind(null, this)], [document, 'mousedown', onMousedownDocument], [document, 'touchstart', onMousedownDocument], [window, 'resize', picker.place.bind(picker)]];\n        registerListeners(this, listeners);\n      }\n    }\n    /**\r\n     * Format Date object or time value in given format and language\r\n     * @param  {Date|Number} date - date or time value to format\r\n     * @param  {String|Object} format - format string or object that contains\r\n     * toDisplay() custom formatter, whose signature is\r\n     * - args:\r\n     *   - date: {Date} - Date instance of the date passed to the method\r\n     *   - format: {Object} - the format object passed to the method\r\n     *   - locale: {Object} - locale for the language specified by `lang`\r\n     * - return:\r\n     *     {String} formatted date\r\n     * @param  {String} [lang=en] - language code for the locale to use\r\n     * @return {String} formatted date\r\n     */\n\n\n    _createClass(Datepicker, [{\n      key: \"active\",\n      get:\n      /**\r\n       * @type {Boolean} - Whether the picker element is shown. `true` whne shown\r\n       */\n      function get() {\n        return !!(this.picker && this.picker.active);\n      }\n      /**\r\n       * @type {HTMLDivElement} - DOM object of picker element\r\n       */\n\n    }, {\n      key: \"pickerElement\",\n      get: function get() {\n        return this.picker ? this.picker.element : undefined;\n      }\n      /**\r\n       * Set new values to the config options\r\n       * @param {Object} options - config options to update\r\n       */\n\n    }, {\n      key: \"setOptions\",\n      value: function setOptions(options) {\n        var picker = this.picker;\n        var newOptions = processOptions(options, this);\n        Object.assign(this._options, options);\n        Object.assign(this.config, newOptions);\n        picker.setOptions(newOptions);\n        refreshUI(this, 3);\n      }\n      /**\r\n       * Show the picker element\r\n       */\n\n    }, {\n      key: \"show\",\n      value: function show() {\n        if (this.inputField) {\n          if (this.inputField.disabled) {\n            return;\n          }\n\n          if (this.inputField !== document.activeElement) {\n            this._showing = true;\n            this.inputField.focus();\n            delete this._showing;\n          }\n        }\n\n        this.picker.show();\n      }\n      /**\r\n       * Hide the picker element\r\n       * Not available on inline picker\r\n       */\n\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        if (this.inline) {\n          return;\n        }\n\n        this.picker.hide();\n        this.picker.update().changeView(this.config.startView).render();\n      }\n      /**\r\n       * Destroy the Datepicker instance\r\n       * @return {Detepicker} - the instance destroyed\r\n       */\n\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        this.hide();\n        unregisterListeners(this);\n        this.picker.detach();\n\n        if (!this.inline) {\n          this.inputField.classList.remove('datepicker-input');\n        }\n\n        delete this.element.datepicker;\n        return this;\n      }\n      /**\r\n       * Get the selected date(s)\r\n       *\r\n       * The method returns a Date object of selected date by default, and returns\r\n       * an array of selected dates in multidate mode. If format string is passed,\r\n       * it returns date string(s) formatted in given format.\r\n       *\r\n       * @param  {String} [format] - Format string to stringify the date(s)\r\n       * @return {Date|String|Date[]|String[]} - selected date(s), or if none is\r\n       * selected, empty array in multidate mode and untitled in sigledate mode\r\n       */\n\n    }, {\n      key: \"getDate\",\n      value: function getDate() {\n        var _this9 = this;\n\n        var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n        var callback = format ? function (date) {\n          return _formatDate(date, format, _this9.config.locale);\n        } : function (date) {\n          return new Date(date);\n        };\n\n        if (this.config.multidate) {\n          return this.dates.map(callback);\n        }\n\n        if (this.dates.length > 0) {\n          return callback(this.dates[0]);\n        }\n      }\n      /**\r\n       * Set selected date(s)\r\n       *\r\n       * In multidate mode, you can pass multiple dates as a series of arguments\r\n       * or an array. (Since each date is parsed individually, the type of the\r\n       * dates doesn't have to be the same.)\r\n       * The given dates are used to toggle the select status of each date. The\r\n       * number of selected dates is kept from exceeding the length set to\r\n       * maxNumberOfDates.\r\n       *\r\n       * With clear: true option, the method can be used to clear the selection\r\n       * and to replace the selection instead of toggling in multidate mode.\r\n       * If the option is passed with no date arguments or an empty dates array,\r\n       * it works as \"clear\" (clear the selection then set nothing), and if the\r\n       * option is passed with new dates to select, it works as \"replace\" (clear\r\n       * the selection then set the given dates)\r\n       *\r\n       * When render: false option is used, the method omits re-rendering the\r\n       * picker element. In this case, you need to call refresh() method later in\r\n       * order for the picker element to reflect the changes. The input field is\r\n       * refreshed always regardless of this option.\r\n       *\r\n       * When invalid (unparsable, repeated, disabled or out-of-range) dates are\r\n       * passed, the method ignores them and applies only valid ones. In the case\r\n       * that all the given dates are invalid, which is distinguished from passing\r\n       * no dates, the method considers it as an error and leaves the selection\r\n       * untouched.\r\n       *\r\n       * @param {...(Date|Number|String)|Array} [dates] - Date strings, Date\r\n       * objects, time values or mix of those for new selection\r\n       * @param {Object} [options] - function options\r\n       * - clear: {boolean} - Whether to clear the existing selection\r\n       *     defualt: false\r\n       * - render: {boolean} - Whether to re-render the picker element\r\n       *     default: true\r\n       * - autohide: {boolean} - Whether to hide the picker element after re-render\r\n       *     Ignored when used with render: false\r\n       *     default: config.autohide\r\n       */\n\n    }, {\n      key: \"setDate\",\n      value: function setDate() {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        var dates = [].concat(args);\n        var opts = {};\n        var lastArg = lastItemOf(args);\n\n        if (_typeof(lastArg) === 'object' && !Array.isArray(lastArg) && !(lastArg instanceof Date) && lastArg) {\n          Object.assign(opts, dates.pop());\n        }\n\n        var inputDates = Array.isArray(dates[0]) ? dates[0] : dates;\n\n        _setDate(this, inputDates, opts);\n      }\n      /**\r\n       * Update the selected date(s) with input field's value\r\n       * Not available on inline picker\r\n       *\r\n       * The input field will be refreshed with properly formatted date string.\r\n       *\r\n       * @param  {Object} [options] - function options\r\n       * - autohide: {boolean} - whether to hide the picker element after refresh\r\n       *     default: false\r\n       */\n\n    }, {\n      key: \"update\",\n      value: function update() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n        if (this.inline) {\n          return;\n        }\n\n        var opts = {\n          clear: true,\n          autohide: !!(options && options.autohide)\n        };\n        var inputDates = stringToArray(this.inputField.value, this.config.dateDelimiter);\n\n        _setDate(this, inputDates, opts);\n      }\n      /**\r\n       * Refresh the picker element and the associated input field\r\n       * @param {String} [target] - target item when refreshing one item only\r\n       * 'picker' or 'input'\r\n       * @param {Boolean} [forceRender] - whether to re-render the picker element\r\n       * regardless of its state instead of optimized refresh\r\n       */\n\n    }, {\n      key: \"refresh\",\n      value: function refresh() {\n        var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n        var forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (target && typeof target !== 'string') {\n          forceRender = target;\n          target = undefined;\n        }\n\n        var mode;\n\n        if (target === 'picker') {\n          mode = 2;\n        } else if (target === 'input') {\n          mode = 1;\n        } else {\n          mode = 3;\n        }\n\n        refreshUI(this, mode, !forceRender);\n      }\n      /**\r\n       * Enter edit mode\r\n       * Not available on inline picker or when the picker element is hidden\r\n       */\n\n    }, {\n      key: \"enterEditMode\",\n      value: function enterEditMode() {\n        if (this.inline || !this.picker.active || this.editMode) {\n          return;\n        }\n\n        this.editMode = true;\n        this.inputField.classList.add('in-edit', 'border-blue-700');\n      }\n      /**\r\n       * Exit from edit mode\r\n       * Not available on inline picker\r\n       * @param  {Object} [options] - function options\r\n       * - update: {boolean} - whether to call update() after exiting\r\n       *     If false, input field is revert to the existing selection\r\n       *     default: false\r\n       */\n\n    }, {\n      key: \"exitEditMode\",\n      value: function exitEditMode() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n        if (this.inline || !this.editMode) {\n          return;\n        }\n\n        var opts = Object.assign({\n          update: false\n        }, options);\n        delete this.editMode;\n        this.inputField.classList.remove('in-edit', 'border-blue-700');\n\n        if (opts.update) {\n          this.update(opts);\n        }\n      }\n    }], [{\n      key: \"formatDate\",\n      value: function formatDate(date, format, lang) {\n        return _formatDate(date, format, lang && locales[lang] || locales.en);\n      }\n      /**\r\n       * Parse date string\r\n       * @param  {String|Date|Number} dateStr - date string, Date object or time\r\n       * value to parse\r\n       * @param  {String|Object} format - format string or object that contains\r\n       * toValue() custom parser, whose signature is\r\n       * - args:\r\n       *   - dateStr: {String|Date|Number} - the dateStr passed to the method\r\n       *   - format: {Object} - the format object passed to the method\r\n       *   - locale: {Object} - locale for the language specified by `lang`\r\n       * - return:\r\n       *     {Date|Number} parsed date or its time value\r\n       * @param  {String} [lang=en] - language code for the locale to use\r\n       * @return {Number} time value of parsed date\r\n       */\n\n    }, {\n      key: \"parseDate\",\n      value: function parseDate(dateStr, format, lang) {\n        return _parseDate(dateStr, format, lang && locales[lang] || locales.en);\n      }\n      /**\r\n       * @type {Object} - Installed locales in `[languageCode]: localeObject` format\r\n       * en`:_English (US)_ is pre-installed.\r\n       */\n\n    }, {\n      key: \"locales\",\n      get: function get() {\n        return locales;\n      }\n    }]);\n\n    return Datepicker;\n  }();\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/DateRangePicker.js\n  // filter out the config options inapproprite to pass to Datepicker\n\n  function filterOptions(options) {\n    var newOpts = Object.assign({}, options);\n    delete newOpts.inputs;\n    delete newOpts.allowOneSidedRange;\n    delete newOpts.maxNumberOfDates; // to ensure each datepicker handles a single date\n\n    return newOpts;\n  }\n\n  function setupDatepicker(rangepicker, changeDateListener, el, options) {\n    registerListeners(rangepicker, [[el, 'changeDate', changeDateListener]]);\n    new Datepicker(el, options, rangepicker);\n  }\n\n  function onChangeDate(rangepicker, ev) {\n    // to prevent both datepickers trigger the other side's update each other\n    if (rangepicker._updating) {\n      return;\n    }\n\n    rangepicker._updating = true;\n    var target = ev.target;\n\n    if (target.datepicker === undefined) {\n      return;\n    }\n\n    var datepickers = rangepicker.datepickers;\n    var setDateOptions = {\n      render: false\n    };\n    var changedSide = rangepicker.inputs.indexOf(target);\n    var otherSide = changedSide === 0 ? 1 : 0;\n    var changedDate = datepickers[changedSide].dates[0];\n    var otherDate = datepickers[otherSide].dates[0];\n\n    if (changedDate !== undefined && otherDate !== undefined) {\n      // if the start of the range > the end, swap them\n      if (changedSide === 0 && changedDate > otherDate) {\n        datepickers[0].setDate(otherDate, setDateOptions);\n        datepickers[1].setDate(changedDate, setDateOptions);\n      } else if (changedSide === 1 && changedDate < otherDate) {\n        datepickers[0].setDate(changedDate, setDateOptions);\n        datepickers[1].setDate(otherDate, setDateOptions);\n      }\n    } else if (!rangepicker.allowOneSidedRange) {\n      // to prevent the range from becoming one-sided, copy changed side's\n      // selection (no matter if it's empty) to the other side\n      if (changedDate !== undefined || otherDate !== undefined) {\n        setDateOptions.clear = true;\n        datepickers[otherSide].setDate(datepickers[changedSide].dates, setDateOptions);\n      }\n    }\n\n    datepickers[0].picker.update().render();\n    datepickers[1].picker.update().render();\n    delete rangepicker._updating;\n  }\n  /**\r\n   * Class representing a date range picker\r\n   */\n\n\n  var DateRangePicker = /*#__PURE__*/function () {\n    /**\r\n     * Create a date range picker\r\n     * @param  {Element} element - element to bind a date range picker\r\n     * @param  {Object} [options] - config options\r\n     */\n    function DateRangePicker(element) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _classCallCheck(this, DateRangePicker);\n\n      var inputs = Array.isArray(options.inputs) ? options.inputs : Array.from(element.querySelectorAll('input'));\n\n      if (inputs.length < 2) {\n        return;\n      }\n\n      element.rangepicker = this;\n      this.element = element;\n      this.inputs = inputs.slice(0, 2);\n      this.allowOneSidedRange = !!options.allowOneSidedRange;\n      var changeDateListener = onChangeDate.bind(null, this);\n      var cleanOptions = filterOptions(options); // in order for initial date setup to work right when pcicLvel > 0,\n      // let Datepicker constructor add the instance to the rangepicker\n\n      var datepickers = [];\n      Object.defineProperty(this, 'datepickers', {\n        get: function get() {\n          return datepickers;\n        }\n      });\n      setupDatepicker(this, changeDateListener, this.inputs[0], cleanOptions);\n      setupDatepicker(this, changeDateListener, this.inputs[1], cleanOptions);\n      Object.freeze(datepickers); // normalize the range if inital dates are given\n\n      if (datepickers[0].dates.length > 0) {\n        onChangeDate(this, {\n          target: this.inputs[0]\n        });\n      } else if (datepickers[1].dates.length > 0) {\n        onChangeDate(this, {\n          target: this.inputs[1]\n        });\n      }\n    }\n    /**\r\n     * @type {Array} - selected date of the linked date pickers\r\n     */\n\n\n    _createClass(DateRangePicker, [{\n      key: \"dates\",\n      get: function get() {\n        return this.datepickers.length === 2 ? [this.datepickers[0].dates[0], this.datepickers[1].dates[0]] : undefined;\n      }\n      /**\r\n       * Set new values to the config options\r\n       * @param {Object} options - config options to update\r\n       */\n\n    }, {\n      key: \"setOptions\",\n      value: function setOptions(options) {\n        this.allowOneSidedRange = !!options.allowOneSidedRange;\n        var cleanOptions = filterOptions(options);\n        this.datepickers[0].setOptions(cleanOptions);\n        this.datepickers[1].setOptions(cleanOptions);\n      }\n      /**\r\n       * Destroy the DateRangePicker instance\r\n       * @return {DateRangePicker} - the instance destroyed\r\n       */\n\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        this.datepickers[0].destroy();\n        this.datepickers[1].destroy();\n        unregisterListeners(this);\n        delete this.element.rangepicker;\n      }\n      /**\r\n       * Get the start and end dates of the date range\r\n       *\r\n       * The method returns Date objects by default. If format string is passed,\r\n       * it returns date strings formatted in given format.\r\n       * The result array always contains 2 items (start date/end date) and\r\n       * undefined is used for unselected side. (e.g. If none is selected,\r\n       * the result will be [undefined, undefined]. If only the end date is set\r\n       * when allowOneSidedRange config option is true, [undefined, endDate] will\r\n       * be returned.)\r\n       *\r\n       * @param  {String} [format] - Format string to stringify the dates\r\n       * @return {Array} - Start and end dates\r\n       */\n\n    }, {\n      key: \"getDates\",\n      value: function getDates() {\n        var _this10 = this;\n\n        var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n        var callback = format ? function (date) {\n          return _formatDate(date, format, _this10.datepickers[0].config.locale);\n        } : function (date) {\n          return new Date(date);\n        };\n        return this.dates.map(function (date) {\n          return date === undefined ? date : callback(date);\n        });\n      }\n      /**\r\n       * Set the start and end dates of the date range\r\n       *\r\n       * The method calls datepicker.setDate() internally using each of the\r\n       * arguments in startend order.\r\n       *\r\n       * When a clear: true option object is passed instead of a date, the method\r\n       * clears the date.\r\n       *\r\n       * If an invalid date, the same date as the current one or an option object\r\n       * without clear: true is passed, the method considers that argument as an\r\n       * \"ineffective\" argument because calling datepicker.setDate() with those\r\n       * values makes no changes to the date selection.\r\n       *\r\n       * When the allowOneSidedRange config option is false, passing {clear: true}\r\n       * to clear the range works only when it is done to the last effective\r\n       * argument (in other words, passed to rangeEnd or to rangeStart along with\r\n       * ineffective rangeEnd). This is because when the date range is changed,\r\n       * it gets normalized based on the last change at the end of the changing\r\n       * process.\r\n       *\r\n       * @param {Date|Number|String|Object} rangeStart - Start date of the range\r\n       * or {clear: true} to clear the date\r\n       * @param {Date|Number|String|Object} rangeEnd - End date of the range\r\n       * or {clear: true} to clear the date\r\n       */\n\n    }, {\n      key: \"setDates\",\n      value: function setDates(rangeStart, rangeEnd) {\n        var _this$datepickers = _slicedToArray(this.datepickers, 2),\n            datepicker0 = _this$datepickers[0],\n            datepicker1 = _this$datepickers[1];\n\n        var origDates = this.dates; // If range normalization runs on every change, we can't set a new range\n        // that starts after the end of the current range correctly because the\n        // normalization process swaps startend right after setting the new start\n        // date. To prevent this, the normalization process needs to run once after\n        // both of the new dates are set.\n\n        this._updating = true;\n        datepicker0.setDate(rangeStart);\n        datepicker1.setDate(rangeEnd);\n        delete this._updating;\n\n        if (datepicker1.dates[0] !== origDates[1]) {\n          onChangeDate(this, {\n            target: this.inputs[1]\n          });\n        } else if (datepicker0.dates[0] !== origDates[0]) {\n          onChangeDate(this, {\n            target: this.inputs[0]\n          });\n        }\n      }\n    }]);\n\n    return DateRangePicker;\n  }();\n\n  ; // CONCATENATED MODULE: ./src/plugins/datepicker.js\n\n  var getDatepickerOptions = function getDatepickerOptions(datepickerEl) {\n    var buttons = datepickerEl.hasAttribute('datepicker-buttons');\n    var autohide = datepickerEl.hasAttribute('datepicker-autohide');\n    var format = datepickerEl.hasAttribute('datepicker-format');\n    var orientation = datepickerEl.hasAttribute('datepicker-orientation');\n    var title = datepickerEl.hasAttribute('datepicker-title');\n    var options = {};\n\n    if (buttons) {\n      options.todayBtn = true;\n      options.clearBtn = true;\n    }\n\n    if (autohide) {\n      options.autohide = true;\n    }\n\n    if (format) {\n      options.format = datepickerEl.getAttribute('datepicker-format');\n    }\n\n    if (orientation) {\n      options.orientation = datepickerEl.getAttribute('datepicker-orientation');\n    }\n\n    if (title) {\n      options.title = datepickerEl.getAttribute('datepicker-title');\n    }\n\n    return options;\n  };\n\n  document.addEventListener('DOMContentLoaded', function () {\n    document.querySelectorAll('[datepicker]').forEach(function (datepickerEl) {\n      new Datepicker(datepickerEl, getDatepickerOptions(datepickerEl));\n    });\n    document.querySelectorAll('[inline-datepicker]').forEach(function (datepickerEl) {\n      new Datepicker(datepickerEl, getDatepickerOptions(datepickerEl));\n    });\n    document.querySelectorAll('[date-rangepicker]').forEach(function (datepickerEl) {\n      new DateRangePicker(datepickerEl, getDatepickerOptions(datepickerEl));\n    });\n  });\n  /******/\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvZGF0ZXBpY2tlci5qcz80NTdmIl0sIm5hbWVzIjpbIl9fd2VicGFja19leHBvcnRzX18iLCJoYXNQcm9wZXJ0eSIsIm9iaiIsInByb3AiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJsYXN0SXRlbU9mIiwiYXJyIiwibGVuZ3RoIiwicHVzaFVuaXF1ZSIsIml0ZW1zIiwiZm9yRWFjaCIsIml0ZW0iLCJpbmNsdWRlcyIsInB1c2giLCJzdHJpbmdUb0FycmF5Iiwic3RyIiwic2VwYXJhdG9yIiwic3BsaXQiLCJpc0luUmFuZ2UiLCJ0ZXN0VmFsIiwibWluIiwibWF4IiwibWluT0siLCJ1bmRlZmluZWQiLCJtYXhPSyIsImxpbWl0VG9SYW5nZSIsInZhbCIsImNyZWF0ZVRhZ1JlcGVhdCIsInRhZ05hbWUiLCJyZXBlYXQiLCJhdHRyaWJ1dGVzIiwiaW5kZXgiLCJodG1sIiwib3BlblRhZ1NyYyIsImtleXMiLCJyZWR1Y2UiLCJzcmMiLCJhdHRyIiwibmV4dCIsIm9wdGltaXplVGVtcGxhdGVIVE1MIiwicmVwbGFjZSIsInN0cmlwVGltZSIsInRpbWVWYWx1ZSIsIkRhdGUiLCJzZXRIb3VycyIsInRvZGF5IiwiZGF0ZVZhbHVlIiwibmV3RGF0ZSIsInNldEZ1bGxZZWFyIiwiYWRkRGF5cyIsImRhdGUiLCJhbW91bnQiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsImFkZFdlZWtzIiwiYWRkTW9udGhzIiwibW9udGhzVG9TZXQiLCJnZXRNb250aCIsImV4cGVjdGVkTW9udGgiLCJ0aW1lIiwic2V0TW9udGgiLCJhZGRZZWFycyIsImdldEZ1bGxZZWFyIiwiZGF5RGlmZiIsImRheSIsImZyb20iLCJkYXlPZlRoZVdlZWtPZiIsImJhc2VEYXRlIiwiZGF5T2ZXZWVrIiwid2Vla1N0YXJ0IiwiYmFzZURheSIsImdldERheSIsImdldFdlZWsiLCJ0aHVPZlRoZVdlZWsiLCJmaXJzdFRodSIsIk1hdGgiLCJyb3VuZCIsInN0YXJ0T2ZZZWFyUGVyaW9kIiwieWVhcnMiLCJ5ZWFyIiwiZmxvb3IiLCJyZUZvcm1hdFRva2VucyIsInJlTm9uRGF0ZVBhcnRzIiwia25vd25Gb3JtYXRzIiwicGFyc2VGbnMiLCJ5IiwicGFyc2VJbnQiLCJtIiwibW9udGgiLCJsb2NhbGUiLCJtb250aEluZGV4IiwiaXNOYU4iLCJOYU4iLCJtb250aE5hbWUiLCJ0b0xvd2VyQ2FzZSIsImNvbXBhcmVOYW1lcyIsIm5hbWUiLCJzdGFydHNXaXRoIiwibW9udGhzU2hvcnQiLCJmaW5kSW5kZXgiLCJtb250aHMiLCJub3JtYWxpemVNb250aCIsImdldFRpbWUiLCJkIiwiZm9ybWF0Rm5zIiwiZGQiLCJwYWRaZXJvIiwiRCIsImRheXNTaG9ydCIsIkREIiwiZGF5cyIsIm1tIiwiTSIsIk1NIiwieXkiLCJzbGljZSIsInl5eXkiLCJudW0iLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwicGFyc2VGb3JtYXRTdHJpbmciLCJmb3JtYXQiLCJFcnJvciIsInNlcGFyYXRvcnMiLCJwYXJ0cyIsIm1hdGNoIiwiUmVnRXhwIiwicGFydEZvcm1hdHRlcnMiLCJtYXAiLCJ0b2tlbiIsInBhcnRQYXJzZXJLZXlzIiwia2V5IiwiZmluZCIsInBhcnQiLCJwYXJzZXIiLCJkYXRlU3RyIiwiZGF0ZVBhcnRzIiwiZHRQYXJ0cyIsIm9yaWdEYXRlIiwiZm9ybWF0dGVyIiwiZm4iLCJwYXJzZURhdGUiLCJ0b1ZhbHVlIiwiZm9ybWF0RGF0ZSIsImRhdGVPYmoiLCJ0b0Rpc3BsYXkiLCJsaXN0ZW5lclJlZ2lzdHJ5IiwiV2Vha01hcCIsIkV2ZW50VGFyZ2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZWdpc3Rlckxpc3RlbmVycyIsImtleU9iaiIsImxpc3RlbmVycyIsInJlZ2lzdGVyZWQiLCJnZXQiLCJzZXQiLCJsaXN0ZW5lciIsInVucmVnaXN0ZXJMaXN0ZW5lcnMiLCJFdmVudCIsImNvbXBvc2VkUGF0aCIsImdldENvbXBvc2VkUGF0aCIsIm5vZGUiLCJwYXRoIiwicGFyZW50IiwicGFyZW50Tm9kZSIsImhvc3QiLCJkZWZhdWx0VmlldyIsInRhcmdldCIsImZpbmRGcm9tUGF0aCIsImNyaXRlcmlhIiwiY3VycmVudFRhcmdldCIsImVsIiwicGFyZW50RWxlbWVudCIsImZpbmRFbGVtZW50SW5FdmVudFBhdGgiLCJldiIsInNlbGVjdG9yIiwibWF0Y2hlcyIsImxvY2FsZXMiLCJlbiIsImRheXNNaW4iLCJjbGVhciIsInRpdGxlRm9ybWF0IiwiZGVmYXVsdE9wdGlvbnMiLCJhdXRvaGlkZSIsImJlZm9yZVNob3dEYXkiLCJiZWZvcmVTaG93RGVjYWRlIiwiYmVmb3JlU2hvd01vbnRoIiwiYmVmb3JlU2hvd1llYXIiLCJjYWxlbmRhcldlZWtzIiwiY2xlYXJCdG4iLCJkYXRlRGVsaW1pdGVyIiwiZGF0ZXNEaXNhYmxlZCIsImRheXNPZldlZWtEaXNhYmxlZCIsImRheXNPZldlZWtIaWdobGlnaHRlZCIsImRlZmF1bHRWaWV3RGF0ZSIsImRpc2FibGVUb3VjaEtleWJvYXJkIiwibGFuZ3VhZ2UiLCJtYXhEYXRlIiwibWF4TnVtYmVyT2ZEYXRlcyIsIm1heFZpZXciLCJtaW5EYXRlIiwibmV4dEFycm93Iiwib3JpZW50YXRpb24iLCJwaWNrTGV2ZWwiLCJwcmV2QXJyb3ciLCJzaG93RGF5c09mV2VlayIsInNob3dPbkNsaWNrIiwic2hvd09uRm9jdXMiLCJzdGFydFZpZXciLCJ0aXRsZSIsInRvZGF5QnRuIiwidG9kYXlCdG5Nb2RlIiwidG9kYXlIaWdobGlnaHQiLCJ1cGRhdGVPbkJsdXIiLCJvcHRpb25zX2RlZmF1bHRPcHRpb25zIiwicmFuZ2UiLCJkb2N1bWVudCIsImNyZWF0ZVJhbmdlIiwicGFyc2VIVE1MIiwiY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50IiwiaXNWaXNpYmxlIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJnZXRDbGllbnRSZWN0cyIsImhpZGVFbGVtZW50Iiwic3R5bGUiLCJkaXNwbGF5IiwiZGF0YXNldCIsInN0eWxlRGlzcGxheSIsInNob3dFbGVtZW50IiwiZW1wdHlDaGlsZE5vZGVzIiwiZmlyc3RDaGlsZCIsInJlbW92ZUNoaWxkIiwicmVwbGFjZUNoaWxkTm9kZXMiLCJuZXdDaGlsZE5vZGVzIiwiRG9jdW1lbnRGcmFnbWVudCIsImFwcGVuZENoaWxkIiwiZGVmYXVsdExhbmciLCJkZWZhdWx0Rm9ybWF0IiwiZGVmYXVsdFdlZWtTdGFydCIsInNhbml0aXplRE9XIiwiZG93IiwiY2FsY0VuZE9mV2VlayIsInN0YXJ0T2ZXZWVrIiwidmFsaWRhdGVEYXRlIiwidmFsdWUiLCJvcmlnVmFsdWUiLCJ2YWxpZGF0ZVZpZXdJZCIsInZpZXdJZCIsInByb2Nlc3NPcHRpb25zIiwib3B0aW9ucyIsImRhdGVwaWNrZXIiLCJpbk9wdHMiLCJhc3NpZ24iLCJjb25maWciLCJjb25zdHJ1Y3RvciIsImxhbmciLCJvcmlnTG9jYWxlIiwid2Vla0VuZCIsImhhc1RvRGlzcGxheSIsImhhc1RvVmFsdWUiLCJ2YWxpZEZvcm1hdFN0cmluZyIsInRlc3QiLCJtaW5EdCIsIm1heER0IiwiZGF0ZXMiLCJkdCIsInZpZXdEYXRlIiwid2tTdGFydCIsIk51bWJlciIsIm11bHRpZGF0ZSIsIlN0cmluZyIsIm5ld1BpY2tMZXZlbCIsIm5ld01heFZpZXciLCJuZXdTdGFydFZpZXciLCJjaGlsZE5vZGVzIiwieCIsInBpY2tlclRlbXBsYXRlIiwidGVtcGxhdGVzX3BpY2tlclRlbXBsYXRlIiwiZGF5c1RlbXBsYXRlIiwidGVtcGxhdGVzX2RheXNUZW1wbGF0ZSIsImNhbGVuZGFyV2Vla3NUZW1wbGF0ZSIsInRlbXBsYXRlc19jYWxlbmRhcldlZWtzVGVtcGxhdGUiLCJWaWV3IiwicGlja2VyIiwiZWxlbWVudCIsInNlbGVjdGVkIiwiaW5pdCIsImlzTWluVmlldyIsImlkIiwic2V0T3B0aW9ucyIsInVwZGF0ZUZvY3VzIiwidXBkYXRlU2VsZWN0aW9uIiwiY3VycmVudCIsInJlc3VsdCIsImJlZm9yZVNob3ciLCJlbmFibGVkIiwiY2xhc3NlcyIsImNsYXNzTGlzdCIsImFkZCIsImRpc2FibGVkIiwiZXh0cmFDbGFzc2VzIiwiY29udGVudCIsIkRheXNWaWV3IiwiY2VsbENsYXNzIiwib25Db25zdHJ1Y3Rpb24iLCJpbm5lciIsImdyaWQiLCJsYXN0Q2hpbGQiLCJ1cGRhdGVET1ciLCJkYXlOYW1lcyIsInN3aXRjaExhYmVsRm9ybWF0Iiwid2Vla3NFbGVtIiwid2Vla3MiLCJpbnNlcnRCZWZvcmUiLCJBcnJheSIsImNoaWxkcmVuIiwidGV4dENvbnRlbnQiLCJjbGFzc05hbWUiLCJ2aWV3WWVhciIsInZpZXdNb250aCIsImZpcnN0T2ZNb250aCIsInN0YXJ0IiwiZmlyc3QiLCJsYXN0IiwiZm9jdXNlZCIsInJhbmdlcGlja2VyIiwic3dpdGNoTGFiZWwiLCJzZXRWaWV3U3dpdGNoTGFiZWwiLCJzZXRQcmV2QnRuRGlzYWJsZWQiLCJzZXROZXh0QnRuRGlzYWJsZWQiLCJyYW5nZVN0YXJ0IiwicmFuZ2VFbmQiLCJyZW1vdmUiLCJwZXJmb3JtQmVmb3JlSG9vayIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJjb21wdXRlTW9udGhSYW5nZSIsInRoaXNZZWFyIiwic3RhcnRZIiwic3RhcnRNIiwiZW5kWSIsImVuZE0iLCJNb250aHNWaWV3IiwiaXgiLCJtb250aE5hbWVzIiwibWluWWVhciIsIm1pbk1vbnRoIiwibWluRGF0ZU9iaiIsIm1heFllYXIiLCJtYXhNb250aCIsIm1heERhdGVPYmoiLCJ5ck91dE9mUmFuZ2UiLCJpc01pblllYXIiLCJpc01heFllYXIiLCJ0b1RpdGxlQ2FzZSIsIndvcmQiLCJjaCIsInRvVXBwZXJDYXNlIiwiWWVhcnNWaWV3IiwibmF2U3RlcCIsInN0ZXAiLCJiZWZvcmVTaG93T3B0aW9uIiwidHJpZ2dlckRhdGVwaWNrZXJFdmVudCIsInR5cGUiLCJkZXRhaWwiLCJjdXJyZW50VmlldyIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsImdvVG9QcmV2T3JOZXh0IiwiZGlyZWN0aW9uIiwibmV3Vmlld0RhdGUiLCJjaGFuZ2VGb2N1cyIsInJlbmRlciIsInN3aXRjaFZpZXciLCJjaGFuZ2VWaWV3IiwidW5mb2N1cyIsInVwZGF0ZSIsInJlZnJlc2giLCJoaWRlIiwiZ29Ub1NlbGVjdGVkTW9udGhPclllYXIiLCJzZWxlY3Rpb24iLCJvbkNsaWNrVG9kYXlCdG4iLCJjdXJyZW50RGF0ZSIsIm9uQ2xpY2tDbGVhckJ0biIsIm9uQ2xpY2tWaWV3U3dpdGNoIiwib25DbGlja1ByZXZCdG4iLCJvbkNsaWNrTmV4dEJ0biIsIm9uQ2xpY2tWaWV3IiwiY29udGFpbnMiLCJvbkNsaWNrUGlja2VyIiwiaW5saW5lIiwiaW5wdXRGaWVsZCIsImZvY3VzIiwicHJvY2Vzc1BpY2tlck9wdGlvbnMiLCJjb250cm9scyIsInByZXZCdG4iLCJjbG9uZU5vZGUiLCJuZXh0QnRuIiwiY29tcHV0ZVJlc2V0Vmlld0RhdGUiLCJzZXRWaWV3RGF0ZSIsIm9sZFZpZXdEYXRlIiwiZ2V0VGV4dERpcmVjdGlvbiIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJQaWNrZXIiLCJ0ZW1wbGF0ZSIsImJ1dHRvbkNsYXNzIiwiaGVhZGVyIiwibWFpbiIsImZvb3RlciIsImZpcnN0RWxlbWVudENoaWxkIiwibGFzdEVsZW1lbnRDaGlsZCIsInZpZXdTd2l0Y2giLCJlbGVtZW50Q2xhc3MiLCJiaW5kIiwiY2FwdHVyZSIsInZpZXdzIiwiY29udGFpbmVyIiwidmlldyIsImFjdGl2ZSIsImlucHV0RGlyZWN0aW9uIiwiZGlyIiwicmVtb3ZlQXR0cmlidXRlIiwicGxhY2UiLCJibHVyIiwiZXhpdEVkaXRNb2RlIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2FsZW5kYXJXaWR0aCIsIndpZHRoIiwiY2FsZW5kYXJIZWlnaHQiLCJoZWlnaHQiLCJjb250YWluZXJMZWZ0IiwibGVmdCIsImNvbnRhaW5lclRvcCIsInRvcCIsImNvbnRhaW5lcldpZHRoIiwiaW5wdXRMZWZ0IiwiaW5wdXRUb3AiLCJpbnB1dFdpZHRoIiwiaW5wdXRIZWlnaHQiLCJvcmllbnRYIiwib3JpZW50WSIsInNjcm9sbFRvcCIsImJvZHkiLCJzY3JvbGxZIiwic2Nyb2xsWCIsImxhYmVsVGV4dCIsIm9sZFZpZXciLCJuZXdWaWV3IiwiX3JlbmRlck1ldGhvZCIsInJlcGxhY2VDaGlsZCIsInF1aWNrUmVuZGVyIiwicmVuZGVyTWV0aG9kIiwiZmluZE5leHRBdmFpbGFibGVPbmUiLCJhZGRGbiIsImluY3JlYXNlIiwidGVzdEZuIiwibW92ZUJ5QXJyb3dLZXkiLCJ2ZXJ0aWNhbCIsImN0cmxLZXkiLCJtZXRhS2V5Iiwib25LZXlkb3duIiwic2hvdyIsImVkaXRNb2RlIiwic2hpZnRLZXkiLCJlbnRlckVkaXRNb2RlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJvbkZvY3VzIiwiX3Nob3dpbmciLCJvbk1vdXNlZG93biIsIl9hY3RpdmUiLCJhY3RpdmVFbGVtZW50IiwiX2NsaWNraW5nIiwic2V0VGltZW91dCIsIm9uQ2xpY2tJbnB1dCIsImNsZWFyVGltZW91dCIsIm9uUGFzdGUiLCJjbGlwYm9hcmREYXRhIiwidHlwZXMiLCJvbkNsaWNrT3V0c2lkZSIsInBpY2tlckVsZW0iLCJzdHJpbmdpZnlEYXRlcyIsImpvaW4iLCJwcm9jZXNzSW5wdXREYXRlcyIsImlucHV0RGF0ZXMiLCJvcmlnRGF0ZXMiLCJkYXRlcGlja2VycyIsIm5ld0RhdGVzIiwiZmlsdGVyIiwicmVmcmVzaFVJIiwibW9kZSIsIkRhdGVwaWNrZXIiLCJfb3B0aW9ucyIsImluaXRpYWxEYXRlcyIsInF1ZXJ5U2VsZWN0b3IiLCJpbnB1dHMiLCJpbmRleE9mIiwiaXNBcnJheSIsImRlZmluZVByb3BlcnR5IiwiaW5wdXREYXRlVmFsdWVzIiwib25Nb3VzZWRvd25Eb2N1bWVudCIsIm5ld09wdGlvbnMiLCJkZXRhY2giLCJjYWxsYmFjayIsImFyZ3MiLCJvcHRzIiwibGFzdEFyZyIsInBvcCIsImZvcmNlUmVuZGVyIiwiZmlsdGVyT3B0aW9ucyIsIm5ld09wdHMiLCJhbGxvd09uZVNpZGVkUmFuZ2UiLCJzZXR1cERhdGVwaWNrZXIiLCJjaGFuZ2VEYXRlTGlzdGVuZXIiLCJvbkNoYW5nZURhdGUiLCJfdXBkYXRpbmciLCJzZXREYXRlT3B0aW9ucyIsImNoYW5nZWRTaWRlIiwib3RoZXJTaWRlIiwiY2hhbmdlZERhdGUiLCJvdGhlckRhdGUiLCJEYXRlUmFuZ2VQaWNrZXIiLCJjbGVhbk9wdGlvbnMiLCJmcmVlemUiLCJkZXN0cm95IiwiZGF0ZXBpY2tlcjAiLCJkYXRlcGlja2VyMSIsImdldERhdGVwaWNrZXJPcHRpb25zIiwiZGF0ZXBpY2tlckVsIiwiYnV0dG9ucyIsImhhc0F0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQVMsQ0FBQyxZQUFNO0FBQUU7O0FBQ2xCO0FBQVU7O0FBQ1YsTUFBSUEsbUJBQW1CLEdBQUcsRUFBMUI7QUFFQSxHQUpnQixDQUlmOztBQUNELFdBQVNDLFdBQVQsQ0FBcUJDLEdBQXJCLEVBQTBCQyxJQUExQixFQUFnQztBQUM5QixXQUFPQyxNQUFNLENBQUNDLFNBQVAsQ0FBaUJDLGNBQWpCLENBQWdDQyxJQUFoQyxDQUFxQ0wsR0FBckMsRUFBMENDLElBQTFDLENBQVA7QUFDRDs7QUFFRCxXQUFTSyxVQUFULENBQW9CQyxHQUFwQixFQUF5QjtBQUN2QixXQUFPQSxHQUFHLENBQUNBLEdBQUcsQ0FBQ0MsTUFBSixHQUFhLENBQWQsQ0FBVjtBQUNELEdBWGUsQ0FhaEI7OztBQUNBLFdBQVNDLFVBQVQsQ0FBb0JGLEdBQXBCLEVBQW1DO0FBQUEsc0NBQVBHLEtBQU87QUFBUEEsTUFBQUEsS0FBTztBQUFBOztBQUNqQ0EsSUFBQUEsS0FBSyxDQUFDQyxPQUFOLENBQWMsVUFBQ0MsSUFBRCxFQUFVO0FBQ3RCLFVBQUlMLEdBQUcsQ0FBQ00sUUFBSixDQUFhRCxJQUFiLENBQUosRUFBd0I7QUFDdEI7QUFDRDs7QUFD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Z0JnVSxZQUFZLENBQUNHLFlBQWIsQ0FBMEIsa0JBQTFCLENBQWhCO0FBQ0Q7O0FBRUQsV0FBTzFSLE9BQVA7QUFDRCxHQTlCRDs7QUFnQ0FsQyxFQUFBQSxRQUFRLENBQUNwRSxnQkFBVCxDQUEwQixrQkFBMUIsRUFBOEMsWUFBTTtBQUNsRG9FLElBQUFBLFFBQVEsQ0FBQ3VILGdCQUFULENBQTBCLGNBQTFCLEVBQTBDdFUsT0FBMUMsQ0FBa0QsVUFBVXdnQixZQUFWLEVBQXdCO0FBQ3hFLFVBQUlyQyxVQUFKLENBQWVxQyxZQUFmLEVBQTZCRCxvQkFBb0IsQ0FBQ0MsWUFBRCxDQUFqRDtBQUNELEtBRkQ7QUFHQXpULElBQUFBLFFBQVEsQ0FBQ3VILGdCQUFULENBQTBCLHFCQUExQixFQUFpRHRVLE9BQWpELENBQXlELFVBQVV3Z0IsWUFBVixFQUF3QjtBQUMvRSxVQUFJckMsVUFBSixDQUFlcUMsWUFBZixFQUE2QkQsb0JBQW9CLENBQUNDLFlBQUQsQ0FBakQ7QUFDRCxLQUZEO0FBR0F6VCxJQUFBQSxRQUFRLENBQUN1SCxnQkFBVCxDQUEwQixvQkFBMUIsRUFBZ0R0VSxPQUFoRCxDQUF3RCxVQUFVd2dCLFlBQVYsRUFBd0I7QUFDOUUsVUFBSVAsZUFBSixDQUFvQk8sWUFBcEIsRUFBa0NELG9CQUFvQixDQUFDQyxZQUFELENBQXREO0FBQ0QsS0FGRDtBQUdELEdBVkQ7QUFXQTtBQUFVLENBajNGRCIsInNvdXJjZXNDb250ZW50IjpbIi8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcclxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fTtcclxuXHJcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdGhlbWVzYmVyZy90YWlsd2luZC1kYXRlcGlja2VyL2pzL2xpYi91dGlscy5qc1xyXG5mdW5jdGlvbiBoYXNQcm9wZXJ0eShvYmosIHByb3ApIHtcclxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxhc3RJdGVtT2YoYXJyKSB7XHJcbiAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XHJcbn1cclxuXHJcbi8vIHB1c2ggb25seSB0aGUgaXRlbXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheVxyXG5mdW5jdGlvbiBwdXNoVW5pcXVlKGFyciwgLi4uaXRlbXMpIHtcclxuICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XHJcbiAgICBpZiAoYXJyLmluY2x1ZGVzKGl0ZW0pKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGFyci5wdXNoKGl0ZW0pO1xyXG4gIH0pO1xyXG4gIHJldHVybiBhcnI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyLCBzZXBhcmF0b3IpIHtcclxuICAvLyBjb252ZXJ0IGVtcHR5IHN0cmluZyB0byBhbiBlbXB0eSBhcnJheVxyXG4gIHJldHVybiBzdHIgPyBzdHIuc3BsaXQoc2VwYXJhdG9yKSA6IFtdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0luUmFuZ2UodGVzdFZhbCwgbWluLCBtYXgpIHtcclxuICBjb25zdCBtaW5PSyA9IG1pbiA9PT0gdW5kZWZpbmVkIHx8IHRlc3RWYWwgPj0gbWluO1xyXG4gIGNvbnN0IG1heE9LID0gbWF4ID09PSB1bmRlZmluZWQgfHwgdGVzdFZhbCA8PSBtYXg7XHJcbiAgcmV0dXJuIG1pbk9LICYmIG1heE9LO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsaW1pdFRvUmFuZ2UodmFsLCBtaW4sIG1heCkge1xyXG4gIGlmICh2YWwgPCBtaW4pIHtcclxuICAgIHJldHVybiBtaW47XHJcbiAgfVxyXG4gIGlmICh2YWwgPiBtYXgpIHtcclxuICAgIHJldHVybiBtYXg7XHJcbiAgfVxyXG4gIHJldHVybiB2YWw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVRhZ1JlcGVhdCh0YWdOYW1lLCByZXBlYXQsIGF0dHJpYnV0ZXMgPSB7fSwgaW5kZXggPSAwLCBodG1sID0gJycpIHtcclxuICBjb25zdCBvcGVuVGFnU3JjID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcykucmVkdWNlKChzcmMsIGF0dHIpID0+IHtcclxuICAgIGxldCB2YWwgPSBhdHRyaWJ1dGVzW2F0dHJdO1xyXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdmFsID0gdmFsKGluZGV4KTtcclxuICAgIH1cclxuICAgIHJldHVybiBgJHtzcmN9ICR7YXR0cn09XCIke3ZhbH1cImA7XHJcbiAgfSwgdGFnTmFtZSk7XHJcbiAgaHRtbCArPSBgPCR7b3BlblRhZ1NyY30+PC8ke3RhZ05hbWV9PmA7XHJcblxyXG4gIGNvbnN0IG5leHQgPSBpbmRleCArIDE7XHJcbiAgcmV0dXJuIG5leHQgPCByZXBlYXRcclxuICAgID8gY3JlYXRlVGFnUmVwZWF0KHRhZ05hbWUsIHJlcGVhdCwgYXR0cmlidXRlcywgbmV4dCwgaHRtbClcclxuICAgIDogaHRtbDtcclxufVxyXG5cclxuLy8gUmVtb3ZlIHRoZSBzcGFjaW5nIHN1cnJvdW5kaW5nIHRhZ3MgZm9yIEhUTUwgcGFyc2VyIG5vdCB0byBjcmVhdGUgdGV4dCBub2Rlc1xyXG4vLyBiZWZvcmUvYWZ0ZXIgZWxlbWVudHNcclxuZnVuY3Rpb24gb3B0aW1pemVUZW1wbGF0ZUhUTUwoaHRtbCkge1xyXG4gIHJldHVybiBodG1sLnJlcGxhY2UoLz5cXHMrL2csICc+JykucmVwbGFjZSgvXFxzKzwvLCAnPCcpO1xyXG59XHJcblxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHRoZW1lc2JlcmcvdGFpbHdpbmQtZGF0ZXBpY2tlci9qcy9saWIvZGF0ZS5qc1xyXG5mdW5jdGlvbiBzdHJpcFRpbWUodGltZVZhbHVlKSB7XHJcbiAgcmV0dXJuIG5ldyBEYXRlKHRpbWVWYWx1ZSkuc2V0SG91cnMoMCwgMCwgMCwgMCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRvZGF5KCkge1xyXG4gIHJldHVybiBuZXcgRGF0ZSgpLnNldEhvdXJzKDAsIDAsIDAsIDApO1xyXG59XHJcblxyXG4vLyBHZXQgdGhlIHRpbWUgdmFsdWUgb2YgdGhlIHN0YXJ0IG9mIGdpdmVuIGRhdGUgb3IgeWVhciwgbW9udGggYW5kIGRheVxyXG5mdW5jdGlvbiBkYXRlVmFsdWUoLi4uYXJncykge1xyXG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcclxuICAgIGNhc2UgMDpcclxuICAgICAgcmV0dXJuIHRvZGF5KCk7XHJcbiAgICBjYXNlIDE6XHJcbiAgICAgIHJldHVybiBzdHJpcFRpbWUoYXJnc1swXSk7XHJcbiAgfVxyXG5cclxuICAvLyB1c2Ugc2V0RnVsbFllYXIoKSB0byBrZWVwIDItZGlnaXQgeWVhciBmcm9tIGJlaW5nIG1hcHBlZCB0byAxOTAwLTE5OTlcclxuICBjb25zdCBuZXdEYXRlID0gbmV3IERhdGUoMCk7XHJcbiAgbmV3RGF0ZS5zZXRGdWxsWWVhciguLi5hcmdzKTtcclxuICByZXR1cm4gbmV3RGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkRGF5cyhkYXRlLCBhbW91bnQpIHtcclxuICBjb25zdCBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZSk7XHJcbiAgcmV0dXJuIG5ld0RhdGUuc2V0RGF0ZShuZXdEYXRlLmdldERhdGUoKSArIGFtb3VudCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFdlZWtzKGRhdGUsIGFtb3VudCkge1xyXG4gIHJldHVybiBhZGREYXlzKGRhdGUsIGFtb3VudCAqIDcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRNb250aHMoZGF0ZSwgYW1vdW50KSB7XHJcbiAgLy8gSWYgdGhlIGRheSBvZiB0aGUgZGF0ZSBpcyBub3QgaW4gdGhlIG5ldyBtb250aCwgdGhlIGxhc3QgZGF5IG9mIHRoZSBuZXdcclxuICAvLyBtb250aCB3aWxsIGJlIHJldHVybmVkLiBlLmcuIEphbiAzMSArIDEgbW9udGgg4oaSIEZlYiAyOCAobm90IE1hciAwMylcclxuICBjb25zdCBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZSk7XHJcbiAgY29uc3QgbW9udGhzVG9TZXQgPSBuZXdEYXRlLmdldE1vbnRoKCkgKyBhbW91bnQ7XHJcbiAgbGV0IGV4cGVjdGVkTW9udGggPSBtb250aHNUb1NldCAlIDEyO1xyXG4gIGlmIChleHBlY3RlZE1vbnRoIDwgMCkge1xyXG4gICAgZXhwZWN0ZWRNb250aCArPSAxMjtcclxuICB9XHJcblxyXG4gIGNvbnN0IHRpbWUgPSBuZXdEYXRlLnNldE1vbnRoKG1vbnRoc1RvU2V0KTtcclxuICByZXR1cm4gbmV3RGF0ZS5nZXRNb250aCgpICE9PSBleHBlY3RlZE1vbnRoID8gbmV3RGF0ZS5zZXREYXRlKDApIDogdGltZTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkWWVhcnMoZGF0ZSwgYW1vdW50KSB7XHJcbiAgLy8gSWYgdGhlIGRhdGUgaXMgRmViIDI5IGFuZCB0aGUgbmV3IHllYXIgaXMgbm90IGEgbGVhcCB5ZWFyLCBGZWIgMjggb2YgdGhlXHJcbiAgLy8gbmV3IHllYXIgd2lsbCBiZSByZXR1cm5lZC5cclxuICBjb25zdCBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZSk7XHJcbiAgY29uc3QgZXhwZWN0ZWRNb250aCA9IG5ld0RhdGUuZ2V0TW9udGgoKTtcclxuICBjb25zdCB0aW1lID0gbmV3RGF0ZS5zZXRGdWxsWWVhcihuZXdEYXRlLmdldEZ1bGxZZWFyKCkgKyBhbW91bnQpO1xyXG4gIHJldHVybiBleHBlY3RlZE1vbnRoID09PSAxICYmIG5ld0RhdGUuZ2V0TW9udGgoKSA9PT0gMiA/IG5ld0RhdGUuc2V0RGF0ZSgwKSA6IHRpbWU7XHJcbn1cclxuXHJcbi8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0dHdlbiAyIGRheXMgb2YgdGhlIHdlZWtcclxuZnVuY3Rpb24gZGF5RGlmZihkYXksIGZyb20pIHtcclxuICByZXR1cm4gKGRheSAtIGZyb20gKyA3KSAlIDc7XHJcbn1cclxuXHJcbi8vIEdldCB0aGUgZGF0ZSBvZiB0aGUgc3BlY2lmaWVkIGRheSBvZiB0aGUgd2VlayBvZiBnaXZlbiBiYXNlIGRhdGVcclxuZnVuY3Rpb24gZGF5T2ZUaGVXZWVrT2YoYmFzZURhdGUsIGRheU9mV2Vlaywgd2Vla1N0YXJ0ID0gMCkge1xyXG4gIGNvbnN0IGJhc2VEYXkgPSBuZXcgRGF0ZShiYXNlRGF0ZSkuZ2V0RGF5KCk7XHJcbiAgcmV0dXJuIGFkZERheXMoYmFzZURhdGUsIGRheURpZmYoZGF5T2ZXZWVrLCB3ZWVrU3RhcnQpIC0gZGF5RGlmZihiYXNlRGF5LCB3ZWVrU3RhcnQpKTtcclxufVxyXG5cclxuLy8gR2V0IHRoZSBJU08gd2VlayBvZiBhIGRhdGVcclxuZnVuY3Rpb24gZ2V0V2VlayhkYXRlKSB7XHJcbiAgLy8gc3RhcnQgb2YgSVNPIHdlZWsgaXMgTW9uZGF5XHJcbiAgY29uc3QgdGh1T2ZUaGVXZWVrID0gZGF5T2ZUaGVXZWVrT2YoZGF0ZSwgNCwgMSk7XHJcbiAgLy8gMXN0IHdlZWsgPT0gdGhlIHdlZWsgd2hlcmUgdGhlIDR0aCBvZiBKYW51YXJ5IGlzIGluXHJcbiAgY29uc3QgZmlyc3RUaHUgPSBkYXlPZlRoZVdlZWtPZihuZXcgRGF0ZSh0aHVPZlRoZVdlZWspLnNldE1vbnRoKDAsIDQpLCA0LCAxKTtcclxuICByZXR1cm4gTWF0aC5yb3VuZCgodGh1T2ZUaGVXZWVrIC0gZmlyc3RUaHUpIC8gNjA0ODAwMDAwKSArIDE7XHJcbn1cclxuXHJcbi8vIEdldCB0aGUgc3RhcnQgeWVhciBvZiB0aGUgcGVyaW9kIG9mIHllYXJzIHRoYXQgaW5jbHVkZXMgZ2l2ZW4gZGF0ZVxyXG4vLyB5ZWFyczogbGVuZ3RoIG9mIHRoZSB5ZWFyIHBlcmlvZFxyXG5mdW5jdGlvbiBzdGFydE9mWWVhclBlcmlvZChkYXRlLCB5ZWFycykge1xyXG4gIC8qIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWWVhcl96ZXJvI0lTT184NjAxICovXHJcbiAgY29uc3QgeWVhciA9IG5ldyBEYXRlKGRhdGUpLmdldEZ1bGxZZWFyKCk7XHJcbiAgcmV0dXJuIE1hdGguZmxvb3IoeWVhciAvIHllYXJzKSAqIHllYXJzO1xyXG59XHJcblxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHRoZW1lc2JlcmcvdGFpbHdpbmQtZGF0ZXBpY2tlci9qcy9saWIvZGF0ZS1mb3JtYXQuanNcclxuXHJcblxyXG5cclxuLy8gcGF0dGVybiBmb3IgZm9ybWF0IHBhcnRzXHJcbmNvbnN0IHJlRm9ybWF0VG9rZW5zID0gL2RkP3xERD98bW0/fE1NP3x5eT8oPzp5eSk/LztcclxuLy8gcGF0dGVybiBmb3Igbm9uIGRhdGUgcGFydHNcclxuY29uc3QgcmVOb25EYXRlUGFydHMgPSAvW1xccyEtLzotQFstYHstfuW5tOaciOaXpV0rLztcclxuLy8gY2FjaGUgZm9yIHBlcnNlZCBmb3JtYXRzXHJcbmxldCBrbm93bkZvcm1hdHMgPSB7fTtcclxuLy8gcGFyc2UgZnVudGlvbnMgZm9yIGRhdGUgcGFydHNcclxuY29uc3QgcGFyc2VGbnMgPSB7XHJcbiAgeShkYXRlLCB5ZWFyKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSkuc2V0RnVsbFllYXIocGFyc2VJbnQoeWVhciwgMTApKTtcclxuICB9LFxyXG4gIG0oZGF0ZSwgbW9udGgsIGxvY2FsZSkge1xyXG4gICAgY29uc3QgbmV3RGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xyXG4gICAgbGV0IG1vbnRoSW5kZXggPSBwYXJzZUludChtb250aCwgMTApIC0gMTtcclxuXHJcbiAgICBpZiAoaXNOYU4obW9udGhJbmRleCkpIHtcclxuICAgICAgaWYgKCFtb250aCkge1xyXG4gICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IG1vbnRoTmFtZSA9IG1vbnRoLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIGNvbnN0IGNvbXBhcmVOYW1lcyA9IG5hbWUgPT4gbmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgobW9udGhOYW1lKTtcclxuICAgICAgLy8gY29tcGFyZSB3aXRoIGJvdGggc2hvcnQgYW5kIGZ1bGwgbmFtZXMgYmVjYXVzZSBzb21lIGxvY2FsZXMgaGF2ZSBwZXJpb2RzXHJcbiAgICAgIC8vIGluIHRoZSBzaG9ydCBuYW1lcyAobm90IGVxdWFsIHRvIHRoZSBmaXJzdCBYIGxldHRlcnMgb2YgdGhlIGZ1bGwgbmFtZXMpXHJcbiAgICAgIG1vbnRoSW5kZXggPSBsb2NhbGUubW9udGhzU2hvcnQuZmluZEluZGV4KGNvbXBhcmVOYW1lcyk7XHJcbiAgICAgIGlmIChtb250aEluZGV4IDwgMCkge1xyXG4gICAgICAgIG1vbnRoSW5kZXggPSBsb2NhbGUubW9udGhzLmZpbmRJbmRleChjb21wYXJlTmFtZXMpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChtb250aEluZGV4IDwgMCkge1xyXG4gICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBuZXdEYXRlLnNldE1vbnRoKG1vbnRoSW5kZXgpO1xyXG4gICAgcmV0dXJuIG5ld0RhdGUuZ2V0TW9udGgoKSAhPT0gbm9ybWFsaXplTW9udGgobW9udGhJbmRleClcclxuICAgICAgPyBuZXdEYXRlLnNldERhdGUoMClcclxuICAgICAgOiBuZXdEYXRlLmdldFRpbWUoKTtcclxuICB9LFxyXG4gIGQoZGF0ZSwgZGF5KSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSkuc2V0RGF0ZShwYXJzZUludChkYXksIDEwKSk7XHJcbiAgfSxcclxufTtcclxuLy8gZm9ybWF0IGZ1bmN0aW9ucyBmb3IgZGF0ZSBwYXJ0c1xyXG5jb25zdCBmb3JtYXRGbnMgPSB7XHJcbiAgZChkYXRlKSB7XHJcbiAgICByZXR1cm4gZGF0ZS5nZXREYXRlKCk7XHJcbiAgfSxcclxuICBkZChkYXRlKSB7XHJcbiAgICByZXR1cm4gcGFkWmVybyhkYXRlLmdldERhdGUoKSwgMik7XHJcbiAgfSxcclxuICBEKGRhdGUsIGxvY2FsZSkge1xyXG4gICAgcmV0dXJuIGxvY2FsZS5kYXlzU2hvcnRbZGF0ZS5nZXREYXkoKV07XHJcbiAgfSxcclxuICBERChkYXRlLCBsb2NhbGUpIHtcclxuICAgIHJldHVybiBsb2NhbGUuZGF5c1tkYXRlLmdldERheSgpXTtcclxuICB9LFxyXG4gIG0oZGF0ZSkge1xyXG4gICAgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKSArIDE7XHJcbiAgfSxcclxuICBtbShkYXRlKSB7XHJcbiAgICByZXR1cm4gcGFkWmVybyhkYXRlLmdldE1vbnRoKCkgKyAxLCAyKTtcclxuICB9LFxyXG4gIE0oZGF0ZSwgbG9jYWxlKSB7XHJcbiAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1Nob3J0W2RhdGUuZ2V0TW9udGgoKV07XHJcbiAgfSxcclxuICBNTShkYXRlLCBsb2NhbGUpIHtcclxuICAgIHJldHVybiBsb2NhbGUubW9udGhzW2RhdGUuZ2V0TW9udGgoKV07XHJcbiAgfSxcclxuICB5KGRhdGUpIHtcclxuICAgIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCk7XHJcbiAgfSxcclxuICB5eShkYXRlKSB7XHJcbiAgICByZXR1cm4gcGFkWmVybyhkYXRlLmdldEZ1bGxZZWFyKCksIDIpLnNsaWNlKC0yKTtcclxuICB9LFxyXG4gIHl5eXkoZGF0ZSkge1xyXG4gICAgcmV0dXJuIHBhZFplcm8oZGF0ZS5nZXRGdWxsWWVhcigpLCA0KTtcclxuICB9LFxyXG59O1xyXG5cclxuLy8gZ2V0IG1vbnRoIGluZGV4IGluIG5vcm1hbCByYW5nZSAoMCAtIDExKSBmcm9tIGFueSBudW1iZXJcclxuZnVuY3Rpb24gbm9ybWFsaXplTW9udGgobW9udGhJbmRleCkge1xyXG4gIHJldHVybiBtb250aEluZGV4ID4gLTEgPyBtb250aEluZGV4ICUgMTIgOiBub3JtYWxpemVNb250aChtb250aEluZGV4ICsgMTIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYWRaZXJvKG51bSwgbGVuZ3RoKSB7XHJcbiAgcmV0dXJuIG51bS50b1N0cmluZygpLnBhZFN0YXJ0KGxlbmd0aCwgJzAnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VGb3JtYXRTdHJpbmcoZm9ybWF0KSB7XHJcbiAgaWYgKHR5cGVvZiBmb3JtYXQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGUgZm9ybWF0LlwiKTtcclxuICB9XHJcbiAgaWYgKGZvcm1hdCBpbiBrbm93bkZvcm1hdHMpIHtcclxuICAgIHJldHVybiBrbm93bkZvcm1hdHNbZm9ybWF0XTtcclxuICB9XHJcblxyXG4gIC8vIHNwcml0IHRoZSBmb3JtYXQgc3RyaW5nIGludG8gcGFydHMgYW5kIHNlcHJhdG9yc1xyXG4gIGNvbnN0IHNlcGFyYXRvcnMgPSBmb3JtYXQuc3BsaXQocmVGb3JtYXRUb2tlbnMpO1xyXG4gIGNvbnN0IHBhcnRzID0gZm9ybWF0Lm1hdGNoKG5ldyBSZWdFeHAocmVGb3JtYXRUb2tlbnMsICdnJykpO1xyXG4gIGlmIChzZXBhcmF0b3JzLmxlbmd0aCA9PT0gMCB8fCAhcGFydHMpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBmb3JtYXQuXCIpO1xyXG4gIH1cclxuXHJcbiAgLy8gY29sbGVjdCBmb3JtYXQgZnVuY3Rpb25zIHVzZWQgaW4gdGhlIGZvcm1hdFxyXG4gIGNvbnN0IHBhcnRGb3JtYXR0ZXJzID0gcGFydHMubWFwKHRva2VuID0+IGZvcm1hdEZuc1t0b2tlbl0pO1xyXG5cclxuICAvLyBjb2xsZWN0IHBhcnNlIGZ1bmN0aW9uIGtleXMgdXNlZCBpbiB0aGUgZm9ybWF0XHJcbiAgLy8gaXRlcmF0ZSBvdmVyIHBhcnNlRm5zJyBrZXlzIGluIG9yZGVyIHRvIGtlZXAgdGhlIG9yZGVyIG9mIHRoZSBrZXlzLlxyXG4gIGNvbnN0IHBhcnRQYXJzZXJLZXlzID0gT2JqZWN0LmtleXMocGFyc2VGbnMpLnJlZHVjZSgoa2V5cywga2V5KSA9PiB7XHJcbiAgICBjb25zdCB0b2tlbiA9IHBhcnRzLmZpbmQocGFydCA9PiBwYXJ0WzBdICE9PSAnRCcgJiYgcGFydFswXS50b0xvd2VyQ2FzZSgpID09PSBrZXkpO1xyXG4gICAgaWYgKHRva2VuKSB7XHJcbiAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGtleXM7XHJcbiAgfSwgW10pO1xyXG5cclxuICByZXR1cm4ga25vd25Gb3JtYXRzW2Zvcm1hdF0gPSB7XHJcbiAgICBwYXJzZXIoZGF0ZVN0ciwgbG9jYWxlKSB7XHJcbiAgICAgIGNvbnN0IGRhdGVQYXJ0cyA9IGRhdGVTdHIuc3BsaXQocmVOb25EYXRlUGFydHMpLnJlZHVjZSgoZHRQYXJ0cywgcGFydCwgaW5kZXgpID0+IHtcclxuICAgICAgICBpZiAocGFydC5sZW5ndGggPiAwICYmIHBhcnRzW2luZGV4XSkge1xyXG4gICAgICAgICAgY29uc3QgdG9rZW4gPSBwYXJ0c1tpbmRleF1bMF07XHJcbiAgICAgICAgICBpZiAodG9rZW4gPT09ICdNJykge1xyXG4gICAgICAgICAgICBkdFBhcnRzLm0gPSBwYXJ0O1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh0b2tlbiAhPT0gJ0QnKSB7XHJcbiAgICAgICAgICAgIGR0UGFydHNbdG9rZW5dID0gcGFydDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGR0UGFydHM7XHJcbiAgICAgIH0sIHt9KTtcclxuXHJcbiAgICAgIC8vIGl0ZXJhdGUgb3ZlciBwYXJ0UGFyc2Vya2V5cyBzbyB0aGF0IHRoZSBwYXJzaW5nIGlzIG1hZGUgaW4gdGhlIG9kZXJcclxuICAgICAgLy8gb2YgeWVhciwgbW9udGggYW5kIGRheSB0byBwcmV2ZW50IHRoZSBkYXkgcGFyc2VyIGZyb20gY29ycmVjdGluZyBsYXN0XHJcbiAgICAgIC8vIGRheSBvZiBtb250aCB3cm9uZ2x5XHJcbiAgICAgIHJldHVybiBwYXJ0UGFyc2VyS2V5cy5yZWR1Y2UoKG9yaWdEYXRlLCBrZXkpID0+IHtcclxuICAgICAgICBjb25zdCBuZXdEYXRlID0gcGFyc2VGbnNba2V5XShvcmlnRGF0ZSwgZGF0ZVBhcnRzW2tleV0sIGxvY2FsZSk7XHJcbiAgICAgICAgLy8gaW5nbm9yZSB0aGUgcGFydCBmYWlsZWQgdG8gcGFyc2VcclxuICAgICAgICByZXR1cm4gaXNOYU4obmV3RGF0ZSkgPyBvcmlnRGF0ZSA6IG5ld0RhdGU7XHJcbiAgICAgIH0sIHRvZGF5KCkpO1xyXG4gICAgfSxcclxuICAgIGZvcm1hdHRlcihkYXRlLCBsb2NhbGUpIHtcclxuICAgICAgbGV0IGRhdGVTdHIgPSBwYXJ0Rm9ybWF0dGVycy5yZWR1Y2UoKHN0ciwgZm4sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHN0ciArPSBgJHtzZXBhcmF0b3JzW2luZGV4XX0ke2ZuKGRhdGUsIGxvY2FsZSl9YDtcclxuICAgICAgfSwgJycpO1xyXG4gICAgICAvLyBzZXBhcmF0b3JzJyBsZW5ndGggaXMgYWx3YXlzIHBhcnRzJyBsZW5ndGggKyAxLFxyXG4gICAgICByZXR1cm4gZGF0ZVN0ciArPSBsYXN0SXRlbU9mKHNlcGFyYXRvcnMpO1xyXG4gICAgfSxcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZURhdGUoZGF0ZVN0ciwgZm9ybWF0LCBsb2NhbGUpIHtcclxuICBpZiAoZGF0ZVN0ciBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIGRhdGVTdHIgPT09ICdudW1iZXInKSB7XHJcbiAgICBjb25zdCBkYXRlID0gc3RyaXBUaW1lKGRhdGVTdHIpO1xyXG4gICAgcmV0dXJuIGlzTmFOKGRhdGUpID8gdW5kZWZpbmVkIDogZGF0ZTtcclxuICB9XHJcbiAgaWYgKCFkYXRlU3RyKSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuICBpZiAoZGF0ZVN0ciA9PT0gJ3RvZGF5Jykge1xyXG4gICAgcmV0dXJuIHRvZGF5KCk7XHJcbiAgfVxyXG5cclxuICBpZiAoZm9ybWF0ICYmIGZvcm1hdC50b1ZhbHVlKSB7XHJcbiAgICBjb25zdCBkYXRlID0gZm9ybWF0LnRvVmFsdWUoZGF0ZVN0ciwgZm9ybWF0LCBsb2NhbGUpO1xyXG4gICAgcmV0dXJuIGlzTmFOKGRhdGUpID8gdW5kZWZpbmVkIDogc3RyaXBUaW1lKGRhdGUpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHBhcnNlRm9ybWF0U3RyaW5nKGZvcm1hdCkucGFyc2VyKGRhdGVTdHIsIGxvY2FsZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCBsb2NhbGUpIHtcclxuICBpZiAoaXNOYU4oZGF0ZSkgfHwgKCFkYXRlICYmIGRhdGUgIT09IDApKSB7XHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfVxyXG5cclxuICBjb25zdCBkYXRlT2JqID0gdHlwZW9mIGRhdGUgPT09ICdudW1iZXInID8gbmV3IERhdGUoZGF0ZSkgOiBkYXRlO1xyXG5cclxuICBpZiAoZm9ybWF0LnRvRGlzcGxheSkge1xyXG4gICAgcmV0dXJuIGZvcm1hdC50b0Rpc3BsYXkoZGF0ZU9iaiwgZm9ybWF0LCBsb2NhbGUpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHBhcnNlRm9ybWF0U3RyaW5nKGZvcm1hdCkuZm9ybWF0dGVyKGRhdGVPYmosIGxvY2FsZSk7XHJcbn1cclxuXHJcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdGhlbWVzYmVyZy90YWlsd2luZC1kYXRlcGlja2VyL2pzL2xpYi9ldmVudC5qc1xyXG5jb25zdCBsaXN0ZW5lclJlZ2lzdHJ5ID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3Qge2FkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXJ9ID0gRXZlbnRUYXJnZXQucHJvdG90eXBlO1xyXG5cclxuLy8gUmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzIHRvIGEga2V5IG9iamVjdFxyXG4vLyBsaXN0ZW5lcnM6IGFycmF5IG9mIGxpc3RlbmVyIGRlZmluaXRpb25zO1xyXG4vLyAgIC0gZWFjaCBkZWZpbml0aW9uIG11c3QgYmUgYSBmbGF0IGFycmF5IG9mIGV2ZW50IHRhcmdldCBhbmQgdGhlIGFyZ3VtZW50c1xyXG4vLyAgICAgdXNlZCB0byBjYWxsIGFkZEV2ZW50TGlzdGVuZXIoKSBvbiB0aGUgdGFyZ2V0XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKGtleU9iaiwgbGlzdGVuZXJzKSB7XHJcbiAgbGV0IHJlZ2lzdGVyZWQgPSBsaXN0ZW5lclJlZ2lzdHJ5LmdldChrZXlPYmopO1xyXG4gIGlmICghcmVnaXN0ZXJlZCkge1xyXG4gICAgcmVnaXN0ZXJlZCA9IFtdO1xyXG4gICAgbGlzdGVuZXJSZWdpc3RyeS5zZXQoa2V5T2JqLCByZWdpc3RlcmVkKTtcclxuICB9XHJcbiAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XHJcbiAgICBhZGRFdmVudExpc3RlbmVyLmNhbGwoLi4ubGlzdGVuZXIpO1xyXG4gICAgcmVnaXN0ZXJlZC5wdXNoKGxpc3RlbmVyKTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycyhrZXlPYmopIHtcclxuICBsZXQgbGlzdGVuZXJzID0gbGlzdGVuZXJSZWdpc3RyeS5nZXQoa2V5T2JqKTtcclxuICBpZiAoIWxpc3RlbmVycykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBsaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcclxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbCguLi5saXN0ZW5lcik7XHJcbiAgfSk7XHJcbiAgbGlzdGVuZXJSZWdpc3RyeS5kZWxldGUoa2V5T2JqKTtcclxufVxyXG5cclxuLy8gRXZlbnQuY29tcG9zZWRQYXRoKCkgcG9seWZpbGwgZm9yIEVkZ2VcclxuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20va2xlaW5mcmV1bmQvZTk3ODdkNzM3NzZjMGUzNzUwZGNmY2RjODlmMTAwZWNcclxuaWYgKCFFdmVudC5wcm90b3R5cGUuY29tcG9zZWRQYXRoKSB7XHJcbiAgY29uc3QgZ2V0Q29tcG9zZWRQYXRoID0gKG5vZGUsIHBhdGggPSBbXSkgPT4ge1xyXG4gICAgcGF0aC5wdXNoKG5vZGUpO1xyXG5cclxuICAgIGxldCBwYXJlbnQ7XHJcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XHJcbiAgICAgIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcclxuICAgIH0gZWxzZSBpZiAobm9kZS5ob3N0KSB7IC8vIFNoYWRvd1Jvb3RcclxuICAgICAgcGFyZW50ID0gbm9kZS5ob3N0O1xyXG4gICAgfSBlbHNlIGlmIChub2RlLmRlZmF1bHRWaWV3KSB7ICAvLyBEb2N1bWVudFxyXG4gICAgICBwYXJlbnQgPSBub2RlLmRlZmF1bHRWaWV3O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcmVudCA/IGdldENvbXBvc2VkUGF0aChwYXJlbnQsIHBhdGgpIDogcGF0aDtcclxuICB9O1xyXG5cclxuICBFdmVudC5wcm90b3R5cGUuY29tcG9zZWRQYXRoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGdldENvbXBvc2VkUGF0aCh0aGlzLnRhcmdldCk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZmluZEZyb21QYXRoKHBhdGgsIGNyaXRlcmlhLCBjdXJyZW50VGFyZ2V0LCBpbmRleCA9IDApIHtcclxuICBjb25zdCBlbCA9IHBhdGhbaW5kZXhdO1xyXG4gIGlmIChjcml0ZXJpYShlbCkpIHtcclxuICAgIHJldHVybiBlbDtcclxuICB9IGVsc2UgaWYgKGVsID09PSBjdXJyZW50VGFyZ2V0IHx8ICFlbC5wYXJlbnRFbGVtZW50KSB7XHJcbiAgICAvLyBzdG9wIHdoZW4gcmVhY2hpbmcgY3VycmVudFRhcmdldCBvciA8aHRtbD5cclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgcmV0dXJuIGZpbmRGcm9tUGF0aChwYXRoLCBjcml0ZXJpYSwgY3VycmVudFRhcmdldCwgaW5kZXggKyAxKTtcclxufVxyXG5cclxuLy8gU2VhcmNoIGZvciB0aGUgYWN0dWFsIHRhcmdldCBvZiBhIGRlbGVnYXRlZCBldmVudFxyXG5mdW5jdGlvbiBmaW5kRWxlbWVudEluRXZlbnRQYXRoKGV2LCBzZWxlY3Rvcikge1xyXG4gIGNvbnN0IGNyaXRlcmlhID0gdHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nID8gc2VsZWN0b3IgOiBlbCA9PiBlbC5tYXRjaGVzKHNlbGVjdG9yKTtcclxuICByZXR1cm4gZmluZEZyb21QYXRoKGV2LmNvbXBvc2VkUGF0aCgpLCBjcml0ZXJpYSwgZXYuY3VycmVudFRhcmdldCk7XHJcbn1cclxuXHJcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdGhlbWVzYmVyZy90YWlsd2luZC1kYXRlcGlja2VyL2pzL2kxOG4vYmFzZS1sb2NhbGVzLmpzXHJcbi8vIGRlZmF1bHQgbG9jYWxlc1xyXG5jb25zdCBsb2NhbGVzID0ge1xyXG4gIGVuOiB7XHJcbiAgICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcclxuICAgIGRheXNTaG9ydDogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxyXG4gICAgZGF5c01pbjogW1wiU3VcIiwgXCJNb1wiLCBcIlR1XCIsIFwiV2VcIiwgXCJUaFwiLCBcIkZyXCIsIFwiU2FcIl0sXHJcbiAgICBtb250aHM6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxyXG4gICAgbW9udGhzU2hvcnQ6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXSxcclxuICAgIHRvZGF5OiBcIlRvZGF5XCIsXHJcbiAgICBjbGVhcjogXCJDbGVhclwiLFxyXG4gICAgdGl0bGVGb3JtYXQ6IFwiTU0geVwiXHJcbiAgfVxyXG59O1xyXG5cclxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0B0aGVtZXNiZXJnL3RhaWx3aW5kLWRhdGVwaWNrZXIvanMvb3B0aW9ucy9kZWZhdWx0T3B0aW9ucy5qc1xyXG4vLyBjb25maWcgb3B0aW9ucyB1cGRhdGFibGUgYnkgc2V0T3B0aW9ucygpIGFuZCB0aGVpciBkZWZhdWx0IHZhbHVlc1xyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICBhdXRvaGlkZTogZmFsc2UsXHJcbiAgYmVmb3JlU2hvd0RheTogbnVsbCxcclxuICBiZWZvcmVTaG93RGVjYWRlOiBudWxsLFxyXG4gIGJlZm9yZVNob3dNb250aDogbnVsbCxcclxuICBiZWZvcmVTaG93WWVhcjogbnVsbCxcclxuICBjYWxlbmRhcldlZWtzOiBmYWxzZSxcclxuICBjbGVhckJ0bjogZmFsc2UsXHJcbiAgZGF0ZURlbGltaXRlcjogJywnLFxyXG4gIGRhdGVzRGlzYWJsZWQ6IFtdLFxyXG4gIGRheXNPZldlZWtEaXNhYmxlZDogW10sXHJcbiAgZGF5c09mV2Vla0hpZ2hsaWdodGVkOiBbXSxcclxuICBkZWZhdWx0Vmlld0RhdGU6IHVuZGVmaW5lZCwgLy8gcGxhY2Vob2xkZXIsIGRlZmF1bHRzIHRvIHRvZGF5KCkgYnkgdGhlIHByb2dyYW1cclxuICBkaXNhYmxlVG91Y2hLZXlib2FyZDogZmFsc2UsXHJcbiAgZm9ybWF0OiAnbW0vZGQveXl5eScsXHJcbiAgbGFuZ3VhZ2U6ICdlbicsXHJcbiAgbWF4RGF0ZTogbnVsbCxcclxuICBtYXhOdW1iZXJPZkRhdGVzOiAxLFxyXG4gIG1heFZpZXc6IDMsXHJcbiAgbWluRGF0ZTogbnVsbCxcclxuICBuZXh0QXJyb3c6ICc8c3ZnIGNsYXNzPVwidy00IGgtNFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDIwIDIwXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTEyLjI5MyA1LjI5M2ExIDEgMCAwMTEuNDE0IDBsNCA0YTEgMSAwIDAxMCAxLjQxNGwtNCA0YTEgMSAwIDAxLTEuNDE0LTEuNDE0TDE0LjU4NiAxMUgzYTEgMSAwIDExMC0yaDExLjU4NmwtMi4yOTMtMi4yOTNhMSAxIDAgMDEwLTEuNDE0elwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIj48L3BhdGg+PC9zdmc+JyxcclxuICBvcmllbnRhdGlvbjogJ2F1dG8nLFxyXG4gIHBpY2tMZXZlbDogMCxcclxuICBwcmV2QXJyb3c6ICc8c3ZnIGNsYXNzPVwidy00IGgtNFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDIwIDIwXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTkuNzA3IDE2LjcwN2ExIDEgMCAwMS0xLjQxNCAwbC02LTZhMSAxIDAgMDEwLTEuNDE0bDYtNmExIDEgMCAwMTEuNDE0IDEuNDE0TDUuNDE0IDlIMTdhMSAxIDAgMTEwIDJINS40MTRsNC4yOTMgNC4yOTNhMSAxIDAgMDEwIDEuNDE0elwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIj48L3BhdGg+PC9zdmc+JyxcclxuICBzaG93RGF5c09mV2VlazogdHJ1ZSxcclxuICBzaG93T25DbGljazogdHJ1ZSxcclxuICBzaG93T25Gb2N1czogdHJ1ZSxcclxuICBzdGFydFZpZXc6IDAsXHJcbiAgdGl0bGU6ICcnLFxyXG4gIHRvZGF5QnRuOiBmYWxzZSxcclxuICB0b2RheUJ0bk1vZGU6IDAsXHJcbiAgdG9kYXlIaWdobGlnaHQ6IGZhbHNlLFxyXG4gIHVwZGF0ZU9uQmx1cjogdHJ1ZSxcclxuICB3ZWVrU3RhcnQ6IDAsXHJcbn07XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IG9wdGlvbnNfZGVmYXVsdE9wdGlvbnMgPSAoZGVmYXVsdE9wdGlvbnMpO1xyXG5cclxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0B0aGVtZXNiZXJnL3RhaWx3aW5kLWRhdGVwaWNrZXIvanMvbGliL2RvbS5qc1xyXG5jb25zdCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XHJcblxyXG5mdW5jdGlvbiBwYXJzZUhUTUwoaHRtbCkge1xyXG4gIHJldHVybiByYW5nZS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoaHRtbCk7XHJcbn1cclxuXHJcbi8vIGVxdWl2YWxlbnQgdG8galF1ZXJ5J3MgOnZpc2JsZVxyXG5mdW5jdGlvbiBpc1Zpc2libGUoZWwpIHtcclxuICByZXR1cm4gISEoZWwub2Zmc2V0V2lkdGggfHwgZWwub2Zmc2V0SGVpZ2h0IHx8IGVsLmdldENsaWVudFJlY3RzKCkubGVuZ3RoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGlkZUVsZW1lbnQoZWwpIHtcclxuICBpZiAoZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIC8vIGJhY2sgdXAgdGhlIGV4aXN0aW5nIGRpc3BsYXkgc2V0dGluZyBpbiBkYXRhLXN0eWxlLWRpc3BsYXlcclxuICBpZiAoZWwuc3R5bGUuZGlzcGxheSkge1xyXG4gICAgZWwuZGF0YXNldC5zdHlsZURpc3BsYXkgPSBlbC5zdHlsZS5kaXNwbGF5O1xyXG4gIH1cclxuICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzaG93RWxlbWVudChlbCkge1xyXG4gIGlmIChlbC5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKGVsLmRhdGFzZXQuc3R5bGVEaXNwbGF5KSB7XHJcbiAgICAvLyByZXN0b3JlIGJhY2tlZC11cCBkaXNwYXkgcHJvcGVydHlcclxuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5kYXRhc2V0LnN0eWxlRGlzcGxheTtcclxuICAgIGRlbGV0ZSBlbC5kYXRhc2V0LnN0eWxlRGlzcGxheTtcclxuICB9IGVsc2Uge1xyXG4gICAgZWwuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZW1wdHlDaGlsZE5vZGVzKGVsKSB7XHJcbiAgaWYgKGVsLmZpcnN0Q2hpbGQpIHtcclxuICAgIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xyXG4gICAgZW1wdHlDaGlsZE5vZGVzKGVsKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlcGxhY2VDaGlsZE5vZGVzKGVsLCBuZXdDaGlsZE5vZGVzKSB7XHJcbiAgZW1wdHlDaGlsZE5vZGVzKGVsKTtcclxuICBpZiAobmV3Q2hpbGROb2RlcyBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcclxuICAgIGVsLmFwcGVuZENoaWxkKG5ld0NoaWxkTm9kZXMpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG5ld0NoaWxkTm9kZXMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBlbC5hcHBlbmRDaGlsZChwYXJzZUhUTUwobmV3Q2hpbGROb2RlcykpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG5ld0NoaWxkTm9kZXMuZm9yRWFjaCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgbmV3Q2hpbGROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XHJcbiAgICAgIGVsLmFwcGVuZENoaWxkKG5vZGUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHRoZW1lc2JlcmcvdGFpbHdpbmQtZGF0ZXBpY2tlci9qcy9vcHRpb25zL3Byb2Nlc3NPcHRpb25zLmpzXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNvbnN0IHtcclxuICBsYW5ndWFnZTogZGVmYXVsdExhbmcsXHJcbiAgZm9ybWF0OiBkZWZhdWx0Rm9ybWF0LFxyXG4gIHdlZWtTdGFydDogZGVmYXVsdFdlZWtTdGFydCxcclxufSA9IG9wdGlvbnNfZGVmYXVsdE9wdGlvbnM7XHJcblxyXG4vLyBSZWR1Y2VyIGZ1bmN0aW9uIHRvIGZpbHRlciBvdXQgaW52YWxpZCBkYXktb2Ytd2VlayBmcm9tIHRoZSBpbnB1dFxyXG5mdW5jdGlvbiBzYW5pdGl6ZURPVyhkb3csIGRheSkge1xyXG4gIHJldHVybiBkb3cubGVuZ3RoIDwgNiAmJiBkYXkgPj0gMCAmJiBkYXkgPCA3XHJcbiAgICA/IHB1c2hVbmlxdWUoZG93LCBkYXkpXHJcbiAgICA6IGRvdztcclxufVxyXG5cclxuZnVuY3Rpb24gY2FsY0VuZE9mV2VlayhzdGFydE9mV2Vlaykge1xyXG4gIHJldHVybiAoc3RhcnRPZldlZWsgKyA2KSAlIDc7XHJcbn1cclxuXHJcbi8vIHZhbGlkYXRlIGlucHV0IGRhdGUuIGlmIGludmFsaWQsIGZhbGxiYWNrIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZVxyXG5mdW5jdGlvbiB2YWxpZGF0ZURhdGUodmFsdWUsIGZvcm1hdCwgbG9jYWxlLCBvcmlnVmFsdWUpIHtcclxuICBjb25zdCBkYXRlID0gcGFyc2VEYXRlKHZhbHVlLCBmb3JtYXQsIGxvY2FsZSk7XHJcbiAgcmV0dXJuIGRhdGUgIT09IHVuZGVmaW5lZCA/IGRhdGUgOiBvcmlnVmFsdWU7XHJcbn1cclxuXHJcbi8vIFZhbGlkYXRlIHZpZXdJZC4gaWYgaW52YWxpZCwgZmFsbGJhY2sgdG8gdGhlIG9yaWdpbmFsIHZhbHVlXHJcbmZ1bmN0aW9uIHZhbGlkYXRlVmlld0lkKHZhbHVlLCBvcmlnVmFsdWUsIG1heCA9IDMpIHtcclxuICBjb25zdCB2aWV3SWQgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xyXG4gIHJldHVybiB2aWV3SWQgPj0gMCAmJiB2aWV3SWQgPD0gbWF4ID8gdmlld0lkIDogb3JpZ1ZhbHVlO1xyXG59XHJcblxyXG4vLyBDcmVhdGUgRGF0ZXBpY2tlciBjb25maWd1cmF0aW9uIHRvIHNldFxyXG5mdW5jdGlvbiBwcm9jZXNzT3B0aW9ucyhvcHRpb25zLCBkYXRlcGlja2VyKSB7XHJcbiAgY29uc3QgaW5PcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XHJcbiAgY29uc3QgY29uZmlnID0ge307XHJcbiAgY29uc3QgbG9jYWxlcyA9IGRhdGVwaWNrZXIuY29uc3RydWN0b3IubG9jYWxlcztcclxuICBsZXQge1xyXG4gICAgZm9ybWF0LFxyXG4gICAgbGFuZ3VhZ2UsXHJcbiAgICBsb2NhbGUsXHJcbiAgICBtYXhEYXRlLFxyXG4gICAgbWF4VmlldyxcclxuICAgIG1pbkRhdGUsXHJcbiAgICBwaWNrTGV2ZWwsXHJcbiAgICBzdGFydFZpZXcsXHJcbiAgICB3ZWVrU3RhcnQsXHJcbiAgfSA9IGRhdGVwaWNrZXIuY29uZmlnIHx8IHt9O1xyXG5cclxuICBpZiAoaW5PcHRzLmxhbmd1YWdlKSB7XHJcbiAgICBsZXQgbGFuZztcclxuICAgIGlmIChpbk9wdHMubGFuZ3VhZ2UgIT09IGxhbmd1YWdlKSB7XHJcbiAgICAgIGlmIChsb2NhbGVzW2luT3B0cy5sYW5ndWFnZV0pIHtcclxuICAgICAgICBsYW5nID0gaW5PcHRzLmxhbmd1YWdlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIGxhbmdhdWdlICsgcmVnaW9uIHRhZyBjYW4gZmFsbGJhY2sgdG8gdGhlIG9uZSB3aXRob3V0XHJcbiAgICAgICAgLy8gcmVnaW9uIChlLmcuIGZyLUNBIOKGkiBmcilcclxuICAgICAgICBsYW5nID0gaW5PcHRzLmxhbmd1YWdlLnNwbGl0KCctJylbMF07XHJcbiAgICAgICAgaWYgKGxvY2FsZXNbbGFuZ10gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgbGFuZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVsZXRlIGluT3B0cy5sYW5ndWFnZTtcclxuICAgIGlmIChsYW5nKSB7XHJcbiAgICAgIGxhbmd1YWdlID0gY29uZmlnLmxhbmd1YWdlID0gbGFuZztcclxuXHJcbiAgICAgIC8vIHVwZGF0ZSBsb2NhbGUgYXMgd2VsbCB3aGVuIHVwZGF0aW5nIGxhbmd1YWdlXHJcbiAgICAgIGNvbnN0IG9yaWdMb2NhbGUgPSBsb2NhbGUgfHwgbG9jYWxlc1tkZWZhdWx0TGFuZ107XHJcbiAgICAgIC8vIHVzZSBkZWZhdWx0IGxhbmd1YWdlJ3MgcHJvcGVydGllcyBmb3IgdGhlIGZhbGxiYWNrXHJcbiAgICAgIGxvY2FsZSA9IE9iamVjdC5hc3NpZ24oe1xyXG4gICAgICAgIGZvcm1hdDogZGVmYXVsdEZvcm1hdCxcclxuICAgICAgICB3ZWVrU3RhcnQ6IGRlZmF1bHRXZWVrU3RhcnRcclxuICAgICAgfSwgbG9jYWxlc1tkZWZhdWx0TGFuZ10pO1xyXG4gICAgICBpZiAobGFuZ3VhZ2UgIT09IGRlZmF1bHRMYW5nKSB7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihsb2NhbGUsIGxvY2FsZXNbbGFuZ3VhZ2VdKTtcclxuICAgICAgfVxyXG4gICAgICBjb25maWcubG9jYWxlID0gbG9jYWxlO1xyXG4gICAgICAvLyBpZiBmb3JtYXQgYW5kL29yIHdlZWtTdGFydCBhcmUgdGhlIHNhbWUgYXMgb2xkIGxvY2FsZSdzIGRlZmF1bHRzLFxyXG4gICAgICAvLyB1cGRhdGUgdGhlbSB0byBuZXcgbG9jYWxlJ3MgZGVmYXVsdHNcclxuICAgICAgaWYgKGZvcm1hdCA9PT0gb3JpZ0xvY2FsZS5mb3JtYXQpIHtcclxuICAgICAgICBmb3JtYXQgPSBjb25maWcuZm9ybWF0ID0gbG9jYWxlLmZvcm1hdDtcclxuICAgICAgfVxyXG4gICAgICBpZiAod2Vla1N0YXJ0ID09PSBvcmlnTG9jYWxlLndlZWtTdGFydCkge1xyXG4gICAgICAgIHdlZWtTdGFydCA9IGNvbmZpZy53ZWVrU3RhcnQgPSBsb2NhbGUud2Vla1N0YXJ0O1xyXG4gICAgICAgIGNvbmZpZy53ZWVrRW5kID0gY2FsY0VuZE9mV2Vlayhsb2NhbGUud2Vla1N0YXJ0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGluT3B0cy5mb3JtYXQpIHtcclxuICAgIGNvbnN0IGhhc1RvRGlzcGxheSA9IHR5cGVvZiBpbk9wdHMuZm9ybWF0LnRvRGlzcGxheSA9PT0gJ2Z1bmN0aW9uJztcclxuICAgIGNvbnN0IGhhc1RvVmFsdWUgPSB0eXBlb2YgaW5PcHRzLmZvcm1hdC50b1ZhbHVlID09PSAnZnVuY3Rpb24nO1xyXG4gICAgY29uc3QgdmFsaWRGb3JtYXRTdHJpbmcgPSByZUZvcm1hdFRva2Vucy50ZXN0KGluT3B0cy5mb3JtYXQpO1xyXG4gICAgaWYgKChoYXNUb0Rpc3BsYXkgJiYgaGFzVG9WYWx1ZSkgfHwgdmFsaWRGb3JtYXRTdHJpbmcpIHtcclxuICAgICAgZm9ybWF0ID0gY29uZmlnLmZvcm1hdCA9IGluT3B0cy5mb3JtYXQ7XHJcbiAgICB9XHJcbiAgICBkZWxldGUgaW5PcHRzLmZvcm1hdDtcclxuICB9XHJcblxyXG4gIC8vKioqIGRhdGVzICoqKi8vXHJcbiAgLy8gd2hpbGUgbWluIGFuZCBtYXhEYXRlIGZvciBcIm5vIGxpbWl0XCIgaW4gdGhlIG9wdGlvbnMgYXJlIGJldHRlciB0byBiZSBudWxsXHJcbiAgLy8gKGVzcGVjaWFsbHkgd2hlbiB1cGRhdGluZyksIHRoZSBvbmVzIGluIHRoZSBjb25maWcgaGF2ZSB0byBiZSB1bmRlZmluZWRcclxuICAvLyBiZWNhdXNlIG51bGwgaXMgdHJlYXRlZCBhcyAwICg9IHVuaXggZXBvY2gpIHdoZW4gY29tcGFyaW5nIHdpdGggdGltZSB2YWx1ZVxyXG4gIGxldCBtaW5EdCA9IG1pbkRhdGU7XHJcbiAgbGV0IG1heER0ID0gbWF4RGF0ZTtcclxuICBpZiAoaW5PcHRzLm1pbkRhdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgbWluRHQgPSBpbk9wdHMubWluRGF0ZSA9PT0gbnVsbFxyXG4gICAgICA/IGRhdGVWYWx1ZSgwLCAwLCAxKSAgLy8gc2V0IDAwMDAtMDEtMDEgdG8gcHJldmVudCBuZWdhdGl2ZSB2YWx1ZXMgZm9yIHllYXJcclxuICAgICAgOiB2YWxpZGF0ZURhdGUoaW5PcHRzLm1pbkRhdGUsIGZvcm1hdCwgbG9jYWxlLCBtaW5EdCk7XHJcbiAgICBkZWxldGUgaW5PcHRzLm1pbkRhdGU7XHJcbiAgfVxyXG4gIGlmIChpbk9wdHMubWF4RGF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBtYXhEdCA9IGluT3B0cy5tYXhEYXRlID09PSBudWxsXHJcbiAgICAgID8gdW5kZWZpbmVkXHJcbiAgICAgIDogdmFsaWRhdGVEYXRlKGluT3B0cy5tYXhEYXRlLCBmb3JtYXQsIGxvY2FsZSwgbWF4RHQpO1xyXG4gICAgZGVsZXRlIGluT3B0cy5tYXhEYXRlO1xyXG4gIH1cclxuICBpZiAobWF4RHQgPCBtaW5EdCkge1xyXG4gICAgbWluRGF0ZSA9IGNvbmZpZy5taW5EYXRlID0gbWF4RHQ7XHJcbiAgICBtYXhEYXRlID0gY29uZmlnLm1heERhdGUgPSBtaW5EdDtcclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKG1pbkRhdGUgIT09IG1pbkR0KSB7XHJcbiAgICAgIG1pbkRhdGUgPSBjb25maWcubWluRGF0ZSA9IG1pbkR0O1xyXG4gICAgfVxyXG4gICAgaWYgKG1heERhdGUgIT09IG1heER0KSB7XHJcbiAgICAgIG1heERhdGUgPSBjb25maWcubWF4RGF0ZSA9IG1heER0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGluT3B0cy5kYXRlc0Rpc2FibGVkKSB7XHJcbiAgICBjb25maWcuZGF0ZXNEaXNhYmxlZCA9IGluT3B0cy5kYXRlc0Rpc2FibGVkLnJlZHVjZSgoZGF0ZXMsIGR0KSA9PiB7XHJcbiAgICAgIGNvbnN0IGRhdGUgPSBwYXJzZURhdGUoZHQsIGZvcm1hdCwgbG9jYWxlKTtcclxuICAgICAgcmV0dXJuIGRhdGUgIT09IHVuZGVmaW5lZCA/IHB1c2hVbmlxdWUoZGF0ZXMsIGRhdGUpIDogZGF0ZXM7XHJcbiAgICB9LCBbXSk7XHJcbiAgICBkZWxldGUgaW5PcHRzLmRhdGVzRGlzYWJsZWQ7XHJcbiAgfVxyXG4gIGlmIChpbk9wdHMuZGVmYXVsdFZpZXdEYXRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGNvbnN0IHZpZXdEYXRlID0gcGFyc2VEYXRlKGluT3B0cy5kZWZhdWx0Vmlld0RhdGUsIGZvcm1hdCwgbG9jYWxlKTtcclxuICAgIGlmICh2aWV3RGF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbmZpZy5kZWZhdWx0Vmlld0RhdGUgPSB2aWV3RGF0ZTtcclxuICAgIH1cclxuICAgIGRlbGV0ZSBpbk9wdHMuZGVmYXVsdFZpZXdEYXRlO1xyXG4gIH1cclxuXHJcbiAgLy8qKiogZGF5cyBvZiB3ZWVrICoqKi8vXHJcbiAgaWYgKGluT3B0cy53ZWVrU3RhcnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgY29uc3Qgd2tTdGFydCA9IE51bWJlcihpbk9wdHMud2Vla1N0YXJ0KSAlIDc7XHJcbiAgICBpZiAoIWlzTmFOKHdrU3RhcnQpKSB7XHJcbiAgICAgIHdlZWtTdGFydCA9IGNvbmZpZy53ZWVrU3RhcnQgPSB3a1N0YXJ0O1xyXG4gICAgICBjb25maWcud2Vla0VuZCA9IGNhbGNFbmRPZldlZWsod2tTdGFydCk7XHJcbiAgICB9XHJcbiAgICBkZWxldGUgaW5PcHRzLndlZWtTdGFydDtcclxuICB9XHJcbiAgaWYgKGluT3B0cy5kYXlzT2ZXZWVrRGlzYWJsZWQpIHtcclxuICAgIGNvbmZpZy5kYXlzT2ZXZWVrRGlzYWJsZWQgPSBpbk9wdHMuZGF5c09mV2Vla0Rpc2FibGVkLnJlZHVjZShzYW5pdGl6ZURPVywgW10pO1xyXG4gICAgZGVsZXRlIGluT3B0cy5kYXlzT2ZXZWVrRGlzYWJsZWQ7XHJcbiAgfVxyXG4gIGlmIChpbk9wdHMuZGF5c09mV2Vla0hpZ2hsaWdodGVkKSB7XHJcbiAgICBjb25maWcuZGF5c09mV2Vla0hpZ2hsaWdodGVkID0gaW5PcHRzLmRheXNPZldlZWtIaWdobGlnaHRlZC5yZWR1Y2Uoc2FuaXRpemVET1csIFtdKTtcclxuICAgIGRlbGV0ZSBpbk9wdHMuZGF5c09mV2Vla0hpZ2hsaWdodGVkO1xyXG4gIH1cclxuXHJcbiAgLy8qKiogbXVsdGkgZGF0ZSAqKiovL1xyXG4gIGlmIChpbk9wdHMubWF4TnVtYmVyT2ZEYXRlcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBjb25zdCBtYXhOdW1iZXJPZkRhdGVzID0gcGFyc2VJbnQoaW5PcHRzLm1heE51bWJlck9mRGF0ZXMsIDEwKTtcclxuICAgIGlmIChtYXhOdW1iZXJPZkRhdGVzID49IDApIHtcclxuICAgICAgY29uZmlnLm1heE51bWJlck9mRGF0ZXMgPSBtYXhOdW1iZXJPZkRhdGVzO1xyXG4gICAgICBjb25maWcubXVsdGlkYXRlID0gbWF4TnVtYmVyT2ZEYXRlcyAhPT0gMTtcclxuICAgIH1cclxuICAgIGRlbGV0ZSBpbk9wdHMubWF4TnVtYmVyT2ZEYXRlcztcclxuICB9XHJcbiAgaWYgKGluT3B0cy5kYXRlRGVsaW1pdGVyKSB7XHJcbiAgICBjb25maWcuZGF0ZURlbGltaXRlciA9IFN0cmluZyhpbk9wdHMuZGF0ZURlbGltaXRlcik7XHJcbiAgICBkZWxldGUgaW5PcHRzLmRhdGVEZWxpbWl0ZXI7XHJcbiAgfVxyXG5cclxuICAvLyoqKiBwaWNrIGxldmVsICYgdmlldyAqKiovL1xyXG4gIGxldCBuZXdQaWNrTGV2ZWwgPSBwaWNrTGV2ZWw7XHJcbiAgaWYgKGluT3B0cy5waWNrTGV2ZWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgbmV3UGlja0xldmVsID0gdmFsaWRhdGVWaWV3SWQoaW5PcHRzLnBpY2tMZXZlbCwgMik7XHJcbiAgICBkZWxldGUgaW5PcHRzLnBpY2tMZXZlbDtcclxuICB9XHJcbiAgaWYgKG5ld1BpY2tMZXZlbCAhPT0gcGlja0xldmVsKSB7XHJcbiAgICBwaWNrTGV2ZWwgPSBjb25maWcucGlja0xldmVsID0gbmV3UGlja0xldmVsO1xyXG4gIH1cclxuXHJcbiAgbGV0IG5ld01heFZpZXcgPSBtYXhWaWV3O1xyXG4gIGlmIChpbk9wdHMubWF4VmlldyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBuZXdNYXhWaWV3ID0gdmFsaWRhdGVWaWV3SWQoaW5PcHRzLm1heFZpZXcsIG1heFZpZXcpO1xyXG4gICAgZGVsZXRlIGluT3B0cy5tYXhWaWV3O1xyXG4gIH1cclxuICAvLyBlbnN1cmUgbWF4IHZpZXcgPj0gcGljayBsZXZlbFxyXG4gIG5ld01heFZpZXcgPSBwaWNrTGV2ZWwgPiBuZXdNYXhWaWV3ID8gcGlja0xldmVsIDogbmV3TWF4VmlldztcclxuICBpZiAobmV3TWF4VmlldyAhPT0gbWF4Vmlldykge1xyXG4gICAgbWF4VmlldyA9IGNvbmZpZy5tYXhWaWV3ID0gbmV3TWF4VmlldztcclxuICB9XHJcblxyXG4gIGxldCBuZXdTdGFydFZpZXcgPSBzdGFydFZpZXc7XHJcbiAgaWYgKGluT3B0cy5zdGFydFZpZXcgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgbmV3U3RhcnRWaWV3ID0gdmFsaWRhdGVWaWV3SWQoaW5PcHRzLnN0YXJ0VmlldywgbmV3U3RhcnRWaWV3KTtcclxuICAgIGRlbGV0ZSBpbk9wdHMuc3RhcnRWaWV3O1xyXG4gIH1cclxuICAvLyBlbnN1cmUgcGljayBsZXZlbCA8PSBzdGFydCB2aWV3IDw9IG1heCB2aWV3XHJcbiAgaWYgKG5ld1N0YXJ0VmlldyA8IHBpY2tMZXZlbCkge1xyXG4gICAgbmV3U3RhcnRWaWV3ID0gcGlja0xldmVsO1xyXG4gIH0gZWxzZSBpZiAobmV3U3RhcnRWaWV3ID4gbWF4Vmlldykge1xyXG4gICAgbmV3U3RhcnRWaWV3ID0gbWF4VmlldztcclxuICB9XHJcbiAgaWYgKG5ld1N0YXJ0VmlldyAhPT0gc3RhcnRWaWV3KSB7XHJcbiAgICBjb25maWcuc3RhcnRWaWV3ID0gbmV3U3RhcnRWaWV3O1xyXG4gIH1cclxuXHJcbiAgLy8qKiogdGVtcGxhdGUgKioqLy9cclxuICBpZiAoaW5PcHRzLnByZXZBcnJvdykge1xyXG4gICAgY29uc3QgcHJldkFycm93ID0gcGFyc2VIVE1MKGluT3B0cy5wcmV2QXJyb3cpO1xyXG4gICAgaWYgKHByZXZBcnJvdy5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uZmlnLnByZXZBcnJvdyA9IHByZXZBcnJvdy5jaGlsZE5vZGVzO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlIGluT3B0cy5wcmV2QXJyb3c7XHJcbiAgfVxyXG4gIGlmIChpbk9wdHMubmV4dEFycm93KSB7XHJcbiAgICBjb25zdCBuZXh0QXJyb3cgPSBwYXJzZUhUTUwoaW5PcHRzLm5leHRBcnJvdyk7XHJcbiAgICBpZiAobmV4dEFycm93LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25maWcubmV4dEFycm93ID0gbmV4dEFycm93LmNoaWxkTm9kZXM7XHJcbiAgICB9XHJcbiAgICBkZWxldGUgaW5PcHRzLm5leHRBcnJvdztcclxuICB9XHJcblxyXG4gIC8vKioqIG1pc2MgKioqLy9cclxuICBpZiAoaW5PcHRzLmRpc2FibGVUb3VjaEtleWJvYXJkICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGNvbmZpZy5kaXNhYmxlVG91Y2hLZXlib2FyZCA9ICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50ICYmICEhaW5PcHRzLmRpc2FibGVUb3VjaEtleWJvYXJkO1xyXG4gICAgZGVsZXRlIGluT3B0cy5kaXNhYmxlVG91Y2hLZXlib2FyZDtcclxuICB9XHJcbiAgaWYgKGluT3B0cy5vcmllbnRhdGlvbikge1xyXG4gICAgY29uc3Qgb3JpZW50YXRpb24gPSBpbk9wdHMub3JpZW50YXRpb24udG9Mb3dlckNhc2UoKS5zcGxpdCgvXFxzKy9nKTtcclxuICAgIGNvbmZpZy5vcmllbnRhdGlvbiA9IHtcclxuICAgICAgeDogb3JpZW50YXRpb24uZmluZCh4ID0+ICh4ID09PSAnbGVmdCcgfHwgeCA9PT0gJ3JpZ2h0JykpIHx8ICdhdXRvJyxcclxuICAgICAgeTogb3JpZW50YXRpb24uZmluZCh5ID0+ICh5ID09PSAndG9wJyB8fCB5ID09PSAnYm90dG9tJykpIHx8ICdhdXRvJyxcclxuICAgIH07XHJcbiAgICBkZWxldGUgaW5PcHRzLm9yaWVudGF0aW9uO1xyXG4gIH1cclxuICBpZiAoaW5PcHRzLnRvZGF5QnRuTW9kZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBzd2l0Y2goaW5PcHRzLnRvZGF5QnRuTW9kZSkge1xyXG4gICAgICBjYXNlIDA6XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICBjb25maWcudG9kYXlCdG5Nb2RlID0gaW5PcHRzLnRvZGF5QnRuTW9kZTtcclxuICAgIH1cclxuICAgIGRlbGV0ZSBpbk9wdHMudG9kYXlCdG5Nb2RlO1xyXG4gIH1cclxuXHJcbiAgLy8qKiogY29weSB0aGUgcmVzdCAqKiovL1xyXG4gIE9iamVjdC5rZXlzKGluT3B0cykuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICBpZiAoaW5PcHRzW2tleV0gIT09IHVuZGVmaW5lZCAmJiBoYXNQcm9wZXJ0eShvcHRpb25zX2RlZmF1bHRPcHRpb25zLCBrZXkpKSB7XHJcbiAgICAgIGNvbmZpZ1trZXldID0gaW5PcHRzW2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBjb25maWc7XHJcbn1cclxuXHJcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdGhlbWVzYmVyZy90YWlsd2luZC1kYXRlcGlja2VyL2pzL3BpY2tlci90ZW1wbGF0ZXMvcGlja2VyVGVtcGxhdGUuanNcclxuXHJcblxyXG5jb25zdCBwaWNrZXJUZW1wbGF0ZSA9IG9wdGltaXplVGVtcGxhdGVIVE1MKGA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlciBoaWRkZW5cIj5cclxuICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1waWNrZXIgaW5saW5lLWJsb2NrIHJvdW5kZWQtbGcgYmctd2hpdGUgZGFyazpiZy1ncmF5LTcwMCBzaGFkb3ctbGcgcC00XCI+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1oZWFkZXJcIj5cclxuICAgICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItdGl0bGUgYmctd2hpdGUgZGFyazpiZy1ncmF5LTcwMCBkYXJrOnRleHQtd2hpdGUgcHgtMiBweS0zIHRleHQtY2VudGVyIGZvbnQtc2VtaWJvbGRcIj48L2Rpdj5cclxuICAgICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItY29udHJvbHMgZmxleCBqdXN0aWZ5LWJldHdlZW4gbWItMlwiPlxyXG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYmctd2hpdGUgZGFyazpiZy1ncmF5LTcwMCByb3VuZGVkLWxnIHRleHQtZ3JheS01MDAgZGFyazp0ZXh0LXdoaXRlIGhvdmVyOmJnLWdyYXktMTAwIGRhcms6aG92ZXI6YmctZ3JheS02MDAgaG92ZXI6dGV4dC1ncmF5LTkwMCBkYXJrOmhvdmVyOnRleHQtd2hpdGUgdGV4dC1sZyBwLTIuNSBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctZ3JheS0yMDAgcHJldi1idG5cIj48L2J1dHRvbj5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cInRleHQtc20gcm91bmRlZC1sZyB0ZXh0LWdyYXktOTAwIGRhcms6dGV4dC13aGl0ZSBiZy13aGl0ZSBkYXJrOmJnLWdyYXktNzAwIGZvbnQtc2VtaWJvbGQgcHktMi41IHB4LTUgaG92ZXI6YmctZ3JheS0xMDAgZGFyazpob3ZlcjpiZy1ncmF5LTYwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctZ3JheS0yMDAgdmlldy1zd2l0Y2hcIj48L2J1dHRvbj5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJnLXdoaXRlIGRhcms6YmctZ3JheS03MDAgcm91bmRlZC1sZyB0ZXh0LWdyYXktNTAwIGRhcms6dGV4dC13aGl0ZSBob3ZlcjpiZy1ncmF5LTEwMCBkYXJrOmhvdmVyOmJnLWdyYXktNjAwIGhvdmVyOnRleHQtZ3JheS05MDAgZGFyazpob3Zlcjp0ZXh0LXdoaXRlIHRleHQtbGcgcC0yLjUgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWdyYXktMjAwIG5leHQtYnRuXCI+PC9idXR0b24+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1tYWluIHAtMVwiPjwvZGl2PlxyXG4gICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItZm9vdGVyXCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLWNvbnRyb2xzIGZsZXggc3BhY2UteC0yIG10LTJcIj5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIiVidXR0b25DbGFzcyUgdG9kYXktYnRuIHRleHQtd2hpdGUgYmctYmx1ZS03MDAgZGFyazpiZy1ibHVlLTYwMCBob3ZlcjpiZy1ibHVlLTgwMCBkYXJrOmhvdmVyOmJnLWJsdWUtNzAwIGZvY3VzOnJpbmctNCBmb2N1czpyaW5nLWJsdWUtMzAwIGZvbnQtbWVkaXVtIHJvdW5kZWQtbGcgdGV4dC1zbSBweC01IHB5LTIgdGV4dC1jZW50ZXIgdy0xLzJcIj48L2J1dHRvbj5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIiVidXR0b25DbGFzcyUgY2xlYXItYnRuIHRleHQtZ3JheS05MDAgZGFyazp0ZXh0LXdoaXRlIGJnLXdoaXRlIGRhcms6YmctZ3JheS03MDAgYm9yZGVyIGJvcmRlci1ncmF5LTMwMCBkYXJrOmJvcmRlci1ncmF5LTYwMCBob3ZlcjpiZy1ncmF5LTEwMCBkYXJrOmhvdmVyOmJnLWdyYXktNjAwIGZvY3VzOnJpbmctNCBmb2N1czpyaW5nLWJsdWUtMzAwIGZvbnQtbWVkaXVtIHJvdW5kZWQtbGcgdGV4dC1zbSBweC01IHB5LTIgdGV4dC1jZW50ZXIgdy0xLzJcIj48L2J1dHRvbj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICA8L2Rpdj5cclxuPC9kaXY+YCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IHRlbXBsYXRlc19waWNrZXJUZW1wbGF0ZSA9IChwaWNrZXJUZW1wbGF0ZSk7XHJcblxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHRoZW1lc2JlcmcvdGFpbHdpbmQtZGF0ZXBpY2tlci9qcy9waWNrZXIvdGVtcGxhdGVzL2RheXNUZW1wbGF0ZS5qc1xyXG5cclxuXHJcbmNvbnN0IGRheXNUZW1wbGF0ZSA9IG9wdGltaXplVGVtcGxhdGVIVE1MKGA8ZGl2IGNsYXNzPVwiZGF5c1wiPlxyXG4gIDxkaXYgY2xhc3M9XCJkYXlzLW9mLXdlZWsgZ3JpZCBncmlkLWNvbHMtNyBtYi0xXCI+JHtjcmVhdGVUYWdSZXBlYXQoJ3NwYW4nLCA3LCB7Y2xhc3M6ICdkb3cgYmxvY2sgZmxleC0xIGxlYWRpbmctOSBib3JkZXItMCByb3VuZGVkLWxnIGN1cnNvci1kZWZhdWx0IHRleHQtY2VudGVyIHRleHQtZ3JheS05MDAgZm9udC1zZW1pYm9sZCB0ZXh0LXNtJ30pfTwvZGl2PlxyXG4gIDxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLWdyaWQgdy02NCBncmlkIGdyaWQtY29scy03XCI+JHtjcmVhdGVUYWdSZXBlYXQoJ3NwYW4nLCA0MiAsIHtjbGFzczogJ2Jsb2NrIGZsZXgtMSBsZWFkaW5nLTkgYm9yZGVyLTAgcm91bmRlZC1sZyBjdXJzb3ItZGVmYXVsdCB0ZXh0LWNlbnRlciB0ZXh0LWdyYXktOTAwIGZvbnQtc2VtaWJvbGQgdGV4dC1zbSBoLTYgbGVhZGluZy02IHRleHQtc20gZm9udC1tZWRpdW0gdGV4dC1ncmF5LTUwMCBkYXJrOnRleHQtZ3JheS00MDAnfSl9PC9kaXY+XHJcbjwvZGl2PmApO1xyXG5cclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCB0ZW1wbGF0ZXNfZGF5c1RlbXBsYXRlID0gKGRheXNUZW1wbGF0ZSk7XHJcblxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHRoZW1lc2JlcmcvdGFpbHdpbmQtZGF0ZXBpY2tlci9qcy9waWNrZXIvdGVtcGxhdGVzL2NhbGVuZGFyV2Vla3NUZW1wbGF0ZS5qc1xyXG5cclxuXHJcbmNvbnN0IGNhbGVuZGFyV2Vla3NUZW1wbGF0ZSA9IG9wdGltaXplVGVtcGxhdGVIVE1MKGA8ZGl2IGNsYXNzPVwiY2FsZW5kYXItd2Vla3NcIj5cclxuICA8ZGl2IGNsYXNzPVwiZGF5cy1vZi13ZWVrIGZsZXhcIj48c3BhbiBjbGFzcz1cImRvdyBoLTYgbGVhZGluZy02IHRleHQtc20gZm9udC1tZWRpdW0gdGV4dC1ncmF5LTUwMCBkYXJrOnRleHQtZ3JheS00MDBcIj48L3NwYW4+PC9kaXY+XHJcbiAgPGRpdiBjbGFzcz1cIndlZWtzXCI+JHtjcmVhdGVUYWdSZXBlYXQoJ3NwYW4nLCA2LCB7Y2xhc3M6ICd3ZWVrIGJsb2NrIGZsZXgtMSBsZWFkaW5nLTkgYm9yZGVyLTAgcm91bmRlZC1sZyBjdXJzb3ItZGVmYXVsdCB0ZXh0LWNlbnRlciB0ZXh0LWdyYXktOTAwIGZvbnQtc2VtaWJvbGQgdGV4dC1zbSd9KX08L2Rpdj5cclxuPC9kaXY+YCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IHRlbXBsYXRlc19jYWxlbmRhcldlZWtzVGVtcGxhdGUgPSAoY2FsZW5kYXJXZWVrc1RlbXBsYXRlKTtcclxuXHJcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdGhlbWVzYmVyZy90YWlsd2luZC1kYXRlcGlja2VyL2pzL3BpY2tlci92aWV3cy9WaWV3LmpzXHJcblxyXG5cclxuXHJcbi8vIEJhc2UgY2xhc3Mgb2YgdGhlIHZpZXcgY2xhc3Nlc1xyXG5jbGFzcyBWaWV3IHtcclxuICBjb25zdHJ1Y3RvcihwaWNrZXIsIGNvbmZpZykge1xyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjb25maWcsIHtcclxuICAgICAgcGlja2VyLFxyXG4gICAgICBlbGVtZW50OiBwYXJzZUhUTUwoYDxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLXZpZXcgZmxleFwiPjwvZGl2PmApLmZpcnN0Q2hpbGQsXHJcbiAgICAgIHNlbGVjdGVkOiBbXSxcclxuICAgIH0pO1xyXG4gICAgdGhpcy5pbml0KHRoaXMucGlja2VyLmRhdGVwaWNrZXIuY29uZmlnKTtcclxuICB9XHJcblxyXG4gIGluaXQob3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMucGlja0xldmVsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy5pc01pblZpZXcgPSB0aGlzLmlkID09PSBvcHRpb25zLnBpY2tMZXZlbDtcclxuICAgIH1cclxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcclxuICAgIHRoaXMudXBkYXRlRm9jdXMoKTtcclxuICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uKCk7XHJcbiAgfVxyXG5cclxuICAvLyBFeGVjdXRlIGJlZm9yZVNob3coKSBjYWxsYmFjayBhbmQgYXBwbHkgdGhlIHJlc3VsdCB0byB0aGUgZWxlbWVudFxyXG4gIC8vIGFyZ3M6XHJcbiAgLy8gLSBjdXJyZW50IC0gY3VycmVudCB2YWx1ZSBvbiB0aGUgaXRlcmF0aW9uIG9uIHZpZXcgcmVuZGVyaW5nXHJcbiAgLy8gLSB0aW1lVmFsdWUgLSB0aW1lIHZhbHVlIG9mIHRoZSBkYXRlIHRvIHBhc3MgdG8gYmVmb3JlU2hvdygpXHJcbiAgcGVyZm9ybUJlZm9yZUhvb2soZWwsIGN1cnJlbnQsIHRpbWVWYWx1ZSkge1xyXG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuYmVmb3JlU2hvdyhuZXcgRGF0ZSh0aW1lVmFsdWUpKTtcclxuICAgIHN3aXRjaCAodHlwZW9mIHJlc3VsdCkge1xyXG4gICAgICBjYXNlICdib29sZWFuJzpcclxuICAgICAgICByZXN1bHQgPSB7ZW5hYmxlZDogcmVzdWx0fTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgICByZXN1bHQgPSB7Y2xhc3NlczogcmVzdWx0fTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgIGlmIChyZXN1bHQuZW5hYmxlZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpO1xyXG4gICAgICAgIHB1c2hVbmlxdWUodGhpcy5kaXNhYmxlZCwgY3VycmVudCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJlc3VsdC5jbGFzc2VzKSB7XHJcbiAgICAgICAgY29uc3QgZXh0cmFDbGFzc2VzID0gcmVzdWx0LmNsYXNzZXMuc3BsaXQoL1xccysvKTtcclxuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKC4uLmV4dHJhQ2xhc3Nlcyk7XHJcbiAgICAgICAgaWYgKGV4dHJhQ2xhc3Nlcy5pbmNsdWRlcygnZGlzYWJsZWQnKSkge1xyXG4gICAgICAgICAgcHVzaFVuaXF1ZSh0aGlzLmRpc2FibGVkLCBjdXJyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJlc3VsdC5jb250ZW50KSB7XHJcbiAgICAgICAgcmVwbGFjZUNoaWxkTm9kZXMoZWwsIHJlc3VsdC5jb250ZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0B0aGVtZXNiZXJnL3RhaWx3aW5kLWRhdGVwaWNrZXIvanMvcGlja2VyL3ZpZXdzL0RheXNWaWV3LmpzXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgRGF5c1ZpZXcgZXh0ZW5kcyBWaWV3IHtcclxuICBjb25zdHJ1Y3RvcihwaWNrZXIpIHtcclxuICAgIHN1cGVyKHBpY2tlciwge1xyXG4gICAgICBpZDogMCxcclxuICAgICAgbmFtZTogJ2RheXMnLFxyXG4gICAgICBjZWxsQ2xhc3M6ICdkYXknLFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBpbml0KG9wdGlvbnMsIG9uQ29uc3RydWN0aW9uID0gdHJ1ZSkge1xyXG4gICAgaWYgKG9uQ29uc3RydWN0aW9uKSB7XHJcbiAgICAgIGNvbnN0IGlubmVyID0gcGFyc2VIVE1MKHRlbXBsYXRlc19kYXlzVGVtcGxhdGUpLmZpcnN0Q2hpbGQ7XHJcbiAgICAgIHRoaXMuZG93ID0gaW5uZXIuZmlyc3RDaGlsZDtcclxuICAgICAgdGhpcy5ncmlkID0gaW5uZXIubGFzdENoaWxkO1xyXG4gICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5uZXIpO1xyXG4gICAgfVxyXG4gICAgc3VwZXIuaW5pdChvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIHNldE9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgbGV0IHVwZGF0ZURPVztcclxuXHJcbiAgICBpZiAoaGFzUHJvcGVydHkob3B0aW9ucywgJ21pbkRhdGUnKSkge1xyXG4gICAgICB0aGlzLm1pbkRhdGUgPSBvcHRpb25zLm1pbkRhdGU7XHJcbiAgICB9XHJcbiAgICBpZiAoaGFzUHJvcGVydHkob3B0aW9ucywgJ21heERhdGUnKSkge1xyXG4gICAgICB0aGlzLm1heERhdGUgPSBvcHRpb25zLm1heERhdGU7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5kYXRlc0Rpc2FibGVkKSB7XHJcbiAgICAgIHRoaXMuZGF0ZXNEaXNhYmxlZCA9IG9wdGlvbnMuZGF0ZXNEaXNhYmxlZDtcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLmRheXNPZldlZWtEaXNhYmxlZCkge1xyXG4gICAgICB0aGlzLmRheXNPZldlZWtEaXNhYmxlZCA9IG9wdGlvbnMuZGF5c09mV2Vla0Rpc2FibGVkO1xyXG4gICAgICB1cGRhdGVET1cgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMuZGF5c09mV2Vla0hpZ2hsaWdodGVkKSB7XHJcbiAgICAgIHRoaXMuZGF5c09mV2Vla0hpZ2hsaWdodGVkID0gb3B0aW9ucy5kYXlzT2ZXZWVrSGlnaGxpZ2h0ZWQ7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy50b2RheUhpZ2hsaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMudG9kYXlIaWdobGlnaHQgPSBvcHRpb25zLnRvZGF5SGlnaGxpZ2h0O1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMud2Vla1N0YXJ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy53ZWVrU3RhcnQgPSBvcHRpb25zLndlZWtTdGFydDtcclxuICAgICAgdGhpcy53ZWVrRW5kID0gb3B0aW9ucy53ZWVrRW5kO1xyXG4gICAgICB1cGRhdGVET1cgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMubG9jYWxlKSB7XHJcbiAgICAgIGNvbnN0IGxvY2FsZSA9IHRoaXMubG9jYWxlID0gb3B0aW9ucy5sb2NhbGU7XHJcbiAgICAgIHRoaXMuZGF5TmFtZXMgPSBsb2NhbGUuZGF5c01pbjtcclxuICAgICAgdGhpcy5zd2l0Y2hMYWJlbEZvcm1hdCA9IGxvY2FsZS50aXRsZUZvcm1hdDtcclxuICAgICAgdXBkYXRlRE9XID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLmJlZm9yZVNob3dEYXkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLmJlZm9yZVNob3cgPSB0eXBlb2Ygb3B0aW9ucy5iZWZvcmVTaG93RGF5ID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgPyBvcHRpb25zLmJlZm9yZVNob3dEYXlcclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0aW9ucy5jYWxlbmRhcldlZWtzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgaWYgKG9wdGlvbnMuY2FsZW5kYXJXZWVrcyAmJiAhdGhpcy5jYWxlbmRhcldlZWtzKSB7XHJcbiAgICAgICAgY29uc3Qgd2Vla3NFbGVtID0gcGFyc2VIVE1MKHRlbXBsYXRlc19jYWxlbmRhcldlZWtzVGVtcGxhdGUpLmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhcldlZWtzID0ge1xyXG4gICAgICAgICAgZWxlbWVudDogd2Vla3NFbGVtLFxyXG4gICAgICAgICAgZG93OiB3ZWVrc0VsZW0uZmlyc3RDaGlsZCxcclxuICAgICAgICAgIHdlZWtzOiB3ZWVrc0VsZW0ubGFzdENoaWxkLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5lbGVtZW50Lmluc2VydEJlZm9yZSh3ZWVrc0VsZW0sIHRoaXMuZWxlbWVudC5maXJzdENoaWxkKTtcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLmNhbGVuZGFyV2Vla3MgJiYgIW9wdGlvbnMuY2FsZW5kYXJXZWVrcykge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLmNhbGVuZGFyV2Vla3MuZWxlbWVudCk7XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhcldlZWtzID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMuc2hvd0RheXNPZldlZWsgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAob3B0aW9ucy5zaG93RGF5c09mV2Vlaykge1xyXG4gICAgICAgIHNob3dFbGVtZW50KHRoaXMuZG93KTtcclxuICAgICAgICBpZiAodGhpcy5jYWxlbmRhcldlZWtzKSB7XHJcbiAgICAgICAgICBzaG93RWxlbWVudCh0aGlzLmNhbGVuZGFyV2Vla3MuZG93KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaGlkZUVsZW1lbnQodGhpcy5kb3cpO1xyXG4gICAgICAgIGlmICh0aGlzLmNhbGVuZGFyV2Vla3MpIHtcclxuICAgICAgICAgIGhpZGVFbGVtZW50KHRoaXMuY2FsZW5kYXJXZWVrcy5kb3cpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHVwZGF0ZSBkYXlzLW9mLXdlZWsgd2hlbiBsb2NhbGUsIGRheXNPZndlZWtEaXNhYmxlZCBvciB3ZWVrU3RhcnQgaXMgY2hhbmdlZFxyXG4gICAgaWYgKHVwZGF0ZURPVykge1xyXG4gICAgICBBcnJheS5mcm9tKHRoaXMuZG93LmNoaWxkcmVuKS5mb3JFYWNoKChlbCwgaW5kZXgpID0+IHtcclxuICAgICAgICBjb25zdCBkb3cgPSAodGhpcy53ZWVrU3RhcnQgKyBpbmRleCkgJSA3O1xyXG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gdGhpcy5kYXlOYW1lc1tkb3ddO1xyXG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IHRoaXMuZGF5c09mV2Vla0Rpc2FibGVkLmluY2x1ZGVzKGRvdykgPyAnZG93IGRpc2FibGVkIHRleHQtY2VudGVyIGgtNiBsZWFkaW5nLTYgdGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LWdyYXktNTAwIGRhcms6dGV4dC1ncmF5LTQwMCBjdXJzb3Itbm90LWFsbG93ZWQnIDogJ2RvdyB0ZXh0LWNlbnRlciBoLTYgbGVhZGluZy02IHRleHQtc20gZm9udC1tZWRpdW0gdGV4dC1ncmF5LTUwMCBkYXJrOnRleHQtZ3JheS00MDAnO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFwcGx5IHVwZGF0ZSBvbiB0aGUgZm9jdXNlZCBkYXRlIHRvIHZpZXcncyBzZXR0aW5nc1xyXG4gIHVwZGF0ZUZvY3VzKCkge1xyXG4gICAgY29uc3Qgdmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLnBpY2tlci52aWV3RGF0ZSk7XHJcbiAgICBjb25zdCB2aWV3WWVhciA9IHZpZXdEYXRlLmdldEZ1bGxZZWFyKCk7XHJcbiAgICBjb25zdCB2aWV3TW9udGggPSB2aWV3RGF0ZS5nZXRNb250aCgpO1xyXG4gICAgY29uc3QgZmlyc3RPZk1vbnRoID0gZGF0ZVZhbHVlKHZpZXdZZWFyLCB2aWV3TW9udGgsIDEpO1xyXG4gICAgY29uc3Qgc3RhcnQgPSBkYXlPZlRoZVdlZWtPZihmaXJzdE9mTW9udGgsIHRoaXMud2Vla1N0YXJ0LCB0aGlzLndlZWtTdGFydCk7XHJcblxyXG4gICAgdGhpcy5maXJzdCA9IGZpcnN0T2ZNb250aDtcclxuICAgIHRoaXMubGFzdCA9IGRhdGVWYWx1ZSh2aWV3WWVhciwgdmlld01vbnRoICsgMSwgMCk7XHJcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICB0aGlzLmZvY3VzZWQgPSB0aGlzLnBpY2tlci52aWV3RGF0ZTtcclxuICB9XHJcblxyXG4gIC8vIEFwcGx5IHVwZGF0ZSBvbiB0aGUgc2VsZWN0ZWQgZGF0ZXMgdG8gdmlldydzIHNldHRpbmdzXHJcbiAgdXBkYXRlU2VsZWN0aW9uKCkge1xyXG4gICAgY29uc3Qge2RhdGVzLCByYW5nZXBpY2tlcn0gPSB0aGlzLnBpY2tlci5kYXRlcGlja2VyO1xyXG4gICAgdGhpcy5zZWxlY3RlZCA9IGRhdGVzO1xyXG4gICAgaWYgKHJhbmdlcGlja2VyKSB7XHJcbiAgICAgIHRoaXMucmFuZ2UgPSByYW5nZXBpY2tlci5kYXRlcztcclxuICAgIH1cclxuICB9XHJcblxyXG4gICAvLyBVcGRhdGUgdGhlIGVudGlyZSB2aWV3IFVJXHJcbiAgcmVuZGVyKCkge1xyXG4gICAgLy8gdXBkYXRlIHRvZGF5IG1hcmtlciBvbiBldmVyIHJlbmRlclxyXG4gICAgdGhpcy50b2RheSA9IHRoaXMudG9kYXlIaWdobGlnaHQgPyB0b2RheSgpIDogdW5kZWZpbmVkO1xyXG4gICAgLy8gcmVmcmVzaCBkaXNhYmxlZCBkYXRlcyBvbiBldmVyeSByZW5kZXIgaW4gb3JkZXIgdG8gY2xlYXIgdGhlIG9uZXMgYWRkZWRcclxuICAgIC8vIGJ5IGJlZm9yZVNob3cgaG9vayBhdCBwcmV2aW91cyByZW5kZXJcclxuICAgIHRoaXMuZGlzYWJsZWQgPSBbLi4udGhpcy5kYXRlc0Rpc2FibGVkXTtcclxuXHJcbiAgICBjb25zdCBzd2l0Y2hMYWJlbCA9IGZvcm1hdERhdGUodGhpcy5mb2N1c2VkLCB0aGlzLnN3aXRjaExhYmVsRm9ybWF0LCB0aGlzLmxvY2FsZSk7XHJcbiAgICB0aGlzLnBpY2tlci5zZXRWaWV3U3dpdGNoTGFiZWwoc3dpdGNoTGFiZWwpO1xyXG4gICAgdGhpcy5waWNrZXIuc2V0UHJldkJ0bkRpc2FibGVkKHRoaXMuZmlyc3QgPD0gdGhpcy5taW5EYXRlKTtcclxuICAgIHRoaXMucGlja2VyLnNldE5leHRCdG5EaXNhYmxlZCh0aGlzLmxhc3QgPj0gdGhpcy5tYXhEYXRlKTtcclxuXHJcbiAgICBpZiAodGhpcy5jYWxlbmRhcldlZWtzKSB7XHJcbiAgICAgIC8vIHN0YXJ0IG9mIHRoZSBVVEMgd2VlayAoTW9uZGF5KSBvZiB0aGUgMXN0IG9mIHRoZSBtb250aFxyXG4gICAgICBjb25zdCBzdGFydE9mV2VlayA9IGRheU9mVGhlV2Vla09mKHRoaXMuZmlyc3QsIDEsIDEpO1xyXG4gICAgICBBcnJheS5mcm9tKHRoaXMuY2FsZW5kYXJXZWVrcy53ZWVrcy5jaGlsZHJlbikuZm9yRWFjaCgoZWwsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSBnZXRXZWVrKGFkZFdlZWtzKHN0YXJ0T2ZXZWVrLCBpbmRleCkpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIEFycmF5LmZyb20odGhpcy5ncmlkLmNoaWxkcmVuKS5mb3JFYWNoKChlbCwgaW5kZXgpID0+IHtcclxuICAgICAgY29uc3QgY2xhc3NMaXN0ID0gZWwuY2xhc3NMaXN0O1xyXG4gICAgICBjb25zdCBjdXJyZW50ID0gYWRkRGF5cyh0aGlzLnN0YXJ0LCBpbmRleCk7XHJcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShjdXJyZW50KTtcclxuICAgICAgY29uc3QgZGF5ID0gZGF0ZS5nZXREYXkoKTtcclxuXHJcbiAgICAgIGVsLmNsYXNzTmFtZSA9IGBkYXRlcGlja2VyLWNlbGwgaG92ZXI6YmctZ3JheS0xMDAgZGFyazpob3ZlcjpiZy1ncmF5LTYwMCBibG9jayBmbGV4LTEgbGVhZGluZy05IGJvcmRlci0wIHJvdW5kZWQtbGcgY3Vyc29yLXBvaW50ZXIgdGV4dC1jZW50ZXIgdGV4dC1ncmF5LTkwMCBkYXJrOnRleHQtd2hpdGUgZm9udC1zZW1pYm9sZCB0ZXh0LXNtICR7dGhpcy5jZWxsQ2xhc3N9YDtcclxuICAgICAgZWwuZGF0YXNldC5kYXRlID0gY3VycmVudDtcclxuICAgICAgZWwudGV4dENvbnRlbnQgPSBkYXRlLmdldERhdGUoKTtcclxuXHJcbiAgICAgIGlmIChjdXJyZW50IDwgdGhpcy5maXJzdCkge1xyXG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3ByZXYnLCAndGV4dC1ncmF5LTUwMCcsICdkYXJrOnRleHQtd2hpdGUnKTtcclxuICAgICAgfSBlbHNlIGlmIChjdXJyZW50ID4gdGhpcy5sYXN0KSB7XHJcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnbmV4dCcsICd0ZXh0LWdyYXktNTAwJywgJ2Rhcms6dGV4dC13aGl0ZScpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLnRvZGF5ID09PSBjdXJyZW50KSB7XHJcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgndG9kYXknLCAnYmctZ3JheS0xMDAnLCAnZGFyazpiZy1ncmF5LTYwMCcsICdkYXJrOmJnLWdyYXktNjAwJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGN1cnJlbnQgPCB0aGlzLm1pbkRhdGUgfHwgY3VycmVudCA+IHRoaXMubWF4RGF0ZSB8fCB0aGlzLmRpc2FibGVkLmluY2x1ZGVzKGN1cnJlbnQpKSB7XHJcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQnLCAnY3Vyc29yLW5vdC1hbGxvd2VkJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuZGF5c09mV2Vla0Rpc2FibGVkLmluY2x1ZGVzKGRheSkpIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcsICdjdXJzb3Itbm90LWFsbG93ZWQnKTtcclxuICAgICAgICBwdXNoVW5pcXVlKHRoaXMuZGlzYWJsZWQsIGN1cnJlbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLmRheXNPZldlZWtIaWdobGlnaHRlZC5pbmNsdWRlcyhkYXkpKSB7XHJcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnaGlnaGxpZ2h0ZWQnKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5yYW5nZSkge1xyXG4gICAgICAgIGNvbnN0IFtyYW5nZVN0YXJ0LCByYW5nZUVuZF0gPSB0aGlzLnJhbmdlO1xyXG4gICAgICAgIGlmIChjdXJyZW50ID4gcmFuZ2VTdGFydCAmJiBjdXJyZW50IDwgcmFuZ2VFbmQpIHtcclxuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlJywgJ2JnLWdyYXktMjAwJywgJ2Rhcms6YmctZ3JheS02MDAnKTtcclxuICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3JvdW5kZWQtbGcnLCAncm91bmRlZC1sLWxnJywgJ3JvdW5kZWQtci1sZycpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjdXJyZW50ID09PSByYW5nZVN0YXJ0KSB7XHJcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1zdGFydCcsICdiZy1ncmF5LTEwMCcsICdkYXJrOmJnLWdyYXktNjAwJywgJ3JvdW5kZWQtbC1sZycpO1xyXG4gICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgncm91bmRlZC1sZycsICdyb3VuZGVkLXItbGcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlRW5kKSB7XHJcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1lbmQnLCAnYmctZ3JheS0xMDAnLCAnZGFyazpiZy1ncmF5LTYwMCcsICdyb3VuZGVkLXItbGcnKTtcclxuICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3JvdW5kZWQtbGcnLCAncm91bmRlZC1sLWxnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkLmluY2x1ZGVzKGN1cnJlbnQpKSB7XHJcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnLCAnYmctYmx1ZS03MDAnLCAndGV4dC13aGl0ZScsICdkYXJrOmJnLWJsdWUtNjAwJywgJ2Rhcms6dGV4dC13aGl0ZScpO1xyXG4gICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3RleHQtZ3JheS05MDAnLCAndGV4dC1ncmF5LTUwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZvY3VzZWQpIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdmb2N1c2VkJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLmJlZm9yZVNob3cpIHtcclxuICAgICAgICB0aGlzLnBlcmZvcm1CZWZvcmVIb29rKGVsLCBjdXJyZW50LCBjdXJyZW50KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBVcGRhdGUgdGhlIHZpZXcgVUkgYnkgYXBwbHlpbmcgdGhlIGNoYW5nZXMgb2Ygc2VsZWN0ZWQgYW5kIGZvY3VzZWQgaXRlbXNcclxuICByZWZyZXNoKCkge1xyXG4gICAgY29uc3QgW3JhbmdlU3RhcnQsIHJhbmdlRW5kXSA9IHRoaXMucmFuZ2UgfHwgW107XHJcbiAgICB0aGlzLmdyaWRcclxuICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoJy5yYW5nZSwgLnJhbmdlLXN0YXJ0LCAucmFuZ2UtZW5kLCAuc2VsZWN0ZWQsIC5mb2N1c2VkJylcclxuICAgICAgLmZvckVhY2goKGVsKSA9PiB7XHJcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgncmFuZ2UnLCAncmFuZ2Utc3RhcnQnLCAncmFuZ2UtZW5kJywgJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJ3RleHQtd2hpdGUnLCAnZGFyazpiZy1ibHVlLTYwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZm9jdXNlZCcsICdiZy1ncmF5LTEwMCcsICdkYXJrOmJnLWdyYXktNjAwJyk7XHJcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgndGV4dC1ncmF5LTkwMCcsICdyb3VuZGVkLWxnJywgJ2Rhcms6dGV4dC13aGl0ZScpO1xyXG4gICAgICB9KTtcclxuICAgIEFycmF5LmZyb20odGhpcy5ncmlkLmNoaWxkcmVuKS5mb3JFYWNoKChlbCkgPT4ge1xyXG4gICAgICBjb25zdCBjdXJyZW50ID0gTnVtYmVyKGVsLmRhdGFzZXQuZGF0ZSk7XHJcbiAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IGVsLmNsYXNzTGlzdDtcclxuICAgICAgaWYgKGN1cnJlbnQgPiByYW5nZVN0YXJ0ICYmIGN1cnJlbnQgPCByYW5nZUVuZCkge1xyXG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlJywgJ2JnLWdyYXktMjAwJywgJ2Rhcms6YmctZ3JheS02MDAnKTtcclxuICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCdyb3VuZGVkLWxnJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlU3RhcnQpIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1zdGFydCcsICdiZy1ncmF5LTIwMCcsICdkYXJrOmJnLWdyYXktNjAwJywgJ3JvdW5kZWQtbC1sZycpO1xyXG4gICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3JvdW5kZWQtbGcnLCAncm91bmRlZC1yLWxnJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlRW5kKSB7XHJcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UtZW5kJywgJ2JnLWdyYXktMjAwJywgJ2Rhcms6YmctZ3JheS02MDAnLCAncm91bmRlZC1yLWxnJyk7XHJcbiAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgncm91bmRlZC1sZycsICdyb3VuZGVkLWwtbGcnKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5zZWxlY3RlZC5pbmNsdWRlcyhjdXJyZW50KSkge1xyXG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJ3RleHQtd2hpdGUnLCAnZGFyazpiZy1ibHVlLTYwMCcsICdkYXJrOnRleHQtd2hpdGUnKTtcclxuICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCd0ZXh0LWdyYXktOTAwJywgJ2hvdmVyOmJnLWdyYXktMTAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICdkYXJrOmhvdmVyOmJnLWdyYXktNjAwJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZm9jdXNlZCkge1xyXG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ2ZvY3VzZWQnLCAnYmctZ3JheS0xMDAnLCAnZGFyazpiZy1ncmF5LTYwMCcpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIFVwZGF0ZSB0aGUgdmlldyBVSSBieSBhcHBseWluZyB0aGUgY2hhbmdlIG9mIGZvY3VzZWQgaXRlbVxyXG4gIHJlZnJlc2hGb2N1cygpIHtcclxuICAgIGNvbnN0IGluZGV4ID0gTWF0aC5yb3VuZCgodGhpcy5mb2N1c2VkIC0gdGhpcy5zdGFydCkgLyA4NjQwMDAwMCk7XHJcbiAgICB0aGlzLmdyaWQucXVlcnlTZWxlY3RvckFsbCgnLmZvY3VzZWQnKS5mb3JFYWNoKChlbCkgPT4ge1xyXG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdmb2N1c2VkJywgJ2JnLWdyYXktMTAwJywgJ2Rhcms6YmctZ3JheS02MDAnKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5ncmlkLmNoaWxkcmVuW2luZGV4XS5jbGFzc0xpc3QuYWRkKCdmb2N1c2VkJywgJ2JnLWdyYXktMTAwJywgJ2Rhcms6YmctZ3JheS02MDAnKTtcclxuICB9XHJcbn1cclxuXHJcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdGhlbWVzYmVyZy90YWlsd2luZC1kYXRlcGlja2VyL2pzL3BpY2tlci92aWV3cy9Nb250aHNWaWV3LmpzXHJcblxyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gY29tcHV0ZU1vbnRoUmFuZ2UocmFuZ2UsIHRoaXNZZWFyKSB7XHJcbiAgaWYgKCFyYW5nZSB8fCAhcmFuZ2VbMF0gfHwgIXJhbmdlWzFdKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBjb25zdCBbW3N0YXJ0WSwgc3RhcnRNXSwgW2VuZFksIGVuZE1dXSA9IHJhbmdlO1xyXG4gIGlmIChzdGFydFkgPiB0aGlzWWVhciB8fCBlbmRZIDwgdGhpc1llYXIpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgcmV0dXJuIFtcclxuICAgIHN0YXJ0WSA9PT0gdGhpc1llYXIgPyBzdGFydE0gOiAtMSxcclxuICAgIGVuZFkgPT09IHRoaXNZZWFyID8gZW5kTSA6IDEyLFxyXG4gIF07XHJcbn1cclxuXHJcbmNsYXNzIE1vbnRoc1ZpZXcgZXh0ZW5kcyBWaWV3IHtcclxuICBjb25zdHJ1Y3RvcihwaWNrZXIpIHtcclxuICAgIHN1cGVyKHBpY2tlciwge1xyXG4gICAgICBpZDogMSxcclxuICAgICAgbmFtZTogJ21vbnRocycsXHJcbiAgICAgIGNlbGxDbGFzczogJ21vbnRoJyxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaW5pdChvcHRpb25zLCBvbkNvbnN0cnVjdGlvbiA9IHRydWUpIHtcclxuICAgIGlmIChvbkNvbnN0cnVjdGlvbikge1xyXG4gICAgICB0aGlzLmdyaWQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdtb250aHMnLCAnZGF0ZXBpY2tlci1ncmlkJywgJ3ctNjQnLCAnZ3JpZCcsICdncmlkLWNvbHMtNCcpO1xyXG4gICAgICB0aGlzLmdyaWQuYXBwZW5kQ2hpbGQocGFyc2VIVE1MKGNyZWF0ZVRhZ1JlcGVhdCgnc3BhbicsIDEyLCB7J2RhdGEtbW9udGgnOiBpeCA9PiBpeH0pKSk7XHJcbiAgICB9XHJcbiAgICBzdXBlci5pbml0KG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucy5sb2NhbGUpIHtcclxuICAgICAgdGhpcy5tb250aE5hbWVzID0gb3B0aW9ucy5sb2NhbGUubW9udGhzU2hvcnQ7XHJcbiAgICB9XHJcbiAgICBpZiAoaGFzUHJvcGVydHkob3B0aW9ucywgJ21pbkRhdGUnKSkge1xyXG4gICAgICBpZiAob3B0aW9ucy5taW5EYXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aGlzLm1pblllYXIgPSB0aGlzLm1pbk1vbnRoID0gdGhpcy5taW5EYXRlID0gdW5kZWZpbmVkO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG1pbkRhdGVPYmogPSBuZXcgRGF0ZShvcHRpb25zLm1pbkRhdGUpO1xyXG4gICAgICAgIHRoaXMubWluWWVhciA9IG1pbkRhdGVPYmouZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICB0aGlzLm1pbk1vbnRoID0gbWluRGF0ZU9iai5nZXRNb250aCgpO1xyXG4gICAgICAgIHRoaXMubWluRGF0ZSA9IG1pbkRhdGVPYmouc2V0RGF0ZSgxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGhhc1Byb3BlcnR5KG9wdGlvbnMsICdtYXhEYXRlJykpIHtcclxuICAgICAgaWYgKG9wdGlvbnMubWF4RGF0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhpcy5tYXhZZWFyID0gdGhpcy5tYXhNb250aCA9IHRoaXMubWF4RGF0ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBtYXhEYXRlT2JqID0gbmV3IERhdGUob3B0aW9ucy5tYXhEYXRlKTtcclxuICAgICAgICB0aGlzLm1heFllYXIgPSBtYXhEYXRlT2JqLmdldEZ1bGxZZWFyKCk7XHJcbiAgICAgICAgdGhpcy5tYXhNb250aCA9IG1heERhdGVPYmouZ2V0TW9udGgoKTtcclxuICAgICAgICB0aGlzLm1heERhdGUgPSBkYXRlVmFsdWUodGhpcy5tYXhZZWFyLCB0aGlzLm1heE1vbnRoICsgMSwgMCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLmJlZm9yZVNob3dNb250aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMuYmVmb3JlU2hvdyA9IHR5cGVvZiBvcHRpb25zLmJlZm9yZVNob3dNb250aCA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgID8gb3B0aW9ucy5iZWZvcmVTaG93TW9udGhcclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFVwZGF0ZSB2aWV3J3Mgc2V0dGluZ3MgdG8gcmVmbGVjdCB0aGUgdmlld0RhdGUgc2V0IG9uIHRoZSBwaWNrZXJcclxuICB1cGRhdGVGb2N1cygpIHtcclxuICAgIGNvbnN0IHZpZXdEYXRlID0gbmV3IERhdGUodGhpcy5waWNrZXIudmlld0RhdGUpO1xyXG4gICAgdGhpcy55ZWFyID0gdmlld0RhdGUuZ2V0RnVsbFllYXIoKTtcclxuICAgIHRoaXMuZm9jdXNlZCA9IHZpZXdEYXRlLmdldE1vbnRoKCk7XHJcbiAgfVxyXG5cclxuICAvLyBVcGRhdGUgdmlldydzIHNldHRpbmdzIHRvIHJlZmxlY3QgdGhlIHNlbGVjdGVkIGRhdGVzXHJcbiAgdXBkYXRlU2VsZWN0aW9uKCkge1xyXG4gICAgY29uc3Qge2RhdGVzLCByYW5nZXBpY2tlcn0gPSB0aGlzLnBpY2tlci5kYXRlcGlja2VyO1xyXG4gICAgdGhpcy5zZWxlY3RlZCA9IGRhdGVzLnJlZHVjZSgoc2VsZWN0ZWQsIHRpbWVWYWx1ZSkgPT4ge1xyXG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodGltZVZhbHVlKTtcclxuICAgICAgY29uc3QgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgY29uc3QgbW9udGggPSBkYXRlLmdldE1vbnRoKCk7XHJcbiAgICAgIGlmIChzZWxlY3RlZFt5ZWFyXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgc2VsZWN0ZWRbeWVhcl0gPSBbbW9udGhdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHB1c2hVbmlxdWUoc2VsZWN0ZWRbeWVhcl0sIG1vbnRoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XHJcbiAgICB9LCB7fSk7XHJcbiAgICBpZiAocmFuZ2VwaWNrZXIgJiYgcmFuZ2VwaWNrZXIuZGF0ZXMpIHtcclxuICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlcGlja2VyLmRhdGVzLm1hcCh0aW1lVmFsdWUgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aW1lVmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBpc05hTihkYXRlKSA/IHVuZGVmaW5lZCA6IFtkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKV07XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gVXBkYXRlIHRoZSBlbnRpcmUgdmlldyBVSVxyXG4gIHJlbmRlcigpIHtcclxuICAgIC8vIHJlZnJlc2ggZGlzYWJsZWQgbW9udGhzIG9uIGV2ZXJ5IHJlbmRlciBpbiBvcmRlciB0byBjbGVhciB0aGUgb25lcyBhZGRlZFxyXG4gICAgLy8gYnkgYmVmb3JlU2hvdyBob29rIGF0IHByZXZpb3VzIHJlbmRlclxyXG4gICAgdGhpcy5kaXNhYmxlZCA9IFtdO1xyXG5cclxuICAgIHRoaXMucGlja2VyLnNldFZpZXdTd2l0Y2hMYWJlbCh0aGlzLnllYXIpO1xyXG4gICAgdGhpcy5waWNrZXIuc2V0UHJldkJ0bkRpc2FibGVkKHRoaXMueWVhciA8PSB0aGlzLm1pblllYXIpO1xyXG4gICAgdGhpcy5waWNrZXIuc2V0TmV4dEJ0bkRpc2FibGVkKHRoaXMueWVhciA+PSB0aGlzLm1heFllYXIpO1xyXG5cclxuICAgIGNvbnN0IHNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZFt0aGlzLnllYXJdIHx8IFtdO1xyXG4gICAgY29uc3QgeXJPdXRPZlJhbmdlID0gdGhpcy55ZWFyIDwgdGhpcy5taW5ZZWFyIHx8IHRoaXMueWVhciA+IHRoaXMubWF4WWVhcjtcclxuICAgIGNvbnN0IGlzTWluWWVhciA9IHRoaXMueWVhciA9PT0gdGhpcy5taW5ZZWFyO1xyXG4gICAgY29uc3QgaXNNYXhZZWFyID0gdGhpcy55ZWFyID09PSB0aGlzLm1heFllYXI7XHJcbiAgICBjb25zdCByYW5nZSA9IGNvbXB1dGVNb250aFJhbmdlKHRoaXMucmFuZ2UsIHRoaXMueWVhcik7XHJcblxyXG4gICAgQXJyYXkuZnJvbSh0aGlzLmdyaWQuY2hpbGRyZW4pLmZvckVhY2goKGVsLCBpbmRleCkgPT4ge1xyXG4gICAgICBjb25zdCBjbGFzc0xpc3QgPSBlbC5jbGFzc0xpc3Q7XHJcbiAgICAgIGNvbnN0IGRhdGUgPSBkYXRlVmFsdWUodGhpcy55ZWFyLCBpbmRleCwgMSk7XHJcblxyXG4gICAgICBlbC5jbGFzc05hbWUgPSBgZGF0ZXBpY2tlci1jZWxsIGhvdmVyOmJnLWdyYXktMTAwIGRhcms6aG92ZXI6YmctZ3JheS02MDAgYmxvY2sgZmxleC0xIGxlYWRpbmctOSBib3JkZXItMCByb3VuZGVkLWxnIGN1cnNvci1wb2ludGVyIHRleHQtY2VudGVyIHRleHQtZ3JheS05MDAgZGFyazp0ZXh0LXdoaXRlIGZvbnQtc2VtaWJvbGQgdGV4dC1zbSAke3RoaXMuY2VsbENsYXNzfWA7XHJcbiAgICAgIGlmICh0aGlzLmlzTWluVmlldykge1xyXG4gICAgICAgIGVsLmRhdGFzZXQuZGF0ZSA9IGRhdGU7XHJcbiAgICAgIH1cclxuICAgICAgLy8gcmVzZXQgdGV4dCBvbiBldmVyeSByZW5kZXIgdG8gY2xlYXIgdGhlIGN1c3RvbSBjb250ZW50IHNldFxyXG4gICAgICAvLyBieSBiZWZvcmVTaG93IGhvb2sgYXQgcHJldmlvdXMgcmVuZGVyXHJcbiAgICAgIGVsLnRleHRDb250ZW50ID0gdGhpcy5tb250aE5hbWVzW2luZGV4XTtcclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICB5ck91dE9mUmFuZ2VcclxuICAgICAgICB8fCBpc01pblllYXIgJiYgaW5kZXggPCB0aGlzLm1pbk1vbnRoXHJcbiAgICAgICAgfHwgaXNNYXhZZWFyICYmIGluZGV4ID4gdGhpcy5tYXhNb250aFxyXG4gICAgICApIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyYW5nZSkge1xyXG4gICAgICAgIGNvbnN0IFtyYW5nZVN0YXJ0LCByYW5nZUVuZF0gPSByYW5nZTtcclxuICAgICAgICBpZiAoaW5kZXggPiByYW5nZVN0YXJ0ICYmIGluZGV4IDwgcmFuZ2VFbmQpIHtcclxuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbmRleCA9PT0gcmFuZ2VTdGFydCkge1xyXG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2Utc3RhcnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluZGV4ID09PSByYW5nZUVuZCkge1xyXG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UtZW5kJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChzZWxlY3RlZC5pbmNsdWRlcyhpbmRleCkpIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcsICdiZy1ibHVlLTcwMCcsICd0ZXh0LXdoaXRlJywgJ2Rhcms6YmctYmx1ZS02MDAnLCAnZGFyazp0ZXh0LXdoaXRlJyk7XHJcbiAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1ncmF5LTkwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5mb2N1c2VkKSB7XHJcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcsICdiZy1ncmF5LTEwMCcsICdkYXJrOmJnLWdyYXktNjAwJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLmJlZm9yZVNob3cpIHtcclxuICAgICAgICB0aGlzLnBlcmZvcm1CZWZvcmVIb29rKGVsLCBpbmRleCwgZGF0ZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gVXBkYXRlIHRoZSB2aWV3IFVJIGJ5IGFwcGx5aW5nIHRoZSBjaGFuZ2VzIG9mIHNlbGVjdGVkIGFuZCBmb2N1c2VkIGl0ZW1zXHJcbiAgcmVmcmVzaCgpIHtcclxuICAgIGNvbnN0IHNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZFt0aGlzLnllYXJdIHx8IFtdO1xyXG4gICAgY29uc3QgW3JhbmdlU3RhcnQsIHJhbmdlRW5kXSA9IGNvbXB1dGVNb250aFJhbmdlKHRoaXMucmFuZ2UsIHRoaXMueWVhcikgfHwgW107XHJcbiAgICB0aGlzLmdyaWRcclxuICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoJy5yYW5nZSwgLnJhbmdlLXN0YXJ0LCAucmFuZ2UtZW5kLCAuc2VsZWN0ZWQsIC5mb2N1c2VkJylcclxuICAgICAgLmZvckVhY2goKGVsKSA9PiB7XHJcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgncmFuZ2UnLCAncmFuZ2Utc3RhcnQnLCAncmFuZ2UtZW5kJywgJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJ2Rhcms6YmctYmx1ZS02MDAnLCAnZGFyazp0ZXh0LXdoaXRlJywgJ3RleHQtd2hpdGUnLCAnZm9jdXNlZCcsICdiZy1ncmF5LTEwMCcsICdkYXJrOmJnLWdyYXktNjAwJyk7XHJcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgndGV4dC1ncmF5LTkwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcpO1xyXG4gICAgICB9KTtcclxuICAgIEFycmF5LmZyb20odGhpcy5ncmlkLmNoaWxkcmVuKS5mb3JFYWNoKChlbCwgaW5kZXgpID0+IHtcclxuICAgICAgY29uc3QgY2xhc3NMaXN0ID0gZWwuY2xhc3NMaXN0O1xyXG4gICAgICBpZiAoaW5kZXggPiByYW5nZVN0YXJ0ICYmIGluZGV4IDwgcmFuZ2VFbmQpIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZScpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpbmRleCA9PT0gcmFuZ2VTdGFydCkge1xyXG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlLXN0YXJ0Jyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGluZGV4ID09PSByYW5nZUVuZCkge1xyXG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlLWVuZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzZWxlY3RlZC5pbmNsdWRlcyhpbmRleCkpIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcsICdiZy1ibHVlLTcwMCcsICd0ZXh0LXdoaXRlJywgJ2Rhcms6YmctYmx1ZS02MDAnLCAnZGFyazp0ZXh0LXdoaXRlJyk7XHJcbiAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1ncmF5LTkwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5mb2N1c2VkKSB7XHJcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcsICdiZy1ncmF5LTEwMCcsICdkYXJrOmJnLWdyYXktNjAwJyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gVXBkYXRlIHRoZSB2aWV3IFVJIGJ5IGFwcGx5aW5nIHRoZSBjaGFuZ2Ugb2YgZm9jdXNlZCBpdGVtXHJcbiAgcmVmcmVzaEZvY3VzKCkge1xyXG4gICAgdGhpcy5ncmlkLnF1ZXJ5U2VsZWN0b3JBbGwoJy5mb2N1c2VkJykuZm9yRWFjaCgoZWwpID0+IHtcclxuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnZm9jdXNlZCcsICdiZy1ncmF5LTEwMCcpLCAnZGFyazpiZy1ncmF5LTYwMCc7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuZ3JpZC5jaGlsZHJlblt0aGlzLmZvY3VzZWRdLmNsYXNzTGlzdC5hZGQoJ2ZvY3VzZWQnLCAnYmctZ3JheS0xMDAnLCAnZGFyazpiZy1ncmF5LTYwMCcpO1xyXG4gIH1cclxufVxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHRoZW1lc2JlcmcvdGFpbHdpbmQtZGF0ZXBpY2tlci9qcy9waWNrZXIvdmlld3MvWWVhcnNWaWV3LmpzXHJcblxyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gdG9UaXRsZUNhc2Uod29yZCkge1xyXG4gIHJldHVybiBbLi4ud29yZF0ucmVkdWNlKChzdHIsIGNoLCBpeCkgPT4gc3RyICs9IGl4ID8gY2ggOiBjaC50b1VwcGVyQ2FzZSgpLCAnJyk7XHJcbn1cclxuXHJcbi8vIENsYXNzIHJlcHJlc2VudGluZyB0aGUgeWVhcnMgYW5kIGRlY2FkZXMgdmlldyBlbGVtZW50c1xyXG5jbGFzcyBZZWFyc1ZpZXcgZXh0ZW5kcyBWaWV3IHtcclxuICBjb25zdHJ1Y3RvcihwaWNrZXIsIGNvbmZpZykge1xyXG4gICAgc3VwZXIocGlja2VyLCBjb25maWcpO1xyXG4gIH1cclxuXHJcbiAgaW5pdChvcHRpb25zLCBvbkNvbnN0cnVjdGlvbiA9IHRydWUpIHtcclxuICAgIGlmIChvbkNvbnN0cnVjdGlvbikge1xyXG4gICAgICB0aGlzLm5hdlN0ZXAgPSB0aGlzLnN0ZXAgKiAxMDtcclxuICAgICAgdGhpcy5iZWZvcmVTaG93T3B0aW9uID0gYGJlZm9yZVNob3cke3RvVGl0bGVDYXNlKHRoaXMuY2VsbENsYXNzKX1gO1xyXG4gICAgICB0aGlzLmdyaWQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMubmFtZSwgJ2RhdGVwaWNrZXItZ3JpZCcsICd3LTY0JywgJ2dyaWQnLCAnZ3JpZC1jb2xzLTQnKTtcclxuICAgICAgdGhpcy5ncmlkLmFwcGVuZENoaWxkKHBhcnNlSFRNTChjcmVhdGVUYWdSZXBlYXQoJ3NwYW4nLCAxMikpKTtcclxuICAgIH1cclxuICAgIHN1cGVyLmluaXQob3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcclxuICAgIGlmIChoYXNQcm9wZXJ0eShvcHRpb25zLCAnbWluRGF0ZScpKSB7XHJcbiAgICAgIGlmIChvcHRpb25zLm1pbkRhdGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRoaXMubWluWWVhciA9IHRoaXMubWluRGF0ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLm1pblllYXIgPSBzdGFydE9mWWVhclBlcmlvZChvcHRpb25zLm1pbkRhdGUsIHRoaXMuc3RlcCk7XHJcbiAgICAgICAgdGhpcy5taW5EYXRlID0gZGF0ZVZhbHVlKHRoaXMubWluWWVhciwgMCwgMSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChoYXNQcm9wZXJ0eShvcHRpb25zLCAnbWF4RGF0ZScpKSB7XHJcbiAgICAgIGlmIChvcHRpb25zLm1heERhdGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRoaXMubWF4WWVhciA9IHRoaXMubWF4RGF0ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLm1heFllYXIgPSBzdGFydE9mWWVhclBlcmlvZChvcHRpb25zLm1heERhdGUsIHRoaXMuc3RlcCk7XHJcbiAgICAgICAgdGhpcy5tYXhEYXRlID0gZGF0ZVZhbHVlKHRoaXMubWF4WWVhciwgMTEsIDMxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnNbdGhpcy5iZWZvcmVTaG93T3B0aW9uXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbnN0IGJlZm9yZVNob3cgPSBvcHRpb25zW3RoaXMuYmVmb3JlU2hvd09wdGlvbl07XHJcbiAgICAgIHRoaXMuYmVmb3JlU2hvdyA9IHR5cGVvZiBiZWZvcmVTaG93ID09PSAnZnVuY3Rpb24nID8gYmVmb3JlU2hvdyA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFVwZGF0ZSB2aWV3J3Mgc2V0dGluZ3MgdG8gcmVmbGVjdCB0aGUgdmlld0RhdGUgc2V0IG9uIHRoZSBwaWNrZXJcclxuICB1cGRhdGVGb2N1cygpIHtcclxuICAgIGNvbnN0IHZpZXdEYXRlID0gbmV3IERhdGUodGhpcy5waWNrZXIudmlld0RhdGUpO1xyXG4gICAgY29uc3QgZmlyc3QgPSBzdGFydE9mWWVhclBlcmlvZCh2aWV3RGF0ZSwgdGhpcy5uYXZTdGVwKTtcclxuICAgIGNvbnN0IGxhc3QgPSBmaXJzdCArIDkgKiB0aGlzLnN0ZXA7XHJcblxyXG4gICAgdGhpcy5maXJzdCA9IGZpcnN0O1xyXG4gICAgdGhpcy5sYXN0ID0gbGFzdDtcclxuICAgIHRoaXMuc3RhcnQgPSBmaXJzdCAtIHRoaXMuc3RlcDtcclxuICAgIHRoaXMuZm9jdXNlZCA9IHN0YXJ0T2ZZZWFyUGVyaW9kKHZpZXdEYXRlLCB0aGlzLnN0ZXApO1xyXG4gIH1cclxuXHJcbiAgLy8gVXBkYXRlIHZpZXcncyBzZXR0aW5ncyB0byByZWZsZWN0IHRoZSBzZWxlY3RlZCBkYXRlc1xyXG4gIHVwZGF0ZVNlbGVjdGlvbigpIHtcclxuICAgIGNvbnN0IHtkYXRlcywgcmFuZ2VwaWNrZXJ9ID0gdGhpcy5waWNrZXIuZGF0ZXBpY2tlcjtcclxuICAgIHRoaXMuc2VsZWN0ZWQgPSBkYXRlcy5yZWR1Y2UoKHllYXJzLCB0aW1lVmFsdWUpID0+IHtcclxuICAgICAgcmV0dXJuIHB1c2hVbmlxdWUoeWVhcnMsIHN0YXJ0T2ZZZWFyUGVyaW9kKHRpbWVWYWx1ZSwgdGhpcy5zdGVwKSk7XHJcbiAgICB9LCBbXSk7XHJcbiAgICBpZiAocmFuZ2VwaWNrZXIgJiYgcmFuZ2VwaWNrZXIuZGF0ZXMpIHtcclxuICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlcGlja2VyLmRhdGVzLm1hcCh0aW1lVmFsdWUgPT4ge1xyXG4gICAgICAgIGlmICh0aW1lVmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZZZWFyUGVyaW9kKHRpbWVWYWx1ZSwgdGhpcy5zdGVwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gVXBkYXRlIHRoZSBlbnRpcmUgdmlldyBVSVxyXG4gIHJlbmRlcigpIHtcclxuICAgIC8vIHJlZnJlc2ggZGlzYWJsZWQgeWVhcnMgb24gZXZlcnkgcmVuZGVyIGluIG9yZGVyIHRvIGNsZWFyIHRoZSBvbmVzIGFkZGVkXHJcbiAgICAvLyBieSBiZWZvcmVTaG93IGhvb2sgYXQgcHJldmlvdXMgcmVuZGVyXHJcbiAgICB0aGlzLmRpc2FibGVkID0gW107XHJcblxyXG4gICAgdGhpcy5waWNrZXIuc2V0Vmlld1N3aXRjaExhYmVsKGAke3RoaXMuZmlyc3R9LSR7dGhpcy5sYXN0fWApO1xyXG4gICAgdGhpcy5waWNrZXIuc2V0UHJldkJ0bkRpc2FibGVkKHRoaXMuZmlyc3QgPD0gdGhpcy5taW5ZZWFyKTtcclxuICAgIHRoaXMucGlja2VyLnNldE5leHRCdG5EaXNhYmxlZCh0aGlzLmxhc3QgPj0gdGhpcy5tYXhZZWFyKTtcclxuXHJcbiAgICBBcnJheS5mcm9tKHRoaXMuZ3JpZC5jaGlsZHJlbikuZm9yRWFjaCgoZWwsIGluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IGVsLmNsYXNzTGlzdDtcclxuICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuc3RhcnQgKyAoaW5kZXggKiB0aGlzLnN0ZXApO1xyXG4gICAgICBjb25zdCBkYXRlID0gZGF0ZVZhbHVlKGN1cnJlbnQsIDAsIDEpO1xyXG5cclxuICAgICAgZWwuY2xhc3NOYW1lID0gYGRhdGVwaWNrZXItY2VsbCBob3ZlcjpiZy1ncmF5LTEwMCBkYXJrOmhvdmVyOmJnLWdyYXktNjAwIGJsb2NrIGZsZXgtMSBsZWFkaW5nLTkgYm9yZGVyLTAgcm91bmRlZC1sZyBjdXJzb3ItcG9pbnRlciB0ZXh0LWNlbnRlciB0ZXh0LWdyYXktOTAwIGRhcms6dGV4dC13aGl0ZSBmb250LXNlbWlib2xkIHRleHQtc20gJHt0aGlzLmNlbGxDbGFzc31gO1xyXG4gICAgICBpZiAodGhpcy5pc01pblZpZXcpIHtcclxuICAgICAgICBlbC5kYXRhc2V0LmRhdGUgPSBkYXRlO1xyXG4gICAgICB9XHJcbiAgICAgIGVsLnRleHRDb250ZW50ID0gZWwuZGF0YXNldC55ZWFyID0gY3VycmVudDtcclxuXHJcbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xyXG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3ByZXYnKTtcclxuICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMTEpIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCduZXh0Jyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGN1cnJlbnQgPCB0aGlzLm1pblllYXIgfHwgY3VycmVudCA+IHRoaXMubWF4WWVhcikge1xyXG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ2Rpc2FibGVkJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMucmFuZ2UpIHtcclxuICAgICAgICBjb25zdCBbcmFuZ2VTdGFydCwgcmFuZ2VFbmRdID0gdGhpcy5yYW5nZTtcclxuICAgICAgICBpZiAoY3VycmVudCA+IHJhbmdlU3RhcnQgJiYgY3VycmVudCA8IHJhbmdlRW5kKSB7XHJcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY3VycmVudCA9PT0gcmFuZ2VTdGFydCkge1xyXG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2Utc3RhcnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlRW5kKSB7XHJcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1lbmQnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQuaW5jbHVkZXMoY3VycmVudCkpIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcsICdiZy1ibHVlLTcwMCcsICd0ZXh0LXdoaXRlJywgJ2Rhcms6YmctYmx1ZS02MDAnLCAnZGFyazp0ZXh0LXdoaXRlJyk7XHJcbiAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1ncmF5LTkwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZvY3VzZWQpIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdmb2N1c2VkJywgJ2JnLWdyYXktMTAwJywgJ2Rhcms6YmctZ3JheS02MDAnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuYmVmb3JlU2hvdykge1xyXG4gICAgICAgIHRoaXMucGVyZm9ybUJlZm9yZUhvb2soZWwsIGN1cnJlbnQsIGRhdGUpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIFVwZGF0ZSB0aGUgdmlldyBVSSBieSBhcHBseWluZyB0aGUgY2hhbmdlcyBvZiBzZWxlY3RlZCBhbmQgZm9jdXNlZCBpdGVtc1xyXG4gIHJlZnJlc2goKSB7XHJcbiAgICBjb25zdCBbcmFuZ2VTdGFydCwgcmFuZ2VFbmRdID0gdGhpcy5yYW5nZSB8fCBbXTtcclxuICAgIHRoaXMuZ3JpZFxyXG4gICAgICAucXVlcnlTZWxlY3RvckFsbCgnLnJhbmdlLCAucmFuZ2Utc3RhcnQsIC5yYW5nZS1lbmQsIC5zZWxlY3RlZCwgLmZvY3VzZWQnKVxyXG4gICAgICAuZm9yRWFjaCgoZWwpID0+IHtcclxuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdyYW5nZScsICdyYW5nZS1zdGFydCcsICdyYW5nZS1lbmQnLCAnc2VsZWN0ZWQnLCAnYmctYmx1ZS03MDAnLCAndGV4dC13aGl0ZScsICdkYXJrOmJnLWJsdWUtNjAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICdmb2N1c2VkJywgJ2JnLWdyYXktMTAwJywgJ2Rhcms6YmctZ3JheS02MDAnKTtcclxuICAgICAgfSk7XHJcbiAgICBBcnJheS5mcm9tKHRoaXMuZ3JpZC5jaGlsZHJlbikuZm9yRWFjaCgoZWwpID0+IHtcclxuICAgICAgY29uc3QgY3VycmVudCA9IE51bWJlcihlbC50ZXh0Q29udGVudCk7XHJcbiAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IGVsLmNsYXNzTGlzdDtcclxuICAgICAgaWYgKGN1cnJlbnQgPiByYW5nZVN0YXJ0ICYmIGN1cnJlbnQgPCByYW5nZUVuZCkge1xyXG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlU3RhcnQpIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1zdGFydCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjdXJyZW50ID09PSByYW5nZUVuZCkge1xyXG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlLWVuZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkLmluY2x1ZGVzKGN1cnJlbnQpKSB7XHJcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnLCAnYmctYmx1ZS03MDAnLCAndGV4dC13aGl0ZScsICdkYXJrOmJnLWJsdWUtNjAwJywgJ2Rhcms6dGV4dC13aGl0ZScpO1xyXG4gICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3RleHQtZ3JheS05MDAnLCAnaG92ZXI6YmctZ3JheS0xMDAnLCAnZGFyazp0ZXh0LXdoaXRlJywgJ2Rhcms6aG92ZXI6YmctZ3JheS02MDAnKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5mb2N1c2VkKSB7XHJcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcsICdiZy1ncmF5LTEwMCcsICdkYXJrOmJnLWdyYXktNjAwJyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gVXBkYXRlIHRoZSB2aWV3IFVJIGJ5IGFwcGx5aW5nIHRoZSBjaGFuZ2Ugb2YgZm9jdXNlZCBpdGVtXHJcbiAgcmVmcmVzaEZvY3VzKCkge1xyXG4gICAgY29uc3QgaW5kZXggPSBNYXRoLnJvdW5kKCh0aGlzLmZvY3VzZWQgLSB0aGlzLnN0YXJ0KSAvIHRoaXMuc3RlcCk7XHJcbiAgICB0aGlzLmdyaWQucXVlcnlTZWxlY3RvckFsbCgnLmZvY3VzZWQnKS5mb3JFYWNoKChlbCkgPT4ge1xyXG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdmb2N1c2VkJywgJ2JnLWdyYXktMTAwJywgJ2Rhcms6YmctZ3JheS02MDAnKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5ncmlkLmNoaWxkcmVuW2luZGV4XS5jbGFzc0xpc3QuYWRkKCdmb2N1c2VkJywgJ2JnLWdyYXktMTAwJywgJ2Rhcms6YmctZ3JheS02MDAnKTtcclxuICB9XHJcbn1cclxuXHJcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdGhlbWVzYmVyZy90YWlsd2luZC1kYXRlcGlja2VyL2pzL2V2ZW50cy9mdW5jdGlvbnMuanNcclxuXHJcblxyXG5cclxuZnVuY3Rpb24gdHJpZ2dlckRhdGVwaWNrZXJFdmVudChkYXRlcGlja2VyLCB0eXBlKSB7XHJcbiAgY29uc3QgZGV0YWlsID0ge1xyXG4gICAgZGF0ZTogZGF0ZXBpY2tlci5nZXREYXRlKCksXHJcbiAgICB2aWV3RGF0ZTogbmV3IERhdGUoZGF0ZXBpY2tlci5waWNrZXIudmlld0RhdGUpLFxyXG4gICAgdmlld0lkOiBkYXRlcGlja2VyLnBpY2tlci5jdXJyZW50Vmlldy5pZCxcclxuICAgIGRhdGVwaWNrZXIsXHJcbiAgfTtcclxuICBkYXRlcGlja2VyLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQodHlwZSwge2RldGFpbH0pKTtcclxufVxyXG5cclxuLy8gZGlyZWN0aW9uOiAtMSAodG8gcHJldmlvdXMpLCAxICh0byBuZXh0KVxyXG5mdW5jdGlvbiBnb1RvUHJldk9yTmV4dChkYXRlcGlja2VyLCBkaXJlY3Rpb24pIHtcclxuICBjb25zdCB7bWluRGF0ZSwgbWF4RGF0ZX0gPSBkYXRlcGlja2VyLmNvbmZpZztcclxuICBjb25zdCB7Y3VycmVudFZpZXcsIHZpZXdEYXRlfSA9IGRhdGVwaWNrZXIucGlja2VyO1xyXG4gIGxldCBuZXdWaWV3RGF0ZTtcclxuICBzd2l0Y2ggKGN1cnJlbnRWaWV3LmlkKSB7XHJcbiAgICBjYXNlIDA6XHJcbiAgICAgIG5ld1ZpZXdEYXRlID0gYWRkTW9udGhzKHZpZXdEYXRlLCBkaXJlY3Rpb24pO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMTpcclxuICAgICAgbmV3Vmlld0RhdGUgPSBhZGRZZWFycyh2aWV3RGF0ZSwgZGlyZWN0aW9uKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBuZXdWaWV3RGF0ZSA9IGFkZFllYXJzKHZpZXdEYXRlLCBkaXJlY3Rpb24gKiBjdXJyZW50Vmlldy5uYXZTdGVwKTtcclxuICB9XHJcbiAgbmV3Vmlld0RhdGUgPSBsaW1pdFRvUmFuZ2UobmV3Vmlld0RhdGUsIG1pbkRhdGUsIG1heERhdGUpO1xyXG4gIGRhdGVwaWNrZXIucGlja2VyLmNoYW5nZUZvY3VzKG5ld1ZpZXdEYXRlKS5yZW5kZXIoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3dpdGNoVmlldyhkYXRlcGlja2VyKSB7XHJcbiAgY29uc3Qgdmlld0lkID0gZGF0ZXBpY2tlci5waWNrZXIuY3VycmVudFZpZXcuaWQ7XHJcbiAgaWYgKHZpZXdJZCA9PT0gZGF0ZXBpY2tlci5jb25maWcubWF4Vmlldykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBkYXRlcGlja2VyLnBpY2tlci5jaGFuZ2VWaWV3KHZpZXdJZCArIDEpLnJlbmRlcigpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1bmZvY3VzKGRhdGVwaWNrZXIpIHtcclxuICBpZiAoZGF0ZXBpY2tlci5jb25maWcudXBkYXRlT25CbHVyKSB7XHJcbiAgICBkYXRlcGlja2VyLnVwZGF0ZSh7YXV0b2hpZGU6IHRydWV9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgZGF0ZXBpY2tlci5yZWZyZXNoKCdpbnB1dCcpO1xyXG4gICAgZGF0ZXBpY2tlci5oaWRlKCk7XHJcbiAgfVxyXG59XHJcblxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHRoZW1lc2JlcmcvdGFpbHdpbmQtZGF0ZXBpY2tlci9qcy9ldmVudHMvcGlja2VyTGlzdGVuZXJzLmpzXHJcblxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBnb1RvU2VsZWN0ZWRNb250aE9yWWVhcihkYXRlcGlja2VyLCBzZWxlY3Rpb24pIHtcclxuICBjb25zdCBwaWNrZXIgPSBkYXRlcGlja2VyLnBpY2tlcjtcclxuICBjb25zdCB2aWV3RGF0ZSA9IG5ldyBEYXRlKHBpY2tlci52aWV3RGF0ZSk7XHJcbiAgY29uc3Qgdmlld0lkID0gcGlja2VyLmN1cnJlbnRWaWV3LmlkO1xyXG4gIGNvbnN0IG5ld0RhdGUgPSB2aWV3SWQgPT09IDFcclxuICAgID8gYWRkTW9udGhzKHZpZXdEYXRlLCBzZWxlY3Rpb24gLSB2aWV3RGF0ZS5nZXRNb250aCgpKVxyXG4gICAgOiBhZGRZZWFycyh2aWV3RGF0ZSwgc2VsZWN0aW9uIC0gdmlld0RhdGUuZ2V0RnVsbFllYXIoKSk7XHJcblxyXG4gIHBpY2tlci5jaGFuZ2VGb2N1cyhuZXdEYXRlKS5jaGFuZ2VWaWV3KHZpZXdJZCAtIDEpLnJlbmRlcigpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvbkNsaWNrVG9kYXlCdG4oZGF0ZXBpY2tlcikge1xyXG4gIGNvbnN0IHBpY2tlciA9IGRhdGVwaWNrZXIucGlja2VyO1xyXG4gIGNvbnN0IGN1cnJlbnREYXRlID0gdG9kYXkoKTtcclxuICBpZiAoZGF0ZXBpY2tlci5jb25maWcudG9kYXlCdG5Nb2RlID09PSAxKSB7XHJcbiAgICBpZiAoZGF0ZXBpY2tlci5jb25maWcuYXV0b2hpZGUpIHtcclxuICAgICAgZGF0ZXBpY2tlci5zZXREYXRlKGN1cnJlbnREYXRlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZGF0ZXBpY2tlci5zZXREYXRlKGN1cnJlbnREYXRlLCB7cmVuZGVyOiBmYWxzZX0pO1xyXG4gICAgcGlja2VyLnVwZGF0ZSgpO1xyXG4gIH1cclxuICBpZiAocGlja2VyLnZpZXdEYXRlICE9PSBjdXJyZW50RGF0ZSkge1xyXG4gICAgcGlja2VyLmNoYW5nZUZvY3VzKGN1cnJlbnREYXRlKTtcclxuICB9XHJcbiAgcGlja2VyLmNoYW5nZVZpZXcoMCkucmVuZGVyKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9uQ2xpY2tDbGVhckJ0bihkYXRlcGlja2VyKSB7XHJcbiAgZGF0ZXBpY2tlci5zZXREYXRlKHtjbGVhcjogdHJ1ZX0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvbkNsaWNrVmlld1N3aXRjaChkYXRlcGlja2VyKSB7XHJcbiAgc3dpdGNoVmlldyhkYXRlcGlja2VyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gb25DbGlja1ByZXZCdG4oZGF0ZXBpY2tlcikge1xyXG4gIGdvVG9QcmV2T3JOZXh0KGRhdGVwaWNrZXIsIC0xKTtcclxufVxyXG5cclxuZnVuY3Rpb24gb25DbGlja05leHRCdG4oZGF0ZXBpY2tlcikge1xyXG4gIGdvVG9QcmV2T3JOZXh0KGRhdGVwaWNrZXIsIDEpO1xyXG59XHJcblxyXG4vLyBGb3IgdGhlIHBpY2tlcidzIG1haW4gYmxvY2sgdG8gZGVsZWdldGUgdGhlIGV2ZW50cyBmcm9tIGBkYXRlcGlja2VyLWNlbGxgc1xyXG5mdW5jdGlvbiBvbkNsaWNrVmlldyhkYXRlcGlja2VyLCBldikge1xyXG4gIGNvbnN0IHRhcmdldCA9IGZpbmRFbGVtZW50SW5FdmVudFBhdGgoZXYsICcuZGF0ZXBpY2tlci1jZWxsJyk7XHJcbiAgaWYgKCF0YXJnZXQgfHwgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qge2lkLCBpc01pblZpZXd9ID0gZGF0ZXBpY2tlci5waWNrZXIuY3VycmVudFZpZXc7XHJcbiAgaWYgKGlzTWluVmlldykge1xyXG4gICAgZGF0ZXBpY2tlci5zZXREYXRlKE51bWJlcih0YXJnZXQuZGF0YXNldC5kYXRlKSk7XHJcbiAgfSBlbHNlIGlmIChpZCA9PT0gMSkge1xyXG4gICAgZ29Ub1NlbGVjdGVkTW9udGhPclllYXIoZGF0ZXBpY2tlciwgTnVtYmVyKHRhcmdldC5kYXRhc2V0Lm1vbnRoKSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGdvVG9TZWxlY3RlZE1vbnRoT3JZZWFyKGRhdGVwaWNrZXIsIE51bWJlcih0YXJnZXQuZGF0YXNldC55ZWFyKSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBvbkNsaWNrUGlja2VyKGRhdGVwaWNrZXIpIHtcclxuICBpZiAoIWRhdGVwaWNrZXIuaW5saW5lICYmICFkYXRlcGlja2VyLmNvbmZpZy5kaXNhYmxlVG91Y2hLZXlib2FyZCkge1xyXG4gICAgZGF0ZXBpY2tlci5pbnB1dEZpZWxkLmZvY3VzKCk7XHJcbiAgfVxyXG59XHJcblxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHRoZW1lc2JlcmcvdGFpbHdpbmQtZGF0ZXBpY2tlci9qcy9waWNrZXIvUGlja2VyLmpzXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc1BpY2tlck9wdGlvbnMocGlja2VyLCBvcHRpb25zKSB7XHJcbiAgaWYgKG9wdGlvbnMudGl0bGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKG9wdGlvbnMudGl0bGUpIHtcclxuICAgICAgcGlja2VyLmNvbnRyb2xzLnRpdGxlLnRleHRDb250ZW50ID0gb3B0aW9ucy50aXRsZTtcclxuICAgICAgc2hvd0VsZW1lbnQocGlja2VyLmNvbnRyb2xzLnRpdGxlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBpY2tlci5jb250cm9scy50aXRsZS50ZXh0Q29udGVudCA9ICcnO1xyXG4gICAgICBoaWRlRWxlbWVudChwaWNrZXIuY29udHJvbHMudGl0bGUpO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAob3B0aW9ucy5wcmV2QXJyb3cpIHtcclxuICAgIGNvbnN0IHByZXZCdG4gPSBwaWNrZXIuY29udHJvbHMucHJldkJ0bjtcclxuICAgIGVtcHR5Q2hpbGROb2RlcyhwcmV2QnRuKTtcclxuICAgIG9wdGlvbnMucHJldkFycm93LmZvckVhY2goKG5vZGUpID0+IHtcclxuICAgICAgcHJldkJ0bi5hcHBlbmRDaGlsZChub2RlLmNsb25lTm9kZSh0cnVlKSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgaWYgKG9wdGlvbnMubmV4dEFycm93KSB7XHJcbiAgICBjb25zdCBuZXh0QnRuID0gcGlja2VyLmNvbnRyb2xzLm5leHRCdG47XHJcbiAgICBlbXB0eUNoaWxkTm9kZXMobmV4dEJ0bik7XHJcbiAgICBvcHRpb25zLm5leHRBcnJvdy5mb3JFYWNoKChub2RlKSA9PiB7XHJcbiAgICAgIG5leHRCdG4uYXBwZW5kQ2hpbGQobm9kZS5jbG9uZU5vZGUodHJ1ZSkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGlmIChvcHRpb25zLmxvY2FsZSkge1xyXG4gICAgcGlja2VyLmNvbnRyb2xzLnRvZGF5QnRuLnRleHRDb250ZW50ID0gb3B0aW9ucy5sb2NhbGUudG9kYXk7XHJcbiAgICBwaWNrZXIuY29udHJvbHMuY2xlYXJCdG4udGV4dENvbnRlbnQgPSBvcHRpb25zLmxvY2FsZS5jbGVhcjtcclxuICB9XHJcbiAgaWYgKG9wdGlvbnMudG9kYXlCdG4gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKG9wdGlvbnMudG9kYXlCdG4pIHtcclxuICAgICAgc2hvd0VsZW1lbnQocGlja2VyLmNvbnRyb2xzLnRvZGF5QnRuKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGhpZGVFbGVtZW50KHBpY2tlci5jb250cm9scy50b2RheUJ0bik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChoYXNQcm9wZXJ0eShvcHRpb25zLCAnbWluRGF0ZScpIHx8IGhhc1Byb3BlcnR5KG9wdGlvbnMsICdtYXhEYXRlJykpIHtcclxuICAgIGNvbnN0IHttaW5EYXRlLCBtYXhEYXRlfSA9IHBpY2tlci5kYXRlcGlja2VyLmNvbmZpZztcclxuICAgIHBpY2tlci5jb250cm9scy50b2RheUJ0bi5kaXNhYmxlZCA9ICFpc0luUmFuZ2UodG9kYXkoKSwgbWluRGF0ZSwgbWF4RGF0ZSk7XHJcbiAgfVxyXG4gIGlmIChvcHRpb25zLmNsZWFyQnRuICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGlmIChvcHRpb25zLmNsZWFyQnRuKSB7XHJcbiAgICAgIHNob3dFbGVtZW50KHBpY2tlci5jb250cm9scy5jbGVhckJ0bik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBoaWRlRWxlbWVudChwaWNrZXIuY29udHJvbHMuY2xlYXJCdG4pO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gQ29tcHV0ZSB2aWV3IGRhdGUgdG8gcmVzZXQsIHdoaWNoIHdpbGwgYmUuLi5cclxuLy8gLSB0aGUgbGFzdCBpdGVtIG9mIHRoZSBzZWxlY3RlZCBkYXRlcyBvciBkZWZhdWx0Vmlld0RhdGUgaWYgbm8gc2VsZWN0aW9uXHJcbi8vIC0gbGltaXR0ZWQgdG8gbWluRGF0ZSBvciBtYXhEYXRlIGlmIGl0IGV4Y2VlZHMgdGhlIHJhbmdlXHJcbmZ1bmN0aW9uIGNvbXB1dGVSZXNldFZpZXdEYXRlKGRhdGVwaWNrZXIpIHtcclxuICBjb25zdCB7ZGF0ZXMsIGNvbmZpZ30gPSBkYXRlcGlja2VyO1xyXG4gIGNvbnN0IHZpZXdEYXRlID0gZGF0ZXMubGVuZ3RoID4gMCA/IGxhc3RJdGVtT2YoZGF0ZXMpIDogY29uZmlnLmRlZmF1bHRWaWV3RGF0ZTtcclxuICByZXR1cm4gbGltaXRUb1JhbmdlKHZpZXdEYXRlLCBjb25maWcubWluRGF0ZSwgY29uZmlnLm1heERhdGUpO1xyXG59XHJcblxyXG4vLyBDaGFuZ2UgY3VycmVudCB2aWV3J3MgdmlldyBkYXRlXHJcbmZ1bmN0aW9uIHNldFZpZXdEYXRlKHBpY2tlciwgbmV3RGF0ZSkge1xyXG4gIGNvbnN0IG9sZFZpZXdEYXRlID0gbmV3IERhdGUocGlja2VyLnZpZXdEYXRlKTtcclxuICBjb25zdCBuZXdWaWV3RGF0ZSA9IG5ldyBEYXRlKG5ld0RhdGUpO1xyXG4gIGNvbnN0IHtpZCwgeWVhciwgZmlyc3QsIGxhc3R9ID0gcGlja2VyLmN1cnJlbnRWaWV3O1xyXG4gIGNvbnN0IHZpZXdZZWFyID0gbmV3Vmlld0RhdGUuZ2V0RnVsbFllYXIoKTtcclxuXHJcbiAgcGlja2VyLnZpZXdEYXRlID0gbmV3RGF0ZTtcclxuICBpZiAodmlld1llYXIgIT09IG9sZFZpZXdEYXRlLmdldEZ1bGxZZWFyKCkpIHtcclxuICAgIHRyaWdnZXJEYXRlcGlja2VyRXZlbnQocGlja2VyLmRhdGVwaWNrZXIsICdjaGFuZ2VZZWFyJyk7XHJcbiAgfVxyXG4gIGlmIChuZXdWaWV3RGF0ZS5nZXRNb250aCgpICE9PSBvbGRWaWV3RGF0ZS5nZXRNb250aCgpKSB7XHJcbiAgICB0cmlnZ2VyRGF0ZXBpY2tlckV2ZW50KHBpY2tlci5kYXRlcGlja2VyLCAnY2hhbmdlTW9udGgnKTtcclxuICB9XHJcblxyXG4gIC8vIHJldHVybiB3aGV0aGVyIHRoZSBuZXcgZGF0ZSBpcyBpbiBkaWZmZXJlbnQgcGVyaW9kIG9uIHRpbWUgZnJvbSB0aGUgb25lXHJcbiAgLy8gZGlzcGxheWVkIGluIHRoZSBjdXJyZW50IHZpZXdcclxuICAvLyB3aGVuIHRydWUsIHRoZSB2aWV3IG5lZWRzIHRvIGJlIHJlLXJlbmRlcmVkIG9uIHRoZSBuZXh0IFVJIHJlZnJlc2guXHJcbiAgc3dpdGNoIChpZCkge1xyXG4gICAgY2FzZSAwOlxyXG4gICAgICByZXR1cm4gbmV3RGF0ZSA8IGZpcnN0IHx8IG5ld0RhdGUgPiBsYXN0O1xyXG4gICAgY2FzZSAxOlxyXG4gICAgICByZXR1cm4gdmlld1llYXIgIT09IHllYXI7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gdmlld1llYXIgPCBmaXJzdCB8fCB2aWV3WWVhciA+IGxhc3Q7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRUZXh0RGlyZWN0aW9uKGVsKSB7XHJcbiAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5kaXJlY3Rpb247XHJcbn1cclxuXHJcbi8vIENsYXNzIHJlcHJlc2VudGluZyB0aGUgcGlja2VyIFVJXHJcbmNsYXNzIFBpY2tlciB7XHJcbiAgY29uc3RydWN0b3IoZGF0ZXBpY2tlcikge1xyXG4gICAgdGhpcy5kYXRlcGlja2VyID0gZGF0ZXBpY2tlcjtcclxuXHJcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlc19waWNrZXJUZW1wbGF0ZS5yZXBsYWNlKC8lYnV0dG9uQ2xhc3MlL2csIGRhdGVwaWNrZXIuY29uZmlnLmJ1dHRvbkNsYXNzKTtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQgPSBwYXJzZUhUTUwodGVtcGxhdGUpLmZpcnN0Q2hpbGQ7XHJcbiAgICBjb25zdCBbaGVhZGVyLCBtYWluLCBmb290ZXJdID0gZWxlbWVudC5maXJzdENoaWxkLmNoaWxkcmVuO1xyXG4gICAgY29uc3QgdGl0bGUgPSBoZWFkZXIuZmlyc3RFbGVtZW50Q2hpbGQ7XHJcbiAgICBjb25zdCBbcHJldkJ0biwgdmlld1N3aXRjaCwgbmV4dEJ0bl0gPSBoZWFkZXIubGFzdEVsZW1lbnRDaGlsZC5jaGlsZHJlbjtcclxuICAgIGNvbnN0IFt0b2RheUJ0biwgY2xlYXJCdG5dID0gZm9vdGVyLmZpcnN0Q2hpbGQuY2hpbGRyZW47XHJcbiAgICBjb25zdCBjb250cm9scyA9IHtcclxuICAgICAgdGl0bGUsXHJcbiAgICAgIHByZXZCdG4sXHJcbiAgICAgIHZpZXdTd2l0Y2gsXHJcbiAgICAgIG5leHRCdG4sXHJcbiAgICAgIHRvZGF5QnRuLFxyXG4gICAgICBjbGVhckJ0bixcclxuICAgIH07XHJcbiAgICB0aGlzLm1haW4gPSBtYWluO1xyXG4gICAgdGhpcy5jb250cm9scyA9IGNvbnRyb2xzO1xyXG5cclxuICAgIGNvbnN0IGVsZW1lbnRDbGFzcyA9IGRhdGVwaWNrZXIuaW5saW5lID8gJ2lubGluZScgOiAnZHJvcGRvd24nO1xyXG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGBkYXRlcGlja2VyLSR7ZWxlbWVudENsYXNzfWApO1xyXG4gICAgZWxlbWVudENsYXNzID09PSAnZHJvcGRvd24nID8gZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdkcm9wZG93bicsICdhYnNvbHV0ZScsICd0b3AtMCcsICdsZWZ0LTAnLCAnei0yMCcsICdwdC0yJykgOiBudWxsO1xyXG5cclxuICAgIHByb2Nlc3NQaWNrZXJPcHRpb25zKHRoaXMsIGRhdGVwaWNrZXIuY29uZmlnKTtcclxuICAgIHRoaXMudmlld0RhdGUgPSBjb21wdXRlUmVzZXRWaWV3RGF0ZShkYXRlcGlja2VyKTtcclxuXHJcbiAgICAvLyBzZXQgdXAgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICByZWdpc3Rlckxpc3RlbmVycyhkYXRlcGlja2VyLCBbXHJcbiAgICAgIFtlbGVtZW50LCAnY2xpY2snLCBvbkNsaWNrUGlja2VyLmJpbmQobnVsbCwgZGF0ZXBpY2tlciksIHtjYXB0dXJlOiB0cnVlfV0sXHJcbiAgICAgIFttYWluLCAnY2xpY2snLCBvbkNsaWNrVmlldy5iaW5kKG51bGwsIGRhdGVwaWNrZXIpXSxcclxuICAgICAgW2NvbnRyb2xzLnZpZXdTd2l0Y2gsICdjbGljaycsIG9uQ2xpY2tWaWV3U3dpdGNoLmJpbmQobnVsbCwgZGF0ZXBpY2tlcildLFxyXG4gICAgICBbY29udHJvbHMucHJldkJ0biwgJ2NsaWNrJywgb25DbGlja1ByZXZCdG4uYmluZChudWxsLCBkYXRlcGlja2VyKV0sXHJcbiAgICAgIFtjb250cm9scy5uZXh0QnRuLCAnY2xpY2snLCBvbkNsaWNrTmV4dEJ0bi5iaW5kKG51bGwsIGRhdGVwaWNrZXIpXSxcclxuICAgICAgW2NvbnRyb2xzLnRvZGF5QnRuLCAnY2xpY2snLCBvbkNsaWNrVG9kYXlCdG4uYmluZChudWxsLCBkYXRlcGlja2VyKV0sXHJcbiAgICAgIFtjb250cm9scy5jbGVhckJ0biwgJ2NsaWNrJywgb25DbGlja0NsZWFyQnRuLmJpbmQobnVsbCwgZGF0ZXBpY2tlcildLFxyXG4gICAgXSk7XHJcblxyXG4gICAgLy8gc2V0IHVwIHZpZXdzXHJcbiAgICB0aGlzLnZpZXdzID0gW1xyXG4gICAgICBuZXcgRGF5c1ZpZXcodGhpcyksXHJcbiAgICAgIG5ldyBNb250aHNWaWV3KHRoaXMpLFxyXG4gICAgICBuZXcgWWVhcnNWaWV3KHRoaXMsIHtpZDogMiwgbmFtZTogJ3llYXJzJywgY2VsbENsYXNzOiAneWVhcicsIHN0ZXA6IDF9KSxcclxuICAgICAgbmV3IFllYXJzVmlldyh0aGlzLCB7aWQ6IDMsIG5hbWU6ICdkZWNhZGVzJywgY2VsbENsYXNzOiAnZGVjYWRlJywgc3RlcDogMTB9KSxcclxuICAgIF07XHJcbiAgICB0aGlzLmN1cnJlbnRWaWV3ID0gdGhpcy52aWV3c1tkYXRlcGlja2VyLmNvbmZpZy5zdGFydFZpZXddO1xyXG5cclxuICAgIHRoaXMuY3VycmVudFZpZXcucmVuZGVyKCk7XHJcbiAgICB0aGlzLm1haW4uYXBwZW5kQ2hpbGQodGhpcy5jdXJyZW50Vmlldy5lbGVtZW50KTtcclxuICAgIGRhdGVwaWNrZXIuY29uZmlnLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xyXG4gIH1cclxuXHJcbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICBwcm9jZXNzUGlja2VyT3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuICAgIHRoaXMudmlld3MuZm9yRWFjaCgodmlldykgPT4ge1xyXG4gICAgICB2aWV3LmluaXQob3B0aW9ucywgZmFsc2UpO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLmN1cnJlbnRWaWV3LnJlbmRlcigpO1xyXG4gIH1cclxuXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhpcy5kYXRlcGlja2VyLmNvbmZpZy5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcclxuICB9XHJcblxyXG4gIHNob3coKSB7XHJcbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScsICdibG9jaycpO1xyXG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xyXG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG5cclxuICAgIGNvbnN0IGRhdGVwaWNrZXIgPSB0aGlzLmRhdGVwaWNrZXI7XHJcbiAgICBpZiAoIWRhdGVwaWNrZXIuaW5saW5lKSB7XHJcbiAgICAgIC8vIGVuc3VyZSBwaWNrZXIncyBkaXJlY3Rpb24gbWF0Y2hlcyBpbnB1dCdzXHJcbiAgICAgIGNvbnN0IGlucHV0RGlyZWN0aW9uID0gZ2V0VGV4dERpcmVjdGlvbihkYXRlcGlja2VyLmlucHV0RmllbGQpO1xyXG4gICAgICBpZiAoaW5wdXREaXJlY3Rpb24gIT09IGdldFRleHREaXJlY3Rpb24oZGF0ZXBpY2tlci5jb25maWcuY29udGFpbmVyKSkge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudC5kaXIgPSBpbnB1dERpcmVjdGlvbjtcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLmVsZW1lbnQuZGlyKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGlyJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMucGxhY2UoKTtcclxuICAgICAgaWYgKGRhdGVwaWNrZXIuY29uZmlnLmRpc2FibGVUb3VjaEtleWJvYXJkKSB7XHJcbiAgICAgICAgZGF0ZXBpY2tlci5pbnB1dEZpZWxkLmJsdXIoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdHJpZ2dlckRhdGVwaWNrZXJFdmVudChkYXRlcGlja2VyLCAnc2hvdycpO1xyXG4gIH1cclxuXHJcbiAgaGlkZSgpIHtcclxuICAgIGlmICghdGhpcy5hY3RpdmUpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5kYXRlcGlja2VyLmV4aXRFZGl0TW9kZSgpO1xyXG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScsICdibG9jaycpO1xyXG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScsICdibG9jaycsICdoaWRkZW4nKTtcclxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICB0cmlnZ2VyRGF0ZXBpY2tlckV2ZW50KHRoaXMuZGF0ZXBpY2tlciwgJ2hpZGUnKTtcclxuICB9XHJcblxyXG4gIHBsYWNlKCkge1xyXG4gICAgY29uc3Qge2NsYXNzTGlzdCwgc3R5bGV9ID0gdGhpcy5lbGVtZW50O1xyXG4gICAgY29uc3Qge2NvbmZpZywgaW5wdXRGaWVsZH0gPSB0aGlzLmRhdGVwaWNrZXI7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBjb25maWcuY29udGFpbmVyO1xyXG4gICAgY29uc3Qge1xyXG4gICAgICB3aWR0aDogY2FsZW5kYXJXaWR0aCxcclxuICAgICAgaGVpZ2h0OiBjYWxlbmRhckhlaWdodCxcclxuICAgIH0gPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIGxlZnQ6IGNvbnRhaW5lckxlZnQsXHJcbiAgICAgIHRvcDogY29udGFpbmVyVG9wLFxyXG4gICAgICB3aWR0aDogY29udGFpbmVyV2lkdGgsXHJcbiAgICB9ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBsZWZ0OiBpbnB1dExlZnQsXHJcbiAgICAgIHRvcDogaW5wdXRUb3AsXHJcbiAgICAgIHdpZHRoOiBpbnB1dFdpZHRoLFxyXG4gICAgICBoZWlnaHQ6IGlucHV0SGVpZ2h0XHJcbiAgICB9ID0gaW5wdXRGaWVsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIGxldCB7eDogb3JpZW50WCwgeTogb3JpZW50WX0gPSBjb25maWcub3JpZW50YXRpb247XHJcbiAgICBsZXQgc2Nyb2xsVG9wO1xyXG4gICAgbGV0IGxlZnQ7XHJcbiAgICBsZXQgdG9wO1xyXG5cclxuICAgIGlmIChjb250YWluZXIgPT09IGRvY3VtZW50LmJvZHkpIHtcclxuICAgICAgc2Nyb2xsVG9wID0gd2luZG93LnNjcm9sbFk7XHJcbiAgICAgIGxlZnQgPSBpbnB1dExlZnQgKyB3aW5kb3cuc2Nyb2xsWDtcclxuICAgICAgdG9wID0gaW5wdXRUb3AgKyBzY3JvbGxUb3A7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzY3JvbGxUb3AgPSBjb250YWluZXIuc2Nyb2xsVG9wO1xyXG4gICAgICBsZWZ0ID0gaW5wdXRMZWZ0IC0gY29udGFpbmVyTGVmdDtcclxuICAgICAgdG9wID0gaW5wdXRUb3AgLSBjb250YWluZXJUb3AgKyBzY3JvbGxUb3A7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9yaWVudFggPT09ICdhdXRvJykge1xyXG4gICAgICBpZiAobGVmdCA8IDApIHtcclxuICAgICAgICAvLyBhbGlnbiB0byB0aGUgbGVmdCBhbmQgbW92ZSBpbnRvIHZpc2libGUgYXJlYSBpZiBpbnB1dCdzIGxlZnQgZWRnZSA8IHdpbmRvdydzXHJcbiAgICAgICAgb3JpZW50WCA9ICdsZWZ0JztcclxuICAgICAgICBsZWZ0ID0gMTA7XHJcbiAgICAgIH0gZWxzZSBpZiAobGVmdCArIGNhbGVuZGFyV2lkdGggPiBjb250YWluZXJXaWR0aCkge1xyXG4gICAgICAgIC8vIGFsaWduIHRvIHRoZSByaWdodCBpZiBjYW5sZW5kYXIncyByaWdodCBlZGdlID4gY29udGFpbmVyJ3NcclxuICAgICAgICBvcmllbnRYID0gJ3JpZ2h0JztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBvcmllbnRYID0gZ2V0VGV4dERpcmVjdGlvbihpbnB1dEZpZWxkKSA9PT0gJ3J0bCcgPyAncmlnaHQnIDogJ2xlZnQnO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAob3JpZW50WCA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgICBsZWZ0IC09IGNhbGVuZGFyV2lkdGggLSBpbnB1dFdpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvcmllbnRZID09PSAnYXV0bycpIHtcclxuICAgICAgb3JpZW50WSA9IHRvcCAtIGNhbGVuZGFySGVpZ2h0IDwgc2Nyb2xsVG9wID8gJ2JvdHRvbScgOiAndG9wJztcclxuICAgIH1cclxuICAgIGlmIChvcmllbnRZID09PSAndG9wJykge1xyXG4gICAgICB0b3AgLT0gY2FsZW5kYXJIZWlnaHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0b3AgKz0gaW5wdXRIZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3NMaXN0LnJlbW92ZShcclxuICAgICAgJ2RhdGVwaWNrZXItb3JpZW50LXRvcCcsXHJcbiAgICAgICdkYXRlcGlja2VyLW9yaWVudC1ib3R0b20nLFxyXG4gICAgICAnZGF0ZXBpY2tlci1vcmllbnQtcmlnaHQnLFxyXG4gICAgICAnZGF0ZXBpY2tlci1vcmllbnQtbGVmdCdcclxuICAgICk7XHJcbiAgICBjbGFzc0xpc3QuYWRkKGBkYXRlcGlja2VyLW9yaWVudC0ke29yaWVudFl9YCwgYGRhdGVwaWNrZXItb3JpZW50LSR7b3JpZW50WH1gKTtcclxuXHJcbiAgICBzdHlsZS50b3AgPSB0b3AgPyBgJHt0b3B9cHhgIDogdG9wO1xyXG4gICAgc3R5bGUubGVmdCA9IGxlZnQgPyBgJHtsZWZ0fXB4YCA6IGxlZnQ7XHJcbiAgfVxyXG5cclxuICBzZXRWaWV3U3dpdGNoTGFiZWwobGFiZWxUZXh0KSB7XHJcbiAgICB0aGlzLmNvbnRyb2xzLnZpZXdTd2l0Y2gudGV4dENvbnRlbnQgPSBsYWJlbFRleHQ7XHJcbiAgfVxyXG5cclxuICBzZXRQcmV2QnRuRGlzYWJsZWQoZGlzYWJsZWQpIHtcclxuICAgIHRoaXMuY29udHJvbHMucHJldkJ0bi5kaXNhYmxlZCA9IGRpc2FibGVkO1xyXG4gIH1cclxuXHJcbiAgc2V0TmV4dEJ0bkRpc2FibGVkKGRpc2FibGVkKSB7XHJcbiAgICB0aGlzLmNvbnRyb2xzLm5leHRCdG4uZGlzYWJsZWQgPSBkaXNhYmxlZDtcclxuICB9XHJcblxyXG4gIGNoYW5nZVZpZXcodmlld0lkKSB7XHJcbiAgICBjb25zdCBvbGRWaWV3ID0gdGhpcy5jdXJyZW50VmlldztcclxuICAgIGNvbnN0IG5ld1ZpZXcgPSAgdGhpcy52aWV3c1t2aWV3SWRdO1xyXG4gICAgaWYgKG5ld1ZpZXcuaWQgIT09IG9sZFZpZXcuaWQpIHtcclxuICAgICAgdGhpcy5jdXJyZW50VmlldyA9IG5ld1ZpZXc7XHJcbiAgICAgIHRoaXMuX3JlbmRlck1ldGhvZCA9ICdyZW5kZXInO1xyXG4gICAgICB0cmlnZ2VyRGF0ZXBpY2tlckV2ZW50KHRoaXMuZGF0ZXBpY2tlciwgJ2NoYW5nZVZpZXcnKTtcclxuICAgICAgdGhpcy5tYWluLnJlcGxhY2VDaGlsZChuZXdWaWV3LmVsZW1lbnQsIG9sZFZpZXcuZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIENoYW5nZSB0aGUgZm9jdXNlZCBkYXRlICh2aWV3IGRhdGUpXHJcbiAgY2hhbmdlRm9jdXMobmV3Vmlld0RhdGUpIHtcclxuICAgIHRoaXMuX3JlbmRlck1ldGhvZCA9IHNldFZpZXdEYXRlKHRoaXMsIG5ld1ZpZXdEYXRlKSA/ICdyZW5kZXInIDogJ3JlZnJlc2hGb2N1cyc7XHJcbiAgICB0aGlzLnZpZXdzLmZvckVhY2goKHZpZXcpID0+IHtcclxuICAgICAgdmlldy51cGRhdGVGb2N1cygpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIEFwcGx5IHRoZSBjaGFuZ2Ugb2YgdGhlIHNlbGVjdGVkIGRhdGVzXHJcbiAgdXBkYXRlKCkge1xyXG4gICAgY29uc3QgbmV3Vmlld0RhdGUgPSBjb21wdXRlUmVzZXRWaWV3RGF0ZSh0aGlzLmRhdGVwaWNrZXIpO1xyXG4gICAgdGhpcy5fcmVuZGVyTWV0aG9kID0gc2V0Vmlld0RhdGUodGhpcywgbmV3Vmlld0RhdGUpID8gJ3JlbmRlcicgOiAncmVmcmVzaCc7XHJcbiAgICB0aGlzLnZpZXdzLmZvckVhY2goKHZpZXcpID0+IHtcclxuICAgICAgdmlldy51cGRhdGVGb2N1cygpO1xyXG4gICAgICB2aWV3LnVwZGF0ZVNlbGVjdGlvbigpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIFJlZnJlc2ggdGhlIHBpY2tlciBVSVxyXG4gIHJlbmRlcihxdWlja1JlbmRlciA9IHRydWUpIHtcclxuICAgIGNvbnN0IHJlbmRlck1ldGhvZCA9IChxdWlja1JlbmRlciAmJiB0aGlzLl9yZW5kZXJNZXRob2QpIHx8ICdyZW5kZXInO1xyXG4gICAgZGVsZXRlIHRoaXMuX3JlbmRlck1ldGhvZDtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRWaWV3W3JlbmRlck1ldGhvZF0oKTtcclxuICB9XHJcbn1cclxuXHJcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdGhlbWVzYmVyZy90YWlsd2luZC1kYXRlcGlja2VyL2pzL2V2ZW50cy9pbnB1dEZpZWxkTGlzdGVuZXJzLmpzXHJcblxyXG5cclxuXHJcblxyXG4vLyBGaW5kIHRoZSBjbG9zZXN0IGRhdGUgdGhhdCBkb2Vzbid0IG1lZXQgdGhlIGNvbmRpdGlvbiBmb3IgdW5hdmFpbGFibGUgZGF0ZVxyXG4vLyBSZXR1cm5zIHVuZGVmaW5lZCBpZiBubyBhdmFpbGFibGUgZGF0ZSBpcyBmb3VuZFxyXG4vLyBhZGRGbjogZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHRoZSBuZXh0IGRhdGVcclxuLy8gICAtIGFyZ3M6IHRpbWUgdmFsdWUsIGFtb3VudFxyXG4vLyBpbmNyZWFzZTogYW1vdW50IHRvIHBhc3MgdG8gYWRkRm5cclxuLy8gdGVzdEZuOiBmdW5jdGlvbiB0byB0ZXN0IHRoZSB1bmF2YWlsYWJsaXR5IG9mIHRoZSBkYXRlXHJcbi8vICAgLSBhcmdzOiB0aW1lIHZhbHVlOyByZXR1bjogdHJ1ZSBpZiB1bmF2YWlsYWJsZVxyXG5mdW5jdGlvbiBmaW5kTmV4dEF2YWlsYWJsZU9uZShkYXRlLCBhZGRGbiwgaW5jcmVhc2UsIHRlc3RGbiwgbWluLCBtYXgpIHtcclxuICBpZiAoIWlzSW5SYW5nZShkYXRlLCBtaW4sIG1heCkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKHRlc3RGbihkYXRlKSkge1xyXG4gICAgY29uc3QgbmV3RGF0ZSA9IGFkZEZuKGRhdGUsIGluY3JlYXNlKTtcclxuICAgIHJldHVybiBmaW5kTmV4dEF2YWlsYWJsZU9uZShuZXdEYXRlLCBhZGRGbiwgaW5jcmVhc2UsIHRlc3RGbiwgbWluLCBtYXgpO1xyXG4gIH1cclxuICByZXR1cm4gZGF0ZTtcclxufVxyXG5cclxuLy8gZGlyZWN0aW9uOiAtMSAobGVmdC91cCksIDEgKHJpZ2h0L2Rvd24pXHJcbi8vIHZlcnRpY2FsOiB0cnVlIGZvciB1cC9kb3duLCBmYWxzZSBmb3IgbGVmdC9yaWdodFxyXG5mdW5jdGlvbiBtb3ZlQnlBcnJvd0tleShkYXRlcGlja2VyLCBldiwgZGlyZWN0aW9uLCB2ZXJ0aWNhbCkge1xyXG4gIGNvbnN0IHBpY2tlciA9IGRhdGVwaWNrZXIucGlja2VyO1xyXG4gIGNvbnN0IGN1cnJlbnRWaWV3ID0gcGlja2VyLmN1cnJlbnRWaWV3O1xyXG4gIGNvbnN0IHN0ZXAgPSBjdXJyZW50Vmlldy5zdGVwIHx8IDE7XHJcbiAgbGV0IHZpZXdEYXRlID0gcGlja2VyLnZpZXdEYXRlO1xyXG4gIGxldCBhZGRGbjtcclxuICBsZXQgdGVzdEZuO1xyXG4gIHN3aXRjaCAoY3VycmVudFZpZXcuaWQpIHtcclxuICAgIGNhc2UgMDpcclxuICAgICAgaWYgKHZlcnRpY2FsKSB7XHJcbiAgICAgICAgdmlld0RhdGUgPSBhZGREYXlzKHZpZXdEYXRlLCBkaXJlY3Rpb24gKiA3KTtcclxuICAgICAgfSBlbHNlIGlmIChldi5jdHJsS2V5IHx8IGV2Lm1ldGFLZXkpIHtcclxuICAgICAgICB2aWV3RGF0ZSA9IGFkZFllYXJzKHZpZXdEYXRlLCBkaXJlY3Rpb24pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZpZXdEYXRlID0gYWRkRGF5cyh2aWV3RGF0ZSwgZGlyZWN0aW9uKTtcclxuICAgICAgfVxyXG4gICAgICBhZGRGbiA9IGFkZERheXM7XHJcbiAgICAgIHRlc3RGbiA9IChkYXRlKSA9PiBjdXJyZW50Vmlldy5kaXNhYmxlZC5pbmNsdWRlcyhkYXRlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDE6XHJcbiAgICAgIHZpZXdEYXRlID0gYWRkTW9udGhzKHZpZXdEYXRlLCB2ZXJ0aWNhbCA/IGRpcmVjdGlvbiAqIDQgOiBkaXJlY3Rpb24pO1xyXG4gICAgICBhZGRGbiA9IGFkZE1vbnRocztcclxuICAgICAgdGVzdEZuID0gKGRhdGUpID0+IHtcclxuICAgICAgICBjb25zdCBkdCA9IG5ldyBEYXRlKGRhdGUpO1xyXG4gICAgICAgIGNvbnN0IHt5ZWFyLCBkaXNhYmxlZH0gPSBjdXJyZW50VmlldztcclxuICAgICAgICByZXR1cm4gZHQuZ2V0RnVsbFllYXIoKSA9PT0geWVhciAmJiBkaXNhYmxlZC5pbmNsdWRlcyhkdC5nZXRNb250aCgpKTtcclxuICAgICAgfTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB2aWV3RGF0ZSA9IGFkZFllYXJzKHZpZXdEYXRlLCBkaXJlY3Rpb24gKiAodmVydGljYWwgPyA0IDogMSkgKiBzdGVwKTtcclxuICAgICAgYWRkRm4gPSBhZGRZZWFycztcclxuICAgICAgdGVzdEZuID0gZGF0ZSA9PiBjdXJyZW50Vmlldy5kaXNhYmxlZC5pbmNsdWRlcyhzdGFydE9mWWVhclBlcmlvZChkYXRlLCBzdGVwKSk7XHJcbiAgfVxyXG4gIHZpZXdEYXRlID0gZmluZE5leHRBdmFpbGFibGVPbmUoXHJcbiAgICB2aWV3RGF0ZSxcclxuICAgIGFkZEZuLFxyXG4gICAgZGlyZWN0aW9uIDwgMCA/IC1zdGVwIDogc3RlcCxcclxuICAgIHRlc3RGbixcclxuICAgIGN1cnJlbnRWaWV3Lm1pbkRhdGUsXHJcbiAgICBjdXJyZW50Vmlldy5tYXhEYXRlXHJcbiAgKTtcclxuICBpZiAodmlld0RhdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgcGlja2VyLmNoYW5nZUZvY3VzKHZpZXdEYXRlKS5yZW5kZXIoKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9uS2V5ZG93bihkYXRlcGlja2VyLCBldikge1xyXG4gIGlmIChldi5rZXkgPT09ICdUYWInKSB7XHJcbiAgICB1bmZvY3VzKGRhdGVwaWNrZXIpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgcGlja2VyID0gZGF0ZXBpY2tlci5waWNrZXI7XHJcbiAgY29uc3Qge2lkLCBpc01pblZpZXd9ID0gcGlja2VyLmN1cnJlbnRWaWV3O1xyXG4gIGlmICghcGlja2VyLmFjdGl2ZSkge1xyXG4gICAgc3dpdGNoIChldi5rZXkpIHtcclxuICAgICAgY2FzZSAnQXJyb3dEb3duJzpcclxuICAgICAgY2FzZSAnRXNjYXBlJzpcclxuICAgICAgICBwaWNrZXIuc2hvdygpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdFbnRlcic6XHJcbiAgICAgICAgZGF0ZXBpY2tlci51cGRhdGUoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChkYXRlcGlja2VyLmVkaXRNb2RlKSB7XHJcbiAgICBzd2l0Y2ggKGV2LmtleSkge1xyXG4gICAgICBjYXNlICdFc2NhcGUnOlxyXG4gICAgICAgIHBpY2tlci5oaWRlKCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ0VudGVyJzpcclxuICAgICAgICBkYXRlcGlja2VyLmV4aXRFZGl0TW9kZSh7dXBkYXRlOiB0cnVlLCBhdXRvaGlkZTogZGF0ZXBpY2tlci5jb25maWcuYXV0b2hpZGV9KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHN3aXRjaCAoZXYua2V5KSB7XHJcbiAgICAgIGNhc2UgJ0VzY2FwZSc6XHJcbiAgICAgICAgcGlja2VyLmhpZGUoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcclxuICAgICAgICBpZiAoZXYuY3RybEtleSB8fCBldi5tZXRhS2V5KSB7XHJcbiAgICAgICAgICBnb1RvUHJldk9yTmV4dChkYXRlcGlja2VyLCAtMSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChldi5zaGlmdEtleSkge1xyXG4gICAgICAgICAgZGF0ZXBpY2tlci5lbnRlckVkaXRNb2RlKCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG1vdmVCeUFycm93S2V5KGRhdGVwaWNrZXIsIGV2LCAtMSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnQXJyb3dSaWdodCc6XHJcbiAgICAgICAgaWYgKGV2LmN0cmxLZXkgfHwgZXYubWV0YUtleSkge1xyXG4gICAgICAgICAgZ29Ub1ByZXZPck5leHQoZGF0ZXBpY2tlciwgMSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChldi5zaGlmdEtleSkge1xyXG4gICAgICAgICAgZGF0ZXBpY2tlci5lbnRlckVkaXRNb2RlKCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG1vdmVCeUFycm93S2V5KGRhdGVwaWNrZXIsIGV2LCAxLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdBcnJvd1VwJzpcclxuICAgICAgICBpZiAoZXYuY3RybEtleSB8fCBldi5tZXRhS2V5KSB7XHJcbiAgICAgICAgICBzd2l0Y2hWaWV3KGRhdGVwaWNrZXIpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZXYuc2hpZnRLZXkpIHtcclxuICAgICAgICAgIGRhdGVwaWNrZXIuZW50ZXJFZGl0TW9kZSgpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBtb3ZlQnlBcnJvd0tleShkYXRlcGlja2VyLCBldiwgLTEsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnQXJyb3dEb3duJzpcclxuICAgICAgICBpZiAoZXYuc2hpZnRLZXkgJiYgIWV2LmN0cmxLZXkgJiYgIWV2Lm1ldGFLZXkpIHtcclxuICAgICAgICAgIGRhdGVwaWNrZXIuZW50ZXJFZGl0TW9kZSgpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtb3ZlQnlBcnJvd0tleShkYXRlcGlja2VyLCBldiwgMSwgdHJ1ZSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ0VudGVyJzpcclxuICAgICAgICBpZiAoaXNNaW5WaWV3KSB7XHJcbiAgICAgICAgICBkYXRlcGlja2VyLnNldERhdGUocGlja2VyLnZpZXdEYXRlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcGlja2VyLmNoYW5nZVZpZXcoaWQgLSAxKS5yZW5kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ0JhY2tzcGFjZSc6XHJcbiAgICAgIGNhc2UgJ0RlbGV0ZSc6XHJcbiAgICAgICAgZGF0ZXBpY2tlci5lbnRlckVkaXRNb2RlKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGlmIChldi5rZXkubGVuZ3RoID09PSAxICYmICFldi5jdHJsS2V5ICYmICFldi5tZXRhS2V5KSB7XHJcbiAgICAgICAgICBkYXRlcGlja2VyLmVudGVyRWRpdE1vZGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gIH1cclxuICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvbkZvY3VzKGRhdGVwaWNrZXIpIHtcclxuICBpZiAoZGF0ZXBpY2tlci5jb25maWcuc2hvd09uRm9jdXMgJiYgIWRhdGVwaWNrZXIuX3Nob3dpbmcpIHtcclxuICAgIGRhdGVwaWNrZXIuc2hvdygpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gZm9yIHRoZSBwcmV2ZW50aW9uIGZvciBlbnRlcmluZyBlZGl0IG1vZGUgd2hpbGUgZ2V0dGluZyBmb2N1cyBvbiBjbGlja1xyXG5mdW5jdGlvbiBvbk1vdXNlZG93bihkYXRlcGlja2VyLCBldikge1xyXG4gIGNvbnN0IGVsID0gZXYudGFyZ2V0O1xyXG4gIGlmIChkYXRlcGlja2VyLnBpY2tlci5hY3RpdmUgfHwgZGF0ZXBpY2tlci5jb25maWcuc2hvd09uQ2xpY2spIHtcclxuICAgIGVsLl9hY3RpdmUgPSBlbCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcclxuICAgIGVsLl9jbGlja2luZyA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBkZWxldGUgZWwuX2FjdGl2ZTtcclxuICAgICAgZGVsZXRlIGVsLl9jbGlja2luZztcclxuICAgIH0sIDIwMDApO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gb25DbGlja0lucHV0KGRhdGVwaWNrZXIsIGV2KSB7XHJcbiAgY29uc3QgZWwgPSBldi50YXJnZXQ7XHJcbiAgaWYgKCFlbC5fY2xpY2tpbmcpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY2xlYXJUaW1lb3V0KGVsLl9jbGlja2luZyk7XHJcbiAgZGVsZXRlIGVsLl9jbGlja2luZztcclxuXHJcbiAgaWYgKGVsLl9hY3RpdmUpIHtcclxuICAgIGRhdGVwaWNrZXIuZW50ZXJFZGl0TW9kZSgpO1xyXG4gIH1cclxuICBkZWxldGUgZWwuX2FjdGl2ZTtcclxuXHJcbiAgaWYgKGRhdGVwaWNrZXIuY29uZmlnLnNob3dPbkNsaWNrKSB7XHJcbiAgICBkYXRlcGlja2VyLnNob3coKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9uUGFzdGUoZGF0ZXBpY2tlciwgZXYpIHtcclxuICBpZiAoZXYuY2xpcGJvYXJkRGF0YS50eXBlcy5pbmNsdWRlcygndGV4dC9wbGFpbicpKSB7XHJcbiAgICBkYXRlcGlja2VyLmVudGVyRWRpdE1vZGUoKTtcclxuICB9XHJcbn1cclxuXHJcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdGhlbWVzYmVyZy90YWlsd2luZC1kYXRlcGlja2VyL2pzL2V2ZW50cy9vdGhlckxpc3RlbmVycy5qc1xyXG5cclxuXHJcblxyXG4vLyBmb3IgdGhlIGBkb2N1bWVudGAgdG8gZGVsZWdhdGUgdGhlIGV2ZW50cyBmcm9tIG91dHNpZGUgdGhlIHBpY2tlci9pbnB1dCBmaWVsZFxyXG5mdW5jdGlvbiBvbkNsaWNrT3V0c2lkZShkYXRlcGlja2VyLCBldikge1xyXG4gIGNvbnN0IGVsZW1lbnQgPSBkYXRlcGlja2VyLmVsZW1lbnQ7XHJcbiAgaWYgKGVsZW1lbnQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY29uc3QgcGlja2VyRWxlbSA9IGRhdGVwaWNrZXIucGlja2VyLmVsZW1lbnQ7XHJcbiAgaWYgKGZpbmRFbGVtZW50SW5FdmVudFBhdGgoZXYsIGVsID0+IGVsID09PSBlbGVtZW50IHx8IGVsID09PSBwaWNrZXJFbGVtKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB1bmZvY3VzKGRhdGVwaWNrZXIpO1xyXG59XHJcblxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHRoZW1lc2JlcmcvdGFpbHdpbmQtZGF0ZXBpY2tlci9qcy9EYXRlcGlja2VyLmpzXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeURhdGVzKGRhdGVzLCBjb25maWcpIHtcclxuICByZXR1cm4gZGF0ZXNcclxuICAgIC5tYXAoZHQgPT4gZm9ybWF0RGF0ZShkdCwgY29uZmlnLmZvcm1hdCwgY29uZmlnLmxvY2FsZSkpXHJcbiAgICAuam9pbihjb25maWcuZGF0ZURlbGltaXRlcik7XHJcbn1cclxuXHJcbi8vIHBhcnNlIGlucHV0IGRhdGVzIGFuZCBjcmVhdGUgYW4gYXJyYXkgb2YgdGltZSB2YWx1ZXMgZm9yIHNlbGVjdGlvblxyXG4vLyByZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGVyZSBhcmUgbm8gdmFsaWQgZGF0ZXMgaW4gaW5wdXREYXRlc1xyXG4vLyB3aGVuIG9yaWdEYXRlcyAoY3VycmVudCBzZWxlY3Rpb24pIGlzIHBhc3NlZCwgdGhlIGZ1bmN0aW9uIHdvcmtzIHRvIG1peFxyXG4vLyB0aGUgaW5wdXQgZGF0ZXMgaW50byB0aGUgY3VycmVudCBzZWxlY3Rpb25cclxuZnVuY3Rpb24gcHJvY2Vzc0lucHV0RGF0ZXMoZGF0ZXBpY2tlciwgaW5wdXREYXRlcywgY2xlYXIgPSBmYWxzZSkge1xyXG4gIGNvbnN0IHtjb25maWcsIGRhdGVzOiBvcmlnRGF0ZXMsIHJhbmdlcGlja2VyfSA9IGRhdGVwaWNrZXI7XHJcbiAgaWYgKGlucHV0RGF0ZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAvLyBlbXB0eSBpbnB1dCBpcyBjb25zaWRlcmVkIHZhbGlkIHVubGVzcyBvcmlnaURhdGVzIGlzIHBhc3NlZFxyXG4gICAgcmV0dXJuIGNsZWFyID8gW10gOiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBjb25zdCByYW5nZUVuZCA9IHJhbmdlcGlja2VyICYmIGRhdGVwaWNrZXIgPT09IHJhbmdlcGlja2VyLmRhdGVwaWNrZXJzWzFdO1xyXG4gIGxldCBuZXdEYXRlcyA9IGlucHV0RGF0ZXMucmVkdWNlKChkYXRlcywgZHQpID0+IHtcclxuICAgIGxldCBkYXRlID0gcGFyc2VEYXRlKGR0LCBjb25maWcuZm9ybWF0LCBjb25maWcubG9jYWxlKTtcclxuICAgIGlmIChkYXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIGRhdGVzO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbmZpZy5waWNrTGV2ZWwgPiAwKSB7XHJcbiAgICAgIC8vIGFkanVzdCB0byAxc3Qgb2YgdGhlIG1vbnRoL0phbiAxc3Qgb2YgdGhlIHllYXJcclxuICAgICAgLy8gb3IgdG8gdGhlIGxhc3QgZGF5IG9mIHRoZSBtb25oL0RlYyAzMXN0IG9mIHRoZSB5ZWFyIGlmIHRoZSBkYXRlcGlja2VyXHJcbiAgICAgIC8vIGlzIHRoZSByYW5nZS1lbmQgcGlja2VyIG9mIGEgcmFuZ2VwaWNrZXJcclxuICAgICAgY29uc3QgZHQgPSBuZXcgRGF0ZShkYXRlKTtcclxuICAgICAgaWYgKGNvbmZpZy5waWNrTGV2ZWwgPT09IDEpIHtcclxuICAgICAgICBkYXRlID0gcmFuZ2VFbmRcclxuICAgICAgICAgID8gZHQuc2V0TW9udGgoZHQuZ2V0TW9udGgoKSArIDEsIDApXHJcbiAgICAgICAgICA6IGR0LnNldERhdGUoMSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGF0ZSA9IHJhbmdlRW5kXHJcbiAgICAgICAgICA/IGR0LnNldEZ1bGxZZWFyKGR0LmdldEZ1bGxZZWFyKCkgKyAxLCAwLCAwKVxyXG4gICAgICAgICAgOiBkdC5zZXRNb250aCgwLCAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKFxyXG4gICAgICBpc0luUmFuZ2UoZGF0ZSwgY29uZmlnLm1pbkRhdGUsIGNvbmZpZy5tYXhEYXRlKVxyXG4gICAgICAmJiAhZGF0ZXMuaW5jbHVkZXMoZGF0ZSlcclxuICAgICAgJiYgIWNvbmZpZy5kYXRlc0Rpc2FibGVkLmluY2x1ZGVzKGRhdGUpXHJcbiAgICAgICYmICFjb25maWcuZGF5c09mV2Vla0Rpc2FibGVkLmluY2x1ZGVzKG5ldyBEYXRlKGRhdGUpLmdldERheSgpKVxyXG4gICAgKSB7XHJcbiAgICAgIGRhdGVzLnB1c2goZGF0ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0ZXM7XHJcbiAgfSwgW10pO1xyXG4gIGlmIChuZXdEYXRlcy5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKGNvbmZpZy5tdWx0aWRhdGUgJiYgIWNsZWFyKSB7XHJcbiAgICAvLyBnZXQgdGhlIHN5bm1ldHJpYyBkaWZmZXJlbmNlIGJldHdlZW4gb3JpZ0RhdGVzIGFuZCBuZXdEYXRlc1xyXG4gICAgbmV3RGF0ZXMgPSBuZXdEYXRlcy5yZWR1Y2UoKGRhdGVzLCBkYXRlKSA9PiB7XHJcbiAgICAgIGlmICghb3JpZ0RhdGVzLmluY2x1ZGVzKGRhdGUpKSB7XHJcbiAgICAgICAgZGF0ZXMucHVzaChkYXRlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZGF0ZXM7XHJcbiAgICB9LCBvcmlnRGF0ZXMuZmlsdGVyKGRhdGUgPT4gIW5ld0RhdGVzLmluY2x1ZGVzKGRhdGUpKSk7XHJcbiAgfVxyXG4gIC8vIGRvIGxlbmd0aCBjaGVjayBhbHdheXMgYmVjYXVzZSB1c2VyIGNhbiBpbnB1dCBtdWx0aXBsZSBkYXRlcyByZWdhcmRsZXNzIG9mIHRoZSBtb2RlXHJcbiAgcmV0dXJuIGNvbmZpZy5tYXhOdW1iZXJPZkRhdGVzICYmIG5ld0RhdGVzLmxlbmd0aCA+IGNvbmZpZy5tYXhOdW1iZXJPZkRhdGVzXHJcbiAgICA/IG5ld0RhdGVzLnNsaWNlKGNvbmZpZy5tYXhOdW1iZXJPZkRhdGVzICogLTEpXHJcbiAgICA6IG5ld0RhdGVzO1xyXG59XHJcblxyXG4vLyByZWZyZXNoIHRoZSBVSSBlbGVtZW50c1xyXG4vLyBtb2RlczogMTogaW5wdXQgb25seSwgMiwgcGlja2VyIG9ubHksIDMgYm90aFxyXG5mdW5jdGlvbiByZWZyZXNoVUkoZGF0ZXBpY2tlciwgbW9kZSA9IDMsIHF1aWNrUmVuZGVyID0gdHJ1ZSkge1xyXG4gIGNvbnN0IHtjb25maWcsIHBpY2tlciwgaW5wdXRGaWVsZH0gPSBkYXRlcGlja2VyO1xyXG4gIGlmIChtb2RlICYgMikge1xyXG4gICAgY29uc3QgbmV3VmlldyA9IHBpY2tlci5hY3RpdmUgPyBjb25maWcucGlja0xldmVsIDogY29uZmlnLnN0YXJ0VmlldztcclxuICAgIHBpY2tlci51cGRhdGUoKS5jaGFuZ2VWaWV3KG5ld1ZpZXcpLnJlbmRlcihxdWlja1JlbmRlcik7XHJcbiAgfVxyXG4gIGlmIChtb2RlICYgMSAmJiBpbnB1dEZpZWxkKSB7XHJcbiAgICBpbnB1dEZpZWxkLnZhbHVlID0gc3RyaW5naWZ5RGF0ZXMoZGF0ZXBpY2tlci5kYXRlcywgY29uZmlnKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldERhdGUoZGF0ZXBpY2tlciwgaW5wdXREYXRlcywgb3B0aW9ucykge1xyXG4gIGxldCB7Y2xlYXIsIHJlbmRlciwgYXV0b2hpZGV9ID0gb3B0aW9ucztcclxuICBpZiAocmVuZGVyID09PSB1bmRlZmluZWQpIHtcclxuICAgIHJlbmRlciA9IHRydWU7XHJcbiAgfVxyXG4gIGlmICghcmVuZGVyKSB7XHJcbiAgICBhdXRvaGlkZSA9IGZhbHNlO1xyXG4gIH0gZWxzZSBpZiAoYXV0b2hpZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgYXV0b2hpZGUgPSBkYXRlcGlja2VyLmNvbmZpZy5hdXRvaGlkZTtcclxuICB9XHJcblxyXG4gIGNvbnN0IG5ld0RhdGVzID0gcHJvY2Vzc0lucHV0RGF0ZXMoZGF0ZXBpY2tlciwgaW5wdXREYXRlcywgY2xlYXIpO1xyXG4gIGlmICghbmV3RGF0ZXMpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKG5ld0RhdGVzLnRvU3RyaW5nKCkgIT09IGRhdGVwaWNrZXIuZGF0ZXMudG9TdHJpbmcoKSkge1xyXG4gICAgZGF0ZXBpY2tlci5kYXRlcyA9IG5ld0RhdGVzO1xyXG4gICAgcmVmcmVzaFVJKGRhdGVwaWNrZXIsIHJlbmRlciA/IDMgOiAxKTtcclxuICAgIHRyaWdnZXJEYXRlcGlja2VyRXZlbnQoZGF0ZXBpY2tlciwgJ2NoYW5nZURhdGUnKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmVmcmVzaFVJKGRhdGVwaWNrZXIsIDEpO1xyXG4gIH1cclxuICBpZiAoYXV0b2hpZGUpIHtcclxuICAgIGRhdGVwaWNrZXIuaGlkZSgpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGRhdGUgcGlja2VyXHJcbiAqL1xyXG5jbGFzcyBEYXRlcGlja2VyIHtcclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBkYXRlIHBpY2tlclxyXG4gICAqIEBwYXJhbSAge0VsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIGJpbmQgYSBkYXRlIHBpY2tlclxyXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIC0gY29uZmlnIG9wdGlvbnNcclxuICAgKiBAcGFyYW0gIHtEYXRlUmFuZ2VQaWNrZXJ9IFtyYW5nZXBpY2tlcl0gLSBEYXRlUmFuZ2VQaWNrZXIgaW5zdGFuY2UgdGhlXHJcbiAgICogZGF0ZSBwaWNrZXIgYmVsb25ncyB0by4gVXNlIHRoaXMgb25seSB3aGVuIGNyZWF0aW5nIGRhdGUgcGlja2VyIGFzIGEgcGFydFxyXG4gICAqIG9mIGRhdGUgcmFuZ2UgcGlja2VyXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucyA9IHt9LCByYW5nZXBpY2tlciA9IHVuZGVmaW5lZCkge1xyXG4gICAgZWxlbWVudC5kYXRlcGlja2VyID0gdGhpcztcclxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcblxyXG4gICAgLy8gc2V0IHVwIGNvbmZpZ1xyXG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcgPSBPYmplY3QuYXNzaWduKHtcclxuICAgICAgYnV0dG9uQ2xhc3M6IChvcHRpb25zLmJ1dHRvbkNsYXNzICYmIFN0cmluZyhvcHRpb25zLmJ1dHRvbkNsYXNzKSkgfHwgJ2J1dHRvbicsXHJcbiAgICAgIGNvbnRhaW5lcjogZG9jdW1lbnQuYm9keSxcclxuICAgICAgZGVmYXVsdFZpZXdEYXRlOiB0b2RheSgpLFxyXG4gICAgICBtYXhEYXRlOiB1bmRlZmluZWQsXHJcbiAgICAgIG1pbkRhdGU6IHVuZGVmaW5lZCxcclxuICAgIH0sIHByb2Nlc3NPcHRpb25zKG9wdGlvbnNfZGVmYXVsdE9wdGlvbnMsIHRoaXMpKTtcclxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgT2JqZWN0LmFzc2lnbihjb25maWcsIHByb2Nlc3NPcHRpb25zKG9wdGlvbnMsIHRoaXMpKTtcclxuXHJcbiAgICAvLyBjb25maWd1cmUgYnkgdHlwZVxyXG4gICAgY29uc3QgaW5saW5lID0gdGhpcy5pbmxpbmUgPSBlbGVtZW50LnRhZ05hbWUgIT09ICdJTlBVVCc7XHJcbiAgICBsZXQgaW5wdXRGaWVsZDtcclxuICAgIGxldCBpbml0aWFsRGF0ZXM7XHJcblxyXG4gICAgaWYgKGlubGluZSkge1xyXG4gICAgICBjb25maWcuY29udGFpbmVyID0gZWxlbWVudDtcclxuICAgICAgaW5pdGlhbERhdGVzID0gc3RyaW5nVG9BcnJheShlbGVtZW50LmRhdGFzZXQuZGF0ZSwgY29uZmlnLmRhdGVEZWxpbWl0ZXIpO1xyXG4gICAgICBkZWxldGUgZWxlbWVudC5kYXRhc2V0LmRhdGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lciA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iob3B0aW9ucy5jb250YWluZXIpIDogbnVsbDtcclxuICAgICAgaWYgKGNvbnRhaW5lcikge1xyXG4gICAgICAgIGNvbmZpZy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgIH1cclxuICAgICAgaW5wdXRGaWVsZCA9IHRoaXMuaW5wdXRGaWVsZCA9IGVsZW1lbnQ7XHJcbiAgICAgIGlucHV0RmllbGQuY2xhc3NMaXN0LmFkZCgnZGF0ZXBpY2tlci1pbnB1dCcpO1xyXG4gICAgICBpbml0aWFsRGF0ZXMgPSBzdHJpbmdUb0FycmF5KGlucHV0RmllbGQudmFsdWUsIGNvbmZpZy5kYXRlRGVsaW1pdGVyKTtcclxuICAgIH1cclxuICAgIGlmIChyYW5nZXBpY2tlcikge1xyXG4gICAgICAvLyBjaGVjayB2YWxpZGlyeVxyXG4gICAgICBjb25zdCBpbmRleCA9IHJhbmdlcGlja2VyLmlucHV0cy5pbmRleE9mKGlucHV0RmllbGQpO1xyXG4gICAgICBjb25zdCBkYXRlcGlja2VycyA9IHJhbmdlcGlja2VyLmRhdGVwaWNrZXJzO1xyXG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gMSB8fCAhQXJyYXkuaXNBcnJheShkYXRlcGlja2VycykpIHtcclxuICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCByYW5nZXBpY2tlciBvYmplY3QuJyk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gYXR0YWNoIGl0YWVsZiB0byB0aGUgcmFuZ2VwaWNrZXIgaGVyZSBzbyB0aGF0IHByb2Nlc3NJbnB1dERhdGVzKCkgY2FuXHJcbiAgICAgIC8vIGRldGVybWluZSBpZiB0aGlzIGlzIHRoZSByYW5nZS1lbmQgcGlja2VyIG9mIHRoZSByYW5nZXBpY2tlciB3aGlsZVxyXG4gICAgICAvLyBzZXR0aW5nIGluaXRhbCB2YWx1ZXMgd2hlbiBwaWNrTGV2ZWwgPiAwXHJcbiAgICAgIGRhdGVwaWNrZXJzW2luZGV4XSA9IHRoaXM7XHJcbiAgICAgIC8vIGFkZCBnZXR0ZXIgZm9yIHJhbmdlcGlja2VyXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmFuZ2VwaWNrZXInLCB7XHJcbiAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgcmV0dXJuIHJhbmdlcGlja2VyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNldCBpbml0aWFsIGRhdGVzXHJcbiAgICB0aGlzLmRhdGVzID0gW107XHJcbiAgICAvLyBwcm9jZXNzIGluaXRpYWwgdmFsdWVcclxuICAgIGNvbnN0IGlucHV0RGF0ZVZhbHVlcyA9IHByb2Nlc3NJbnB1dERhdGVzKHRoaXMsIGluaXRpYWxEYXRlcyk7XHJcbiAgICBpZiAoaW5wdXREYXRlVmFsdWVzICYmIGlucHV0RGF0ZVZhbHVlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMuZGF0ZXMgPSBpbnB1dERhdGVWYWx1ZXM7XHJcbiAgICB9XHJcbiAgICBpZiAoaW5wdXRGaWVsZCkge1xyXG4gICAgICBpbnB1dEZpZWxkLnZhbHVlID0gc3RyaW5naWZ5RGF0ZXModGhpcy5kYXRlcywgY29uZmlnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwaWNrZXIgPSB0aGlzLnBpY2tlciA9IG5ldyBQaWNrZXIodGhpcyk7XHJcblxyXG4gICAgaWYgKGlubGluZSkge1xyXG4gICAgICB0aGlzLnNob3coKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHNldCB1cCBldmVudCBsaXN0ZW5lcnMgaW4gb3RoZXIgbW9kZXNcclxuICAgICAgY29uc3Qgb25Nb3VzZWRvd25Eb2N1bWVudCA9IG9uQ2xpY2tPdXRzaWRlLmJpbmQobnVsbCwgdGhpcyk7XHJcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IFtcclxuICAgICAgICBbaW5wdXRGaWVsZCwgJ2tleWRvd24nLCBvbktleWRvd24uYmluZChudWxsLCB0aGlzKV0sXHJcbiAgICAgICAgW2lucHV0RmllbGQsICdmb2N1cycsIG9uRm9jdXMuYmluZChudWxsLCB0aGlzKV0sXHJcbiAgICAgICAgW2lucHV0RmllbGQsICdtb3VzZWRvd24nLCBvbk1vdXNlZG93bi5iaW5kKG51bGwsIHRoaXMpXSxcclxuICAgICAgICBbaW5wdXRGaWVsZCwgJ2NsaWNrJywgb25DbGlja0lucHV0LmJpbmQobnVsbCwgdGhpcyldLFxyXG4gICAgICAgIFtpbnB1dEZpZWxkLCAncGFzdGUnLCBvblBhc3RlLmJpbmQobnVsbCwgdGhpcyldLFxyXG4gICAgICAgIFtkb2N1bWVudCwgJ21vdXNlZG93bicsIG9uTW91c2Vkb3duRG9jdW1lbnRdLFxyXG4gICAgICAgIFtkb2N1bWVudCwgJ3RvdWNoc3RhcnQnLCBvbk1vdXNlZG93bkRvY3VtZW50XSxcclxuICAgICAgICBbd2luZG93LCAncmVzaXplJywgcGlja2VyLnBsYWNlLmJpbmQocGlja2VyKV1cclxuICAgICAgXTtcclxuICAgICAgcmVnaXN0ZXJMaXN0ZW5lcnModGhpcywgbGlzdGVuZXJzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZvcm1hdCBEYXRlIG9iamVjdCBvciB0aW1lIHZhbHVlIGluIGdpdmVuIGZvcm1hdCBhbmQgbGFuZ3VhZ2VcclxuICAgKiBAcGFyYW0gIHtEYXRlfE51bWJlcn0gZGF0ZSAtIGRhdGUgb3IgdGltZSB2YWx1ZSB0byBmb3JtYXRcclxuICAgKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fSBmb3JtYXQgLSBmb3JtYXQgc3RyaW5nIG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zXHJcbiAgICogdG9EaXNwbGF5KCkgY3VzdG9tIGZvcm1hdHRlciwgd2hvc2Ugc2lnbmF0dXJlIGlzXHJcbiAgICogLSBhcmdzOlxyXG4gICAqICAgLSBkYXRlOiB7RGF0ZX0gLSBEYXRlIGluc3RhbmNlIG9mIHRoZSBkYXRlIHBhc3NlZCB0byB0aGUgbWV0aG9kXHJcbiAgICogICAtIGZvcm1hdDoge09iamVjdH0gLSB0aGUgZm9ybWF0IG9iamVjdCBwYXNzZWQgdG8gdGhlIG1ldGhvZFxyXG4gICAqICAgLSBsb2NhbGU6IHtPYmplY3R9IC0gbG9jYWxlIGZvciB0aGUgbGFuZ3VhZ2Ugc3BlY2lmaWVkIGJ5IGBsYW5nYFxyXG4gICAqIC0gcmV0dXJuOlxyXG4gICAqICAgICB7U3RyaW5nfSBmb3JtYXR0ZWQgZGF0ZVxyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gW2xhbmc9ZW5dIC0gbGFuZ3VhZ2UgY29kZSBmb3IgdGhlIGxvY2FsZSB0byB1c2VcclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGZvcm1hdHRlZCBkYXRlXHJcbiAgICovXHJcbiAgc3RhdGljIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCBsYW5nKSB7XHJcbiAgICByZXR1cm4gZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQsIGxhbmcgJiYgbG9jYWxlc1tsYW5nXSB8fCBsb2NhbGVzLmVuKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhcnNlIGRhdGUgc3RyaW5nXHJcbiAgICogQHBhcmFtICB7U3RyaW5nfERhdGV8TnVtYmVyfSBkYXRlU3RyIC0gZGF0ZSBzdHJpbmcsIERhdGUgb2JqZWN0IG9yIHRpbWVcclxuICAgKiB2YWx1ZSB0byBwYXJzZVxyXG4gICAqIEBwYXJhbSAge1N0cmluZ3xPYmplY3R9IGZvcm1hdCAtIGZvcm1hdCBzdHJpbmcgb3Igb2JqZWN0IHRoYXQgY29udGFpbnNcclxuICAgKiB0b1ZhbHVlKCkgY3VzdG9tIHBhcnNlciwgd2hvc2Ugc2lnbmF0dXJlIGlzXHJcbiAgICogLSBhcmdzOlxyXG4gICAqICAgLSBkYXRlU3RyOiB7U3RyaW5nfERhdGV8TnVtYmVyfSAtIHRoZSBkYXRlU3RyIHBhc3NlZCB0byB0aGUgbWV0aG9kXHJcbiAgICogICAtIGZvcm1hdDoge09iamVjdH0gLSB0aGUgZm9ybWF0IG9iamVjdCBwYXNzZWQgdG8gdGhlIG1ldGhvZFxyXG4gICAqICAgLSBsb2NhbGU6IHtPYmplY3R9IC0gbG9jYWxlIGZvciB0aGUgbGFuZ3VhZ2Ugc3BlY2lmaWVkIGJ5IGBsYW5nYFxyXG4gICAqIC0gcmV0dXJuOlxyXG4gICAqICAgICB7RGF0ZXxOdW1iZXJ9IHBhcnNlZCBkYXRlIG9yIGl0cyB0aW1lIHZhbHVlXHJcbiAgICogQHBhcmFtICB7U3RyaW5nfSBbbGFuZz1lbl0gLSBsYW5ndWFnZSBjb2RlIGZvciB0aGUgbG9jYWxlIHRvIHVzZVxyXG4gICAqIEByZXR1cm4ge051bWJlcn0gdGltZSB2YWx1ZSBvZiBwYXJzZWQgZGF0ZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBwYXJzZURhdGUoZGF0ZVN0ciwgZm9ybWF0LCBsYW5nKSB7XHJcbiAgICByZXR1cm4gcGFyc2VEYXRlKGRhdGVTdHIsIGZvcm1hdCwgbGFuZyAmJiBsb2NhbGVzW2xhbmddIHx8IGxvY2FsZXMuZW4pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge09iamVjdH0gLSBJbnN0YWxsZWQgbG9jYWxlcyBpbiBgW2xhbmd1YWdlQ29kZV06IGxvY2FsZU9iamVjdGAgZm9ybWF0XHJcbiAgICogZW5gOl9FbmdsaXNoIChVUylfIGlzIHByZS1pbnN0YWxsZWQuXHJcbiAgICovXHJcbiAgc3RhdGljIGdldCBsb2NhbGVzKCkge1xyXG4gICAgcmV0dXJuIGxvY2FsZXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn0gLSBXaGV0aGVyIHRoZSBwaWNrZXIgZWxlbWVudCBpcyBzaG93bi4gYHRydWVgIHdobmUgc2hvd25cclxuICAgKi9cclxuICBnZXQgYWN0aXZlKCkge1xyXG4gICAgcmV0dXJuICEhKHRoaXMucGlja2VyICYmIHRoaXMucGlja2VyLmFjdGl2ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9IC0gRE9NIG9iamVjdCBvZiBwaWNrZXIgZWxlbWVudFxyXG4gICAqL1xyXG4gIGdldCBwaWNrZXJFbGVtZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMucGlja2VyID8gdGhpcy5waWNrZXIuZWxlbWVudCA6IHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBuZXcgdmFsdWVzIHRvIHRoZSBjb25maWcgb3B0aW9uc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlnIG9wdGlvbnMgdG8gdXBkYXRlXHJcbiAgICovXHJcbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICBjb25zdCBwaWNrZXIgPSB0aGlzLnBpY2tlcjtcclxuICAgIGNvbnN0IG5ld09wdGlvbnMgPSBwcm9jZXNzT3B0aW9ucyhvcHRpb25zLCB0aGlzKTtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7XHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuY29uZmlnLCBuZXdPcHRpb25zKTtcclxuICAgIHBpY2tlci5zZXRPcHRpb25zKG5ld09wdGlvbnMpO1xyXG5cclxuICAgIHJlZnJlc2hVSSh0aGlzLCAzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNob3cgdGhlIHBpY2tlciBlbGVtZW50XHJcbiAgICovXHJcbiAgc2hvdygpIHtcclxuICAgIGlmICh0aGlzLmlucHV0RmllbGQpIHtcclxuICAgICAgaWYgKHRoaXMuaW5wdXRGaWVsZC5kaXNhYmxlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5pbnB1dEZpZWxkICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5fc2hvd2luZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmZvY3VzKCk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX3Nob3dpbmc7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMucGlja2VyLnNob3coKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhpZGUgdGhlIHBpY2tlciBlbGVtZW50XHJcbiAgICogTm90IGF2YWlsYWJsZSBvbiBpbmxpbmUgcGlja2VyXHJcbiAgICovXHJcbiAgaGlkZSgpIHtcclxuICAgIGlmICh0aGlzLmlubGluZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLnBpY2tlci5oaWRlKCk7XHJcbiAgICB0aGlzLnBpY2tlci51cGRhdGUoKS5jaGFuZ2VWaWV3KHRoaXMuY29uZmlnLnN0YXJ0VmlldykucmVuZGVyKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95IHRoZSBEYXRlcGlja2VyIGluc3RhbmNlXHJcbiAgICogQHJldHVybiB7RGV0ZXBpY2tlcn0gLSB0aGUgaW5zdGFuY2UgZGVzdHJveWVkXHJcbiAgICovXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgdW5yZWdpc3Rlckxpc3RlbmVycyh0aGlzKTtcclxuICAgIHRoaXMucGlja2VyLmRldGFjaCgpO1xyXG4gICAgaWYgKCF0aGlzLmlubGluZSkge1xyXG4gICAgICB0aGlzLmlucHV0RmllbGQuY2xhc3NMaXN0LnJlbW92ZSgnZGF0ZXBpY2tlci1pbnB1dCcpO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlIHRoaXMuZWxlbWVudC5kYXRlcGlja2VyO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIHNlbGVjdGVkIGRhdGUocylcclxuICAgKlxyXG4gICAqIFRoZSBtZXRob2QgcmV0dXJucyBhIERhdGUgb2JqZWN0IG9mIHNlbGVjdGVkIGRhdGUgYnkgZGVmYXVsdCwgYW5kIHJldHVybnNcclxuICAgKiBhbiBhcnJheSBvZiBzZWxlY3RlZCBkYXRlcyBpbiBtdWx0aWRhdGUgbW9kZS4gSWYgZm9ybWF0IHN0cmluZyBpcyBwYXNzZWQsXHJcbiAgICogaXQgcmV0dXJucyBkYXRlIHN0cmluZyhzKSBmb3JtYXR0ZWQgaW4gZ2l2ZW4gZm9ybWF0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7U3RyaW5nfSBbZm9ybWF0XSAtIEZvcm1hdCBzdHJpbmcgdG8gc3RyaW5naWZ5IHRoZSBkYXRlKHMpXHJcbiAgICogQHJldHVybiB7RGF0ZXxTdHJpbmd8RGF0ZVtdfFN0cmluZ1tdfSAtIHNlbGVjdGVkIGRhdGUocyksIG9yIGlmIG5vbmUgaXNcclxuICAgKiBzZWxlY3RlZCwgZW1wdHkgYXJyYXkgaW4gbXVsdGlkYXRlIG1vZGUgYW5kIHVudGl0bGVkIGluIHNpZ2xlZGF0ZSBtb2RlXHJcbiAgICovXHJcbiAgZ2V0RGF0ZShmb3JtYXQgPSB1bmRlZmluZWQpIHtcclxuICAgIGNvbnN0IGNhbGxiYWNrID0gZm9ybWF0XHJcbiAgICAgID8gZGF0ZSA9PiBmb3JtYXREYXRlKGRhdGUsIGZvcm1hdCwgdGhpcy5jb25maWcubG9jYWxlKVxyXG4gICAgICA6IGRhdGUgPT4gbmV3IERhdGUoZGF0ZSk7XHJcblxyXG4gICAgaWYgKHRoaXMuY29uZmlnLm11bHRpZGF0ZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5kYXRlcy5tYXAoY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuZGF0ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5kYXRlc1swXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgc2VsZWN0ZWQgZGF0ZShzKVxyXG4gICAqXHJcbiAgICogSW4gbXVsdGlkYXRlIG1vZGUsIHlvdSBjYW4gcGFzcyBtdWx0aXBsZSBkYXRlcyBhcyBhIHNlcmllcyBvZiBhcmd1bWVudHNcclxuICAgKiBvciBhbiBhcnJheS4gKFNpbmNlIGVhY2ggZGF0ZSBpcyBwYXJzZWQgaW5kaXZpZHVhbGx5LCB0aGUgdHlwZSBvZiB0aGVcclxuICAgKiBkYXRlcyBkb2Vzbid0IGhhdmUgdG8gYmUgdGhlIHNhbWUuKVxyXG4gICAqIFRoZSBnaXZlbiBkYXRlcyBhcmUgdXNlZCB0byB0b2dnbGUgdGhlIHNlbGVjdCBzdGF0dXMgb2YgZWFjaCBkYXRlLiBUaGVcclxuICAgKiBudW1iZXIgb2Ygc2VsZWN0ZWQgZGF0ZXMgaXMga2VwdCBmcm9tIGV4Y2VlZGluZyB0aGUgbGVuZ3RoIHNldCB0b1xyXG4gICAqIG1heE51bWJlck9mRGF0ZXMuXHJcbiAgICpcclxuICAgKiBXaXRoIGNsZWFyOiB0cnVlIG9wdGlvbiwgdGhlIG1ldGhvZCBjYW4gYmUgdXNlZCB0byBjbGVhciB0aGUgc2VsZWN0aW9uXHJcbiAgICogYW5kIHRvIHJlcGxhY2UgdGhlIHNlbGVjdGlvbiBpbnN0ZWFkIG9mIHRvZ2dsaW5nIGluIG11bHRpZGF0ZSBtb2RlLlxyXG4gICAqIElmIHRoZSBvcHRpb24gaXMgcGFzc2VkIHdpdGggbm8gZGF0ZSBhcmd1bWVudHMgb3IgYW4gZW1wdHkgZGF0ZXMgYXJyYXksXHJcbiAgICogaXQgd29ya3MgYXMgXCJjbGVhclwiIChjbGVhciB0aGUgc2VsZWN0aW9uIHRoZW4gc2V0IG5vdGhpbmcpLCBhbmQgaWYgdGhlXHJcbiAgICogb3B0aW9uIGlzIHBhc3NlZCB3aXRoIG5ldyBkYXRlcyB0byBzZWxlY3QsIGl0IHdvcmtzIGFzIFwicmVwbGFjZVwiIChjbGVhclxyXG4gICAqIHRoZSBzZWxlY3Rpb24gdGhlbiBzZXQgdGhlIGdpdmVuIGRhdGVzKVxyXG4gICAqXHJcbiAgICogV2hlbiByZW5kZXI6IGZhbHNlIG9wdGlvbiBpcyB1c2VkLCB0aGUgbWV0aG9kIG9taXRzIHJlLXJlbmRlcmluZyB0aGVcclxuICAgKiBwaWNrZXIgZWxlbWVudC4gSW4gdGhpcyBjYXNlLCB5b3UgbmVlZCB0byBjYWxsIHJlZnJlc2goKSBtZXRob2QgbGF0ZXIgaW5cclxuICAgKiBvcmRlciBmb3IgdGhlIHBpY2tlciBlbGVtZW50IHRvIHJlZmxlY3QgdGhlIGNoYW5nZXMuIFRoZSBpbnB1dCBmaWVsZCBpc1xyXG4gICAqIHJlZnJlc2hlZCBhbHdheXMgcmVnYXJkbGVzcyBvZiB0aGlzIG9wdGlvbi5cclxuICAgKlxyXG4gICAqIFdoZW4gaW52YWxpZCAodW5wYXJzYWJsZSwgcmVwZWF0ZWQsIGRpc2FibGVkIG9yIG91dC1vZi1yYW5nZSkgZGF0ZXMgYXJlXHJcbiAgICogcGFzc2VkLCB0aGUgbWV0aG9kIGlnbm9yZXMgdGhlbSBhbmQgYXBwbGllcyBvbmx5IHZhbGlkIG9uZXMuIEluIHRoZSBjYXNlXHJcbiAgICogdGhhdCBhbGwgdGhlIGdpdmVuIGRhdGVzIGFyZSBpbnZhbGlkLCB3aGljaCBpcyBkaXN0aW5ndWlzaGVkIGZyb20gcGFzc2luZ1xyXG4gICAqIG5vIGRhdGVzLCB0aGUgbWV0aG9kIGNvbnNpZGVycyBpdCBhcyBhbiBlcnJvciBhbmQgbGVhdmVzIHRoZSBzZWxlY3Rpb25cclxuICAgKiB1bnRvdWNoZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gey4uLihEYXRlfE51bWJlcnxTdHJpbmcpfEFycmF5fSBbZGF0ZXNdIC0gRGF0ZSBzdHJpbmdzLCBEYXRlXHJcbiAgICogb2JqZWN0cywgdGltZSB2YWx1ZXMgb3IgbWl4IG9mIHRob3NlIGZvciBuZXcgc2VsZWN0aW9uXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIGZ1bmN0aW9uIG9wdGlvbnNcclxuICAgKiAtIGNsZWFyOiB7Ym9vbGVhbn0gLSBXaGV0aGVyIHRvIGNsZWFyIHRoZSBleGlzdGluZyBzZWxlY3Rpb25cclxuICAgKiAgICAgZGVmdWFsdDogZmFsc2VcclxuICAgKiAtIHJlbmRlcjoge2Jvb2xlYW59IC0gV2hldGhlciB0byByZS1yZW5kZXIgdGhlIHBpY2tlciBlbGVtZW50XHJcbiAgICogICAgIGRlZmF1bHQ6IHRydWVcclxuICAgKiAtIGF1dG9oaWRlOiB7Ym9vbGVhbn0gLSBXaGV0aGVyIHRvIGhpZGUgdGhlIHBpY2tlciBlbGVtZW50IGFmdGVyIHJlLXJlbmRlclxyXG4gICAqICAgICBJZ25vcmVkIHdoZW4gdXNlZCB3aXRoIHJlbmRlcjogZmFsc2VcclxuICAgKiAgICAgZGVmYXVsdDogY29uZmlnLmF1dG9oaWRlXHJcbiAgICovXHJcbiAgc2V0RGF0ZSguLi5hcmdzKSB7XHJcbiAgICBjb25zdCBkYXRlcyA9IFsuLi5hcmdzXTtcclxuICAgIGNvbnN0IG9wdHMgPSB7fTtcclxuICAgIGNvbnN0IGxhc3RBcmcgPSBsYXN0SXRlbU9mKGFyZ3MpO1xyXG4gICAgaWYgKFxyXG4gICAgICB0eXBlb2YgbGFzdEFyZyA9PT0gJ29iamVjdCdcclxuICAgICAgJiYgIUFycmF5LmlzQXJyYXkobGFzdEFyZylcclxuICAgICAgJiYgIShsYXN0QXJnIGluc3RhbmNlb2YgRGF0ZSlcclxuICAgICAgJiYgbGFzdEFyZ1xyXG4gICAgKSB7XHJcbiAgICAgIE9iamVjdC5hc3NpZ24ob3B0cywgZGF0ZXMucG9wKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGlucHV0RGF0ZXMgPSBBcnJheS5pc0FycmF5KGRhdGVzWzBdKSA/IGRhdGVzWzBdIDogZGF0ZXM7XHJcbiAgICBzZXREYXRlKHRoaXMsIGlucHV0RGF0ZXMsIG9wdHMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBzZWxlY3RlZCBkYXRlKHMpIHdpdGggaW5wdXQgZmllbGQncyB2YWx1ZVxyXG4gICAqIE5vdCBhdmFpbGFibGUgb24gaW5saW5lIHBpY2tlclxyXG4gICAqXHJcbiAgICogVGhlIGlucHV0IGZpZWxkIHdpbGwgYmUgcmVmcmVzaGVkIHdpdGggcHJvcGVybHkgZm9ybWF0dGVkIGRhdGUgc3RyaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gLSBmdW5jdGlvbiBvcHRpb25zXHJcbiAgICogLSBhdXRvaGlkZToge2Jvb2xlYW59IC0gd2hldGhlciB0byBoaWRlIHRoZSBwaWNrZXIgZWxlbWVudCBhZnRlciByZWZyZXNoXHJcbiAgICogICAgIGRlZmF1bHQ6IGZhbHNlXHJcbiAgICovXHJcbiAgdXBkYXRlKG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcclxuICAgIGlmICh0aGlzLmlubGluZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb3B0cyA9IHtjbGVhcjogdHJ1ZSwgYXV0b2hpZGU6ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5hdXRvaGlkZSl9O1xyXG4gICAgY29uc3QgaW5wdXREYXRlcyA9IHN0cmluZ1RvQXJyYXkodGhpcy5pbnB1dEZpZWxkLnZhbHVlLCB0aGlzLmNvbmZpZy5kYXRlRGVsaW1pdGVyKTtcclxuICAgIHNldERhdGUodGhpcywgaW5wdXREYXRlcywgb3B0cyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWZyZXNoIHRoZSBwaWNrZXIgZWxlbWVudCBhbmQgdGhlIGFzc29jaWF0ZWQgaW5wdXQgZmllbGRcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3RhcmdldF0gLSB0YXJnZXQgaXRlbSB3aGVuIHJlZnJlc2hpbmcgb25lIGl0ZW0gb25seVxyXG4gICAqICdwaWNrZXInIG9yICdpbnB1dCdcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZVJlbmRlcl0gLSB3aGV0aGVyIHRvIHJlLXJlbmRlciB0aGUgcGlja2VyIGVsZW1lbnRcclxuICAgKiByZWdhcmRsZXNzIG9mIGl0cyBzdGF0ZSBpbnN0ZWFkIG9mIG9wdGltaXplZCByZWZyZXNoXHJcbiAgICovXHJcbiAgcmVmcmVzaCh0YXJnZXQgPSB1bmRlZmluZWQsIGZvcmNlUmVuZGVyID0gZmFsc2UpIHtcclxuICAgIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgZm9yY2VSZW5kZXIgPSB0YXJnZXQ7XHJcbiAgICAgIHRhcmdldCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgbW9kZTtcclxuICAgIGlmICh0YXJnZXQgPT09ICdwaWNrZXInKSB7XHJcbiAgICAgIG1vZGUgPSAyO1xyXG4gICAgfSBlbHNlIGlmICh0YXJnZXQgPT09ICdpbnB1dCcpIHtcclxuICAgICAgbW9kZSA9IDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBtb2RlID0gMztcclxuICAgIH1cclxuICAgIHJlZnJlc2hVSSh0aGlzLCBtb2RlLCAhZm9yY2VSZW5kZXIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW50ZXIgZWRpdCBtb2RlXHJcbiAgICogTm90IGF2YWlsYWJsZSBvbiBpbmxpbmUgcGlja2VyIG9yIHdoZW4gdGhlIHBpY2tlciBlbGVtZW50IGlzIGhpZGRlblxyXG4gICAqL1xyXG4gIGVudGVyRWRpdE1vZGUoKSB7XHJcbiAgICBpZiAodGhpcy5pbmxpbmUgfHwgIXRoaXMucGlja2VyLmFjdGl2ZSB8fCB0aGlzLmVkaXRNb2RlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuZWRpdE1vZGUgPSB0cnVlO1xyXG4gICAgdGhpcy5pbnB1dEZpZWxkLmNsYXNzTGlzdC5hZGQoJ2luLWVkaXQnLCAnYm9yZGVyLWJsdWUtNzAwJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeGl0IGZyb20gZWRpdCBtb2RlXHJcbiAgICogTm90IGF2YWlsYWJsZSBvbiBpbmxpbmUgcGlja2VyXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gLSBmdW5jdGlvbiBvcHRpb25zXHJcbiAgICogLSB1cGRhdGU6IHtib29sZWFufSAtIHdoZXRoZXIgdG8gY2FsbCB1cGRhdGUoKSBhZnRlciBleGl0aW5nXHJcbiAgICogICAgIElmIGZhbHNlLCBpbnB1dCBmaWVsZCBpcyByZXZlcnQgdG8gdGhlIGV4aXN0aW5nIHNlbGVjdGlvblxyXG4gICAqICAgICBkZWZhdWx0OiBmYWxzZVxyXG4gICAqL1xyXG4gIGV4aXRFZGl0TW9kZShvcHRpb25zID0gdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAodGhpcy5pbmxpbmUgfHwgIXRoaXMuZWRpdE1vZGUpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe3VwZGF0ZTogZmFsc2V9LCBvcHRpb25zKTtcclxuICAgIGRlbGV0ZSB0aGlzLmVkaXRNb2RlO1xyXG4gICAgdGhpcy5pbnB1dEZpZWxkLmNsYXNzTGlzdC5yZW1vdmUoJ2luLWVkaXQnLCAnYm9yZGVyLWJsdWUtNzAwJyk7XHJcbiAgICBpZiAob3B0cy51cGRhdGUpIHtcclxuICAgICAgdGhpcy51cGRhdGUob3B0cyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHRoZW1lc2JlcmcvdGFpbHdpbmQtZGF0ZXBpY2tlci9qcy9EYXRlUmFuZ2VQaWNrZXIuanNcclxuXHJcblxyXG5cclxuXHJcbi8vIGZpbHRlciBvdXQgdGhlIGNvbmZpZyBvcHRpb25zIGluYXBwcm9wcml0ZSB0byBwYXNzIHRvIERhdGVwaWNrZXJcclxuZnVuY3Rpb24gZmlsdGVyT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgY29uc3QgbmV3T3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xyXG5cclxuICBkZWxldGUgbmV3T3B0cy5pbnB1dHM7XHJcbiAgZGVsZXRlIG5ld09wdHMuYWxsb3dPbmVTaWRlZFJhbmdlO1xyXG4gIGRlbGV0ZSBuZXdPcHRzLm1heE51bWJlck9mRGF0ZXM7IC8vIHRvIGVuc3VyZSBlYWNoIGRhdGVwaWNrZXIgaGFuZGxlcyBhIHNpbmdsZSBkYXRlXHJcblxyXG4gIHJldHVybiBuZXdPcHRzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXR1cERhdGVwaWNrZXIocmFuZ2VwaWNrZXIsIGNoYW5nZURhdGVMaXN0ZW5lciwgZWwsIG9wdGlvbnMpIHtcclxuICByZWdpc3Rlckxpc3RlbmVycyhyYW5nZXBpY2tlciwgW1xyXG4gICAgW2VsLCAnY2hhbmdlRGF0ZScsIGNoYW5nZURhdGVMaXN0ZW5lcl0sXHJcbiAgXSk7XHJcbiAgbmV3IERhdGVwaWNrZXIoZWwsIG9wdGlvbnMsIHJhbmdlcGlja2VyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gb25DaGFuZ2VEYXRlKHJhbmdlcGlja2VyLCBldikge1xyXG4gIC8vIHRvIHByZXZlbnQgYm90aCBkYXRlcGlja2VycyB0cmlnZ2VyIHRoZSBvdGhlciBzaWRlJ3MgdXBkYXRlIGVhY2ggb3RoZXJcclxuICBpZiAocmFuZ2VwaWNrZXIuX3VwZGF0aW5nKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHJhbmdlcGlja2VyLl91cGRhdGluZyA9IHRydWU7XHJcblxyXG4gIGNvbnN0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICBpZiAodGFyZ2V0LmRhdGVwaWNrZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZGF0ZXBpY2tlcnMgPSByYW5nZXBpY2tlci5kYXRlcGlja2VycztcclxuICBjb25zdCBzZXREYXRlT3B0aW9ucyA9IHtyZW5kZXI6IGZhbHNlfTtcclxuICBjb25zdCBjaGFuZ2VkU2lkZSA9IHJhbmdlcGlja2VyLmlucHV0cy5pbmRleE9mKHRhcmdldCk7XHJcbiAgY29uc3Qgb3RoZXJTaWRlID0gY2hhbmdlZFNpZGUgPT09IDAgPyAxIDogMDtcclxuICBjb25zdCBjaGFuZ2VkRGF0ZSA9IGRhdGVwaWNrZXJzW2NoYW5nZWRTaWRlXS5kYXRlc1swXTtcclxuICBjb25zdCBvdGhlckRhdGUgPSBkYXRlcGlja2Vyc1tvdGhlclNpZGVdLmRhdGVzWzBdO1xyXG5cclxuICBpZiAoY2hhbmdlZERhdGUgIT09IHVuZGVmaW5lZCAmJiBvdGhlckRhdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgLy8gaWYgdGhlIHN0YXJ0IG9mIHRoZSByYW5nZSA+IHRoZSBlbmQsIHN3YXAgdGhlbVxyXG4gICAgaWYgKGNoYW5nZWRTaWRlID09PSAwICYmIGNoYW5nZWREYXRlID4gb3RoZXJEYXRlKSB7XHJcbiAgICAgIGRhdGVwaWNrZXJzWzBdLnNldERhdGUob3RoZXJEYXRlLCBzZXREYXRlT3B0aW9ucyk7XHJcbiAgICAgIGRhdGVwaWNrZXJzWzFdLnNldERhdGUoY2hhbmdlZERhdGUsIHNldERhdGVPcHRpb25zKTtcclxuICAgIH0gZWxzZSBpZiAoY2hhbmdlZFNpZGUgPT09IDEgJiYgY2hhbmdlZERhdGUgPCBvdGhlckRhdGUpIHtcclxuICAgICAgZGF0ZXBpY2tlcnNbMF0uc2V0RGF0ZShjaGFuZ2VkRGF0ZSwgc2V0RGF0ZU9wdGlvbnMpO1xyXG4gICAgICBkYXRlcGlja2Vyc1sxXS5zZXREYXRlKG90aGVyRGF0ZSwgc2V0RGF0ZU9wdGlvbnMpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoIXJhbmdlcGlja2VyLmFsbG93T25lU2lkZWRSYW5nZSkge1xyXG4gICAgLy8gdG8gcHJldmVudCB0aGUgcmFuZ2UgZnJvbSBiZWNvbWluZyBvbmUtc2lkZWQsIGNvcHkgY2hhbmdlZCBzaWRlJ3NcclxuICAgIC8vIHNlbGVjdGlvbiAobm8gbWF0dGVyIGlmIGl0J3MgZW1wdHkpIHRvIHRoZSBvdGhlciBzaWRlXHJcbiAgICBpZiAoY2hhbmdlZERhdGUgIT09IHVuZGVmaW5lZCB8fCBvdGhlckRhdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBzZXREYXRlT3B0aW9ucy5jbGVhciA9IHRydWU7XHJcbiAgICAgIGRhdGVwaWNrZXJzW290aGVyU2lkZV0uc2V0RGF0ZShkYXRlcGlja2Vyc1tjaGFuZ2VkU2lkZV0uZGF0ZXMsIHNldERhdGVPcHRpb25zKTtcclxuICAgIH1cclxuICB9XHJcbiAgZGF0ZXBpY2tlcnNbMF0ucGlja2VyLnVwZGF0ZSgpLnJlbmRlcigpO1xyXG4gIGRhdGVwaWNrZXJzWzFdLnBpY2tlci51cGRhdGUoKS5yZW5kZXIoKTtcclxuICBkZWxldGUgcmFuZ2VwaWNrZXIuX3VwZGF0aW5nO1xyXG59XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgZGF0ZSByYW5nZSBwaWNrZXJcclxuICovXHJcbmNsYXNzIERhdGVSYW5nZVBpY2tlciAge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIGRhdGUgcmFuZ2UgcGlja2VyXHJcbiAgICogQHBhcmFtICB7RWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gYmluZCBhIGRhdGUgcmFuZ2UgcGlja2VyXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gLSBjb25maWcgb3B0aW9uc1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgaW5wdXRzID0gQXJyYXkuaXNBcnJheShvcHRpb25zLmlucHV0cylcclxuICAgICAgPyBvcHRpb25zLmlucHV0c1xyXG4gICAgICA6IEFycmF5LmZyb20oZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCcpKTtcclxuICAgIGlmIChpbnB1dHMubGVuZ3RoIDwgMikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZWxlbWVudC5yYW5nZXBpY2tlciA9IHRoaXM7XHJcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgdGhpcy5pbnB1dHMgPSBpbnB1dHMuc2xpY2UoMCwgMik7XHJcbiAgICB0aGlzLmFsbG93T25lU2lkZWRSYW5nZSA9ICEhb3B0aW9ucy5hbGxvd09uZVNpZGVkUmFuZ2U7XHJcblxyXG4gICAgY29uc3QgY2hhbmdlRGF0ZUxpc3RlbmVyID0gb25DaGFuZ2VEYXRlLmJpbmQobnVsbCwgdGhpcyk7XHJcbiAgICBjb25zdCBjbGVhbk9wdGlvbnMgPSBmaWx0ZXJPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgLy8gaW4gb3JkZXIgZm9yIGluaXRpYWwgZGF0ZSBzZXR1cCB0byB3b3JrIHJpZ2h0IHdoZW4gcGNpY0x2ZWwgPiAwLFxyXG4gICAgLy8gbGV0IERhdGVwaWNrZXIgY29uc3RydWN0b3IgYWRkIHRoZSBpbnN0YW5jZSB0byB0aGUgcmFuZ2VwaWNrZXJcclxuICAgIGNvbnN0IGRhdGVwaWNrZXJzID0gW107XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2RhdGVwaWNrZXJzJywge1xyXG4gICAgICBnZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGVwaWNrZXJzO1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgICBzZXR1cERhdGVwaWNrZXIodGhpcywgY2hhbmdlRGF0ZUxpc3RlbmVyLCB0aGlzLmlucHV0c1swXSwgY2xlYW5PcHRpb25zKTtcclxuICAgIHNldHVwRGF0ZXBpY2tlcih0aGlzLCBjaGFuZ2VEYXRlTGlzdGVuZXIsIHRoaXMuaW5wdXRzWzFdLCBjbGVhbk9wdGlvbnMpO1xyXG4gICAgT2JqZWN0LmZyZWV6ZShkYXRlcGlja2Vycyk7XHJcbiAgICAvLyBub3JtYWxpemUgdGhlIHJhbmdlIGlmIGluaXRhbCBkYXRlcyBhcmUgZ2l2ZW5cclxuICAgIGlmIChkYXRlcGlja2Vyc1swXS5kYXRlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIG9uQ2hhbmdlRGF0ZSh0aGlzLCB7dGFyZ2V0OiB0aGlzLmlucHV0c1swXX0pO1xyXG4gICAgfSBlbHNlIGlmIChkYXRlcGlja2Vyc1sxXS5kYXRlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIG9uQ2hhbmdlRGF0ZSh0aGlzLCB7dGFyZ2V0OiB0aGlzLmlucHV0c1sxXX0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge0FycmF5fSAtIHNlbGVjdGVkIGRhdGUgb2YgdGhlIGxpbmtlZCBkYXRlIHBpY2tlcnNcclxuICAgKi9cclxuICBnZXQgZGF0ZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRlcGlja2Vycy5sZW5ndGggPT09IDJcclxuICAgICAgPyBbXHJcbiAgICAgICAgICB0aGlzLmRhdGVwaWNrZXJzWzBdLmRhdGVzWzBdLFxyXG4gICAgICAgICAgdGhpcy5kYXRlcGlja2Vyc1sxXS5kYXRlc1swXSxcclxuICAgICAgICBdXHJcbiAgICAgIDogdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IG5ldyB2YWx1ZXMgdG8gdGhlIGNvbmZpZyBvcHRpb25zXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWcgb3B0aW9ucyB0byB1cGRhdGVcclxuICAgKi9cclxuICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcclxuICAgIHRoaXMuYWxsb3dPbmVTaWRlZFJhbmdlID0gISFvcHRpb25zLmFsbG93T25lU2lkZWRSYW5nZTtcclxuXHJcbiAgICBjb25zdCBjbGVhbk9wdGlvbnMgPSBmaWx0ZXJPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgdGhpcy5kYXRlcGlja2Vyc1swXS5zZXRPcHRpb25zKGNsZWFuT3B0aW9ucyk7XHJcbiAgICB0aGlzLmRhdGVwaWNrZXJzWzFdLnNldE9wdGlvbnMoY2xlYW5PcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgdGhlIERhdGVSYW5nZVBpY2tlciBpbnN0YW5jZVxyXG4gICAqIEByZXR1cm4ge0RhdGVSYW5nZVBpY2tlcn0gLSB0aGUgaW5zdGFuY2UgZGVzdHJveWVkXHJcbiAgICovXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuZGF0ZXBpY2tlcnNbMF0uZGVzdHJveSgpO1xyXG4gICAgdGhpcy5kYXRlcGlja2Vyc1sxXS5kZXN0cm95KCk7XHJcbiAgICB1bnJlZ2lzdGVyTGlzdGVuZXJzKHRoaXMpO1xyXG4gICAgZGVsZXRlIHRoaXMuZWxlbWVudC5yYW5nZXBpY2tlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgYW5kIGVuZCBkYXRlcyBvZiB0aGUgZGF0ZSByYW5nZVxyXG4gICAqXHJcbiAgICogVGhlIG1ldGhvZCByZXR1cm5zIERhdGUgb2JqZWN0cyBieSBkZWZhdWx0LiBJZiBmb3JtYXQgc3RyaW5nIGlzIHBhc3NlZCxcclxuICAgKiBpdCByZXR1cm5zIGRhdGUgc3RyaW5ncyBmb3JtYXR0ZWQgaW4gZ2l2ZW4gZm9ybWF0LlxyXG4gICAqIFRoZSByZXN1bHQgYXJyYXkgYWx3YXlzIGNvbnRhaW5zIDIgaXRlbXMgKHN0YXJ0IGRhdGUvZW5kIGRhdGUpIGFuZFxyXG4gICAqIHVuZGVmaW5lZCBpcyB1c2VkIGZvciB1bnNlbGVjdGVkIHNpZGUuIChlLmcuIElmIG5vbmUgaXMgc2VsZWN0ZWQsXHJcbiAgICogdGhlIHJlc3VsdCB3aWxsIGJlIFt1bmRlZmluZWQsIHVuZGVmaW5lZF0uIElmIG9ubHkgdGhlIGVuZCBkYXRlIGlzIHNldFxyXG4gICAqIHdoZW4gYWxsb3dPbmVTaWRlZFJhbmdlIGNvbmZpZyBvcHRpb24gaXMgdHJ1ZSwgW3VuZGVmaW5lZCwgZW5kRGF0ZV0gd2lsbFxyXG4gICAqIGJlIHJldHVybmVkLilcclxuICAgKlxyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gW2Zvcm1hdF0gLSBGb3JtYXQgc3RyaW5nIHRvIHN0cmluZ2lmeSB0aGUgZGF0ZXNcclxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBTdGFydCBhbmQgZW5kIGRhdGVzXHJcbiAgICovXHJcbiAgZ2V0RGF0ZXMoZm9ybWF0ID0gdW5kZWZpbmVkKSB7XHJcbiAgICBjb25zdCBjYWxsYmFjayA9IGZvcm1hdFxyXG4gICAgICA/IGRhdGUgPT4gZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQsIHRoaXMuZGF0ZXBpY2tlcnNbMF0uY29uZmlnLmxvY2FsZSlcclxuICAgICAgOiBkYXRlID0+IG5ldyBEYXRlKGRhdGUpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmRhdGVzLm1hcChkYXRlID0+IGRhdGUgPT09IHVuZGVmaW5lZCA/IGRhdGUgOiBjYWxsYmFjayhkYXRlKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgb2YgdGhlIGRhdGUgcmFuZ2VcclxuICAgKlxyXG4gICAqIFRoZSBtZXRob2QgY2FsbHMgZGF0ZXBpY2tlci5zZXREYXRlKCkgaW50ZXJuYWxseSB1c2luZyBlYWNoIG9mIHRoZVxyXG4gICAqIGFyZ3VtZW50cyBpbiBzdGFydOKGkmVuZCBvcmRlci5cclxuICAgKlxyXG4gICAqIFdoZW4gYSBjbGVhcjogdHJ1ZSBvcHRpb24gb2JqZWN0IGlzIHBhc3NlZCBpbnN0ZWFkIG9mIGEgZGF0ZSwgdGhlIG1ldGhvZFxyXG4gICAqIGNsZWFycyB0aGUgZGF0ZS5cclxuICAgKlxyXG4gICAqIElmIGFuIGludmFsaWQgZGF0ZSwgdGhlIHNhbWUgZGF0ZSBhcyB0aGUgY3VycmVudCBvbmUgb3IgYW4gb3B0aW9uIG9iamVjdFxyXG4gICAqIHdpdGhvdXQgY2xlYXI6IHRydWUgaXMgcGFzc2VkLCB0aGUgbWV0aG9kIGNvbnNpZGVycyB0aGF0IGFyZ3VtZW50IGFzIGFuXHJcbiAgICogXCJpbmVmZmVjdGl2ZVwiIGFyZ3VtZW50IGJlY2F1c2UgY2FsbGluZyBkYXRlcGlja2VyLnNldERhdGUoKSB3aXRoIHRob3NlXHJcbiAgICogdmFsdWVzIG1ha2VzIG5vIGNoYW5nZXMgdG8gdGhlIGRhdGUgc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogV2hlbiB0aGUgYWxsb3dPbmVTaWRlZFJhbmdlIGNvbmZpZyBvcHRpb24gaXMgZmFsc2UsIHBhc3Npbmcge2NsZWFyOiB0cnVlfVxyXG4gICAqIHRvIGNsZWFyIHRoZSByYW5nZSB3b3JrcyBvbmx5IHdoZW4gaXQgaXMgZG9uZSB0byB0aGUgbGFzdCBlZmZlY3RpdmVcclxuICAgKiBhcmd1bWVudCAoaW4gb3RoZXIgd29yZHMsIHBhc3NlZCB0byByYW5nZUVuZCBvciB0byByYW5nZVN0YXJ0IGFsb25nIHdpdGhcclxuICAgKiBpbmVmZmVjdGl2ZSByYW5nZUVuZCkuIFRoaXMgaXMgYmVjYXVzZSB3aGVuIHRoZSBkYXRlIHJhbmdlIGlzIGNoYW5nZWQsXHJcbiAgICogaXQgZ2V0cyBub3JtYWxpemVkIGJhc2VkIG9uIHRoZSBsYXN0IGNoYW5nZSBhdCB0aGUgZW5kIG9mIHRoZSBjaGFuZ2luZ1xyXG4gICAqIHByb2Nlc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0RhdGV8TnVtYmVyfFN0cmluZ3xPYmplY3R9IHJhbmdlU3RhcnQgLSBTdGFydCBkYXRlIG9mIHRoZSByYW5nZVxyXG4gICAqIG9yIHtjbGVhcjogdHJ1ZX0gdG8gY2xlYXIgdGhlIGRhdGVcclxuICAgKiBAcGFyYW0ge0RhdGV8TnVtYmVyfFN0cmluZ3xPYmplY3R9IHJhbmdlRW5kIC0gRW5kIGRhdGUgb2YgdGhlIHJhbmdlXHJcbiAgICogb3Ige2NsZWFyOiB0cnVlfSB0byBjbGVhciB0aGUgZGF0ZVxyXG4gICAqL1xyXG4gIHNldERhdGVzKHJhbmdlU3RhcnQsIHJhbmdlRW5kKSB7XHJcbiAgICBjb25zdCBbZGF0ZXBpY2tlcjAsIGRhdGVwaWNrZXIxXSA9IHRoaXMuZGF0ZXBpY2tlcnM7XHJcbiAgICBjb25zdCBvcmlnRGF0ZXMgPSB0aGlzLmRhdGVzO1xyXG5cclxuICAgIC8vIElmIHJhbmdlIG5vcm1hbGl6YXRpb24gcnVucyBvbiBldmVyeSBjaGFuZ2UsIHdlIGNhbid0IHNldCBhIG5ldyByYW5nZVxyXG4gICAgLy8gdGhhdCBzdGFydHMgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgY3VycmVudCByYW5nZSBjb3JyZWN0bHkgYmVjYXVzZSB0aGVcclxuICAgIC8vIG5vcm1hbGl6YXRpb24gcHJvY2VzcyBzd2FwcyBzdGFydOKGlO+4jmVuZCByaWdodCBhZnRlciBzZXR0aW5nIHRoZSBuZXcgc3RhcnRcclxuICAgIC8vIGRhdGUuIFRvIHByZXZlbnQgdGhpcywgdGhlIG5vcm1hbGl6YXRpb24gcHJvY2VzcyBuZWVkcyB0byBydW4gb25jZSBhZnRlclxyXG4gICAgLy8gYm90aCBvZiB0aGUgbmV3IGRhdGVzIGFyZSBzZXQuXHJcbiAgICB0aGlzLl91cGRhdGluZyA9IHRydWU7XHJcbiAgICBkYXRlcGlja2VyMC5zZXREYXRlKHJhbmdlU3RhcnQpO1xyXG4gICAgZGF0ZXBpY2tlcjEuc2V0RGF0ZShyYW5nZUVuZCk7XHJcbiAgICBkZWxldGUgdGhpcy5fdXBkYXRpbmc7XHJcblxyXG4gICAgaWYgKGRhdGVwaWNrZXIxLmRhdGVzWzBdICE9PSBvcmlnRGF0ZXNbMV0pIHtcclxuICAgICAgb25DaGFuZ2VEYXRlKHRoaXMsIHt0YXJnZXQ6IHRoaXMuaW5wdXRzWzFdfSk7XHJcbiAgICB9IGVsc2UgaWYgKGRhdGVwaWNrZXIwLmRhdGVzWzBdICE9PSBvcmlnRGF0ZXNbMF0pIHtcclxuICAgICAgb25DaGFuZ2VEYXRlKHRoaXMsIHt0YXJnZXQ6IHRoaXMuaW5wdXRzWzBdfSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcGx1Z2lucy9kYXRlcGlja2VyLmpzXHJcblxyXG5cclxuXHJcbmNvbnN0IGdldERhdGVwaWNrZXJPcHRpb25zID0gZGF0ZXBpY2tlckVsID0+IHtcclxuICBjb25zdCBidXR0b25zID0gZGF0ZXBpY2tlckVsLmhhc0F0dHJpYnV0ZSgnZGF0ZXBpY2tlci1idXR0b25zJyk7XHJcbiAgY29uc3QgYXV0b2hpZGUgPSBkYXRlcGlja2VyRWwuaGFzQXR0cmlidXRlKCdkYXRlcGlja2VyLWF1dG9oaWRlJyk7XHJcbiAgY29uc3QgZm9ybWF0ID0gZGF0ZXBpY2tlckVsLmhhc0F0dHJpYnV0ZSgnZGF0ZXBpY2tlci1mb3JtYXQnKTtcclxuICBjb25zdCBvcmllbnRhdGlvbiA9IGRhdGVwaWNrZXJFbC5oYXNBdHRyaWJ1dGUoJ2RhdGVwaWNrZXItb3JpZW50YXRpb24nKTtcclxuICBjb25zdCB0aXRsZSA9IGRhdGVwaWNrZXJFbC5oYXNBdHRyaWJ1dGUoJ2RhdGVwaWNrZXItdGl0bGUnKTtcclxuICBsZXQgb3B0aW9ucyA9IHt9O1xyXG5cclxuICBpZiAoYnV0dG9ucykge1xyXG4gICAgb3B0aW9ucy50b2RheUJ0biA9IHRydWU7XHJcbiAgICBvcHRpb25zLmNsZWFyQnRuID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChhdXRvaGlkZSkge1xyXG4gICAgb3B0aW9ucy5hdXRvaGlkZSA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAoZm9ybWF0KSB7XHJcbiAgICBvcHRpb25zLmZvcm1hdCA9IGRhdGVwaWNrZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGVwaWNrZXItZm9ybWF0Jyk7XHJcbiAgfVxyXG5cclxuICBpZiAob3JpZW50YXRpb24pIHtcclxuICAgIG9wdGlvbnMub3JpZW50YXRpb24gPSBkYXRlcGlja2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRlcGlja2VyLW9yaWVudGF0aW9uJyk7XHJcbiAgfVxyXG5cclxuICBpZiAodGl0bGUpIHtcclxuICAgIG9wdGlvbnMudGl0bGUgPSBkYXRlcGlja2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRlcGlja2VyLXRpdGxlJyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb3B0aW9ucztcclxufTtcclxuXHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XHJcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGVwaWNrZXJdJykuZm9yRWFjaChmdW5jdGlvbiAoZGF0ZXBpY2tlckVsKSB7XHJcbiAgICBuZXcgRGF0ZXBpY2tlcihkYXRlcGlja2VyRWwsIGdldERhdGVwaWNrZXJPcHRpb25zKGRhdGVwaWNrZXJFbCkpO1xyXG4gIH0pO1xyXG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpbmxpbmUtZGF0ZXBpY2tlcl0nKS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRlcGlja2VyRWwpIHtcclxuICAgIG5ldyBEYXRlcGlja2VyKGRhdGVwaWNrZXJFbCwgZ2V0RGF0ZXBpY2tlck9wdGlvbnMoZGF0ZXBpY2tlckVsKSk7XHJcbiAgfSk7XHJcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGUtcmFuZ2VwaWNrZXJdJykuZm9yRWFjaChmdW5jdGlvbiAoZGF0ZXBpY2tlckVsKSB7XHJcbiAgICBuZXcgRGF0ZVJhbmdlUGlja2VyKGRhdGVwaWNrZXJFbCwgZ2V0RGF0ZXBpY2tlck9wdGlvbnMoZGF0ZXBpY2tlckVsKSk7XHJcbiAgfSk7XHJcbn0pO1xyXG4vKioqKioqLyB9KSgpXHJcbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0ZXBpY2tlci5qcy5tYXAiXSwiZmlsZSI6Ii4vcmVzb3VyY2VzL2pzL2RhdGVwaWNrZXIuanMuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/datepicker.js\n");

/***/ }),

/***/ "./node_modules/flowbite/dist/flowbite.js":
/*!************************************************!*\
  !*** ./node_modules/flowbite/dist/flowbite.js ***!
  \************************************************/
/***/ (() => {

eval("/******/ (() => { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 366:\n/***/ (() => {\n\nvar hideAllOtherAccordionHeaderElements = function hideAllOtherAccordionHeaderElements(accordionHeaderElements, currentAccordionHeaderEl, activeClassesArray, inactiveClassesArray) {\n  accordionHeaderElements.forEach(function (headerEl) {\n    if (currentAccordionHeaderEl !== headerEl) {\n      var bodyEl = document.querySelector(headerEl.getAttribute('data-accordion-target'));\n      headerEl.setAttribute('aria-expanded', false); // active classes\n\n      activeClassesArray.map(function (c) {\n        headerEl.classList.remove(c);\n      }); // inactive classes\n\n      inactiveClassesArray.map(function (c) {\n        headerEl.classList.add(c);\n      });\n      bodyEl.classList.add('hidden');\n\n      if (headerEl.querySelector('[data-accordion-icon]')) {\n        headerEl.querySelector('[data-accordion-icon]').classList.remove('rotate-180');\n      }\n    }\n  });\n};\n\nvar rotateAccordionIcon = function rotateAccordionIcon(accordionHeaderEl) {\n  if (accordionHeaderEl.querySelector('[data-accordion-icon]')) {\n    accordionHeaderEl.querySelector('[data-accordion-icon]').classList.toggle('rotate-180');\n  }\n};\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  document.querySelectorAll('[data-accordion]').forEach(function (accordionEl) {\n    var accordionId = accordionEl.getAttribute('id');\n    var collapseAccordion = accordionEl.getAttribute('data-accordion');\n    var accordionHeaderElements = document.querySelectorAll('#' + accordionId + ' [data-accordion-target]');\n    var activeClasses = accordionEl.getAttribute('data-active-classes');\n    var inactiveClasses = accordionEl.getAttribute('data-inactive-classes');\n    var activeClassesArray = null;\n\n    if (activeClasses && activeClasses !== '') {\n      activeClassesArray = activeClasses.split(\" \");\n    } else {\n      // fallback classes if option not set\n      activeClassesArray = ['bg-gray-100', 'dark:bg-gray-800', 'text-gray-900', 'dark:text-white'];\n    }\n\n    var inactiveClassesArray = null;\n\n    if (inactiveClasses && inactiveClasses !== '') {\n      inactiveClassesArray = inactiveClasses.split(\" \");\n    } else {\n      // fallback classes if option not set\n      inactiveClassesArray = ['text-gray-500', 'dark:text-gray-400'];\n    }\n\n    accordionHeaderElements.forEach(function (accordionHeaderEl) {\n      var accordionBodyEl = document.querySelector(accordionHeaderEl.getAttribute('data-accordion-target'));\n      accordionHeaderEl.addEventListener('click', function () {\n        if (collapseAccordion === 'collapse') {\n          hideAllOtherAccordionHeaderElements(accordionHeaderElements, accordionHeaderEl, activeClassesArray, inactiveClassesArray);\n        }\n\n        if (accordionHeaderEl.getAttribute('aria-expanded') === 'true') {\n          accordionHeaderEl.setAttribute('aria-expanded', false); // active classes\n\n          activeClassesArray.map(function (c) {\n            accordionHeaderEl.classList.remove(c);\n          }); // inactive classes\n\n          inactiveClassesArray.map(function (c) {\n            accordionHeaderEl.classList.add(c);\n          });\n          accordionBodyEl.classList.add('hidden');\n          rotateAccordionIcon(accordionHeaderEl);\n        } else {\n          accordionHeaderEl.setAttribute('aria-expanded', true); // active classes\n\n          activeClassesArray.map(function (c) {\n            accordionHeaderEl.classList.add(c);\n          }); // inactive classes\n\n          inactiveClassesArray.map(function (c) {\n            accordionHeaderEl.classList.remove(c);\n          });\n          accordionBodyEl.classList.remove('hidden');\n          rotateAccordionIcon(accordionHeaderEl);\n        }\n      });\n    });\n  });\n});\n\n/***/ }),\n\n/***/ 791:\n/***/ (() => {\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  document.querySelectorAll('[data-carousel]').forEach(function (carouselEl) {\n    var interval = carouselEl.getAttribute('data-carousel-interval');\n    var slide = carouselEl.getAttribute('data-carousel') === 'slide' ? true : false;\n    var carousel = new Carousel(carouselEl.getAttribute('id'), {\n      interval: interval\n    });\n\n    if (slide) {\n      carousel.cycle();\n    } // check for controls\n\n\n    var carouselNextEl = carouselEl.querySelector('[data-carousel-next]');\n    var carouselPrevEl = carouselEl.querySelector('[data-carousel-prev]');\n\n    if (carouselNextEl) {\n      carouselNextEl.addEventListener('click', function () {\n        carousel.nextSlide();\n      });\n    }\n\n    if (carouselPrevEl) {\n      carouselPrevEl.addEventListener('click', function () {\n        carousel.prevSlide();\n      });\n    } // check for indicators\n\n\n    carouselEl.querySelectorAll('[data-carousel-slide-to]').forEach(function (slideToEl) {\n      slideToEl.addEventListener('click', function () {\n        var id = slideToEl.getAttribute('data-carousel-slide-to');\n        carousel.slideTo(id);\n      });\n    });\n  });\n});\nvar Default = {\n  interval: 3000\n};\n\nvar Carousel = /*#__PURE__*/function () {\n  function Carousel(id, options) {\n    _classCallCheck(this, Carousel);\n\n    this._el = document.getElementById(id);\n    this._items = _toConsumableArray(this._el.querySelectorAll('[data-carousel-item]')).length ? _toConsumableArray(this._el.querySelectorAll('[data-carousel-item]')).map(function (el, id) {\n      return {\n        id: id,\n        el: el,\n        active: el.getAttribute(['data-carousel-item']) === 'active' ? true : false\n      };\n    }) : [];\n    this._indicators = _toConsumableArray(this._el.querySelectorAll('[data-carousel-slide-to]')).length ? _toConsumableArray(this._el.querySelectorAll('[data-carousel-slide-to]')).map(function (el, id) {\n      return {\n        id: id,\n        el: el\n      };\n    }) : [];\n    this._interval = null;\n    this._intervalDuration = options.interval ? options.interval : Default.interval;\n\n    this._init();\n  }\n  /**\n   * Initialise carousel and items based on active one\n   */\n\n\n  _createClass(Carousel, [{\n    key: \"_init\",\n    value: function _init() {\n      var activeItem = this._getActiveItem();\n\n      this._items.map(function (item) {\n        item.el.classList.add('absolute', 'inset-0', 'transition-all', 'transform');\n      });\n\n      this.slideTo(activeItem.id);\n    }\n    /**\n     * Slide to the element based on id\n     * @param {*} id \n     */\n\n  }, {\n    key: \"slideTo\",\n    value: function slideTo(id) {\n      var nextItem = this._items[id];\n      var rotationItems = {\n        'left': nextItem.id === 0 ? this._items[this._items.length - 1] : this._items[nextItem.id - 1],\n        'middle': nextItem,\n        'right': nextItem.id === this._items.length - 1 ? this._items[0] : this._items[nextItem.id + 1]\n      };\n\n      this._rotate(rotationItems);\n\n      this._setActiveItem(nextItem.id);\n\n      if (this._interval) {\n        this.pause();\n        this.cycle();\n      }\n    }\n    /**\n     * Based on the currently active item it will go to the next position\n     */\n\n  }, {\n    key: \"nextSlide\",\n    value: function nextSlide() {\n      var activeItem = this._getActiveItem();\n\n      var nextItem = null; // check if last item\n\n      if (activeItem.id === this._items.length - 1) {\n        nextItem = this._items[0];\n      } else {\n        nextItem = this._items[activeItem.id + 1];\n      }\n\n      this.slideTo(nextItem.id);\n    }\n    /**\n     * Based on the currently active item it will go to the previous position\n     */\n\n  }, {\n    key: \"prevSlide\",\n    value: function prevSlide() {\n      var activeItem = this._getActiveItem();\n\n      var prevItem = null; // check if first item\n\n      if (activeItem.id === 0) {\n        prevItem = this._items[this._items.length - 1];\n      } else {\n        prevItem = this._items[activeItem.id - 1];\n      }\n\n      this.slideTo(prevItem.id);\n    }\n    /**\n     * This method applies the transform classes based on the left, middle, and right rotation carousel items\n     * @param {*} rotationItems \n     */\n\n  }, {\n    key: \"_rotate\",\n    value: function _rotate(rotationItems) {\n      // reset\n      this._items.map(function (item) {\n        item.el.classList.add('hidden');\n      }); // left item (previously active)\n\n\n      rotationItems.left.el.classList.remove('-translate-x-full', 'translate-x-full', 'translate-x-0', 'hidden');\n      rotationItems.left.el.classList.add('-translate-x-full'); // currently active item\n\n      rotationItems.middle.el.classList.remove('-translate-x-full', 'translate-x-full', 'translate-x-0', 'hidden');\n      rotationItems.middle.el.classList.add('translate-x-0'); // right item (upcoming active)\n\n      rotationItems.right.el.classList.remove('-translate-x-full', 'translate-x-full', 'translate-x-0', 'hidden');\n      rotationItems.right.el.classList.add('translate-x-full');\n    }\n    /**\n     * Set an interval to cycle through the carousel items\n     */\n\n  }, {\n    key: \"cycle\",\n    value: function cycle(intervalDuration) {\n      var _this = this;\n\n      if (intervalDuration) {\n        this._intervalDuration = intervalDuration;\n      }\n\n      this._interval = setInterval(function () {\n        _this.nextSlide();\n      }, this._intervalDuration);\n    }\n    /**\n     * Clears the cycling interval\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      clearInterval(this._interval);\n    }\n    /**\n     * Get the currently active item\n     */\n\n  }, {\n    key: \"_getActiveItem\",\n    value: function _getActiveItem() {\n      return this._items.filter(function (item) {\n        return item.active;\n      })[0];\n    }\n    /**\n     * Set the currently active item and data attribute\n     * @param {*} id \n     */\n\n  }, {\n    key: \"_setActiveItem\",\n    value: function _setActiveItem(id) {\n      this._items.map(function (item) {\n        item.active = false;\n        item.el.setAttribute('data-carousel-item', '');\n\n        if (item.id === id) {\n          item.active = true;\n          item.el.setAttribute('data-carousel-item', 'active');\n        }\n      }); // update the indicators if available\n\n\n      this._indicators.map(function (indicator) {\n        indicator.el.setAttribute('aria-current', 'false');\n        indicator.el.classList.remove('bg-white', 'dark:bg-gray-800');\n        indicator.el.classList.add('bg-white/50', 'dark:bg-gray-800/50');\n\n        if (indicator.id === id) {\n          indicator.el.classList.add('bg-white', 'dark:bg-gray-800');\n          indicator.el.classList.remove('bg-white/50', 'dark:bg-gray-800/50');\n          indicator.el.setAttribute('aria-current', 'true');\n        }\n      });\n    }\n  }]);\n\n  return Carousel;\n}();\n\n/***/ }),\n\n/***/ 540:\n/***/ (() => {\n\nvar toggleCollapse = function toggleCollapse(elementId) {\n  var show = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var collapseEl = document.getElementById(elementId);\n\n  if (show) {\n    collapseEl.classList.remove('hidden');\n  } else {\n    collapseEl.classList.add('hidden');\n  }\n};\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  // Toggle target elements using [data-collapse-toggle]\n  document.querySelectorAll('[data-collapse-toggle]').forEach(function (collapseToggleEl) {\n    var collapseId = collapseToggleEl.getAttribute('data-collapse-toggle');\n    collapseToggleEl.addEventListener('click', function () {\n      toggleCollapse(collapseId, document.getElementById(collapseId).classList.contains('hidden'));\n    });\n  });\n});\nwindow.toggleCollapse = toggleCollapse;\n\n/***/ }),\n\n/***/ 84:\n/***/ (() => {\n\nvar toggleModal = function toggleModal(modalId) {\n  var show = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var modalEl = document.getElementById(modalId);\n\n  if (show) {\n    modalEl.classList.add('flex');\n    modalEl.classList.remove('hidden');\n    modalEl.setAttribute('aria-modal', 'true');\n    modalEl.setAttribute('role', 'dialog');\n    modalEl.removeAttribute('aria-hidden'); // create backdrop element\n\n    var backdropEl = document.createElement('div');\n    backdropEl.setAttribute('modal-backdrop', '');\n    backdropEl.classList.add('bg-gray-900', 'bg-opacity-50', 'dark:bg-opacity-80', 'fixed', 'inset-0', 'z-40');\n    document.querySelector('body').append(backdropEl);\n  } else {\n    modalEl.classList.add('hidden');\n    modalEl.classList.remove('flex');\n    modalEl.setAttribute('aria-hidden', 'true');\n    modalEl.removeAttribute('aria-modal');\n    modalEl.removeAttribute('role');\n    document.querySelector('[modal-backdrop]').remove();\n  }\n};\n\nwindow.toggleModal = toggleModal;\ndocument.addEventListener('DOMContentLoaded', function () {\n  document.querySelectorAll('[data-modal-toggle]').forEach(function (modalToggleEl) {\n    var modalId = modalToggleEl.getAttribute('data-modal-toggle');\n    var modalEl = document.getElementById(modalId);\n\n    if (modalEl) {\n      if (!modalEl.hasAttribute('aria-hidden') && !modalEl.hasAttribute('aria-modal')) {\n        modalEl.setAttribute('aria-hidden', 'true');\n      }\n\n      modalToggleEl.addEventListener('click', function () {\n        toggleModal(modalId, modalEl.hasAttribute('aria-hidden', 'true'));\n      });\n    }\n  });\n});\n\n/***/ }),\n\n/***/ 97:\n/***/ (() => {\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  document.querySelectorAll('[data-tabs-toggle]').forEach(function (tabsToggleEl) {\n    var tabsToggleElementsId = tabsToggleEl.getAttribute('id');\n    var tabsToggleElements = document.querySelectorAll('#' + tabsToggleElementsId + ' [role=\"tab\"]');\n    var activeTabToggleEl = null;\n    var activeTabContentEl = null;\n    tabsToggleElements.forEach(function (tabToggleEl) {\n      tabToggleEl.addEventListener('click', function (event) {\n        var tabToggleEl = event.target;\n        var tabTargetSelector = tabToggleEl.getAttribute('data-tabs-target');\n        var tabContentEl = document.querySelector(tabTargetSelector); // don't do anything if it's already active\n\n        if (tabToggleEl !== activeTabToggleEl) {\n          // find currently active tab toggle and content if not set\n          if (!activeTabToggleEl && !activeTabContentEl) {\n            activeTabToggleEl = document.querySelector('#' + tabsToggleElementsId + ' [aria-selected=\"true\"]');\n            activeTabContentEl = document.querySelector(activeTabToggleEl.getAttribute('data-tabs-target'));\n          } // show and activate tab\n\n\n          tabToggleEl.classList.add('active');\n          tabToggleEl.setAttribute('aria-selected', true);\n          tabContentEl.classList.remove('hidden'); // hide and deactive currently active tab toggle and content\n\n          activeTabToggleEl.setAttribute('aria-selected', false);\n          activeTabToggleEl.classList.remove('active');\n          activeTabContentEl.classList.add('hidden'); // set currently active toggle and content tabs\n\n          activeTabToggleEl = tabToggleEl;\n          activeTabContentEl = tabContentEl;\n        }\n      });\n    });\n  });\n});\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_16998__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_16998__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be in strict mode.\n(() => {\n\"use strict\";\n\n// EXTERNAL MODULE: ./src/components/accordion.js\nvar accordion = __nested_webpack_require_16998__(366);\n// EXTERNAL MODULE: ./src/components/collapse.js\nvar collapse = __nested_webpack_require_16998__(540);\n// EXTERNAL MODULE: ./src/components/carousel.js\nvar carousel = __nested_webpack_require_16998__(791);\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (node.toString() !== '[object Window]') {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\n\n\nfunction isElement(node) {\n  var OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\n\nfunction isHTMLElement(node) {\n  var OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\n\nfunction isShadowRoot(node) {\n  // IE 11 has no ShadowRoot\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  var OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\n\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/math.js\nvar math_max = Math.max;\nvar math_min = Math.min;\nvar round = Math.round;\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\n\n\nfunction getBoundingClientRect(element, includeScale) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  var rect = element.getBoundingClientRect();\n  var scaleX = 1;\n  var scaleY = 1;\n\n  if (isHTMLElement(element) && includeScale) {\n    var offsetHeight = element.offsetHeight;\n    var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale\n    // Fallback to 1 in case both values are `0`\n\n    if (offsetWidth > 0) {\n      scaleX = round(rect.width) / offsetWidth || 1;\n    }\n\n    if (offsetHeight > 0) {\n      scaleY = round(rect.height) / offsetHeight || 1;\n    }\n  }\n\n  return {\n    width: rect.width / scaleX,\n    height: rect.height / scaleY,\n    top: rect.top / scaleY,\n    right: rect.right / scaleX,\n    bottom: rect.bottom / scaleY,\n    left: rect.left / scaleX,\n    x: rect.left / scaleX,\n    y: rect.top / scaleY\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js\n\nfunction getWindowScroll(node) {\n  var win = getWindow(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js\nfunction getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js\n\n\n\n\nfunction getNodeScroll(node) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\nfunction getNodeName(element) {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\n\nfunction getDocumentElement(element) {\n  // $FlowFixMe[incompatible-return]: assume body is always available\n  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]\n  element.document) || window.document).documentElement;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js\n\n\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // Popper 1 is broken in this case and never had a bug report so let's assume\n  // it's not an issue. I don't think anyone ever specifies width on <html>\n  // anyway.\n  // Browsers where the left scrollbar doesn't cause an issue report `0` for\n  // this (e.g. Edge 2019, IE11, Safari)\n  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\n\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js\n\nfunction isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  var _getComputedStyle = getComputedStyle(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js\n\n\n\n\n\n\n\n\n\nfunction isElementScaled(element) {\n  var rect = element.getBoundingClientRect();\n  var scaleX = round(rect.width) / element.offsetWidth || 1;\n  var scaleY = round(rect.height) / element.offsetHeight || 1;\n  return scaleX !== 1 || scaleY !== 1;\n} // Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\n\n\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n\n  var isOffsetParentAnElement = isHTMLElement(offsetParent);\n  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n  var documentElement = getDocumentElement(offsetParent);\n  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\n    isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      offsets = getBoundingClientRect(offsetParent, true);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js\n // Returns the layout rect of an element relative to its offsetParent. Layout\n// means it doesn't take into account transforms.\n\nfunction getLayoutRect(element) {\n  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n  // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n  var width = element.offsetWidth;\n  var height = element.offsetHeight;\n\n  if (Math.abs(clientRect.width - width) <= 1) {\n    width = clientRect.width;\n  }\n\n  if (Math.abs(clientRect.height - height) <= 1) {\n    height = clientRect.height;\n  }\n\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width: width,\n    height: height\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\n\n\n\nfunction getParentNode(element) {\n  if (getNodeName(element) === 'html') {\n    return element;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || ( // DOM Element detected\n    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    getDocumentElement(element) // fallback\n\n  );\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js\n\n\n\n\nfunction getScrollParent(node) {\n  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node) && isScrollParent(node)) {\n    return node;\n  }\n\n  return getScrollParent(getParentNode(node));\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js\n\n\n\n\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we'll need to re-calculate the\nreference element's position.\n*/\n\nfunction listScrollParents(element, list) {\n  var _element$ownerDocumen;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  var scrollParent = getScrollParent(element);\n  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n  var win = getWindow(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n  updatedList.concat(listScrollParents(getParentNode(target)));\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js\n\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\n\n\n\n\n\n\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n  getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\n\n\nfunction getContainingBlock(element) {\n  var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;\n  var isIE = navigator.userAgent.indexOf('Trident') !== -1;\n\n  if (isIE && isHTMLElement(element)) {\n    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n    var elementCss = getComputedStyle(element);\n\n    if (elementCss.position === 'fixed') {\n      return null;\n    }\n  }\n\n  var currentNode = getParentNode(element);\n\n  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  var window = getWindow(element);\n  var offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/enums.js\nvar enums_top = 'top';\nvar bottom = 'bottom';\nvar right = 'right';\nvar left = 'left';\nvar auto = 'auto';\nvar basePlacements = [enums_top, bottom, right, left];\nvar start = 'start';\nvar end = 'end';\nvar clippingParents = 'clippingParents';\nvar viewport = 'viewport';\nvar popper = 'popper';\nvar reference = 'reference';\nvar variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n  return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nvar enums_placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n  return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n}, []); // modifiers that need to read the DOM\n\nvar beforeRead = 'beforeRead';\nvar read = 'read';\nvar afterRead = 'afterRead'; // pure-logic modifiers\n\nvar beforeMain = 'beforeMain';\nvar main = 'main';\nvar afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\nvar beforeWrite = 'beforeWrite';\nvar write = 'write';\nvar afterWrite = 'afterWrite';\nvar modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/orderModifiers.js\n // source: https://stackoverflow.com/questions/49875255\n\nfunction order(modifiers) {\n  var map = new Map();\n  var visited = new Set();\n  var result = [];\n  modifiers.forEach(function (modifier) {\n    map.set(modifier.name, modifier);\n  }); // On visiting object, check for its dependencies and visit them recursively\n\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function (dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n\n  modifiers.forEach(function (modifier) {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n  return result;\n}\n\nfunction orderModifiers(modifiers) {\n  // order based on dependencies\n  var orderedModifiers = order(modifiers); // order based on phase\n\n  return modifierPhases.reduce(function (acc, phase) {\n    return acc.concat(orderedModifiers.filter(function (modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/debounce.js\nfunction debounce(fn) {\n  var pending;\n  return function () {\n    if (!pending) {\n      pending = new Promise(function (resolve) {\n        Promise.resolve().then(function () {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/mergeByName.js\nfunction mergeByName(modifiers) {\n  var merged = modifiers.reduce(function (merged, current) {\n    var existing = merged[current.name];\n    merged[current.name] = existing ? Object.assign({}, existing, current, {\n      options: Object.assign({}, existing.options, current.options),\n      data: Object.assign({}, existing.data, current.data)\n    }) : current;\n    return merged;\n  }, {}); // IE11 does not support Object.values\n\n  return Object.keys(merged).map(function (key) {\n    return merged[key];\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/createPopper.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';\nvar INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nfunction popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n          popper: listScrollParents(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        }); // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n\n        if (false) { var _getComputedStyle, marginTop, marginRight, marginBottom, marginLeft, flipModifier, modifiers; }\n\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update  it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          if (false) {}\n\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        var __debug_loops__ = 0;\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (false) {}\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update  it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      if (false) {}\n\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref3) {\n        var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\nvar createPopper = /*#__PURE__*/(/* unused pure expression or super */ null && (0)); // eslint-disable-next-line import/no-unused-modules\n\n\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/eventListeners.js\n // eslint-disable-next-line import/no-unused-modules\n\nvar passive = {\n  passive: true\n};\n\nfunction effect(_ref) {\n  var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n  var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n  var window = getWindow(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n  if (scroll) {\n    scrollParents.forEach(function (scrollParent) {\n      scrollParent.addEventListener('scroll', instance.update, passive);\n    });\n  }\n\n  if (resize) {\n    window.addEventListener('resize', instance.update, passive);\n  }\n\n  return function () {\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.removeEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.removeEventListener('resize', instance.update, passive);\n    }\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const eventListeners = ({\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: function fn() {},\n  effect: effect,\n  data: {}\n});\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\n\nfunction getBasePlacement(placement) {\n  return placement.split('-')[0];\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getVariation.js\nfunction getVariation(placement) {\n  return placement.split('-')[1];\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/computeOffsets.js\n\n\n\n\nfunction computeOffsets(_ref) {\n  var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n  var basePlacement = placement ? getBasePlacement(placement) : null;\n  var variation = placement ? getVariation(placement) : null;\n  var commonX = reference.x + reference.width / 2 - element.width / 2;\n  var commonY = reference.y + reference.height / 2 - element.height / 2;\n  var offsets;\n\n  switch (basePlacement) {\n    case enums_top:\n      offsets = {\n        x: commonX,\n        y: reference.y - element.height\n      };\n      break;\n\n    case bottom:\n      offsets = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case right:\n      offsets = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case left:\n      offsets = {\n        x: reference.x - element.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n\n  if (mainAxis != null) {\n    var len = mainAxis === 'y' ? 'height' : 'width';\n\n    switch (variation) {\n      case start:\n        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n        break;\n\n      case end:\n        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n        break;\n\n      default:\n    }\n  }\n\n  return offsets;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js\n\n\nfunction popperOffsets(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = computeOffsets({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: 'absolute',\n    placement: state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_popperOffsets = ({\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets,\n  data: {}\n});\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/computeStyles.js\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nvar unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n\nfunction roundOffsetsByDPR(_ref) {\n  var x = _ref.x,\n      y = _ref.y;\n  var win = window;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: round(x * dpr) / dpr || 0,\n    y: round(y * dpr) / dpr || 0\n  };\n}\n\nfunction mapToStyles(_ref2) {\n  var _Object$assign2;\n\n  var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      variation = _ref2.variation,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive,\n      roundOffsets = _ref2.roundOffsets,\n      isFixed = _ref2.isFixed;\n\n  var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === 'function' ? roundOffsets(offsets) : offsets,\n      _ref3$x = _ref3.x,\n      x = _ref3$x === void 0 ? 0 : _ref3$x,\n      _ref3$y = _ref3.y,\n      y = _ref3$y === void 0 ? 0 : _ref3$y;\n\n  var hasX = offsets.hasOwnProperty('x');\n  var hasY = offsets.hasOwnProperty('y');\n  var sideX = left;\n  var sideY = enums_top;\n  var win = window;\n\n  if (adaptive) {\n    var offsetParent = getOffsetParent(popper);\n    var heightProp = 'clientHeight';\n    var widthProp = 'clientWidth';\n\n    if (offsetParent === getWindow(popper)) {\n      offsetParent = getDocumentElement(popper);\n\n      if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {\n        heightProp = 'scrollHeight';\n        widthProp = 'scrollWidth';\n      }\n    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n\n    offsetParent = offsetParent;\n\n    if (placement === enums_top || (placement === left || placement === right) && variation === end) {\n      sideY = bottom;\n      var offsetY = isFixed && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]\n      offsetParent[heightProp];\n      y -= offsetY - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === left || (placement === enums_top || placement === bottom) && variation === end) {\n      sideX = right;\n      var offsetX = isFixed && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]\n      offsetParent[widthProp];\n      x -= offsetX - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  var commonStyles = Object.assign({\n    position: position\n  }, adaptive && unsetSides);\n\n  if (gpuAcceleration) {\n    var _Object$assign;\n\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n}\n\nfunction computeStyles(_ref4) {\n  var state = _ref4.state,\n      options = _ref4.options;\n  var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n      _options$roundOffsets = options.roundOffsets,\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n\n  if (false) { var transitionProperty; }\n\n  var commonStyles = {\n    placement: getBasePlacement(state.placement),\n    variation: getVariation(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration: gpuAcceleration,\n    isFixed: state.options.strategy === 'fixed'\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive: adaptive,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-placement': state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_computeStyles = ({\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n});\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\n\n // This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function (name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element = state.elements[name]; // arrow is optional + virtual elements\n\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    } // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe[cannot-write]\n\n\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(function (name) {\n      var value = attributes[name];\n\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\n\nfunction applyStyles_effect(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: '0',\n      top: '0',\n      margin: '0'\n    },\n    arrow: {\n      position: 'absolute'\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n  state.styles = initialStyles;\n\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n\n  return function () {\n    Object.keys(state.elements).forEach(function (name) {\n      var element = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n      var style = styleProperties.reduce(function (style, property) {\n        style[property] = '';\n        return style;\n      }, {}); // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      }\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (attribute) {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_applyStyles = ({\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect: applyStyles_effect,\n  requires: ['computeStyles']\n});\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/offset.js\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction distanceAndSkiddingToXY(placement, rects, offset) {\n  var basePlacement = getBasePlacement(placement);\n  var invertDistance = [left, enums_top].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n    placement: placement\n  })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [left, right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\n\nfunction offset(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = enums_placements.reduce(function (acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_offset = ({\n  name: 'offset',\n  enabled: true,\n  phase: 'main',\n  requires: ['popperOffsets'],\n  fn: offset\n});\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js\nvar hash = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js\nvar getOppositeVariationPlacement_hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function (matched) {\n    return getOppositeVariationPlacement_hash[matched];\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js\n\n\n\nfunction getViewportRect(element) {\n  var win = getWindow(element);\n  var html = getDocumentElement(element);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x = 0;\n  var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper\n  // can be obscured underneath it.\n  // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even\n  // if it isn't open, so if this isn't available, the popper will be detected\n  // to overflow the bottom of the screen too early.\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)\n    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding\n    // errors due to floating point numbers, so we need to check precision.\n    // Safari returns a number <= 0, usually < -1 when pinch-zoomed\n    // Feature detection fails in mobile emulation mode in Chrome.\n    // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <\n    // 0.001\n    // Fallback here: \"Not Safari\" userAgent\n\n    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x + getWindowScrollBarX(element),\n    y: y\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js\n\n\n\n\n // Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  var html = getDocumentElement(element);\n  var winScroll = getWindowScroll(element);\n  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  var width = math_max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  var height = math_max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n  var y = -winScroll.scrollTop;\n\n  if (getComputedStyle(body || html).direction === 'rtl') {\n    x += math_max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/contains.js\n\nfunction contains(parent, child) {\n  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n      var next = child;\n\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n\n  return false;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js\nfunction rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getInnerBoundingClientRect(element) {\n  var rect = getBoundingClientRect(element);\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\n\nfunction getClientRectFromMixedType(element, clippingParent) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  var clippingParents = listScrollParents(getParentNode(element));\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(function (clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body' && (canEscapeClipping ? getComputedStyle(clippingParent).position !== 'static' : true);\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nfunction getClippingRect(element, boundary, rootBoundary) {\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent);\n    accRect.top = math_max(rect.top, accRect.top);\n    accRect.right = math_min(rect.right, accRect.right);\n    accRect.bottom = math_min(rect.bottom, accRect.bottom);\n    accRect.left = math_max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js\n\nfunction mergePaddingObject(paddingObject) {\n  return Object.assign({}, getFreshSideObject(), paddingObject);\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js\nfunction expandToHashMap(value, keys) {\n  return keys.reduce(function (hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/detectOverflow.js\n\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === popper ? reference : popper;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n  var referenceClientRect = getBoundingClientRect(state.elements.reference);\n  var popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement: placement\n  });\n  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === popper && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [enums_top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js\n\n\n\n\nfunction computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? enums_placements : _options$allowedAutoP;\n  var variation = getVariation(placement);\n  var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n    return getVariation(placement) === variation;\n  }) : basePlacements;\n  var allowedPlacements = placements.filter(function (placement) {\n    return allowedAutoPlacements.indexOf(placement) >= 0;\n  });\n\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements;\n\n    if (false) {}\n  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n\n  var overflows = allowedPlacements.reduce(function (acc, placement) {\n    acc[placement] = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding\n    })[getBasePlacement(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function (a, b) {\n    return overflows[a] - overflows[b];\n  });\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/flip.js\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\n\nfunction flip(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = getBasePlacement(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n\n    var _basePlacement = getBasePlacement(placement);\n\n    var isStartVariation = getVariation(placement) === start;\n    var isVertical = [enums_top, bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? 'width' : 'height';\n    var overflow = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : enums_top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n\n    var altVariationSide = getOppositePlacement(mainVariationSide);\n    var checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases  research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n\n      if (_ret === \"break\") break;\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_flip = ({\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n});\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getAltAxis.js\nfunction getAltAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/within.js\n\nfunction within(min, value, max) {\n  return math_max(min, math_min(value, max));\n}\nfunction withinMaxClamp(min, value, max) {\n  var v = within(min, value, max);\n  return v > max ? max : v;\n}\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js\n\n\n\n\n\n\n\n\n\n\n\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n    mainAxis: tetherOffsetValue,\n    altAxis: tetherOffsetValue\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, tetherOffsetValue);\n  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var _offsetModifierState$;\n\n    var mainSide = mainAxis === 'y' ? enums_top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = offset + overflow[mainSide];\n    var max = offset - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = offset + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? math_min(min, tetherMin) : min, offset, tether ? math_max(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _offsetModifierState$2;\n\n    var _mainSide = mainAxis === 'x' ? enums_top : left;\n\n    var _altSide = mainAxis === 'x' ? bottom : right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _len = altAxis === 'y' ? 'height' : 'width';\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var isOriginSide = [enums_top, left].indexOf(basePlacement) !== -1;\n\n    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n\n    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n\n    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n\n    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_preventOverflow = ({\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n});\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/arrow.js\n\n\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nvar toPaddingObject = function toPaddingObject(padding, state) {\n  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : padding;\n  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n};\n\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n\n  var state = _ref.state,\n      name = _ref.name,\n      options = _ref.options;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var basePlacement = getBasePlacement(state.placement);\n  var axis = getMainAxisFromPlacement(basePlacement);\n  var isVertical = [left, right].indexOf(basePlacement) >= 0;\n  var len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  var paddingObject = toPaddingObject(options.padding, state);\n  var arrowRect = getLayoutRect(arrowElement);\n  var minProp = axis === 'y' ? enums_top : left;\n  var maxProp = axis === 'y' ? bottom : right;\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = getOffsetParent(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n\n  var min = paddingObject[minProp];\n  var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\n\nfunction arrow_effect(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options;\n  var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n\n  if (arrowElement == null) {\n    return;\n  } // CSS selector\n\n\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (false) {}\n\n  if (!contains(state.elements.popper, arrowElement)) {\n    if (false) {}\n\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_arrow = ({\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect: arrow_effect,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n});\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/hide.js\n\n\n\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return [enums_top, right, bottom, left].some(function (side) {\n    return overflow[side] >= 0;\n  });\n}\n\nfunction hide(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = detectOverflow(state, {\n    elementContext: 'reference'\n  });\n  var popperAltOverflow = detectOverflow(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets: referenceClippingOffsets,\n    popperEscapeOffsets: popperEscapeOffsets,\n    isReferenceHidden: isReferenceHidden,\n    hasPopperEscaped: hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-reference-hidden': isReferenceHidden,\n    'data-popper-escaped': hasPopperEscaped\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_hide = ({\n  name: 'hide',\n  enabled: true,\n  phase: 'main',\n  requiresIfExists: ['preventOverflow'],\n  fn: hide\n});\n;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/popper.js\n\n\n\n\n\n\n\n\n\n\nvar defaultModifiers = [eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles, modifiers_offset, modifiers_flip, modifiers_preventOverflow, modifiers_arrow, modifiers_hide];\nvar popper_createPopper = /*#__PURE__*/popperGenerator({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n\n;// CONCATENATED MODULE: ./src/components/dropdown.js\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  // Toggle dropdown elements using [data-dropdown-toggle]\n  document.querySelectorAll('[data-dropdown-toggle]').forEach(function (dropdownToggleEl) {\n    var dropdownMenuId = dropdownToggleEl.getAttribute('data-dropdown-toggle');\n    var dropdownMenuEl = document.getElementById(dropdownMenuId); // options\n\n    var placement = dropdownToggleEl.getAttribute('data-dropdown-placement');\n    dropdownToggleEl.addEventListener('click', function (event) {\n      var element = event.target;\n\n      while (element.nodeName !== \"BUTTON\") {\n        element = element.parentNode;\n      }\n\n      popper_createPopper(element, dropdownMenuEl, {\n        placement: placement ? placement : 'bottom-start',\n        modifiers: [{\n          name: 'offset',\n          options: {\n            offset: [0, 10]\n          }\n        }]\n      }); // toggle when click on the button\n\n      dropdownMenuEl.classList.toggle('hidden');\n      dropdownMenuEl.classList.toggle('block');\n\n      function handleDropdownOutsideClick(event) {\n        var targetElement = event.target; // clicked element\n\n        if (targetElement !== dropdownMenuEl && targetElement !== dropdownToggleEl && !dropdownToggleEl.contains(targetElement)) {\n          dropdownMenuEl.classList.add('hidden');\n          dropdownMenuEl.classList.remove('block');\n          document.body.removeEventListener('click', handleDropdownOutsideClick, true);\n        }\n      } // hide popper when clicking outside the element\n\n\n      document.body.addEventListener('click', handleDropdownOutsideClick, true);\n    });\n  });\n});\n// EXTERNAL MODULE: ./src/components/tabs.js\nvar tabs = __nested_webpack_require_16998__(97);\n// EXTERNAL MODULE: ./src/components/modal.js\nvar modal = __nested_webpack_require_16998__(84);\n;// CONCATENATED MODULE: ./src/components/tooltip.js\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  // Toggle dropdown elements using [data-dropdown-toggle]\n  document.querySelectorAll('[data-tooltip-target]').forEach(function (tooltipToggleEl) {\n    var tooltipEl = document.getElementById(tooltipToggleEl.getAttribute('data-tooltip-target'));\n    var placement = tooltipToggleEl.getAttribute('data-tooltip-placement');\n    var trigger = tooltipToggleEl.getAttribute('data-tooltip-trigger');\n    var popperInstance = popper_createPopper(tooltipToggleEl, tooltipEl, {\n      placement: placement ? placement : 'top',\n      modifiers: [{\n        name: 'offset',\n        options: {\n          offset: [0, 8]\n        }\n      }]\n    });\n\n    function show() {\n      // Make the tooltip visible\n      tooltipEl.classList.remove('opacity-0');\n      tooltipEl.classList.add('opacity-100');\n      tooltipEl.classList.remove('invisible');\n      tooltipEl.classList.add('visible'); // Enable the event listeners\n\n      popperInstance.setOptions(function (options) {\n        return _objectSpread(_objectSpread({}, options), {}, {\n          modifiers: [].concat(_toConsumableArray(options.modifiers), [{\n            name: 'eventListeners',\n            enabled: true\n          }])\n        });\n      }); // Update its position\n\n      popperInstance.update();\n    }\n\n    function hide() {\n      // Hide the tooltip\n      tooltipEl.classList.remove('opacity-100');\n      tooltipEl.classList.add('opacity-0');\n      tooltipEl.classList.remove('visible');\n      tooltipEl.classList.add('invisible'); // Disable the event listeners\n\n      popperInstance.setOptions(function (options) {\n        return _objectSpread(_objectSpread({}, options), {}, {\n          modifiers: [].concat(_toConsumableArray(options.modifiers), [{\n            name: 'eventListeners',\n            enabled: false\n          }])\n        });\n      });\n    }\n\n    var showEvents = [];\n    var hideEvents = [];\n\n    switch (trigger) {\n      case 'hover':\n        showEvents = ['mouseenter', 'focus'];\n        hideEvents = ['mouseleave', 'blur'];\n        break;\n\n      case 'click':\n        showEvents = ['click', 'focus'];\n        hideEvents = ['focusout', 'blur'];\n        break;\n\n      default:\n        showEvents = ['mouseenter', 'focus'];\n        hideEvents = ['mouseleave', 'blur'];\n    }\n\n    showEvents.forEach(function (event) {\n      tooltipToggleEl.addEventListener(event, show);\n    });\n    hideEvents.forEach(function (event) {\n      tooltipToggleEl.addEventListener(event, hide);\n    });\n  });\n});\n;// CONCATENATED MODULE: ./src/flowbite.js\n // core components\n\n\n\n\n\n\n\n\n})();\n\n/******/ })()\n;\n//# sourceMappingURL=flowbite.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvZGlzdC9mbG93Yml0ZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBLE9BQU8sR0FBRzs7QUFFVjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRUFBa0U7O0FBRWxFO0FBQ0E7QUFDQSxXQUFXLEdBQUc7O0FBRWQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVTtBQUNWLGlFQUFpRTs7QUFFakU7QUFDQTtBQUNBLFdBQVcsR0FBRzs7QUFFZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBOztBQUVBLG1DQUFtQzs7QUFFbkMsZ0NBQWdDOztBQUVoQyxrREFBa0QsZ0JBQWdCLGdFQUFnRSx3REFBd0QsNkRBQTZELHNEQUFzRDs7QUFFN1Msa0NBQWtDOztBQUVsQyxtQ0FBbUM7O0FBRW5DLHVDQUF1Qyx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxvQkFBb0I7O0FBRXpLLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RDs7QUFFbE07QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7O0FBVUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FBUUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7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Q0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxRQUFRO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQWFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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MUM7QUFDQSw2Q0FBNkMsY0FBYztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU8sR0FBRzs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNELENBQUM7QUFDRDs7Ozs7Ozs7O0FBU0EsQ0FBQzs7QUFFRCxVQUFVO0FBQ1Y7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9kaXN0L2Zsb3diaXRlLmpzPzM4ODciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDM2Njpcbi8qKiovICgoKSA9PiB7XG5cbnZhciBoaWRlQWxsT3RoZXJBY2NvcmRpb25IZWFkZXJFbGVtZW50cyA9IGZ1bmN0aW9uIGhpZGVBbGxPdGhlckFjY29yZGlvbkhlYWRlckVsZW1lbnRzKGFjY29yZGlvbkhlYWRlckVsZW1lbnRzLCBjdXJyZW50QWNjb3JkaW9uSGVhZGVyRWwsIGFjdGl2ZUNsYXNzZXNBcnJheSwgaW5hY3RpdmVDbGFzc2VzQXJyYXkpIHtcbiAgYWNjb3JkaW9uSGVhZGVyRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyRWwpIHtcbiAgICBpZiAoY3VycmVudEFjY29yZGlvbkhlYWRlckVsICE9PSBoZWFkZXJFbCkge1xuICAgICAgdmFyIGJvZHlFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaGVhZGVyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWFjY29yZGlvbi10YXJnZXQnKSk7XG4gICAgICBoZWFkZXJFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7IC8vIGFjdGl2ZSBjbGFzc2VzXG5cbiAgICAgIGFjdGl2ZUNsYXNzZXNBcnJheS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaGVhZGVyRWwuY2xhc3NMaXN0LnJlbW92ZShjKTtcbiAgICAgIH0pOyAvLyBpbmFjdGl2ZSBjbGFzc2VzXG5cbiAgICAgIGluYWN0aXZlQ2xhc3Nlc0FycmF5Lm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICBoZWFkZXJFbC5jbGFzc0xpc3QuYWRkKGMpO1xuICAgICAgfSk7XG4gICAgICBib2R5RWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG5cbiAgICAgIGlmIChoZWFkZXJFbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1hY2NvcmRpb24taWNvbl0nKSkge1xuICAgICAgICBoZWFkZXJFbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1hY2NvcmRpb24taWNvbl0nKS5jbGFzc0xpc3QucmVtb3ZlKCdyb3RhdGUtMTgwJyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciByb3RhdGVBY2NvcmRpb25JY29uID0gZnVuY3Rpb24gcm90YXRlQWNjb3JkaW9uSWNvbihhY2NvcmRpb25IZWFkZXJFbCkge1xuICBpZiAoYWNjb3JkaW9uSGVhZGVyRWwucXVlcnlTZWxlY3RvcignW2RhdGEtYWNjb3JkaW9uLWljb25dJykpIHtcbiAgICBhY2NvcmRpb25IZWFkZXJFbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1hY2NvcmRpb24taWNvbl0nKS5jbGFzc0xpc3QudG9nZ2xlKCdyb3RhdGUtMTgwJyk7XG4gIH1cbn07XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWFjY29yZGlvbl0nKS5mb3JFYWNoKGZ1bmN0aW9uIChhY2NvcmRpb25FbCkge1xuICAgIHZhciBhY2NvcmRpb25JZCA9IGFjY29yZGlvbkVsLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICB2YXIgY29sbGFwc2VBY2NvcmRpb24gPSBhY2NvcmRpb25FbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYWNjb3JkaW9uJyk7XG4gICAgdmFyIGFjY29yZGlvbkhlYWRlckVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnIycgKyBhY2NvcmRpb25JZCArICcgW2RhdGEtYWNjb3JkaW9uLXRhcmdldF0nKTtcbiAgICB2YXIgYWN0aXZlQ2xhc3NlcyA9IGFjY29yZGlvbkVsLmdldEF0dHJpYnV0ZSgnZGF0YS1hY3RpdmUtY2xhc3NlcycpO1xuICAgIHZhciBpbmFjdGl2ZUNsYXNzZXMgPSBhY2NvcmRpb25FbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5hY3RpdmUtY2xhc3NlcycpO1xuICAgIHZhciBhY3RpdmVDbGFzc2VzQXJyYXkgPSBudWxsO1xuXG4gICAgaWYgKGFjdGl2ZUNsYXNzZXMgJiYgYWN0aXZlQ2xhc3NlcyAhPT0gJycpIHtcbiAgICAgIGFjdGl2ZUNsYXNzZXNBcnJheSA9IGFjdGl2ZUNsYXNzZXMuc3BsaXQoXCIgXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmYWxsYmFjayBjbGFzc2VzIGlmIG9wdGlvbiBub3Qgc2V0XG4gICAgICBhY3RpdmVDbGFzc2VzQXJyYXkgPSBbJ2JnLWdyYXktMTAwJywgJ2Rhcms6YmctZ3JheS04MDAnLCAndGV4dC1ncmF5LTkwMCcsICdkYXJrOnRleHQtd2hpdGUnXTtcbiAgICB9XG5cbiAgICB2YXIgaW5hY3RpdmVDbGFzc2VzQXJyYXkgPSBudWxsO1xuXG4gICAgaWYgKGluYWN0aXZlQ2xhc3NlcyAmJiBpbmFjdGl2ZUNsYXNzZXMgIT09ICcnKSB7XG4gICAgICBpbmFjdGl2ZUNsYXNzZXNBcnJheSA9IGluYWN0aXZlQ2xhc3Nlcy5zcGxpdChcIiBcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZhbGxiYWNrIGNsYXNzZXMgaWYgb3B0aW9uIG5vdCBzZXRcbiAgICAgIGluYWN0aXZlQ2xhc3Nlc0FycmF5ID0gWyd0ZXh0LWdyYXktNTAwJywgJ2Rhcms6dGV4dC1ncmF5LTQwMCddO1xuICAgIH1cblxuICAgIGFjY29yZGlvbkhlYWRlckVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGFjY29yZGlvbkhlYWRlckVsKSB7XG4gICAgICB2YXIgYWNjb3JkaW9uQm9keUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhY2NvcmRpb25IZWFkZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYWNjb3JkaW9uLXRhcmdldCcpKTtcbiAgICAgIGFjY29yZGlvbkhlYWRlckVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY29sbGFwc2VBY2NvcmRpb24gPT09ICdjb2xsYXBzZScpIHtcbiAgICAgICAgICBoaWRlQWxsT3RoZXJBY2NvcmRpb25IZWFkZXJFbGVtZW50cyhhY2NvcmRpb25IZWFkZXJFbGVtZW50cywgYWNjb3JkaW9uSGVhZGVyRWwsIGFjdGl2ZUNsYXNzZXNBcnJheSwgaW5hY3RpdmVDbGFzc2VzQXJyYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFjY29yZGlvbkhlYWRlckVsLmdldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBhY2NvcmRpb25IZWFkZXJFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7IC8vIGFjdGl2ZSBjbGFzc2VzXG5cbiAgICAgICAgICBhY3RpdmVDbGFzc2VzQXJyYXkubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBhY2NvcmRpb25IZWFkZXJFbC5jbGFzc0xpc3QucmVtb3ZlKGMpO1xuICAgICAgICAgIH0pOyAvLyBpbmFjdGl2ZSBjbGFzc2VzXG5cbiAgICAgICAgICBpbmFjdGl2ZUNsYXNzZXNBcnJheS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIGFjY29yZGlvbkhlYWRlckVsLmNsYXNzTGlzdC5hZGQoYyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWNjb3JkaW9uQm9keUVsLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICAgIHJvdGF0ZUFjY29yZGlvbkljb24oYWNjb3JkaW9uSGVhZGVyRWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjY29yZGlvbkhlYWRlckVsLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpOyAvLyBhY3RpdmUgY2xhc3Nlc1xuXG4gICAgICAgICAgYWN0aXZlQ2xhc3Nlc0FycmF5Lm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgYWNjb3JkaW9uSGVhZGVyRWwuY2xhc3NMaXN0LmFkZChjKTtcbiAgICAgICAgICB9KTsgLy8gaW5hY3RpdmUgY2xhc3Nlc1xuXG4gICAgICAgICAgaW5hY3RpdmVDbGFzc2VzQXJyYXkubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBhY2NvcmRpb25IZWFkZXJFbC5jbGFzc0xpc3QucmVtb3ZlKGMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFjY29yZGlvbkJvZHlFbC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICAgICAgICByb3RhdGVBY2NvcmRpb25JY29uKGFjY29yZGlvbkhlYWRlckVsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA3OTE6XG4vKioqLyAoKCkgPT4ge1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtY2Fyb3VzZWxdJykuZm9yRWFjaChmdW5jdGlvbiAoY2Fyb3VzZWxFbCkge1xuICAgIHZhciBpbnRlcnZhbCA9IGNhcm91c2VsRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWNhcm91c2VsLWludGVydmFsJyk7XG4gICAgdmFyIHNsaWRlID0gY2Fyb3VzZWxFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY2Fyb3VzZWwnKSA9PT0gJ3NsaWRlJyA/IHRydWUgOiBmYWxzZTtcbiAgICB2YXIgY2Fyb3VzZWwgPSBuZXcgQ2Fyb3VzZWwoY2Fyb3VzZWxFbC5nZXRBdHRyaWJ1dGUoJ2lkJyksIHtcbiAgICAgIGludGVydmFsOiBpbnRlcnZhbFxuICAgIH0pO1xuXG4gICAgaWYgKHNsaWRlKSB7XG4gICAgICBjYXJvdXNlbC5jeWNsZSgpO1xuICAgIH0gLy8gY2hlY2sgZm9yIGNvbnRyb2xzXG5cblxuICAgIHZhciBjYXJvdXNlbE5leHRFbCA9IGNhcm91c2VsRWwucXVlcnlTZWxlY3RvcignW2RhdGEtY2Fyb3VzZWwtbmV4dF0nKTtcbiAgICB2YXIgY2Fyb3VzZWxQcmV2RWwgPSBjYXJvdXNlbEVsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWNhcm91c2VsLXByZXZdJyk7XG5cbiAgICBpZiAoY2Fyb3VzZWxOZXh0RWwpIHtcbiAgICAgIGNhcm91c2VsTmV4dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjYXJvdXNlbC5uZXh0U2xpZGUoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjYXJvdXNlbFByZXZFbCkge1xuICAgICAgY2Fyb3VzZWxQcmV2RWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhcm91c2VsLnByZXZTbGlkZSgpO1xuICAgICAgfSk7XG4gICAgfSAvLyBjaGVjayBmb3IgaW5kaWNhdG9yc1xuXG5cbiAgICBjYXJvdXNlbEVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNhcm91c2VsLXNsaWRlLXRvXScpLmZvckVhY2goZnVuY3Rpb24gKHNsaWRlVG9FbCkge1xuICAgICAgc2xpZGVUb0VsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWQgPSBzbGlkZVRvRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWNhcm91c2VsLXNsaWRlLXRvJyk7XG4gICAgICAgIGNhcm91c2VsLnNsaWRlVG8oaWQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG52YXIgRGVmYXVsdCA9IHtcbiAgaW50ZXJ2YWw6IDMwMDBcbn07XG5cbnZhciBDYXJvdXNlbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENhcm91c2VsKGlkLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhcm91c2VsKTtcblxuICAgIHRoaXMuX2VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgIHRoaXMuX2l0ZW1zID0gX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuX2VsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNhcm91c2VsLWl0ZW1dJykpLmxlbmd0aCA/IF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9lbC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1jYXJvdXNlbC1pdGVtXScpKS5tYXAoZnVuY3Rpb24gKGVsLCBpZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBlbDogZWwsXG4gICAgICAgIGFjdGl2ZTogZWwuZ2V0QXR0cmlidXRlKFsnZGF0YS1jYXJvdXNlbC1pdGVtJ10pID09PSAnYWN0aXZlJyA/IHRydWUgOiBmYWxzZVxuICAgICAgfTtcbiAgICB9KSA6IFtdO1xuICAgIHRoaXMuX2luZGljYXRvcnMgPSBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5fZWwucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtY2Fyb3VzZWwtc2xpZGUtdG9dJykpLmxlbmd0aCA/IF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9lbC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1jYXJvdXNlbC1zbGlkZS10b10nKSkubWFwKGZ1bmN0aW9uIChlbCwgaWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgZWw6IGVsXG4gICAgICB9O1xuICAgIH0pIDogW107XG4gICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xuICAgIHRoaXMuX2ludGVydmFsRHVyYXRpb24gPSBvcHRpb25zLmludGVydmFsID8gb3B0aW9ucy5pbnRlcnZhbCA6IERlZmF1bHQuaW50ZXJ2YWw7XG5cbiAgICB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpc2UgY2Fyb3VzZWwgYW5kIGl0ZW1zIGJhc2VkIG9uIGFjdGl2ZSBvbmVcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQ2Fyb3VzZWwsIFt7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgdmFyIGFjdGl2ZUl0ZW0gPSB0aGlzLl9nZXRBY3RpdmVJdGVtKCk7XG5cbiAgICAgIHRoaXMuX2l0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpdGVtLmVsLmNsYXNzTGlzdC5hZGQoJ2Fic29sdXRlJywgJ2luc2V0LTAnLCAndHJhbnNpdGlvbi1hbGwnLCAndHJhbnNmb3JtJyk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zbGlkZVRvKGFjdGl2ZUl0ZW0uaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTbGlkZSB0byB0aGUgZWxlbWVudCBiYXNlZCBvbiBpZFxuICAgICAqIEBwYXJhbSB7Kn0gaWQgXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzbGlkZVRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNsaWRlVG8oaWQpIHtcbiAgICAgIHZhciBuZXh0SXRlbSA9IHRoaXMuX2l0ZW1zW2lkXTtcbiAgICAgIHZhciByb3RhdGlvbkl0ZW1zID0ge1xuICAgICAgICAnbGVmdCc6IG5leHRJdGVtLmlkID09PSAwID8gdGhpcy5faXRlbXNbdGhpcy5faXRlbXMubGVuZ3RoIC0gMV0gOiB0aGlzLl9pdGVtc1tuZXh0SXRlbS5pZCAtIDFdLFxuICAgICAgICAnbWlkZGxlJzogbmV4dEl0ZW0sXG4gICAgICAgICdyaWdodCc6IG5leHRJdGVtLmlkID09PSB0aGlzLl9pdGVtcy5sZW5ndGggLSAxID8gdGhpcy5faXRlbXNbMF0gOiB0aGlzLl9pdGVtc1tuZXh0SXRlbS5pZCArIDFdXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9yb3RhdGUocm90YXRpb25JdGVtcyk7XG5cbiAgICAgIHRoaXMuX3NldEFjdGl2ZUl0ZW0obmV4dEl0ZW0uaWQpO1xuXG4gICAgICBpZiAodGhpcy5faW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB0aGlzLmN5Y2xlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhc2VkIG9uIHRoZSBjdXJyZW50bHkgYWN0aXZlIGl0ZW0gaXQgd2lsbCBnbyB0byB0aGUgbmV4dCBwb3NpdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibmV4dFNsaWRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5leHRTbGlkZSgpIHtcbiAgICAgIHZhciBhY3RpdmVJdGVtID0gdGhpcy5fZ2V0QWN0aXZlSXRlbSgpO1xuXG4gICAgICB2YXIgbmV4dEl0ZW0gPSBudWxsOyAvLyBjaGVjayBpZiBsYXN0IGl0ZW1cblxuICAgICAgaWYgKGFjdGl2ZUl0ZW0uaWQgPT09IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgbmV4dEl0ZW0gPSB0aGlzLl9pdGVtc1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRJdGVtID0gdGhpcy5faXRlbXNbYWN0aXZlSXRlbS5pZCArIDFdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNsaWRlVG8obmV4dEl0ZW0uaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiB0aGUgY3VycmVudGx5IGFjdGl2ZSBpdGVtIGl0IHdpbGwgZ28gdG8gdGhlIHByZXZpb3VzIHBvc2l0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcmV2U2xpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJldlNsaWRlKCkge1xuICAgICAgdmFyIGFjdGl2ZUl0ZW0gPSB0aGlzLl9nZXRBY3RpdmVJdGVtKCk7XG5cbiAgICAgIHZhciBwcmV2SXRlbSA9IG51bGw7IC8vIGNoZWNrIGlmIGZpcnN0IGl0ZW1cblxuICAgICAgaWYgKGFjdGl2ZUl0ZW0uaWQgPT09IDApIHtcbiAgICAgICAgcHJldkl0ZW0gPSB0aGlzLl9pdGVtc1t0aGlzLl9pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZJdGVtID0gdGhpcy5faXRlbXNbYWN0aXZlSXRlbS5pZCAtIDFdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNsaWRlVG8ocHJldkl0ZW0uaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBhcHBsaWVzIHRoZSB0cmFuc2Zvcm0gY2xhc3NlcyBiYXNlZCBvbiB0aGUgbGVmdCwgbWlkZGxlLCBhbmQgcmlnaHQgcm90YXRpb24gY2Fyb3VzZWwgaXRlbXNcbiAgICAgKiBAcGFyYW0geyp9IHJvdGF0aW9uSXRlbXMgXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcm90YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yb3RhdGUocm90YXRpb25JdGVtcykge1xuICAgICAgLy8gcmVzZXRcbiAgICAgIHRoaXMuX2l0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpdGVtLmVsLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgfSk7IC8vIGxlZnQgaXRlbSAocHJldmlvdXNseSBhY3RpdmUpXG5cblxuICAgICAgcm90YXRpb25JdGVtcy5sZWZ0LmVsLmNsYXNzTGlzdC5yZW1vdmUoJy10cmFuc2xhdGUteC1mdWxsJywgJ3RyYW5zbGF0ZS14LWZ1bGwnLCAndHJhbnNsYXRlLXgtMCcsICdoaWRkZW4nKTtcbiAgICAgIHJvdGF0aW9uSXRlbXMubGVmdC5lbC5jbGFzc0xpc3QuYWRkKCctdHJhbnNsYXRlLXgtZnVsbCcpOyAvLyBjdXJyZW50bHkgYWN0aXZlIGl0ZW1cblxuICAgICAgcm90YXRpb25JdGVtcy5taWRkbGUuZWwuY2xhc3NMaXN0LnJlbW92ZSgnLXRyYW5zbGF0ZS14LWZ1bGwnLCAndHJhbnNsYXRlLXgtZnVsbCcsICd0cmFuc2xhdGUteC0wJywgJ2hpZGRlbicpO1xuICAgICAgcm90YXRpb25JdGVtcy5taWRkbGUuZWwuY2xhc3NMaXN0LmFkZCgndHJhbnNsYXRlLXgtMCcpOyAvLyByaWdodCBpdGVtICh1cGNvbWluZyBhY3RpdmUpXG5cbiAgICAgIHJvdGF0aW9uSXRlbXMucmlnaHQuZWwuY2xhc3NMaXN0LnJlbW92ZSgnLXRyYW5zbGF0ZS14LWZ1bGwnLCAndHJhbnNsYXRlLXgtZnVsbCcsICd0cmFuc2xhdGUteC0wJywgJ2hpZGRlbicpO1xuICAgICAgcm90YXRpb25JdGVtcy5yaWdodC5lbC5jbGFzc0xpc3QuYWRkKCd0cmFuc2xhdGUteC1mdWxsJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhbiBpbnRlcnZhbCB0byBjeWNsZSB0aHJvdWdoIHRoZSBjYXJvdXNlbCBpdGVtc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY3ljbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3ljbGUoaW50ZXJ2YWxEdXJhdGlvbikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKGludGVydmFsRHVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5faW50ZXJ2YWxEdXJhdGlvbiA9IGludGVydmFsRHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5uZXh0U2xpZGUoKTtcbiAgICAgIH0sIHRoaXMuX2ludGVydmFsRHVyYXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGN5Y2xpbmcgaW50ZXJ2YWxcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhdXNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudGx5IGFjdGl2ZSBpdGVtXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QWN0aXZlSXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QWN0aXZlSXRlbSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0uYWN0aXZlO1xuICAgICAgfSlbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3VycmVudGx5IGFjdGl2ZSBpdGVtIGFuZCBkYXRhIGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7Kn0gaWQgXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0QWN0aXZlSXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0QWN0aXZlSXRlbShpZCkge1xuICAgICAgdGhpcy5faXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGl0ZW0uYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGl0ZW0uZWwuc2V0QXR0cmlidXRlKCdkYXRhLWNhcm91c2VsLWl0ZW0nLCAnJyk7XG5cbiAgICAgICAgaWYgKGl0ZW0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgaXRlbS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgIGl0ZW0uZWwuc2V0QXR0cmlidXRlKCdkYXRhLWNhcm91c2VsLWl0ZW0nLCAnYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyB1cGRhdGUgdGhlIGluZGljYXRvcnMgaWYgYXZhaWxhYmxlXG5cblxuICAgICAgdGhpcy5faW5kaWNhdG9ycy5tYXAoZnVuY3Rpb24gKGluZGljYXRvcikge1xuICAgICAgICBpbmRpY2F0b3IuZWwuc2V0QXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnLCAnZmFsc2UnKTtcbiAgICAgICAgaW5kaWNhdG9yLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ2JnLXdoaXRlJywgJ2Rhcms6YmctZ3JheS04MDAnKTtcbiAgICAgICAgaW5kaWNhdG9yLmVsLmNsYXNzTGlzdC5hZGQoJ2JnLXdoaXRlLzUwJywgJ2Rhcms6YmctZ3JheS04MDAvNTAnKTtcblxuICAgICAgICBpZiAoaW5kaWNhdG9yLmlkID09PSBpZCkge1xuICAgICAgICAgIGluZGljYXRvci5lbC5jbGFzc0xpc3QuYWRkKCdiZy13aGl0ZScsICdkYXJrOmJnLWdyYXktODAwJyk7XG4gICAgICAgICAgaW5kaWNhdG9yLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ2JnLXdoaXRlLzUwJywgJ2Rhcms6YmctZ3JheS04MDAvNTAnKTtcbiAgICAgICAgICBpbmRpY2F0b3IuZWwuc2V0QXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnLCAndHJ1ZScpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2Fyb3VzZWw7XG59KCk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NDA6XG4vKioqLyAoKCkgPT4ge1xuXG52YXIgdG9nZ2xlQ29sbGFwc2UgPSBmdW5jdGlvbiB0b2dnbGVDb2xsYXBzZShlbGVtZW50SWQpIHtcbiAgdmFyIHNob3cgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIHZhciBjb2xsYXBzZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudElkKTtcblxuICBpZiAoc2hvdykge1xuICAgIGNvbGxhcHNlRWwuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gIH0gZWxzZSB7XG4gICAgY29sbGFwc2VFbC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgfVxufTtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgLy8gVG9nZ2xlIHRhcmdldCBlbGVtZW50cyB1c2luZyBbZGF0YS1jb2xsYXBzZS10b2dnbGVdXG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNvbGxhcHNlLXRvZ2dsZV0nKS5mb3JFYWNoKGZ1bmN0aW9uIChjb2xsYXBzZVRvZ2dsZUVsKSB7XG4gICAgdmFyIGNvbGxhcHNlSWQgPSBjb2xsYXBzZVRvZ2dsZUVsLmdldEF0dHJpYnV0ZSgnZGF0YS1jb2xsYXBzZS10b2dnbGUnKTtcbiAgICBjb2xsYXBzZVRvZ2dsZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgdG9nZ2xlQ29sbGFwc2UoY29sbGFwc2VJZCwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29sbGFwc2VJZCkuY2xhc3NMaXN0LmNvbnRhaW5zKCdoaWRkZW4nKSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG53aW5kb3cudG9nZ2xlQ29sbGFwc2UgPSB0b2dnbGVDb2xsYXBzZTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDg0OlxuLyoqKi8gKCgpID0+IHtcblxudmFyIHRvZ2dsZU1vZGFsID0gZnVuY3Rpb24gdG9nZ2xlTW9kYWwobW9kYWxJZCkge1xuICB2YXIgc2hvdyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgdmFyIG1vZGFsRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtb2RhbElkKTtcblxuICBpZiAoc2hvdykge1xuICAgIG1vZGFsRWwuY2xhc3NMaXN0LmFkZCgnZmxleCcpO1xuICAgIG1vZGFsRWwuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgbW9kYWxFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCAndHJ1ZScpO1xuICAgIG1vZGFsRWwuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RpYWxvZycpO1xuICAgIG1vZGFsRWwucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpOyAvLyBjcmVhdGUgYmFja2Ryb3AgZWxlbWVudFxuXG4gICAgdmFyIGJhY2tkcm9wRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBiYWNrZHJvcEVsLnNldEF0dHJpYnV0ZSgnbW9kYWwtYmFja2Ryb3AnLCAnJyk7XG4gICAgYmFja2Ryb3BFbC5jbGFzc0xpc3QuYWRkKCdiZy1ncmF5LTkwMCcsICdiZy1vcGFjaXR5LTUwJywgJ2Rhcms6Ymctb3BhY2l0eS04MCcsICdmaXhlZCcsICdpbnNldC0wJywgJ3otNDAnKTtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5JykuYXBwZW5kKGJhY2tkcm9wRWwpO1xuICB9IGVsc2Uge1xuICAgIG1vZGFsRWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgbW9kYWxFbC5jbGFzc0xpc3QucmVtb3ZlKCdmbGV4Jyk7XG4gICAgbW9kYWxFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICBtb2RhbEVsLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcpO1xuICAgIG1vZGFsRWwucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW21vZGFsLWJhY2tkcm9wXScpLnJlbW92ZSgpO1xuICB9XG59O1xuXG53aW5kb3cudG9nZ2xlTW9kYWwgPSB0b2dnbGVNb2RhbDtcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLW1vZGFsLXRvZ2dsZV0nKS5mb3JFYWNoKGZ1bmN0aW9uIChtb2RhbFRvZ2dsZUVsKSB7XG4gICAgdmFyIG1vZGFsSWQgPSBtb2RhbFRvZ2dsZUVsLmdldEF0dHJpYnV0ZSgnZGF0YS1tb2RhbC10b2dnbGUnKTtcbiAgICB2YXIgbW9kYWxFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1vZGFsSWQpO1xuXG4gICAgaWYgKG1vZGFsRWwpIHtcbiAgICAgIGlmICghbW9kYWxFbC5oYXNBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJykgJiYgIW1vZGFsRWwuaGFzQXR0cmlidXRlKCdhcmlhLW1vZGFsJykpIHtcbiAgICAgICAgbW9kYWxFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgIH1cblxuICAgICAgbW9kYWxUb2dnbGVFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdG9nZ2xlTW9kYWwobW9kYWxJZCwgbW9kYWxFbC5oYXNBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA5Nzpcbi8qKiovICgoKSA9PiB7XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXRhYnMtdG9nZ2xlXScpLmZvckVhY2goZnVuY3Rpb24gKHRhYnNUb2dnbGVFbCkge1xuICAgIHZhciB0YWJzVG9nZ2xlRWxlbWVudHNJZCA9IHRhYnNUb2dnbGVFbC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgdmFyIHRhYnNUb2dnbGVFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyMnICsgdGFic1RvZ2dsZUVsZW1lbnRzSWQgKyAnIFtyb2xlPVwidGFiXCJdJyk7XG4gICAgdmFyIGFjdGl2ZVRhYlRvZ2dsZUVsID0gbnVsbDtcbiAgICB2YXIgYWN0aXZlVGFiQ29udGVudEVsID0gbnVsbDtcbiAgICB0YWJzVG9nZ2xlRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFiVG9nZ2xlRWwpIHtcbiAgICAgIHRhYlRvZ2dsZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciB0YWJUb2dnbGVFbCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgdmFyIHRhYlRhcmdldFNlbGVjdG9yID0gdGFiVG9nZ2xlRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXRhYnMtdGFyZ2V0Jyk7XG4gICAgICAgIHZhciB0YWJDb250ZW50RWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhYlRhcmdldFNlbGVjdG9yKTsgLy8gZG9uJ3QgZG8gYW55dGhpbmcgaWYgaXQncyBhbHJlYWR5IGFjdGl2ZVxuXG4gICAgICAgIGlmICh0YWJUb2dnbGVFbCAhPT0gYWN0aXZlVGFiVG9nZ2xlRWwpIHtcbiAgICAgICAgICAvLyBmaW5kIGN1cnJlbnRseSBhY3RpdmUgdGFiIHRvZ2dsZSBhbmQgY29udGVudCBpZiBub3Qgc2V0XG4gICAgICAgICAgaWYgKCFhY3RpdmVUYWJUb2dnbGVFbCAmJiAhYWN0aXZlVGFiQ29udGVudEVsKSB7XG4gICAgICAgICAgICBhY3RpdmVUYWJUb2dnbGVFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgdGFic1RvZ2dsZUVsZW1lbnRzSWQgKyAnIFthcmlhLXNlbGVjdGVkPVwidHJ1ZVwiXScpO1xuICAgICAgICAgICAgYWN0aXZlVGFiQ29udGVudEVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhY3RpdmVUYWJUb2dnbGVFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFicy10YXJnZXQnKSk7XG4gICAgICAgICAgfSAvLyBzaG93IGFuZCBhY3RpdmF0ZSB0YWJcblxuXG4gICAgICAgICAgdGFiVG9nZ2xlRWwuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgdGFiVG9nZ2xlRWwuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSk7XG4gICAgICAgICAgdGFiQ29udGVudEVsLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpOyAvLyBoaWRlIGFuZCBkZWFjdGl2ZSBjdXJyZW50bHkgYWN0aXZlIHRhYiB0b2dnbGUgYW5kIGNvbnRlbnRcblxuICAgICAgICAgIGFjdGl2ZVRhYlRvZ2dsZUVsLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGZhbHNlKTtcbiAgICAgICAgICBhY3RpdmVUYWJUb2dnbGVFbC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgICBhY3RpdmVUYWJDb250ZW50RWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7IC8vIHNldCBjdXJyZW50bHkgYWN0aXZlIHRvZ2dsZSBhbmQgY29udGVudCB0YWJzXG5cbiAgICAgICAgICBhY3RpdmVUYWJUb2dnbGVFbCA9IHRhYlRvZ2dsZUVsO1xuICAgICAgICAgIGFjdGl2ZVRhYkNvbnRlbnRFbCA9IHRhYkNvbnRlbnRFbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IHt9O1xuLy8gVGhpcyBlbnRyeSBuZWVkIHRvIGJlIHdyYXBwZWQgaW4gYW4gSUlGRSBiZWNhdXNlIGl0IG5lZWQgdG8gYmUgaW4gc3RyaWN0IG1vZGUuXG4oKCkgPT4ge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9hY2NvcmRpb24uanNcbnZhciBhY2NvcmRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2Nik7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvY29sbGFwc2UuanNcbnZhciBjb2xsYXBzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTQwKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9jYXJvdXNlbC5qc1xudmFyIGNhcm91c2VsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OTEpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXG5mdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmIChub2RlLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1xuXG5cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkhUTUxFbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZSkge1xuICAvLyBJRSAxMSBoYXMgbm8gU2hhZG93Um9vdFxuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuU2hhZG93Um9vdDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qc1xudmFyIG1hdGhfbWF4ID0gTWF0aC5tYXg7XG52YXIgbWF0aF9taW4gPSBNYXRoLm1pbjtcbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcblxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlKSB7XG4gIGlmIChpbmNsdWRlU2NhbGUgPT09IHZvaWQgMCkge1xuICAgIGluY2x1ZGVTY2FsZSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gMTtcbiAgdmFyIHNjYWxlWSA9IDE7XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgJiYgaW5jbHVkZVNjYWxlKSB7XG4gICAgdmFyIG9mZnNldEhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIHZhciBvZmZzZXRXaWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7IC8vIERvIG5vdCBhdHRlbXB0IHRvIGRpdmlkZSBieSAwLCBvdGhlcndpc2Ugd2UgZ2V0IGBJbmZpbml0eWAgYXMgc2NhbGVcbiAgICAvLyBGYWxsYmFjayB0byAxIGluIGNhc2UgYm90aCB2YWx1ZXMgYXJlIGAwYFxuXG4gICAgaWYgKG9mZnNldFdpZHRoID4gMCkge1xuICAgICAgc2NhbGVYID0gcm91bmQocmVjdC53aWR0aCkgLyBvZmZzZXRXaWR0aCB8fCAxO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXRIZWlnaHQgPiAwKSB7XG4gICAgICBzY2FsZVkgPSByb3VuZChyZWN0LmhlaWdodCkgLyBvZmZzZXRIZWlnaHQgfHwgMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiByZWN0LndpZHRoIC8gc2NhbGVYLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHQgLyBzY2FsZVksXG4gICAgdG9wOiByZWN0LnRvcCAvIHNjYWxlWSxcbiAgICByaWdodDogcmVjdC5yaWdodCAvIHNjYWxlWCxcbiAgICBib3R0b206IHJlY3QuYm90dG9tIC8gc2NhbGVZLFxuICAgIGxlZnQ6IHJlY3QubGVmdCAvIHNjYWxlWCxcbiAgICB4OiByZWN0LmxlZnQgLyBzY2FsZVgsXG4gICAgeTogcmVjdC50b3AgLyBzY2FsZVlcbiAgfTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbC5qc1xuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KG5vZGUpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gIH07XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRIVE1MRWxlbWVudFNjcm9sbC5qc1xuZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRTY3JvbGwoZWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXG4gIH07XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzXG5cblxuXG5cbmZ1bmN0aW9uIGdldE5vZGVTY3JvbGwobm9kZSkge1xuICBpZiAobm9kZSA9PT0gZ2V0V2luZG93KG5vZGUpIHx8ICFpc0hUTUxFbGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRTY3JvbGwobm9kZSk7XG4gIH1cbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzXG5mdW5jdGlvbiBnZXROb2RlTmFtZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50ID8gKGVsZW1lbnQubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXG5cbmZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSB7XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgcmV0dXJuICgoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5vd25lckRvY3VtZW50IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gIGVsZW1lbnQuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1xuXG5cblxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSB7XG4gIC8vIElmIDxodG1sPiBoYXMgYSBDU1Mgd2lkdGggZ3JlYXRlciB0aGFuIHRoZSB2aWV3cG9ydCwgdGhlbiB0aGlzIHdpbGwgYmVcbiAgLy8gaW5jb3JyZWN0IGZvciBSVEwuXG4gIC8vIFBvcHBlciAxIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UgYW5kIG5ldmVyIGhhZCBhIGJ1ZyByZXBvcnQgc28gbGV0J3MgYXNzdW1lXG4gIC8vIGl0J3Mgbm90IGFuIGlzc3VlLiBJIGRvbid0IHRoaW5rIGFueW9uZSBldmVyIHNwZWNpZmllcyB3aWR0aCBvbiA8aHRtbD5cbiAgLy8gYW55d2F5LlxuICAvLyBCcm93c2VycyB3aGVyZSB0aGUgbGVmdCBzY3JvbGxiYXIgZG9lc24ndCBjYXVzZSBhbiBpc3N1ZSByZXBvcnQgYDBgIGZvclxuICAvLyB0aGlzIChlLmcuIEVkZ2UgMjAxOSwgSUUxMSwgU2FmYXJpKVxuICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGdldFdpbmRvd1Njcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0O1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1xuXG5mdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNTY3JvbGxQYXJlbnQuanNcblxuZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qc1xuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gaXNFbGVtZW50U2NhbGVkKGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gcm91bmQocmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDE7XG4gIHZhciBzY2FsZVkgPSByb3VuZChyZWN0LmhlaWdodCkgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxO1xuICByZXR1cm4gc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMTtcbn0gLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LlxuLy8gQ29tcG9zaXRlIG1lYW5zIGl0IHRha2VzIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zIGFzIHdlbGwgYXMgbGF5b3V0LlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudCwgaXNGaXhlZCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50SXNTY2FsZWQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgaXNFbGVtZW50U2NhbGVkKG9mZnNldFBhcmVudCk7XG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudElzU2NhbGVkKTtcbiAgdmFyIHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcbiAgICBpc1Njcm9sbFBhcmVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgb2Zmc2V0cyA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUpO1xuICAgICAgb2Zmc2V0cy54ICs9IG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ICs9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXG4gLy8gUmV0dXJucyB0aGUgbGF5b3V0IHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LiBMYXlvdXRcbi8vIG1lYW5zIGl0IGRvZXNuJ3QgdGFrZSBpbnRvIGFjY291bnQgdHJhbnNmb3Jtcy5cblxuZnVuY3Rpb24gZ2V0TGF5b3V0UmVjdChlbGVtZW50KSB7XG4gIHZhciBjbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpOyAvLyBVc2UgdGhlIGNsaWVudFJlY3Qgc2l6ZXMgaWYgaXQncyBub3QgYmVlbiB0cmFuc2Zvcm1lZC5cbiAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMjIzXG5cbiAgdmFyIHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LndpZHRoIC0gd2lkdGgpIDw9IDEpIHtcbiAgICB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC5oZWlnaHQgLSBoZWlnaHQpIDw9IDEpIHtcbiAgICBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogZWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgIHk6IGVsZW1lbnQub2Zmc2V0VG9wLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0UGFyZW50Tm9kZS5qc1xuXG5cblxuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChnZXROb2RlTmFtZShlbGVtZW50KSA9PT0gJ2h0bWwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gKC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIGVsZW1lbnQuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgZWxlbWVudC5wYXJlbnROb2RlIHx8ICggLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWRcbiAgICBpc1NoYWRvd1Jvb3QoZWxlbWVudCkgPyBlbGVtZW50Lmhvc3QgOiBudWxsKSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IEhUTUxFbGVtZW50IGlzIGEgTm9kZVxuICAgIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSAvLyBmYWxsYmFja1xuXG4gICk7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRTY3JvbGxQYXJlbnQuanNcblxuXG5cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KG5vZGUpIHtcbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUobm9kZSkpID49IDApIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qc1xuXG5cblxuXG4vKlxuZ2l2ZW4gYSBET00gZWxlbWVudCwgcmV0dXJuIHRoZSBsaXN0IG9mIGFsbCBzY3JvbGwgcGFyZW50cywgdXAgdGhlIGxpc3Qgb2YgYW5jZXNvcnNcbnVudGlsIHdlIGdldCB0byB0aGUgdG9wIHdpbmRvdyBvYmplY3QuIFRoaXMgbGlzdCBpcyB3aGF0IHdlIGF0dGFjaCBzY3JvbGwgbGlzdGVuZXJzXG50bywgYmVjYXVzZSBpZiBhbnkgb2YgdGhlc2UgcGFyZW50IGVsZW1lbnRzIHNjcm9sbCwgd2UnbGwgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlXG5yZWZlcmVuY2UgZWxlbWVudCdzIHBvc2l0aW9uLlxuKi9cblxuZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCwgbGlzdCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cblxuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpO1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50ID09PSAoKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5KTtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhzY3JvbGxQYXJlbnQpO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gW3dpbl0uY29uY2F0KHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNTY3JvbGxQYXJlbnQoc2Nyb2xsUGFyZW50KSA/IHNjcm9sbFBhcmVudCA6IFtdKSA6IHNjcm9sbFBhcmVudDtcbiAgdmFyIHVwZGF0ZWRMaXN0ID0gbGlzdC5jb25jYXQodGFyZ2V0KTtcbiAgcmV0dXJuIGlzQm9keSA/IHVwZGF0ZWRMaXN0IDogLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gIHVwZGF0ZWRMaXN0LmNvbmNhdChsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKHRhcmdldCkpKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzVGFibGVFbGVtZW50LmpzXG5cbmZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmRleE9mKGdldE5vZGVOYW1lKGVsZW1lbnQpKSA+PSAwO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy84MzdcbiAgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xufSAvLyBgLm9mZnNldFBhcmVudGAgcmVwb3J0cyBgbnVsbGAgZm9yIGZpeGVkIGVsZW1lbnRzLCB3aGlsZSBhYnNvbHV0ZSBlbGVtZW50c1xuLy8gcmV0dXJuIHRoZSBjb250YWluaW5nIGJsb2NrXG5cblxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgdmFyIGlzRmlyZWZveCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdmaXJlZm94JykgIT09IC0xO1xuICB2YXIgaXNJRSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudCcpICE9PSAtMTtcblxuICBpZiAoaXNJRSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgLy8gSW4gSUUgOSwgMTAgYW5kIDExIGZpeGVkIGVsZW1lbnRzIGNvbnRhaW5pbmcgYmxvY2sgaXMgYWx3YXlzIGVzdGFibGlzaGVkIGJ5IHRoZSB2aWV3cG9ydFxuICAgIHZhciBlbGVtZW50Q3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmIChlbGVtZW50Q3NzLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiBbJ2h0bWwnLCAnYm9keSddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoY3VycmVudE5vZGUpKSA8IDApIHtcbiAgICB2YXIgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7IC8vIFRoaXMgaXMgbm9uLWV4aGF1c3RpdmUgYnV0IGNvdmVycyB0aGUgbW9zdCBjb21tb24gQ1NTIHByb3BlcnRpZXMgdGhhdFxuICAgIC8vIGNyZWF0ZSBhIGNvbnRhaW5pbmcgYmxvY2suXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcblxuICAgIGlmIChjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgY3NzLmNvbnRhaW4gPT09ICdwYWludCcgfHwgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnXS5pbmRleE9mKGNzcy53aWxsQ2hhbmdlKSAhPT0gLTEgfHwgaXNGaXJlZm94ICYmIGNzcy53aWxsQ2hhbmdlID09PSAnZmlsdGVyJyB8fCBpc0ZpcmVmb3ggJiYgY3NzLmZpbHRlciAmJiBjc3MuZmlsdGVyICE9PSAnbm9uZScpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSAvLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXG4vLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuXG5cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuXG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgaWYgKG9mZnNldFBhcmVudCAmJiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2h0bWwnIHx8IGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdib2R5JyAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW5kb3c7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzXG52YXIgZW51bXNfdG9wID0gJ3RvcCc7XG52YXIgYm90dG9tID0gJ2JvdHRvbSc7XG52YXIgcmlnaHQgPSAncmlnaHQnO1xudmFyIGxlZnQgPSAnbGVmdCc7XG52YXIgYXV0byA9ICdhdXRvJztcbnZhciBiYXNlUGxhY2VtZW50cyA9IFtlbnVtc190b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xudmFyIHN0YXJ0ID0gJ3N0YXJ0JztcbnZhciBlbmQgPSAnZW5kJztcbnZhciBjbGlwcGluZ1BhcmVudHMgPSAnY2xpcHBpbmdQYXJlbnRzJztcbnZhciB2aWV3cG9ydCA9ICd2aWV3cG9ydCc7XG52YXIgcG9wcGVyID0gJ3BvcHBlcic7XG52YXIgcmVmZXJlbmNlID0gJ3JlZmVyZW5jZSc7XG52YXIgdmFyaWF0aW9uUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9iYXNlUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pO1xudmFyIGVudW1zX3BsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovW10uY29uY2F0KGJhc2VQbGFjZW1lbnRzLCBbYXV0b10pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCwgcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTsgLy8gbW9kaWZpZXJzIHRoYXQgbmVlZCB0byByZWFkIHRoZSBET01cblxudmFyIGJlZm9yZVJlYWQgPSAnYmVmb3JlUmVhZCc7XG52YXIgcmVhZCA9ICdyZWFkJztcbnZhciBhZnRlclJlYWQgPSAnYWZ0ZXJSZWFkJzsgLy8gcHVyZS1sb2dpYyBtb2RpZmllcnNcblxudmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XG52YXIgbWFpbiA9ICdtYWluJztcbnZhciBhZnRlck1haW4gPSAnYWZ0ZXJNYWluJzsgLy8gbW9kaWZpZXIgd2l0aCB0aGUgcHVycG9zZSB0byB3cml0ZSB0byB0aGUgRE9NIChvciB3cml0ZSBpbnRvIGEgZnJhbWV3b3JrIHN0YXRlKVxuXG52YXIgYmVmb3JlV3JpdGUgPSAnYmVmb3JlV3JpdGUnO1xudmFyIHdyaXRlID0gJ3dyaXRlJztcbnZhciBhZnRlcldyaXRlID0gJ2FmdGVyV3JpdGUnO1xudmFyIG1vZGlmaWVyUGhhc2VzID0gW2JlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGVdO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9vcmRlck1vZGlmaWVycy5qc1xuIC8vIHNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk4NzUyNTVcblxuZnVuY3Rpb24gb3JkZXIobW9kaWZpZXJzKSB7XG4gIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIG1hcC5zZXQobW9kaWZpZXIubmFtZSwgbW9kaWZpZXIpO1xuICB9KTsgLy8gT24gdmlzaXRpbmcgb2JqZWN0LCBjaGVjayBmb3IgaXRzIGRlcGVuZGVuY2llcyBhbmQgdmlzaXQgdGhlbSByZWN1cnNpdmVseVxuXG4gIGZ1bmN0aW9uIHNvcnQobW9kaWZpZXIpIHtcbiAgICB2aXNpdGVkLmFkZChtb2RpZmllci5uYW1lKTtcbiAgICB2YXIgcmVxdWlyZXMgPSBbXS5jb25jYXQobW9kaWZpZXIucmVxdWlyZXMgfHwgW10sIG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pO1xuICAgIHJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhkZXApKSB7XG4gICAgICAgIHZhciBkZXBNb2RpZmllciA9IG1hcC5nZXQoZGVwKTtcblxuICAgICAgICBpZiAoZGVwTW9kaWZpZXIpIHtcbiAgICAgICAgICBzb3J0KGRlcE1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3VsdC5wdXNoKG1vZGlmaWVyKTtcbiAgfVxuXG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmICghdmlzaXRlZC5oYXMobW9kaWZpZXIubmFtZSkpIHtcbiAgICAgIC8vIGNoZWNrIGZvciB2aXNpdGVkIG9iamVjdFxuICAgICAgc29ydChtb2RpZmllcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gb3JkZXJNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gIC8vIG9yZGVyIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xuICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyKG1vZGlmaWVycyk7IC8vIG9yZGVyIGJhc2VkIG9uIHBoYXNlXG5cbiAgcmV0dXJuIG1vZGlmaWVyUGhhc2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwaGFzZSkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgcmV0dXJuIG1vZGlmaWVyLnBoYXNlID09PSBwaGFzZTtcbiAgICB9KSk7XG4gIH0sIFtdKTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGVib3VuY2UuanNcbmZ1bmN0aW9uIGRlYm91bmNlKGZuKSB7XG4gIHZhciBwZW5kaW5nO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHBlbmRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmVzb2x2ZShmbigpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGVuZGluZztcbiAgfTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VCeU5hbWUuanNcbmZ1bmN0aW9uIG1lcmdlQnlOYW1lKG1vZGlmaWVycykge1xuICB2YXIgbWVyZ2VkID0gbW9kaWZpZXJzLnJlZHVjZShmdW5jdGlvbiAobWVyZ2VkLCBjdXJyZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nID0gbWVyZ2VkW2N1cnJlbnQubmFtZV07XG4gICAgbWVyZ2VkW2N1cnJlbnQubmFtZV0gPSBleGlzdGluZyA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCBjdXJyZW50LCB7XG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5vcHRpb25zLCBjdXJyZW50Lm9wdGlvbnMpLFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcuZGF0YSwgY3VycmVudC5kYXRhKVxuICAgIH0pIDogY3VycmVudDtcbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9LCB7fSk7IC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1lcmdlZCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbWVyZ2VkW2tleV07XG4gIH0pO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9jcmVhdGVQb3BwZXIuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgSU5WQUxJRF9FTEVNRU5UX0VSUk9SID0gJ1BvcHBlcjogSW52YWxpZCByZWZlcmVuY2Ugb3IgcG9wcGVyIGFyZ3VtZW50IHByb3ZpZGVkLiBUaGV5IG11c3QgYmUgZWl0aGVyIGEgRE9NIGVsZW1lbnQgb3IgdmlydHVhbCBlbGVtZW50Lic7XG52YXIgSU5GSU5JVEVfTE9PUF9FUlJPUiA9ICdQb3BwZXI6IEFuIGluZmluaXRlIGxvb3AgaW4gdGhlIG1vZGlmaWVycyBjeWNsZSBoYXMgYmVlbiBkZXRlY3RlZCEgVGhlIGN5Y2xlIGhhcyBiZWVuIGludGVycnVwdGVkIHRvIHByZXZlbnQgYSBicm93c2VyIGNyYXNoLic7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICBtb2RpZmllcnM6IFtdLFxuICBzdHJhdGVneTogJ2Fic29sdXRlJ1xufTtcblxuZnVuY3Rpb24gYXJlVmFsaWRFbGVtZW50cygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiAhYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuICEoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT09ICdmdW5jdGlvbicpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnMpIHtcbiAgaWYgKGdlbmVyYXRvck9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIGdlbmVyYXRvck9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfZ2VuZXJhdG9yT3B0aW9ucyA9IGdlbmVyYXRvck9wdGlvbnMsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0TW9kaWZpZXJzLFxuICAgICAgZGVmYXVsdE1vZGlmaWVycyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9PT0gdm9pZCAwID8gW10gOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsXG4gICAgICBkZWZhdWx0T3B0aW9ucyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPT09IHZvaWQgMCA/IERFRkFVTFRfT1BUSU9OUyA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZjI7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICBtb2RpZmllcnNEYXRhOiB7fSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXI6IHBvcHBlclxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH07XG4gICAgdmFyIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB2YXIgaXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB2YXIgaW5zdGFuY2UgPSB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBzZXRPcHRpb25zOiBmdW5jdGlvbiBzZXRPcHRpb25zKHNldE9wdGlvbnNBY3Rpb24pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2V0T3B0aW9uc0FjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHNldE9wdGlvbnNBY3Rpb24oc3RhdGUub3B0aW9ucykgOiBzZXRPcHRpb25zQWN0aW9uO1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHN0YXRlLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgc3RhdGUub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBpc0VsZW1lbnQocmVmZXJlbmNlKSA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZSkgOiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIDogW10sXG4gICAgICAgICAgcG9wcGVyOiBsaXN0U2Nyb2xsUGFyZW50cyhwb3BwZXIpXG4gICAgICAgIH07IC8vIE9yZGVycyB0aGUgbW9kaWZpZXJzIGJhc2VkIG9uIHRoZWlyIGRlcGVuZGVuY2llcyBhbmQgYHBoYXNlYFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG5cbiAgICAgICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlck1vZGlmaWVycyhtZXJnZUJ5TmFtZShbXS5jb25jYXQoZGVmYXVsdE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpKSk7IC8vIFN0cmlwIG91dCBkaXNhYmxlZCBtb2RpZmllcnNcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICByZXR1cm4gbS5lbmFibGVkO1xuICAgICAgICB9KTsgLy8gVmFsaWRhdGUgdGhlIHByb3ZpZGVkIG1vZGlmaWVycyBzbyB0aGF0IHRoZSBjb25zdW1lciB3aWxsIGdldCB3YXJuZWRcbiAgICAgICAgLy8gaWYgb25lIG9mIHRoZSBtb2RpZmllcnMgaXMgaW52YWxpZCBmb3IgYW55IHJlYXNvblxuXG4gICAgICAgIGlmIChmYWxzZSkgeyB2YXIgX2dldENvbXB1dGVkU3R5bGUsIG1hcmdpblRvcCwgbWFyZ2luUmlnaHQsIG1hcmdpbkJvdHRvbSwgbWFyZ2luTGVmdCwgZmxpcE1vZGlmaWVyLCBtb2RpZmllcnM7IH1cblxuICAgICAgICBydW5Nb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIC8vIFN5bmMgdXBkYXRlIOKAkyBpdCB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCwgZXZlbiBpZiBub3QgbmVjZXNzYXJ5LiBUaGlzXG4gICAgICAvLyBpcyB1c2VmdWwgZm9yIGxvdyBmcmVxdWVuY3kgdXBkYXRlcyB3aGVyZSBzeW5jIGJlaGF2aW9yIHNpbXBsaWZpZXMgdGhlXG4gICAgICAvLyBsb2dpYy5cbiAgICAgIC8vIEZvciBoaWdoIGZyZXF1ZW5jeSB1cGRhdGVzIChlLmcuIGByZXNpemVgIGFuZCBgc2Nyb2xsYCBldmVudHMpLCBhbHdheXNcbiAgICAgIC8vIHByZWZlciB0aGUgYXN5bmMgUG9wcGVyI3VwZGF0ZSBtZXRob2RcbiAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKGlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9zdGF0ZSRlbGVtZW50cyA9IHN0YXRlLmVsZW1lbnRzLFxuICAgICAgICAgICAgcmVmZXJlbmNlID0gX3N0YXRlJGVsZW1lbnRzLnJlZmVyZW5jZSxcbiAgICAgICAgICAgIHBvcHBlciA9IF9zdGF0ZSRlbGVtZW50cy5wb3BwZXI7IC8vIERvbid0IHByb2NlZWQgaWYgYHJlZmVyZW5jZWAgb3IgYHBvcHBlcmAgYXJlIG5vdCB2YWxpZCBlbGVtZW50c1xuICAgICAgICAvLyBhbnltb3JlXG5cbiAgICAgICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgICAgIGlmIChmYWxzZSkge31cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBTdG9yZSB0aGUgcmVmZXJlbmNlIGFuZCBwb3BwZXIgcmVjdHMgdG8gYmUgcmVhZCBieSBtb2RpZmllcnNcblxuXG4gICAgICAgIHN0YXRlLnJlY3RzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogZ2V0Q29tcG9zaXRlUmVjdChyZWZlcmVuY2UsIGdldE9mZnNldFBhcmVudChwb3BwZXIpLCBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnKSxcbiAgICAgICAgICBwb3BwZXI6IGdldExheW91dFJlY3QocG9wcGVyKVxuICAgICAgICB9OyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXNldCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUuIFRoZVxuICAgICAgICAvLyBtb3N0IGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0aGUgYGZsaXBgIG1vZGlmaWVyIGNoYW5naW5nIHRoZVxuICAgICAgICAvLyBwbGFjZW1lbnQsIHdoaWNoIHRoZW4gbmVlZHMgdG8gcmUtcnVuIGFsbCB0aGUgbW9kaWZpZXJzLCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBsb2dpYyB3YXMgcHJldmlvdXNseSByYW4gZm9yIHRoZSBwcmV2aW91cyBwbGFjZW1lbnQgYW5kIGlzIHRoZXJlZm9yZVxuICAgICAgICAvLyBzdGFsZS9pbmNvcnJlY3RcblxuICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDsgLy8gT24gZWFjaCB1cGRhdGUgY3ljbGUsIHRoZSBgbW9kaWZpZXJzRGF0YWAgcHJvcGVydHkgZm9yIGVhY2ggbW9kaWZpZXJcbiAgICAgICAgLy8gaXMgZmlsbGVkIHdpdGggdGhlIGluaXRpYWwgZGF0YSBzcGVjaWZpZWQgYnkgdGhlIG1vZGlmaWVyLiBUaGlzIG1lYW5zXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgcGVyc2lzdCBhbmQgaXMgZnJlc2ggb24gZWFjaCB1cGRhdGUuXG4gICAgICAgIC8vIFRvIGVuc3VyZSBwZXJzaXN0ZW50IGRhdGEsIHVzZSBgJHtuYW1lfSNwZXJzaXN0ZW50YFxuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUubW9kaWZpZXJzRGF0YVttb2RpZmllci5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIG1vZGlmaWVyLmRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9fZGVidWdfbG9vcHNfXyA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaWYgKGZhbHNlKSB7fVxuXG4gICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfc3RhdGUkb3JkZXJlZE1vZGlmaWUgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XSxcbiAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXG4gICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcbiAgICAgICAgICAgICAgX29wdGlvbnMgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID09PSB2b2lkIDAgPyB7fSA6IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIsXG4gICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gZm4oe1xuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IF9vcHRpb25zLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgIH0pIHx8IHN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICBpZiAoZmFsc2UpIHt9XG5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICBpZiAoIWlzRGVzdHJveWVkICYmIG9wdGlvbnMub25GaXJzdFVwZGF0ZSkge1xuICAgICAgICBvcHRpb25zLm9uRmlyc3RVcGRhdGUoc3RhdGUpO1xuICAgICAgfVxuICAgIH0pOyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAvLyB1cGRhdGUgY3ljbGUgcnVucy4gVGhleSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB1cGRhdGVcbiAgICAvLyBjeWNsZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIG1vZGlmaWVyIGFkZHMgc29tZSBwZXJzaXN0ZW50IGRhdGEgdGhhdFxuICAgIC8vIG90aGVyIG1vZGlmaWVycyBuZWVkIHRvIHVzZSwgYnV0IHRoZSBtb2RpZmllciBpcyBydW4gYWZ0ZXIgdGhlIGRlcGVuZGVudFxuICAgIC8vIG9uZS5cblxuICAgIGZ1bmN0aW9uIHJ1bk1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lLFxuICAgICAgICAgICAgX3JlZjMkb3B0aW9ucyA9IF9yZWYzLm9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zID0gX3JlZjMkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmMyRvcHRpb25zLFxuICAgICAgICAgICAgZWZmZWN0ID0gX3JlZjMuZWZmZWN0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGNsZWFudXBGbiA9IGVmZmVjdCh7XG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIG5vb3BGbiA9IGZ1bmN0aW9uIG5vb3BGbigpIHt9O1xuXG4gICAgICAgICAgZWZmZWN0Q2xlYW51cEZucy5wdXNoKGNsZWFudXBGbiB8fCBub29wRm4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgZWZmZWN0Q2xlYW51cEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0pO1xuICAgICAgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn1cbnZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAocG9wcGVyR2VuZXJhdG9yKCkpKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXG4gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgcGFzc2l2ZSA9IHtcbiAgcGFzc2l2ZTogdHJ1ZVxufTtcblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRzY3JvbGwgPSBvcHRpb25zLnNjcm9sbCxcbiAgICAgIHNjcm9sbCA9IF9vcHRpb25zJHNjcm9sbCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHNjcm9sbCxcbiAgICAgIF9vcHRpb25zJHJlc2l6ZSA9IG9wdGlvbnMucmVzaXplLFxuICAgICAgcmVzaXplID0gX29wdGlvbnMkcmVzaXplID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcmVzaXplO1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KHN0YXRlLmVsZW1lbnRzLnBvcHBlcik7XG4gIHZhciBzY3JvbGxQYXJlbnRzID0gW10uY29uY2F0KHN0YXRlLnNjcm9sbFBhcmVudHMucmVmZXJlbmNlLCBzdGF0ZS5zY3JvbGxQYXJlbnRzLnBvcHBlcik7XG5cbiAgaWYgKHNjcm9sbCkge1xuICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICBzY3JvbGxQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyZXNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgICAgc2Nyb2xsUGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0gKHtcbiAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgZGF0YToge31cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXG5cbmZ1bmN0aW9uIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXG5mdW5jdGlvbiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXG5mdW5jdGlvbiBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgPj0gMCA/ICd4JyA6ICd5Jztcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZU9mZnNldHMuanNcblxuXG5cblxuZnVuY3Rpb24gY29tcHV0ZU9mZnNldHMoX3JlZikge1xuICB2YXIgcmVmZXJlbmNlID0gX3JlZi5yZWZlcmVuY2UsXG4gICAgICBlbGVtZW50ID0gX3JlZi5lbGVtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZi5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50ID8gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudCA/IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBlbGVtZW50LndpZHRoIC8gMjtcbiAgdmFyIGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZWxlbWVudC5oZWlnaHQgLyAyO1xuICB2YXIgb2Zmc2V0cztcblxuICBzd2l0Y2ggKGJhc2VQbGFjZW1lbnQpIHtcbiAgICBjYXNlIGVudW1zX3RvcDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZWxlbWVudC5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgYm90dG9tOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHJpZ2h0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgbGVmdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZWxlbWVudC53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54LFxuICAgICAgICB5OiByZWZlcmVuY2UueVxuICAgICAgfTtcbiAgfVxuXG4gIHZhciBtYWluQXhpcyA9IGJhc2VQbGFjZW1lbnQgPyBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCkgOiBudWxsO1xuXG4gIGlmIChtYWluQXhpcyAhPSBudWxsKSB7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICBzd2l0Y2ggKHZhcmlhdGlvbikge1xuICAgICAgY2FzZSBzdGFydDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSAtIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgZW5kOlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdICsgKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanNcblxuXG5mdW5jdGlvbiBwb3BwZXJPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIC8vIE9mZnNldHMgYXJlIHRoZSBhY3R1YWwgcG9zaXRpb24gdGhlIHBvcHBlciBuZWVkcyB0byBoYXZlIHRvIGJlXG4gIC8vIHByb3Blcmx5IHBvc2l0aW9uZWQgbmVhciBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVGhpcyBpcyB0aGUgbW9zdCBiYXNpYyBwbGFjZW1lbnQsIGFuZCB3aWxsIGJlIGFkanVzdGVkIGJ5XG4gIC8vIHRoZSBtb2RpZmllcnMgaW4gdGhlIG5leHQgc3RlcFxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogc3RhdGUucmVjdHMucmVmZXJlbmNlLFxuICAgIGVsZW1lbnQ6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgbW9kaWZpZXJzX3BvcHBlck9mZnNldHMgPSAoe1xuICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAncmVhZCcsXG4gIGZuOiBwb3BwZXJPZmZzZXRzLFxuICBkYXRhOiB7fVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzXG5cblxuXG5cblxuXG5cbiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciB1bnNldFNpZGVzID0ge1xuICB0b3A6ICdhdXRvJyxcbiAgcmlnaHQ6ICdhdXRvJyxcbiAgYm90dG9tOiAnYXV0bycsXG4gIGxlZnQ6ICdhdXRvJ1xufTsgLy8gUm91bmQgdGhlIG9mZnNldHMgdG8gdGhlIG5lYXJlc3Qgc3VpdGFibGUgc3VicGl4ZWwgYmFzZWQgb24gdGhlIERQUi5cbi8vIFpvb21pbmcgY2FuIGNoYW5nZSB0aGUgRFBSLCBidXQgaXQgc2VlbXMgdG8gcmVwb3J0IGEgdmFsdWUgdGhhdCB3aWxsXG4vLyBjbGVhbmx5IGRpdmlkZSB0aGUgdmFsdWVzIGludG8gdGhlIGFwcHJvcHJpYXRlIHN1YnBpeGVscy5cblxuZnVuY3Rpb24gcm91bmRPZmZzZXRzQnlEUFIoX3JlZikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG4gIHZhciBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKHggKiBkcHIpIC8gZHByIHx8IDAsXG4gICAgeTogcm91bmQoeSAqIGRwcikgLyBkcHIgfHwgMFxuICB9O1xufVxuXG5mdW5jdGlvbiBtYXBUb1N0eWxlcyhfcmVmMikge1xuICB2YXIgX09iamVjdCRhc3NpZ24yO1xuXG4gIHZhciBwb3BwZXIgPSBfcmVmMi5wb3BwZXIsXG4gICAgICBwb3BwZXJSZWN0ID0gX3JlZjIucG9wcGVyUmVjdCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYyLnBsYWNlbWVudCxcbiAgICAgIHZhcmlhdGlvbiA9IF9yZWYyLnZhcmlhdGlvbixcbiAgICAgIG9mZnNldHMgPSBfcmVmMi5vZmZzZXRzLFxuICAgICAgcG9zaXRpb24gPSBfcmVmMi5wb3NpdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9yZWYyLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGFkYXB0aXZlID0gX3JlZjIuYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHMgPSBfcmVmMi5yb3VuZE9mZnNldHMsXG4gICAgICBpc0ZpeGVkID0gX3JlZjIuaXNGaXhlZDtcblxuICB2YXIgX3JlZjMgPSByb3VuZE9mZnNldHMgPT09IHRydWUgPyByb3VuZE9mZnNldHNCeURQUihvZmZzZXRzKSA6IHR5cGVvZiByb3VuZE9mZnNldHMgPT09ICdmdW5jdGlvbicgPyByb3VuZE9mZnNldHMob2Zmc2V0cykgOiBvZmZzZXRzLFxuICAgICAgX3JlZjMkeCA9IF9yZWYzLngsXG4gICAgICB4ID0gX3JlZjMkeCA9PT0gdm9pZCAwID8gMCA6IF9yZWYzJHgsXG4gICAgICBfcmVmMyR5ID0gX3JlZjMueSxcbiAgICAgIHkgPSBfcmVmMyR5ID09PSB2b2lkIDAgPyAwIDogX3JlZjMkeTtcblxuICB2YXIgaGFzWCA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3gnKTtcbiAgdmFyIGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XG4gIHZhciBzaWRlWCA9IGxlZnQ7XG4gIHZhciBzaWRlWSA9IGVudW1zX3RvcDtcbiAgdmFyIHdpbiA9IHdpbmRvdztcblxuICBpZiAoYWRhcHRpdmUpIHtcbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XG4gICAgdmFyIGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcbiAgICB2YXIgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcblxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcblxuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycgJiYgcG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF06IGZvcmNlIHR5cGUgcmVmaW5lbWVudCwgd2UgY29tcGFyZSBvZmZzZXRQYXJlbnQgd2l0aCB3aW5kb3cgYWJvdmUsIGJ1dCBGbG93IGRvZXNuJ3QgZGV0ZWN0IGl0XG5cblxuICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcblxuICAgIGlmIChwbGFjZW1lbnQgPT09IGVudW1zX3RvcCB8fCAocGxhY2VtZW50ID09PSBsZWZ0IHx8IHBsYWNlbWVudCA9PT0gcmlnaHQpICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWSA9IGJvdHRvbTtcbiAgICAgIHZhciBvZmZzZXRZID0gaXNGaXhlZCAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQuaGVpZ2h0IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBvZmZzZXRQYXJlbnRbaGVpZ2h0UHJvcF07XG4gICAgICB5IC09IG9mZnNldFkgLSBwb3BwZXJSZWN0LmhlaWdodDtcbiAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IGxlZnQgfHwgKHBsYWNlbWVudCA9PT0gZW51bXNfdG9wIHx8IHBsYWNlbWVudCA9PT0gYm90dG9tKSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVggPSByaWdodDtcbiAgICAgIHZhciBvZmZzZXRYID0gaXNGaXhlZCAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQud2lkdGggOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFt3aWR0aFByb3BdO1xuICAgICAgeCAtPSBvZmZzZXRYIC0gcG9wcGVyUmVjdC53aWR0aDtcbiAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25TdHlsZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgfSwgYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyk7XG5cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbikge1xuICAgIHZhciBfT2JqZWN0JGFzc2lnbjtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbiA9IHt9LCBfT2JqZWN0JGFzc2lnbltzaWRlWV0gPSBoYXNZID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduW3NpZGVYXSA9IGhhc1ggPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ24udHJhbnNmb3JtID0gKHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDw9IDEgPyBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4LCAwKVwiLCBfT2JqZWN0JGFzc2lnbikpO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduMiA9IHt9LCBfT2JqZWN0JGFzc2lnbjJbc2lkZVldID0gaGFzWSA/IHkgKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yW3NpZGVYXSA9IGhhc1ggPyB4ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMi50cmFuc2Zvcm0gPSAnJywgX09iamVjdCRhc3NpZ24yKSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZXMoX3JlZjQpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjQuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjQub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZ3B1QWNjZWxlcmF0LFxuICAgICAgX29wdGlvbnMkYWRhcHRpdmUgPSBvcHRpb25zLmFkYXB0aXZlLFxuICAgICAgYWRhcHRpdmUgPSBfb3B0aW9ucyRhZGFwdGl2ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFkYXB0aXZlLFxuICAgICAgX29wdGlvbnMkcm91bmRPZmZzZXRzID0gb3B0aW9ucy5yb3VuZE9mZnNldHMsXG4gICAgICByb3VuZE9mZnNldHMgPSBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyb3VuZE9mZnNldHM7XG5cbiAgaWYgKGZhbHNlKSB7IHZhciB0cmFuc2l0aW9uUHJvcGVydHk7IH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHZhcmlhdGlvbjogZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiBzdGF0ZS5lbGVtZW50cy5wb3BwZXIsXG4gICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogZ3B1QWNjZWxlcmF0aW9uLFxuICAgIGlzRml4ZWQ6IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCdcbiAgfTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLnBvcHBlciwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMuYXJyb3csIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IG1vZGlmaWVyc19jb21wdXRlU3R5bGVzID0gKHtcbiAgbmFtZTogJ2NvbXB1dGVTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ2JlZm9yZVdyaXRlJyxcbiAgZm46IGNvbXB1dGVTdHlsZXMsXG4gIGRhdGE6IHt9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzXG5cbiAvLyBUaGlzIG1vZGlmaWVyIHRha2VzIHRoZSBzdHlsZXMgcHJlcGFyZWQgYnkgdGhlIGBjb21wdXRlU3R5bGVzYCBtb2RpZmllclxuLy8gYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgSFRNTEVsZW1lbnRzIHN1Y2ggYXMgcG9wcGVyIGFuZCBhcnJvd1xuXG5mdW5jdGlvbiBhcHBseVN0eWxlcyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUuc3R5bGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxuICAgIC8vIGVmZmVjdGl2ZSB3YXkgdG8gYXBwbHkgc3R5bGVzIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG5cblxuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYXBwbHlTdHlsZXNfZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xuICB2YXIgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICBwb3BwZXI6IHtcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgbGVmdDogJzAnLFxuICAgICAgdG9wOiAnMCcsXG4gICAgICBtYXJnaW46ICcwJ1xuICAgIH0sXG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSxcbiAgICByZWZlcmVuY2U6IHt9XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBpbml0aWFsU3R5bGVzLnBvcHBlcik7XG4gIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XG5cbiAgaWYgKHN0YXRlLmVsZW1lbnRzLmFycm93KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgICAgdmFyIHN0eWxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHN0YXRlLnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHN0YXRlLnN0eWxlc1tuYW1lXSA6IGluaXRpYWxTdHlsZXNbbmFtZV0pOyAvLyBTZXQgYWxsIHZhbHVlcyB0byBhbiBlbXB0eSBzdHJpbmcgdG8gdW5zZXQgdGhlbVxuXG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZVByb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChzdHlsZSwgcHJvcGVydHkpIHtcbiAgICAgICAgc3R5bGVbcHJvcGVydHldID0gJyc7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH0sIHt9KTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IG1vZGlmaWVyc19hcHBseVN0eWxlcyA9ICh7XG4gIG5hbWU6ICdhcHBseVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogYXBwbHlTdHlsZXMsXG4gIGVmZmVjdDogYXBwbHlTdHlsZXNfZWZmZWN0LFxuICByZXF1aXJlczogWydjb21wdXRlU3R5bGVzJ11cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvb2Zmc2V0LmpzXG5cbiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmZ1bmN0aW9uIGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgcmVjdHMsIG9mZnNldCkge1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIGludmVydERpc3RhbmNlID0gW2xlZnQsIGVudW1zX3RvcF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8gLTEgOiAxO1xuXG4gIHZhciBfcmVmID0gdHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IG9mZnNldChPYmplY3QuYXNzaWduKHt9LCByZWN0cywge1xuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pKSA6IG9mZnNldCxcbiAgICAgIHNraWRkaW5nID0gX3JlZlswXSxcbiAgICAgIGRpc3RhbmNlID0gX3JlZlsxXTtcblxuICBza2lkZGluZyA9IHNraWRkaW5nIHx8IDA7XG4gIGRpc3RhbmNlID0gKGRpc3RhbmNlIHx8IDApICogaW52ZXJ0RGlzdGFuY2U7XG4gIHJldHVybiBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IHtcbiAgICB4OiBkaXN0YW5jZSxcbiAgICB5OiBza2lkZGluZ1xuICB9IDoge1xuICAgIHg6IHNraWRkaW5nLFxuICAgIHk6IGRpc3RhbmNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIG9mZnNldChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYyLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRvZmZzZXQgPSBvcHRpb25zLm9mZnNldCxcbiAgICAgIG9mZnNldCA9IF9vcHRpb25zJG9mZnNldCA9PT0gdm9pZCAwID8gWzAsIDBdIDogX29wdGlvbnMkb2Zmc2V0O1xuICB2YXIgZGF0YSA9IGVudW1zX3BsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCBzdGF0ZS5yZWN0cywgb2Zmc2V0KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHZhciBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQgPSBkYXRhW3N0YXRlLnBsYWNlbWVudF0sXG4gICAgICB4ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50LngsXG4gICAgICB5ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50Lnk7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggKz0geDtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSArPSB5O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IG1vZGlmaWVyc19vZmZzZXQgPSAoe1xuICBuYW1lOiAnb2Zmc2V0JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICBmbjogb2Zmc2V0XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanNcbnZhciBoYXNoID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qc1xudmFyIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50X2hhc2ggPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50X2hhc2hbbWF0Y2hlZF07XG4gIH0pO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Vmlld3BvcnRSZWN0LmpzXG5cblxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICB2YXIgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XG4gIHZhciB4ID0gMDtcbiAgdmFyIHkgPSAwOyAvLyBOQjogVGhpcyBpc24ndCBzdXBwb3J0ZWQgb24gaU9TIDw9IDEyLiBJZiB0aGUga2V5Ym9hcmQgaXMgb3BlbiwgdGhlIHBvcHBlclxuICAvLyBjYW4gYmUgb2JzY3VyZWQgdW5kZXJuZWF0aCBpdC5cbiAgLy8gQWxzbywgYGh0bWwuY2xpZW50SGVpZ2h0YCBhZGRzIHRoZSBib3R0b20gYmFyIGhlaWdodCBpbiBTYWZhcmkgaU9TLCBldmVuXG4gIC8vIGlmIGl0IGlzbid0IG9wZW4sIHNvIGlmIHRoaXMgaXNuJ3QgYXZhaWxhYmxlLCB0aGUgcG9wcGVyIHdpbGwgYmUgZGV0ZWN0ZWRcbiAgLy8gdG8gb3ZlcmZsb3cgdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuIHRvbyBlYXJseS5cblxuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDsgLy8gVXNlcyBMYXlvdXQgVmlld3BvcnQgKGxpa2UgQ2hyb21lOyBTYWZhcmkgZG9lcyBub3QgY3VycmVudGx5KVxuICAgIC8vIEluIENocm9tZSwgaXQgcmV0dXJucyBhIHZhbHVlIHZlcnkgY2xvc2UgdG8gMCAoKy8tKSBidXQgY29udGFpbnMgcm91bmRpbmdcbiAgICAvLyBlcnJvcnMgZHVlIHRvIGZsb2F0aW5nIHBvaW50IG51bWJlcnMsIHNvIHdlIG5lZWQgdG8gY2hlY2sgcHJlY2lzaW9uLlxuICAgIC8vIFNhZmFyaSByZXR1cm5zIGEgbnVtYmVyIDw9IDAsIHVzdWFsbHkgPCAtMSB3aGVuIHBpbmNoLXpvb21lZFxuICAgIC8vIEZlYXR1cmUgZGV0ZWN0aW9uIGZhaWxzIGluIG1vYmlsZSBlbXVsYXRpb24gbW9kZSBpbiBDaHJvbWUuXG4gICAgLy8gTWF0aC5hYnMod2luLmlubmVyV2lkdGggLyB2aXN1YWxWaWV3cG9ydC5zY2FsZSAtIHZpc3VhbFZpZXdwb3J0LndpZHRoKSA8XG4gICAgLy8gMC4wMDFcbiAgICAvLyBGYWxsYmFjayBoZXJlOiBcIk5vdCBTYWZhcmlcIiB1c2VyQWdlbnRcblxuICAgIGlmICghL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHggKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpLFxuICAgIHk6IHlcbiAgfTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50UmVjdC5qc1xuXG5cblxuXG4gLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgd2luU2Nyb2xsID0gZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpO1xuICB2YXIgYm9keSA9IChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keTtcbiAgdmFyIHdpZHRoID0gbWF0aF9tYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuc2Nyb2xsV2lkdGggOiAwLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApO1xuICB2YXIgaGVpZ2h0ID0gbWF0aF9tYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwKTtcbiAgdmFyIHggPSAtd2luU2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICB2YXIgeSA9IC13aW5TY3JvbGwuc2Nyb2xsVG9wO1xuXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKGJvZHkgfHwgaHRtbCkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF0aF9tYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qc1xuXG5mdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gIHZhciByb290Tm9kZSA9IGNoaWxkLmdldFJvb3ROb2RlICYmIGNoaWxkLmdldFJvb3ROb2RlKCk7IC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcblxuICBpZiAocGFyZW50LmNvbnRhaW5zKGNoaWxkKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIHRoZW4gZmFsbGJhY2sgdG8gY3VzdG9tIGltcGxlbWVudGF0aW9uIHdpdGggU2hhZG93IERPTSBzdXBwb3J0XG4gIGVsc2UgaWYgKHJvb3ROb2RlICYmIGlzU2hhZG93Um9vdChyb290Tm9kZSkpIHtcbiAgICAgIHZhciBuZXh0ID0gY2hpbGQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG5leHQgJiYgcGFyZW50LmlzU2FtZU5vZGUobmV4dCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ106IG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG5cblxuICAgICAgICBuZXh0ID0gbmV4dC5wYXJlbnROb2RlIHx8IG5leHQuaG9zdDtcbiAgICAgIH0gd2hpbGUgKG5leHQpO1xuICAgIH0gLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxuXG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzXG5mdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlY3QsIHtcbiAgICBsZWZ0OiByZWN0LngsXG4gICAgdG9wOiByZWN0LnksXG4gICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiByZWN0LnkgKyByZWN0LmhlaWdodFxuICB9KTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENsaXBwaW5nUmVjdC5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTtcbiAgcmVjdC50b3AgPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xuICByZWN0LmxlZnQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQ7XG4gIHJlY3QuYm90dG9tID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHJlY3Qud2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LmhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZWN0LnggPSByZWN0LmxlZnQ7XG4gIHJlY3QueSA9IHJlY3QudG9wO1xuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQpIHtcbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50ID09PSB2aWV3cG9ydCA/IHJlY3RUb0NsaWVudFJlY3QoZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQpKSA6IGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgPyBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCkgOiByZWN0VG9DbGllbnRSZWN0KGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpKTtcbn0gLy8gQSBcImNsaXBwaW5nIHBhcmVudFwiIGlzIGFuIG92ZXJmbG93YWJsZSBjb250YWluZXIgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWMgb2Zcbi8vIGNsaXBwaW5nIChvciBoaWRpbmcpIG92ZXJmbG93aW5nIGVsZW1lbnRzIHdpdGggYSBwb3NpdGlvbiBkaWZmZXJlbnQgZnJvbVxuLy8gYGluaXRpYWxgXG5cblxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIHtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xuICB2YXIgY2FuRXNjYXBlQ2xpcHBpbmcgPSBbJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uKSA+PSAwO1xuICB2YXIgY2xpcHBlckVsZW1lbnQgPSBjYW5Fc2NhcGVDbGlwcGluZyAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpID8gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIDogZWxlbWVudDtcblxuICBpZiAoIWlzRWxlbWVudChjbGlwcGVyRWxlbWVudCkpIHtcbiAgICByZXR1cm4gW107XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzE0MTRcblxuXG4gIHJldHVybiBjbGlwcGluZ1BhcmVudHMuZmlsdGVyKGZ1bmN0aW9uIChjbGlwcGluZ1BhcmVudCkge1xuICAgIHJldHVybiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpICYmIGNvbnRhaW5zKGNsaXBwaW5nUGFyZW50LCBjbGlwcGVyRWxlbWVudCkgJiYgZ2V0Tm9kZU5hbWUoY2xpcHBpbmdQYXJlbnQpICE9PSAnYm9keScgJiYgKGNhbkVzY2FwZUNsaXBwaW5nID8gZ2V0Q29tcHV0ZWRTdHlsZShjbGlwcGluZ1BhcmVudCkucG9zaXRpb24gIT09ICdzdGF0aWMnIDogdHJ1ZSk7XG4gIH0pO1xufSAvLyBHZXRzIHRoZSBtYXhpbXVtIGFyZWEgdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIGR1ZSB0byBhbnkgbnVtYmVyIG9mXG4vLyBjbGlwcGluZyBwYXJlbnRzXG5cblxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KGVsZW1lbnQsIGJvdW5kYXJ5LCByb290Qm91bmRhcnkpIHtcbiAgdmFyIG1haW5DbGlwcGluZ1BhcmVudHMgPSBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nUGFyZW50cycgPyBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gW10uY29uY2F0KG1haW5DbGlwcGluZ1BhcmVudHMsIFtyb290Qm91bmRhcnldKTtcbiAgdmFyIGZpcnN0Q2xpcHBpbmdQYXJlbnQgPSBjbGlwcGluZ1BhcmVudHNbMF07XG4gIHZhciBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ1BhcmVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2NSZWN0LCBjbGlwcGluZ1BhcmVudCkge1xuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQpO1xuICAgIGFjY1JlY3QudG9wID0gbWF0aF9tYXgocmVjdC50b3AsIGFjY1JlY3QudG9wKTtcbiAgICBhY2NSZWN0LnJpZ2h0ID0gbWF0aF9taW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtYXRoX21pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1hdGhfbWF4KHJlY3QubGVmdCwgYWNjUmVjdC5sZWZ0KTtcbiAgICByZXR1cm4gYWNjUmVjdDtcbiAgfSwgZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgZmlyc3RDbGlwcGluZ1BhcmVudCkpO1xuICBjbGlwcGluZ1JlY3Qud2lkdGggPSBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LmhlaWdodCA9IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wO1xuICBjbGlwcGluZ1JlY3QueCA9IGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QueSA9IGNsaXBwaW5nUmVjdC50b3A7XG4gIHJldHVybiBjbGlwcGluZ1JlY3Q7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qc1xuZnVuY3Rpb24gZ2V0RnJlc2hTaWRlT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9O1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanNcblxuZnVuY3Rpb24gbWVyZ2VQYWRkaW5nT2JqZWN0KHBhZGRpbmdPYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGdldEZyZXNoU2lkZU9iamVjdCgpLCBwYWRkaW5nT2JqZWN0KTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzXG5mdW5jdGlvbiBleHBhbmRUb0hhc2hNYXAodmFsdWUsIGtleXMpIHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChoYXNoTWFwLCBrZXkpIHtcbiAgICBoYXNoTWFwW2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gaGFzaE1hcDtcbiAgfSwge30pO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1xuXG5cblxuXG5cblxuXG5cbiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMkcGxhY2VtZW50ID09PSB2b2lkIDAgPyBzdGF0ZS5wbGFjZW1lbnQgOiBfb3B0aW9ucyRwbGFjZW1lbnQsXG4gICAgICBfb3B0aW9ucyRib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucyRib3VuZGFyeSA9PT0gdm9pZCAwID8gY2xpcHBpbmdQYXJlbnRzIDogX29wdGlvbnMkYm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRyb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucyRyb290Qm91bmRhcnkgPT09IHZvaWQgMCA/IHZpZXdwb3J0IDogX29wdGlvbnMkcm9vdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZWxlbWVudENvbnRlID0gX29wdGlvbnMuZWxlbWVudENvbnRleHQsXG4gICAgICBlbGVtZW50Q29udGV4dCA9IF9vcHRpb25zJGVsZW1lbnRDb250ZSA9PT0gdm9pZCAwID8gcG9wcGVyIDogX29wdGlvbnMkZWxlbWVudENvbnRlLFxuICAgICAgX29wdGlvbnMkYWx0Qm91bmRhcnkgPSBfb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMkYWx0Qm91bmRhcnkgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucyRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkcGFkZGluZztcbiAgdmFyIHBhZGRpbmdPYmplY3QgPSBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xuICB2YXIgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyByZWZlcmVuY2UgOiBwb3BwZXI7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgdmFyIGNsaXBwaW5nQ2xpZW50UmVjdCA9IGdldENsaXBwaW5nUmVjdChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCBnZXREb2N1bWVudEVsZW1lbnQoc3RhdGUuZWxlbWVudHMucG9wcGVyKSwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSk7XG4gIHZhciByZWZlcmVuY2VDbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICBlbGVtZW50OiBwb3BwZXJSZWN0LFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pO1xuICB2YXIgcG9wcGVyQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoT2JqZWN0LmFzc2lnbih7fSwgcG9wcGVyUmVjdCwgcG9wcGVyT2Zmc2V0cykpO1xuICB2YXIgZWxlbWVudENsaWVudFJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcG9wcGVyQ2xpZW50UmVjdCA6IHJlZmVyZW5jZUNsaWVudFJlY3Q7IC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcbiAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxuXG4gIHZhciBvdmVyZmxvd09mZnNldHMgPSB7XG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgYm90dG9tOiBlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxuICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcbiAgfTtcbiAgdmFyIG9mZnNldERhdGEgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDsgLy8gT2Zmc2V0cyBjYW4gYmUgYXBwbGllZCBvbmx5IHRvIHRoZSBwb3BwZXIgZWxlbWVudFxuXG4gIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcbiAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0RGF0YVtwbGFjZW1lbnRdO1xuICAgIE9iamVjdC5rZXlzKG92ZXJmbG93T2Zmc2V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XG4gICAgICB2YXIgYXhpcyA9IFtlbnVtc190b3AsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAneScgOiAneCc7XG4gICAgICBvdmVyZmxvd09mZnNldHNba2V5XSArPSBvZmZzZXRbYXhpc10gKiBtdWx0aXBseTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvdmVyZmxvd09mZnNldHM7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzXG5cblxuXG5cbmZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9IF9vcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9PT0gdm9pZCAwID8gZW51bXNfcGxhY2VtZW50cyA6IF9vcHRpb25zJGFsbG93ZWRBdXRvUDtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpO1xuICB2YXIgcGxhY2VtZW50cyA9IHZhcmlhdGlvbiA/IGZsaXBWYXJpYXRpb25zID8gdmFyaWF0aW9uUGxhY2VtZW50cyA6IHZhcmlhdGlvblBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHZhcmlhdGlvbjtcbiAgfSkgOiBiYXNlUGxhY2VtZW50cztcbiAgdmFyIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhbGxvd2VkQXV0b1BsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpID49IDA7XG4gIH0pO1xuXG4gIGlmIChhbGxvd2VkUGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG5cbiAgICBpZiAoZmFsc2UpIHt9XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV06IEZsb3cgc2VlbXMgdG8gaGF2ZSBwcm9ibGVtcyB3aXRoIHR3byBhcnJheSB1bmlvbnMuLi5cblxuXG4gIHZhciBvdmVyZmxvd3MgPSBhbGxvd2VkUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KVtnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCldO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG92ZXJmbG93cykuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBvdmVyZmxvd3NbYV0gLSBvdmVyZmxvd3NbYl07XG4gIH0pO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZmxpcC5qc1xuXG5cblxuXG5cblxuIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGlmIChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICByZXR1cm4gW2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xufVxuXG5mdW5jdGlvbiBmbGlwKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzID0gb3B0aW9ucy5mYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPSBvcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRmbGlwVmFyaWF0aW8sXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBvcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cztcbiAgdmFyIHByZWZlcnJlZFBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9IGJhc2VQbGFjZW1lbnQgPT09IHByZWZlcnJlZFBsYWNlbWVudDtcbiAgdmFyIGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwVmFyaWF0aW9ucyA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHByZWZlcnJlZFBsYWNlbWVudCkpO1xuICB2YXIgcGxhY2VtZW50cyA9IFtwcmVmZXJyZWRQbGFjZW1lbnRdLmNvbmNhdChmYWxsYmFja1BsYWNlbWVudHMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8gPyBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9uczogZmxpcFZhcmlhdGlvbnMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHM6IGFsbG93ZWRBdXRvUGxhY2VtZW50c1xuICAgIH0pIDogcGxhY2VtZW50KTtcbiAgfSwgW10pO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBjaGVja3NNYXAgPSBuZXcgTWFwKCk7XG4gIHZhciBtYWtlRmFsbGJhY2tDaGVja3MgPSB0cnVlO1xuICB2YXIgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50c1swXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGxhY2VtZW50ID0gcGxhY2VtZW50c1tpXTtcblxuICAgIHZhciBfYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBpc1N0YXJ0VmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHN0YXJ0O1xuICAgIHZhciBpc1ZlcnRpY2FsID0gW2VudW1zX3RvcCwgYm90dG9tXS5pbmRleE9mKF9iYXNlUGxhY2VtZW50KSA+PSAwO1xuICAgIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pO1xuICAgIHZhciBtYWluVmFyaWF0aW9uU2lkZSA9IGlzVmVydGljYWwgPyBpc1N0YXJ0VmFyaWF0aW9uID8gcmlnaHQgOiBsZWZ0IDogaXNTdGFydFZhcmlhdGlvbiA/IGJvdHRvbSA6IGVudW1zX3RvcDtcblxuICAgIGlmIChyZWZlcmVuY2VSZWN0W2xlbl0gPiBwb3BwZXJSZWN0W2xlbl0pIHtcbiAgICAgIG1haW5WYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIH1cblxuICAgIHZhciBhbHRWYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIHZhciBjaGVja3MgPSBbXTtcblxuICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1tfYmFzZVBsYWNlbWVudF0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbbWFpblZhcmlhdGlvblNpZGVdIDw9IDAsIG92ZXJmbG93W2FsdFZhcmlhdGlvblNpZGVdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja3MuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICByZXR1cm4gY2hlY2s7XG4gICAgfSkpIHtcbiAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgIG1ha2VGYWxsYmFja0NoZWNrcyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2hlY2tzTWFwLnNldChwbGFjZW1lbnQsIGNoZWNrcyk7XG4gIH1cblxuICBpZiAobWFrZUZhbGxiYWNrQ2hlY2tzKSB7XG4gICAgLy8gYDJgIG1heSBiZSBkZXNpcmVkIGluIHNvbWUgY2FzZXMg4oCTIHJlc2VhcmNoIGxhdGVyXG4gICAgdmFyIG51bWJlck9mQ2hlY2tzID0gZmxpcFZhcmlhdGlvbnMgPyAzIDogMTtcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pKSB7XG4gICAgICB2YXIgZml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHMuZmluZChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgICAgIHZhciBjaGVja3MgPSBjaGVja3NNYXAuZ2V0KHBsYWNlbWVudCk7XG5cbiAgICAgICAgaWYgKGNoZWNrcykge1xuICAgICAgICAgIHJldHVybiBjaGVja3Muc2xpY2UoMCwgX2kpLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gZml0dGluZ1BsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgX2kgPSBudW1iZXJPZkNoZWNrczsgX2kgPiAwOyBfaS0tKSB7XG4gICAgICB2YXIgX3JldCA9IF9sb29wKF9pKTtcblxuICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnBsYWNlbWVudCAhPT0gZmlyc3RGaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCA9IHRydWU7XG4gICAgc3RhdGUucGxhY2VtZW50ID0gZmlyc3RGaXR0aW5nUGxhY2VtZW50O1xuICAgIHN0YXRlLnJlc2V0ID0gdHJ1ZTtcbiAgfVxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBtb2RpZmllcnNfZmxpcCA9ICh7XG4gIG5hbWU6ICdmbGlwJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGZsaXAsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J10sXG4gIGRhdGE6IHtcbiAgICBfc2tpcDogZmFsc2VcbiAgfVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEFsdEF4aXMuanNcbmZ1bmN0aW9uIGdldEFsdEF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy93aXRoaW4uanNcblxuZnVuY3Rpb24gd2l0aGluKG1pbiwgdmFsdWUsIG1heCkge1xuICByZXR1cm4gbWF0aF9tYXgobWluLCBtYXRoX21pbih2YWx1ZSwgbWF4KSk7XG59XG5mdW5jdGlvbiB3aXRoaW5NYXhDbGFtcChtaW4sIHZhbHVlLCBtYXgpIHtcbiAgdmFyIHYgPSB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KTtcbiAgcmV0dXJuIHYgPiBtYXggPyBtYXggOiB2O1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXIgPSBvcHRpb25zLnRldGhlcixcbiAgICAgIHRldGhlciA9IF9vcHRpb25zJHRldGhlciA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHRldGhlcixcbiAgICAgIF9vcHRpb25zJHRldGhlck9mZnNldCA9IG9wdGlvbnMudGV0aGVyT2Zmc2V0LFxuICAgICAgdGV0aGVyT2Zmc2V0ID0gX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkdGV0aGVyT2Zmc2V0O1xuICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeVxuICB9KTtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9ICF2YXJpYXRpb247XG4gIHZhciBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGFsdEF4aXMgPSBnZXRBbHRBeGlzKG1haW5BeGlzKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IHRldGhlck9mZnNldChPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHRldGhlck9mZnNldDtcbiAgdmFyIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXRWYWx1ZSA9PT0gJ251bWJlcicgPyB7XG4gICAgbWFpbkF4aXM6IHRldGhlck9mZnNldFZhbHVlLFxuICAgIGFsdEF4aXM6IHRldGhlck9mZnNldFZhbHVlXG4gIH0gOiBPYmplY3QuYXNzaWduKHtcbiAgICBtYWluQXhpczogMCxcbiAgICBhbHRBeGlzOiAwXG4gIH0sIHRldGhlck9mZnNldFZhbHVlKTtcbiAgdmFyIG9mZnNldE1vZGlmaWVyU3RhdGUgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldCA/IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0W3N0YXRlLnBsYWNlbWVudF0gOiBudWxsO1xuICB2YXIgZGF0YSA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQ7XG5cbiAgICB2YXIgbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gZW51bXNfdG9wIDogbGVmdDtcbiAgICB2YXIgYWx0U2lkZSA9IG1haW5BeGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc107XG4gICAgdmFyIG1pbiA9IG9mZnNldCArIG92ZXJmbG93W21haW5TaWRlXTtcbiAgICB2YXIgbWF4ID0gb2Zmc2V0IC0gb3ZlcmZsb3dbYWx0U2lkZV07XG4gICAgdmFyIGFkZGl0aXZlID0gdGV0aGVyID8gLXBvcHBlclJlY3RbbGVuXSAvIDIgOiAwO1xuICAgIHZhciBtaW5MZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gcmVmZXJlbmNlUmVjdFtsZW5dIDogcG9wcGVyUmVjdFtsZW5dO1xuICAgIHZhciBtYXhMZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gLXBvcHBlclJlY3RbbGVuXSA6IC1yZWZlcmVuY2VSZWN0W2xlbl07IC8vIFdlIG5lZWQgdG8gaW5jbHVkZSB0aGUgYXJyb3cgaW4gdGhlIGNhbGN1bGF0aW9uIHNvIHRoZSBhcnJvdyBkb2Vzbid0IGdvXG4gICAgLy8gb3V0c2lkZSB0aGUgcmVmZXJlbmNlIGJvdW5kc1xuXG4gICAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICAgIHZhciBhcnJvd1JlY3QgPSB0ZXRoZXIgJiYgYXJyb3dFbGVtZW50ID8gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpIDoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIHZhciBhcnJvd1BhZGRpbmdPYmplY3QgPSBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10gPyBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10ucGFkZGluZyA6IGdldEZyZXNoU2lkZU9iamVjdCgpO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNaW4gPSBhcnJvd1BhZGRpbmdPYmplY3RbbWFpblNpZGVdO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNYXggPSBhcnJvd1BhZGRpbmdPYmplY3RbYWx0U2lkZV07IC8vIElmIHRoZSByZWZlcmVuY2UgbGVuZ3RoIGlzIHNtYWxsZXIgdGhhbiB0aGUgYXJyb3cgbGVuZ3RoLCB3ZSBkb24ndCB3YW50XG4gICAgLy8gdG8gaW5jbHVkZSBpdHMgZnVsbCBzaXplIGluIHRoZSBjYWxjdWxhdGlvbi4gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbFxuICAgIC8vIGFuZCBuZWFyIHRoZSBlZGdlIG9mIGEgYm91bmRhcnksIHRoZSBwb3BwZXIgY2FuIG92ZXJmbG93IGV2ZW4gaWYgdGhlXG4gICAgLy8gcmVmZXJlbmNlIGlzIG5vdCBvdmVyZmxvd2luZyBhcyB3ZWxsIChlLmcuIHZpcnR1YWwgZWxlbWVudHMgd2l0aCBub1xuICAgIC8vIHdpZHRoIG9yIGhlaWdodClcblxuICAgIHZhciBhcnJvd0xlbiA9IHdpdGhpbigwLCByZWZlcmVuY2VSZWN0W2xlbl0sIGFycm93UmVjdFtsZW5dKTtcbiAgICB2YXIgbWluT2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiAtIGFkZGl0aXZlIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtaW5MZW4gLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgbWF4T2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gLXJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgKyBhZGRpdGl2ZSArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWF4TGVuICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3cgJiYgZ2V0T2Zmc2V0UGFyZW50KHN0YXRlLmVsZW1lbnRzLmFycm93KTtcbiAgICB2YXIgY2xpZW50T2Zmc2V0ID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBtYWluQXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50VG9wIHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRMZWZ0IHx8IDAgOiAwO1xuICAgIHZhciBvZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJCA9IG9mZnNldE1vZGlmaWVyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9mZnNldE1vZGlmaWVyU3RhdGVbbWFpbkF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkIDogMDtcbiAgICB2YXIgdGV0aGVyTWluID0gb2Zmc2V0ICsgbWluT2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIGNsaWVudE9mZnNldDtcbiAgICB2YXIgdGV0aGVyTWF4ID0gb2Zmc2V0ICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcbiAgICB2YXIgcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKHRldGhlciA/IG1hdGhfbWluKG1pbiwgdGV0aGVyTWluKSA6IG1pbiwgb2Zmc2V0LCB0ZXRoZXIgPyBtYXRoX21heChtYXgsIHRldGhlck1heCkgOiBtYXgpO1xuICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0IC0gb2Zmc2V0O1xuICB9XG5cbiAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyO1xuXG4gICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBlbnVtc190b3AgOiBsZWZ0O1xuXG4gICAgdmFyIF9hbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xuXG4gICAgdmFyIF9vZmZzZXQgPSBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdO1xuXG4gICAgdmFyIF9sZW4gPSBhbHRBeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICB2YXIgX21pbiA9IF9vZmZzZXQgKyBvdmVyZmxvd1tfbWFpblNpZGVdO1xuXG4gICAgdmFyIF9tYXggPSBfb2Zmc2V0IC0gb3ZlcmZsb3dbX2FsdFNpZGVdO1xuXG4gICAgdmFyIGlzT3JpZ2luU2lkZSA9IFtlbnVtc190b3AsIGxlZnRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJDIgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW2FsdEF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkMiA6IDA7XG5cbiAgICB2YXIgX3RldGhlck1pbiA9IGlzT3JpZ2luU2lkZSA/IF9taW4gOiBfb2Zmc2V0IC0gcmVmZXJlbmNlUmVjdFtfbGVuXSAtIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzO1xuXG4gICAgdmFyIF90ZXRoZXJNYXggPSBpc09yaWdpblNpZGUgPyBfb2Zmc2V0ICsgcmVmZXJlbmNlUmVjdFtfbGVuXSArIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzIDogX21heDtcblxuICAgIHZhciBfcHJldmVudGVkT2Zmc2V0ID0gdGV0aGVyICYmIGlzT3JpZ2luU2lkZSA/IHdpdGhpbk1heENsYW1wKF90ZXRoZXJNaW4sIF9vZmZzZXQsIF90ZXRoZXJNYXgpIDogd2l0aGluKHRldGhlciA/IF90ZXRoZXJNaW4gOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBfdGV0aGVyTWF4IDogX21heCk7XG5cbiAgICBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldCAtIF9vZmZzZXQ7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgbW9kaWZpZXJzX3ByZXZlbnRPdmVyZmxvdyA9ICh7XG4gIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogcHJldmVudE92ZXJmbG93LFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2Fycm93LmpzXG5cblxuXG5cblxuXG5cblxuXG4gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdG9QYWRkaW5nT2JqZWN0ID0gZnVuY3Rpb24gdG9QYWRkaW5nT2JqZWN0KHBhZGRpbmcsIHN0YXRlKSB7XG4gIHBhZGRpbmcgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IHBhZGRpbmcoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiBwYWRkaW5nO1xuICByZXR1cm4gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbn07XG5cbmZ1bmN0aW9uIGFycm93KF9yZWYpIHtcbiAgdmFyIF9zdGF0ZSRtb2RpZmllcnNEYXRhJDtcblxuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgYXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGlzVmVydGljYWwgPSBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgaWYgKCFhcnJvd0VsZW1lbnQgfHwgIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFkZGluZ09iamVjdCA9IHRvUGFkZGluZ09iamVjdChvcHRpb25zLnBhZGRpbmcsIHN0YXRlKTtcbiAgdmFyIGFycm93UmVjdCA9IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KTtcbiAgdmFyIG1pblByb3AgPSBheGlzID09PSAneScgPyBlbnVtc190b3AgOiBsZWZ0O1xuICB2YXIgbWF4UHJvcCA9IGF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICB2YXIgZW5kRGlmZiA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtsZW5dICsgc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnBvcHBlcltsZW5dO1xuICB2YXIgc3RhcnREaWZmID0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGFycm93RWxlbWVudCk7XG4gIHZhciBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBheGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoIHx8IDAgOiAwO1xuICB2YXIgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7IC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgcG9wcGVyIGlmIHRoZSBjZW50ZXIgcG9pbnQgaXNcbiAgLy8gb3V0c2lkZSBvZiB0aGUgcG9wcGVyIGJvdW5kc1xuXG4gIHZhciBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xuICB2YXIgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93UmVjdFtsZW5dIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcbiAgdmFyIGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dSZWN0W2xlbl0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gIHZhciBvZmZzZXQgPSB3aXRoaW4obWluLCBjZW50ZXIsIG1heCk7IC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cblxuICB2YXIgYXhpc1Byb3AgPSBheGlzO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gKF9zdGF0ZSRtb2RpZmllcnNEYXRhJCA9IHt9LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSRbYXhpc1Byb3BdID0gb2Zmc2V0LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQuY2VudGVyT2Zmc2V0ID0gb2Zmc2V0IC0gY2VudGVyLCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQpO1xufVxuXG5mdW5jdGlvbiBhcnJvd19lZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXG4gICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50O1xuXG4gIGlmIChhcnJvd0VsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBDU1Mgc2VsZWN0b3JcblxuXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmYWxzZSkge31cblxuICBpZiAoIWNvbnRhaW5zKHN0YXRlLmVsZW1lbnRzLnBvcHBlciwgYXJyb3dFbGVtZW50KSkge1xuICAgIGlmIChmYWxzZSkge31cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0YXRlLmVsZW1lbnRzLmFycm93ID0gYXJyb3dFbGVtZW50O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBtb2RpZmllcnNfYXJyb3cgPSAoe1xuICBuYW1lOiAnYXJyb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogYXJyb3csXG4gIGVmZmVjdDogYXJyb3dfZWZmZWN0LFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J11cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qc1xuXG5cblxuZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3QsIHByZXZlbnRlZE9mZnNldHMpIHtcbiAgaWYgKHByZXZlbnRlZE9mZnNldHMgPT09IHZvaWQgMCkge1xuICAgIHByZXZlbnRlZE9mZnNldHMgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQgLSBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCArIHByZXZlbnRlZE9mZnNldHMueCxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0ICsgcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoIC0gcHJldmVudGVkT2Zmc2V0cy54XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gW2VudW1zX3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF0uc29tZShmdW5jdGlvbiAoc2lkZSkge1xuICAgIHJldHVybiBvdmVyZmxvd1tzaWRlXSA+PSAwO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGlkZShfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBwcmV2ZW50ZWRPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wcmV2ZW50T3ZlcmZsb3c7XG4gIHZhciByZWZlcmVuY2VPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXG4gIH0pO1xuICB2YXIgcG9wcGVyQWx0T3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGFsdEJvdW5kYXJ5OiB0cnVlXG4gIH0pO1xuICB2YXIgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocmVmZXJlbmNlT3ZlcmZsb3csIHJlZmVyZW5jZVJlY3QpO1xuICB2YXIgcG9wcGVyRXNjYXBlT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHBvcHBlckFsdE92ZXJmbG93LCBwb3BwZXJSZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKTtcbiAgdmFyIGlzUmVmZXJlbmNlSGlkZGVuID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyk7XG4gIHZhciBoYXNQb3BwZXJFc2NhcGVkID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHBvcHBlckVzY2FwZU9mZnNldHMpO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0ge1xuICAgIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0czogcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzLFxuICAgIHBvcHBlckVzY2FwZU9mZnNldHM6IHBvcHBlckVzY2FwZU9mZnNldHMsXG4gICAgaXNSZWZlcmVuY2VIaWRkZW46IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgIGhhc1BvcHBlckVzY2FwZWQ6IGhhc1BvcHBlckVzY2FwZWRcbiAgfTtcbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuJzogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgJ2RhdGEtcG9wcGVyLWVzY2FwZWQnOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBtb2RpZmllcnNfaGlkZSA9ICh7XG4gIG5hbWU6ICdoaWRlJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXSxcbiAgZm46IGhpZGVcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXIuanNcblxuXG5cblxuXG5cblxuXG5cblxudmFyIGRlZmF1bHRNb2RpZmllcnMgPSBbZXZlbnRMaXN0ZW5lcnMsIG1vZGlmaWVyc19wb3BwZXJPZmZzZXRzLCBtb2RpZmllcnNfY29tcHV0ZVN0eWxlcywgbW9kaWZpZXJzX2FwcGx5U3R5bGVzLCBtb2RpZmllcnNfb2Zmc2V0LCBtb2RpZmllcnNfZmxpcCwgbW9kaWZpZXJzX3ByZXZlbnRPdmVyZmxvdywgbW9kaWZpZXJzX2Fycm93LCBtb2RpZmllcnNfaGlkZV07XG52YXIgcG9wcGVyX2NyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG4gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG4gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2Ryb3Bkb3duLmpzXG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XG4gIC8vIFRvZ2dsZSBkcm9wZG93biBlbGVtZW50cyB1c2luZyBbZGF0YS1kcm9wZG93bi10b2dnbGVdXG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWRyb3Bkb3duLXRvZ2dsZV0nKS5mb3JFYWNoKGZ1bmN0aW9uIChkcm9wZG93blRvZ2dsZUVsKSB7XG4gICAgdmFyIGRyb3Bkb3duTWVudUlkID0gZHJvcGRvd25Ub2dnbGVFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZHJvcGRvd24tdG9nZ2xlJyk7XG4gICAgdmFyIGRyb3Bkb3duTWVudUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZHJvcGRvd25NZW51SWQpOyAvLyBvcHRpb25zXG5cbiAgICB2YXIgcGxhY2VtZW50ID0gZHJvcGRvd25Ub2dnbGVFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZHJvcGRvd24tcGxhY2VtZW50Jyk7XG4gICAgZHJvcGRvd25Ub2dnbGVFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBldmVudC50YXJnZXQ7XG5cbiAgICAgIHdoaWxlIChlbGVtZW50Lm5vZGVOYW1lICE9PSBcIkJVVFRPTlwiKSB7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG5cbiAgICAgIHBvcHBlcl9jcmVhdGVQb3BwZXIoZWxlbWVudCwgZHJvcGRvd25NZW51RWwsIHtcbiAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQgPyBwbGFjZW1lbnQgOiAnYm90dG9tLXN0YXJ0JyxcbiAgICAgICAgbW9kaWZpZXJzOiBbe1xuICAgICAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9mZnNldDogWzAsIDEwXVxuICAgICAgICAgIH1cbiAgICAgICAgfV1cbiAgICAgIH0pOyAvLyB0b2dnbGUgd2hlbiBjbGljayBvbiB0aGUgYnV0dG9uXG5cbiAgICAgIGRyb3Bkb3duTWVudUVsLmNsYXNzTGlzdC50b2dnbGUoJ2hpZGRlbicpO1xuICAgICAgZHJvcGRvd25NZW51RWwuY2xhc3NMaXN0LnRvZ2dsZSgnYmxvY2snKTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlRHJvcGRvd25PdXRzaWRlQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgdmFyIHRhcmdldEVsZW1lbnQgPSBldmVudC50YXJnZXQ7IC8vIGNsaWNrZWQgZWxlbWVudFxuXG4gICAgICAgIGlmICh0YXJnZXRFbGVtZW50ICE9PSBkcm9wZG93bk1lbnVFbCAmJiB0YXJnZXRFbGVtZW50ICE9PSBkcm9wZG93blRvZ2dsZUVsICYmICFkcm9wZG93blRvZ2dsZUVsLmNvbnRhaW5zKHRhcmdldEVsZW1lbnQpKSB7XG4gICAgICAgICAgZHJvcGRvd25NZW51RWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgICAgZHJvcGRvd25NZW51RWwuY2xhc3NMaXN0LnJlbW92ZSgnYmxvY2snKTtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlRHJvcGRvd25PdXRzaWRlQ2xpY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGhpZGUgcG9wcGVyIHdoZW4gY2xpY2tpbmcgb3V0c2lkZSB0aGUgZWxlbWVudFxuXG5cbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVEcm9wZG93bk91dHNpZGVDbGljaywgdHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdGFicy5qc1xudmFyIHRhYnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9tb2RhbC5qc1xudmFyIG1vZGFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NCk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy90b29sdGlwLmpzXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xuICAvLyBUb2dnbGUgZHJvcGRvd24gZWxlbWVudHMgdXNpbmcgW2RhdGEtZHJvcGRvd24tdG9nZ2xlXVxuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS10b29sdGlwLXRhcmdldF0nKS5mb3JFYWNoKGZ1bmN0aW9uICh0b29sdGlwVG9nZ2xlRWwpIHtcbiAgICB2YXIgdG9vbHRpcEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodG9vbHRpcFRvZ2dsZUVsLmdldEF0dHJpYnV0ZSgnZGF0YS10b29sdGlwLXRhcmdldCcpKTtcbiAgICB2YXIgcGxhY2VtZW50ID0gdG9vbHRpcFRvZ2dsZUVsLmdldEF0dHJpYnV0ZSgnZGF0YS10b29sdGlwLXBsYWNlbWVudCcpO1xuICAgIHZhciB0cmlnZ2VyID0gdG9vbHRpcFRvZ2dsZUVsLmdldEF0dHJpYnV0ZSgnZGF0YS10b29sdGlwLXRyaWdnZXInKTtcbiAgICB2YXIgcG9wcGVySW5zdGFuY2UgPSBwb3BwZXJfY3JlYXRlUG9wcGVyKHRvb2x0aXBUb2dnbGVFbCwgdG9vbHRpcEVsLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCA/IHBsYWNlbWVudCA6ICd0b3AnLFxuICAgICAgbW9kaWZpZXJzOiBbe1xuICAgICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIG9mZnNldDogWzAsIDhdXG4gICAgICAgIH1cbiAgICAgIH1dXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgLy8gTWFrZSB0aGUgdG9vbHRpcCB2aXNpYmxlXG4gICAgICB0b29sdGlwRWwuY2xhc3NMaXN0LnJlbW92ZSgnb3BhY2l0eS0wJyk7XG4gICAgICB0b29sdGlwRWwuY2xhc3NMaXN0LmFkZCgnb3BhY2l0eS0xMDAnKTtcbiAgICAgIHRvb2x0aXBFbC5jbGFzc0xpc3QucmVtb3ZlKCdpbnZpc2libGUnKTtcbiAgICAgIHRvb2x0aXBFbC5jbGFzc0xpc3QuYWRkKCd2aXNpYmxlJyk7IC8vIEVuYWJsZSB0aGUgZXZlbnQgbGlzdGVuZXJzXG5cbiAgICAgIHBvcHBlckluc3RhbmNlLnNldE9wdGlvbnMoZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgbW9kaWZpZXJzOiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG9wdGlvbnMubW9kaWZpZXJzKSwgW3tcbiAgICAgICAgICAgIG5hbWU6ICdldmVudExpc3RlbmVycycsXG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgICAgfV0pXG4gICAgICAgIH0pO1xuICAgICAgfSk7IC8vIFVwZGF0ZSBpdHMgcG9zaXRpb25cblxuICAgICAgcG9wcGVySW5zdGFuY2UudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgIC8vIEhpZGUgdGhlIHRvb2x0aXBcbiAgICAgIHRvb2x0aXBFbC5jbGFzc0xpc3QucmVtb3ZlKCdvcGFjaXR5LTEwMCcpO1xuICAgICAgdG9vbHRpcEVsLmNsYXNzTGlzdC5hZGQoJ29wYWNpdHktMCcpO1xuICAgICAgdG9vbHRpcEVsLmNsYXNzTGlzdC5yZW1vdmUoJ3Zpc2libGUnKTtcbiAgICAgIHRvb2x0aXBFbC5jbGFzc0xpc3QuYWRkKCdpbnZpc2libGUnKTsgLy8gRGlzYWJsZSB0aGUgZXZlbnQgbGlzdGVuZXJzXG5cbiAgICAgIHBvcHBlckluc3RhbmNlLnNldE9wdGlvbnMoZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgbW9kaWZpZXJzOiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG9wdGlvbnMubW9kaWZpZXJzKSwgW3tcbiAgICAgICAgICAgIG5hbWU6ICdldmVudExpc3RlbmVycycsXG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgIH1dKVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBzaG93RXZlbnRzID0gW107XG4gICAgdmFyIGhpZGVFdmVudHMgPSBbXTtcblxuICAgIHN3aXRjaCAodHJpZ2dlcikge1xuICAgICAgY2FzZSAnaG92ZXInOlxuICAgICAgICBzaG93RXZlbnRzID0gWydtb3VzZWVudGVyJywgJ2ZvY3VzJ107XG4gICAgICAgIGhpZGVFdmVudHMgPSBbJ21vdXNlbGVhdmUnLCAnYmx1ciddO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnY2xpY2snOlxuICAgICAgICBzaG93RXZlbnRzID0gWydjbGljaycsICdmb2N1cyddO1xuICAgICAgICBoaWRlRXZlbnRzID0gWydmb2N1c291dCcsICdibHVyJ107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzaG93RXZlbnRzID0gWydtb3VzZWVudGVyJywgJ2ZvY3VzJ107XG4gICAgICAgIGhpZGVFdmVudHMgPSBbJ21vdXNlbGVhdmUnLCAnYmx1ciddO1xuICAgIH1cblxuICAgIHNob3dFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHRvb2x0aXBUb2dnbGVFbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBzaG93KTtcbiAgICB9KTtcbiAgICBoaWRlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB0b29sdGlwVG9nZ2xlRWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGlkZSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvZmxvd2JpdGUuanNcbiAvLyBjb3JlIGNvbXBvbmVudHNcblxuXG5cblxuXG5cblxuXG59KSgpO1xuXG4vKioqKioqLyB9KSgpXG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mbG93Yml0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/flowbite/dist/flowbite.js\n");

/***/ }),

/***/ "./resources/sass/app.scss":
/*!*********************************!*\
  !*** ./resources/sass/app.scss ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvc2Fzcy9hcHAuc2Nzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Fzcy9hcHAuc2Nzcz9hOTdiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/sass/app.scss\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/app": 0,
/******/ 			"css/app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/js/app.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/sass/app.scss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;