/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/alpinejs/dist/module.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/alpinejs/dist/module.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ module_default)\n/* harmony export */ });\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", {value: true});\nvar __commonJS = (callback, module) => () => {\n  if (!module) {\n    module = {exports: {}};\n    callback(module.exports, module);\n  }\n  return module.exports;\n};\nvar __exportStar = (target, module, desc) => {\n  if (module && typeof module === \"object\" || typeof module === \"function\") {\n    for (let key of __getOwnPropNames(module))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, {get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable});\n  }\n  return target;\n};\nvar __toModule = (module) => {\n  return __exportStar(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, \"default\", module && module.__esModule && \"default\" in module ? {get: () => module.default, enumerable: true} : {value: module, enumerable: true})), module);\n};\n\n// node_modules/@vue/shared/dist/shared.cjs.js\nvar require_shared_cjs = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  function makeMap(str, expectsLowerCase) {\n    const map = Object.create(null);\n    const list = str.split(\",\");\n    for (let i = 0; i < list.length; i++) {\n      map[list[i]] = true;\n    }\n    return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];\n  }\n  var PatchFlagNames = {\n    [1]: `TEXT`,\n    [2]: `CLASS`,\n    [4]: `STYLE`,\n    [8]: `PROPS`,\n    [16]: `FULL_PROPS`,\n    [32]: `HYDRATE_EVENTS`,\n    [64]: `STABLE_FRAGMENT`,\n    [128]: `KEYED_FRAGMENT`,\n    [256]: `UNKEYED_FRAGMENT`,\n    [512]: `NEED_PATCH`,\n    [1024]: `DYNAMIC_SLOTS`,\n    [2048]: `DEV_ROOT_FRAGMENT`,\n    [-1]: `HOISTED`,\n    [-2]: `BAIL`\n  };\n  var slotFlagsText = {\n    [1]: \"STABLE\",\n    [2]: \"DYNAMIC\",\n    [3]: \"FORWARDED\"\n  };\n  var GLOBALS_WHITE_LISTED = \"Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt\";\n  var isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);\n  var range = 2;\n  function generateCodeFrame(source, start2 = 0, end = source.length) {\n    const lines = source.split(/\\r?\\n/);\n    let count = 0;\n    const res = [];\n    for (let i = 0; i < lines.length; i++) {\n      count += lines[i].length + 1;\n      if (count >= start2) {\n        for (let j = i - range; j <= i + range || end > count; j++) {\n          if (j < 0 || j >= lines.length)\n            continue;\n          const line = j + 1;\n          res.push(`${line}${\" \".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\n          const lineLength = lines[j].length;\n          if (j === i) {\n            const pad = start2 - (count - lineLength) + 1;\n            const length = Math.max(1, end > count ? lineLength - pad : end - start2);\n            res.push(`   |  ` + \" \".repeat(pad) + \"^\".repeat(length));\n          } else if (j > i) {\n            if (end > count) {\n              const length = Math.max(Math.min(end - count, lineLength), 1);\n              res.push(`   |  ` + \"^\".repeat(length));\n            }\n            count += lineLength + 1;\n          }\n        }\n        break;\n      }\n    }\n    return res.join(\"\\n\");\n  }\n  var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\n  var isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);\n  var isBooleanAttr2 = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);\n  var unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\n  var attrValidationCache = {};\n  function isSSRSafeAttrName(name) {\n    if (attrValidationCache.hasOwnProperty(name)) {\n      return attrValidationCache[name];\n    }\n    const isUnsafe = unsafeAttrCharRE.test(name);\n    if (isUnsafe) {\n      console.error(`unsafe attribute name: ${name}`);\n    }\n    return attrValidationCache[name] = !isUnsafe;\n  }\n  var propsToAttrMap = {\n    acceptCharset: \"accept-charset\",\n    className: \"class\",\n    htmlFor: \"for\",\n    httpEquiv: \"http-equiv\"\n  };\n  var isNoUnitNumericStyleProp = /* @__PURE__ */ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-miterlimit,stroke-opacity,stroke-width`);\n  var isKnownAttr = /* @__PURE__ */ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);\n  function normalizeStyle(value) {\n    if (isArray(value)) {\n      const res = {};\n      for (let i = 0; i < value.length; i++) {\n        const item = value[i];\n        const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);\n        if (normalized) {\n          for (const key in normalized) {\n            res[key] = normalized[key];\n          }\n        }\n      }\n      return res;\n    } else if (isObject(value)) {\n      return value;\n    }\n  }\n  var listDelimiterRE = /;(?![^(]*\\))/g;\n  var propertyDelimiterRE = /:(.+)/;\n  function parseStringStyle(cssText) {\n    const ret = {};\n    cssText.split(listDelimiterRE).forEach((item) => {\n      if (item) {\n        const tmp = item.split(propertyDelimiterRE);\n        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n      }\n    });\n    return ret;\n  }\n  function stringifyStyle(styles) {\n    let ret = \"\";\n    if (!styles) {\n      return ret;\n    }\n    for (const key in styles) {\n      const value = styles[key];\n      const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n      if (isString(value) || typeof value === \"number\" && isNoUnitNumericStyleProp(normalizedKey)) {\n        ret += `${normalizedKey}:${value};`;\n      }\n    }\n    return ret;\n  }\n  function normalizeClass(value) {\n    let res = \"\";\n    if (isString(value)) {\n      res = value;\n    } else if (isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        const normalized = normalizeClass(value[i]);\n        if (normalized) {\n          res += normalized + \" \";\n        }\n      }\n    } else if (isObject(value)) {\n      for (const name in value) {\n        if (value[name]) {\n          res += name + \" \";\n        }\n      }\n    }\n    return res.trim();\n  }\n  var HTML_TAGS = \"html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot\";\n  var SVG_TAGS = \"svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view\";\n  var VOID_TAGS = \"area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr\";\n  var isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);\n  var isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);\n  var isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);\n  var escapeRE = /[\"'&<>]/;\n  function escapeHtml(string) {\n    const str = \"\" + string;\n    const match = escapeRE.exec(str);\n    if (!match) {\n      return str;\n    }\n    let html = \"\";\n    let escaped;\n    let index;\n    let lastIndex = 0;\n    for (index = match.index; index < str.length; index++) {\n      switch (str.charCodeAt(index)) {\n        case 34:\n          escaped = \"&quot;\";\n          break;\n        case 38:\n          escaped = \"&amp;\";\n          break;\n        case 39:\n          escaped = \"&#39;\";\n          break;\n        case 60:\n          escaped = \"&lt;\";\n          break;\n        case 62:\n          escaped = \"&gt;\";\n          break;\n        default:\n          continue;\n      }\n      if (lastIndex !== index) {\n        html += str.substring(lastIndex, index);\n      }\n      lastIndex = index + 1;\n      html += escaped;\n    }\n    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;\n  }\n  var commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\n  function escapeHtmlComment(src) {\n    return src.replace(commentStripRE, \"\");\n  }\n  function looseCompareArrays(a, b) {\n    if (a.length !== b.length)\n      return false;\n    let equal = true;\n    for (let i = 0; equal && i < a.length; i++) {\n      equal = looseEqual(a[i], b[i]);\n    }\n    return equal;\n  }\n  function looseEqual(a, b) {\n    if (a === b)\n      return true;\n    let aValidType = isDate(a);\n    let bValidType = isDate(b);\n    if (aValidType || bValidType) {\n      return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n    }\n    aValidType = isArray(a);\n    bValidType = isArray(b);\n    if (aValidType || bValidType) {\n      return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n    }\n    aValidType = isObject(a);\n    bValidType = isObject(b);\n    if (aValidType || bValidType) {\n      if (!aValidType || !bValidType) {\n        return false;\n      }\n      const aKeysCount = Object.keys(a).length;\n      const bKeysCount = Object.keys(b).length;\n      if (aKeysCount !== bKeysCount) {\n        return false;\n      }\n      for (const key in a) {\n        const aHasKey = a.hasOwnProperty(key);\n        const bHasKey = b.hasOwnProperty(key);\n        if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {\n          return false;\n        }\n      }\n    }\n    return String(a) === String(b);\n  }\n  function looseIndexOf(arr, val) {\n    return arr.findIndex((item) => looseEqual(item, val));\n  }\n  var toDisplayString = (val) => {\n    return val == null ? \"\" : isObject(val) ? JSON.stringify(val, replacer, 2) : String(val);\n  };\n  var replacer = (_key, val) => {\n    if (isMap(val)) {\n      return {\n        [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {\n          entries[`${key} =>`] = val2;\n          return entries;\n        }, {})\n      };\n    } else if (isSet(val)) {\n      return {\n        [`Set(${val.size})`]: [...val.values()]\n      };\n    } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n      return String(val);\n    }\n    return val;\n  };\n  var babelParserDefaultPlugins = [\n    \"bigInt\",\n    \"optionalChaining\",\n    \"nullishCoalescingOperator\"\n  ];\n  var EMPTY_OBJ = Object.freeze({});\n  var EMPTY_ARR = Object.freeze([]);\n  var NOOP = () => {\n  };\n  var NO = () => false;\n  var onRE = /^on[^a-z]/;\n  var isOn = (key) => onRE.test(key);\n  var isModelListener = (key) => key.startsWith(\"onUpdate:\");\n  var extend = Object.assign;\n  var remove = (arr, el) => {\n    const i = arr.indexOf(el);\n    if (i > -1) {\n      arr.splice(i, 1);\n    }\n  };\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  var hasOwn = (val, key) => hasOwnProperty.call(val, key);\n  var isArray = Array.isArray;\n  var isMap = (val) => toTypeString(val) === \"[object Map]\";\n  var isSet = (val) => toTypeString(val) === \"[object Set]\";\n  var isDate = (val) => val instanceof Date;\n  var isFunction = (val) => typeof val === \"function\";\n  var isString = (val) => typeof val === \"string\";\n  var isSymbol = (val) => typeof val === \"symbol\";\n  var isObject = (val) => val !== null && typeof val === \"object\";\n  var isPromise = (val) => {\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\n  };\n  var objectToString = Object.prototype.toString;\n  var toTypeString = (value) => objectToString.call(value);\n  var toRawType = (value) => {\n    return toTypeString(value).slice(8, -1);\n  };\n  var isPlainObject = (val) => toTypeString(val) === \"[object Object]\";\n  var isIntegerKey = (key) => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && \"\" + parseInt(key, 10) === key;\n  var isReservedProp = /* @__PURE__ */ makeMap(\",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted\");\n  var cacheStringFunction = (fn) => {\n    const cache = Object.create(null);\n    return (str) => {\n      const hit = cache[str];\n      return hit || (cache[str] = fn(str));\n    };\n  };\n  var camelizeRE = /-(\\w)/g;\n  var camelize = cacheStringFunction((str) => {\n    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n  });\n  var hyphenateRE = /\\B([A-Z])/g;\n  var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \"-$1\").toLowerCase());\n  var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\n  var toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);\n  var hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\n  var invokeArrayFns = (fns, arg) => {\n    for (let i = 0; i < fns.length; i++) {\n      fns[i](arg);\n    }\n  };\n  var def = (obj, key, value) => {\n    Object.defineProperty(obj, key, {\n      configurable: true,\n      enumerable: false,\n      value\n    });\n  };\n  var toNumber = (val) => {\n    const n = parseFloat(val);\n    return isNaN(n) ? val : n;\n  };\n  var _globalThis;\n  var getGlobalThis = () => {\n    return _globalThis || (_globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof __webpack_require__.g !== \"undefined\" ? __webpack_require__.g : {});\n  };\n  exports.EMPTY_ARR = EMPTY_ARR;\n  exports.EMPTY_OBJ = EMPTY_OBJ;\n  exports.NO = NO;\n  exports.NOOP = NOOP;\n  exports.PatchFlagNames = PatchFlagNames;\n  exports.babelParserDefaultPlugins = babelParserDefaultPlugins;\n  exports.camelize = camelize;\n  exports.capitalize = capitalize;\n  exports.def = def;\n  exports.escapeHtml = escapeHtml;\n  exports.escapeHtmlComment = escapeHtmlComment;\n  exports.extend = extend;\n  exports.generateCodeFrame = generateCodeFrame;\n  exports.getGlobalThis = getGlobalThis;\n  exports.hasChanged = hasChanged;\n  exports.hasOwn = hasOwn;\n  exports.hyphenate = hyphenate;\n  exports.invokeArrayFns = invokeArrayFns;\n  exports.isArray = isArray;\n  exports.isBooleanAttr = isBooleanAttr2;\n  exports.isDate = isDate;\n  exports.isFunction = isFunction;\n  exports.isGloballyWhitelisted = isGloballyWhitelisted;\n  exports.isHTMLTag = isHTMLTag;\n  exports.isIntegerKey = isIntegerKey;\n  exports.isKnownAttr = isKnownAttr;\n  exports.isMap = isMap;\n  exports.isModelListener = isModelListener;\n  exports.isNoUnitNumericStyleProp = isNoUnitNumericStyleProp;\n  exports.isObject = isObject;\n  exports.isOn = isOn;\n  exports.isPlainObject = isPlainObject;\n  exports.isPromise = isPromise;\n  exports.isReservedProp = isReservedProp;\n  exports.isSSRSafeAttrName = isSSRSafeAttrName;\n  exports.isSVGTag = isSVGTag;\n  exports.isSet = isSet;\n  exports.isSpecialBooleanAttr = isSpecialBooleanAttr;\n  exports.isString = isString;\n  exports.isSymbol = isSymbol;\n  exports.isVoidTag = isVoidTag;\n  exports.looseEqual = looseEqual;\n  exports.looseIndexOf = looseIndexOf;\n  exports.makeMap = makeMap;\n  exports.normalizeClass = normalizeClass;\n  exports.normalizeStyle = normalizeStyle;\n  exports.objectToString = objectToString;\n  exports.parseStringStyle = parseStringStyle;\n  exports.propsToAttrMap = propsToAttrMap;\n  exports.remove = remove;\n  exports.slotFlagsText = slotFlagsText;\n  exports.stringifyStyle = stringifyStyle;\n  exports.toDisplayString = toDisplayString;\n  exports.toHandlerKey = toHandlerKey;\n  exports.toNumber = toNumber;\n  exports.toRawType = toRawType;\n  exports.toTypeString = toTypeString;\n});\n\n// node_modules/@vue/shared/index.js\nvar require_shared = __commonJS((exports, module) => {\n  \"use strict\";\n  if (false) {} else {\n    module.exports = require_shared_cjs();\n  }\n});\n\n// node_modules/@vue/reactivity/dist/reactivity.cjs.js\nvar require_reactivity_cjs = __commonJS((exports) => {\n  \"use strict\";\n  Object.defineProperty(exports, \"__esModule\", {value: true});\n  var shared = require_shared();\n  var targetMap = new WeakMap();\n  var effectStack = [];\n  var activeEffect;\n  var ITERATE_KEY = Symbol(\"iterate\");\n  var MAP_KEY_ITERATE_KEY = Symbol(\"Map key iterate\");\n  function isEffect(fn) {\n    return fn && fn._isEffect === true;\n  }\n  function effect3(fn, options = shared.EMPTY_OBJ) {\n    if (isEffect(fn)) {\n      fn = fn.raw;\n    }\n    const effect4 = createReactiveEffect(fn, options);\n    if (!options.lazy) {\n      effect4();\n    }\n    return effect4;\n  }\n  function stop2(effect4) {\n    if (effect4.active) {\n      cleanup(effect4);\n      if (effect4.options.onStop) {\n        effect4.options.onStop();\n      }\n      effect4.active = false;\n    }\n  }\n  var uid = 0;\n  function createReactiveEffect(fn, options) {\n    const effect4 = function reactiveEffect() {\n      if (!effect4.active) {\n        return fn();\n      }\n      if (!effectStack.includes(effect4)) {\n        cleanup(effect4);\n        try {\n          enableTracking();\n          effectStack.push(effect4);\n          activeEffect = effect4;\n          return fn();\n        } finally {\n          effectStack.pop();\n          resetTracking();\n          activeEffect = effectStack[effectStack.length - 1];\n        }\n      }\n    };\n    effect4.id = uid++;\n    effect4.allowRecurse = !!options.allowRecurse;\n    effect4._isEffect = true;\n    effect4.active = true;\n    effect4.raw = fn;\n    effect4.deps = [];\n    effect4.options = options;\n    return effect4;\n  }\n  function cleanup(effect4) {\n    const {deps} = effect4;\n    if (deps.length) {\n      for (let i = 0; i < deps.length; i++) {\n        deps[i].delete(effect4);\n      }\n      deps.length = 0;\n    }\n  }\n  var shouldTrack = true;\n  var trackStack = [];\n  function pauseTracking() {\n    trackStack.push(shouldTrack);\n    shouldTrack = false;\n  }\n  function enableTracking() {\n    trackStack.push(shouldTrack);\n    shouldTrack = true;\n  }\n  function resetTracking() {\n    const last = trackStack.pop();\n    shouldTrack = last === void 0 ? true : last;\n  }\n  function track(target, type, key) {\n    if (!shouldTrack || activeEffect === void 0) {\n      return;\n    }\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = new Set());\n    }\n    if (!dep.has(activeEffect)) {\n      dep.add(activeEffect);\n      activeEffect.deps.push(dep);\n      if (activeEffect.options.onTrack) {\n        activeEffect.options.onTrack({\n          effect: activeEffect,\n          target,\n          type,\n          key\n        });\n      }\n    }\n  }\n  function trigger(target, type, key, newValue, oldValue, oldTarget) {\n    const depsMap = targetMap.get(target);\n    if (!depsMap) {\n      return;\n    }\n    const effects = new Set();\n    const add2 = (effectsToAdd) => {\n      if (effectsToAdd) {\n        effectsToAdd.forEach((effect4) => {\n          if (effect4 !== activeEffect || effect4.allowRecurse) {\n            effects.add(effect4);\n          }\n        });\n      }\n    };\n    if (type === \"clear\") {\n      depsMap.forEach(add2);\n    } else if (key === \"length\" && shared.isArray(target)) {\n      depsMap.forEach((dep, key2) => {\n        if (key2 === \"length\" || key2 >= newValue) {\n          add2(dep);\n        }\n      });\n    } else {\n      if (key !== void 0) {\n        add2(depsMap.get(key));\n      }\n      switch (type) {\n        case \"add\":\n          if (!shared.isArray(target)) {\n            add2(depsMap.get(ITERATE_KEY));\n            if (shared.isMap(target)) {\n              add2(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          } else if (shared.isIntegerKey(key)) {\n            add2(depsMap.get(\"length\"));\n          }\n          break;\n        case \"delete\":\n          if (!shared.isArray(target)) {\n            add2(depsMap.get(ITERATE_KEY));\n            if (shared.isMap(target)) {\n              add2(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          }\n          break;\n        case \"set\":\n          if (shared.isMap(target)) {\n            add2(depsMap.get(ITERATE_KEY));\n          }\n          break;\n      }\n    }\n    const run = (effect4) => {\n      if (effect4.options.onTrigger) {\n        effect4.options.onTrigger({\n          effect: effect4,\n          target,\n          key,\n          type,\n          newValue,\n          oldValue,\n          oldTarget\n        });\n      }\n      if (effect4.options.scheduler) {\n        effect4.options.scheduler(effect4);\n      } else {\n        effect4();\n      }\n    };\n    effects.forEach(run);\n  }\n  var isNonTrackableKeys = /* @__PURE__ */ shared.makeMap(`__proto__,__v_isRef,__isVue`);\n  var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(shared.isSymbol));\n  var get2 = /* @__PURE__ */ createGetter();\n  var shallowGet = /* @__PURE__ */ createGetter(false, true);\n  var readonlyGet = /* @__PURE__ */ createGetter(true);\n  var shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);\n  var arrayInstrumentations = {};\n  [\"includes\", \"indexOf\", \"lastIndexOf\"].forEach((key) => {\n    const method = Array.prototype[key];\n    arrayInstrumentations[key] = function(...args) {\n      const arr = toRaw2(this);\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, \"get\", i + \"\");\n      }\n      const res = method.apply(arr, args);\n      if (res === -1 || res === false) {\n        return method.apply(arr, args.map(toRaw2));\n      } else {\n        return res;\n      }\n    };\n  });\n  [\"push\", \"pop\", \"shift\", \"unshift\", \"splice\"].forEach((key) => {\n    const method = Array.prototype[key];\n    arrayInstrumentations[key] = function(...args) {\n      pauseTracking();\n      const res = method.apply(this, args);\n      resetTracking();\n      return res;\n    };\n  });\n  function createGetter(isReadonly2 = false, shallow = false) {\n    return function get3(target, key, receiver) {\n      if (key === \"__v_isReactive\") {\n        return !isReadonly2;\n      } else if (key === \"__v_isReadonly\") {\n        return isReadonly2;\n      } else if (key === \"__v_raw\" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\n        return target;\n      }\n      const targetIsArray = shared.isArray(target);\n      if (!isReadonly2 && targetIsArray && shared.hasOwn(arrayInstrumentations, key)) {\n        return Reflect.get(arrayInstrumentations, key, receiver);\n      }\n      const res = Reflect.get(target, key, receiver);\n      if (shared.isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n        return res;\n      }\n      if (!isReadonly2) {\n        track(target, \"get\", key);\n      }\n      if (shallow) {\n        return res;\n      }\n      if (isRef(res)) {\n        const shouldUnwrap = !targetIsArray || !shared.isIntegerKey(key);\n        return shouldUnwrap ? res.value : res;\n      }\n      if (shared.isObject(res)) {\n        return isReadonly2 ? readonly(res) : reactive3(res);\n      }\n      return res;\n    };\n  }\n  var set2 = /* @__PURE__ */ createSetter();\n  var shallowSet = /* @__PURE__ */ createSetter(true);\n  function createSetter(shallow = false) {\n    return function set3(target, key, value, receiver) {\n      let oldValue = target[key];\n      if (!shallow) {\n        value = toRaw2(value);\n        oldValue = toRaw2(oldValue);\n        if (!shared.isArray(target) && isRef(oldValue) && !isRef(value)) {\n          oldValue.value = value;\n          return true;\n        }\n      }\n      const hadKey = shared.isArray(target) && shared.isIntegerKey(key) ? Number(key) < target.length : shared.hasOwn(target, key);\n      const result = Reflect.set(target, key, value, receiver);\n      if (target === toRaw2(receiver)) {\n        if (!hadKey) {\n          trigger(target, \"add\", key, value);\n        } else if (shared.hasChanged(value, oldValue)) {\n          trigger(target, \"set\", key, value, oldValue);\n        }\n      }\n      return result;\n    };\n  }\n  function deleteProperty(target, key) {\n    const hadKey = shared.hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n      trigger(target, \"delete\", key, void 0, oldValue);\n    }\n    return result;\n  }\n  function has(target, key) {\n    const result = Reflect.has(target, key);\n    if (!shared.isSymbol(key) || !builtInSymbols.has(key)) {\n      track(target, \"has\", key);\n    }\n    return result;\n  }\n  function ownKeys(target) {\n    track(target, \"iterate\", shared.isArray(target) ? \"length\" : ITERATE_KEY);\n    return Reflect.ownKeys(target);\n  }\n  var mutableHandlers = {\n    get: get2,\n    set: set2,\n    deleteProperty,\n    has,\n    ownKeys\n  };\n  var readonlyHandlers = {\n    get: readonlyGet,\n    set(target, key) {\n      {\n        console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n      }\n      return true;\n    },\n    deleteProperty(target, key) {\n      {\n        console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n      }\n      return true;\n    }\n  };\n  var shallowReactiveHandlers = shared.extend({}, mutableHandlers, {\n    get: shallowGet,\n    set: shallowSet\n  });\n  var shallowReadonlyHandlers = shared.extend({}, readonlyHandlers, {\n    get: shallowReadonlyGet\n  });\n  var toReactive = (value) => shared.isObject(value) ? reactive3(value) : value;\n  var toReadonly = (value) => shared.isObject(value) ? readonly(value) : value;\n  var toShallow = (value) => value;\n  var getProto = (v) => Reflect.getPrototypeOf(v);\n  function get$1(target, key, isReadonly2 = false, isShallow = false) {\n    target = target[\"__v_raw\"];\n    const rawTarget = toRaw2(target);\n    const rawKey = toRaw2(key);\n    if (key !== rawKey) {\n      !isReadonly2 && track(rawTarget, \"get\", key);\n    }\n    !isReadonly2 && track(rawTarget, \"get\", rawKey);\n    const {has: has2} = getProto(rawTarget);\n    const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;\n    if (has2.call(rawTarget, key)) {\n      return wrap(target.get(key));\n    } else if (has2.call(rawTarget, rawKey)) {\n      return wrap(target.get(rawKey));\n    } else if (target !== rawTarget) {\n      target.get(key);\n    }\n  }\n  function has$1(key, isReadonly2 = false) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw2(target);\n    const rawKey = toRaw2(key);\n    if (key !== rawKey) {\n      !isReadonly2 && track(rawTarget, \"has\", key);\n    }\n    !isReadonly2 && track(rawTarget, \"has\", rawKey);\n    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n  }\n  function size(target, isReadonly2 = false) {\n    target = target[\"__v_raw\"];\n    !isReadonly2 && track(toRaw2(target), \"iterate\", ITERATE_KEY);\n    return Reflect.get(target, \"size\", target);\n  }\n  function add(value) {\n    value = toRaw2(value);\n    const target = toRaw2(this);\n    const proto = getProto(target);\n    const hadKey = proto.has.call(target, value);\n    if (!hadKey) {\n      target.add(value);\n      trigger(target, \"add\", value, value);\n    }\n    return this;\n  }\n  function set$1(key, value) {\n    value = toRaw2(value);\n    const target = toRaw2(this);\n    const {has: has2, get: get3} = getProto(target);\n    let hadKey = has2.call(target, key);\n    if (!hadKey) {\n      key = toRaw2(key);\n      hadKey = has2.call(target, key);\n    } else {\n      checkIdentityKeys(target, has2, key);\n    }\n    const oldValue = get3.call(target, key);\n    target.set(key, value);\n    if (!hadKey) {\n      trigger(target, \"add\", key, value);\n    } else if (shared.hasChanged(value, oldValue)) {\n      trigger(target, \"set\", key, value, oldValue);\n    }\n    return this;\n  }\n  function deleteEntry(key) {\n    const target = toRaw2(this);\n    const {has: has2, get: get3} = getProto(target);\n    let hadKey = has2.call(target, key);\n    if (!hadKey) {\n      key = toRaw2(key);\n      hadKey = has2.call(target, key);\n    } else {\n      checkIdentityKeys(target, has2, key);\n    }\n    const oldValue = get3 ? get3.call(target, key) : void 0;\n    const result = target.delete(key);\n    if (hadKey) {\n      trigger(target, \"delete\", key, void 0, oldValue);\n    }\n    return result;\n  }\n  function clear() {\n    const target = toRaw2(this);\n    const hadItems = target.size !== 0;\n    const oldTarget = shared.isMap(target) ? new Map(target) : new Set(target);\n    const result = target.clear();\n    if (hadItems) {\n      trigger(target, \"clear\", void 0, void 0, oldTarget);\n    }\n    return result;\n  }\n  function createForEach(isReadonly2, isShallow) {\n    return function forEach(callback, thisArg) {\n      const observed = this;\n      const target = observed[\"__v_raw\"];\n      const rawTarget = toRaw2(target);\n      const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;\n      !isReadonly2 && track(rawTarget, \"iterate\", ITERATE_KEY);\n      return target.forEach((value, key) => {\n        return callback.call(thisArg, wrap(value), wrap(key), observed);\n      });\n    };\n  }\n  function createIterableMethod(method, isReadonly2, isShallow) {\n    return function(...args) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw2(target);\n      const targetIsMap = shared.isMap(rawTarget);\n      const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n      const isKeyOnly = method === \"keys\" && targetIsMap;\n      const innerIterator = target[method](...args);\n      const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;\n      !isReadonly2 && track(rawTarget, \"iterate\", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n      return {\n        next() {\n          const {value, done} = innerIterator.next();\n          return done ? {value, done} : {\n            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n            done\n          };\n        },\n        [Symbol.iterator]() {\n          return this;\n        }\n      };\n    };\n  }\n  function createReadonlyMethod(type) {\n    return function(...args) {\n      {\n        const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n        console.warn(`${shared.capitalize(type)} operation ${key}failed: target is readonly.`, toRaw2(this));\n      }\n      return type === \"delete\" ? false : this;\n    };\n  }\n  var mutableInstrumentations = {\n    get(key) {\n      return get$1(this, key);\n    },\n    get size() {\n      return size(this);\n    },\n    has: has$1,\n    add,\n    set: set$1,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  var shallowInstrumentations = {\n    get(key) {\n      return get$1(this, key, false, true);\n    },\n    get size() {\n      return size(this);\n    },\n    has: has$1,\n    add,\n    set: set$1,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  var readonlyInstrumentations = {\n    get(key) {\n      return get$1(this, key, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has$1.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, false)\n  };\n  var shallowReadonlyInstrumentations = {\n    get(key) {\n      return get$1(this, key, true, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has$1.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, true)\n  };\n  var iteratorMethods = [\"keys\", \"values\", \"entries\", Symbol.iterator];\n  iteratorMethods.forEach((method) => {\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\n    shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\n  });\n  function createInstrumentationGetter(isReadonly2, shallow) {\n    const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;\n    return (target, key, receiver) => {\n      if (key === \"__v_isReactive\") {\n        return !isReadonly2;\n      } else if (key === \"__v_isReadonly\") {\n        return isReadonly2;\n      } else if (key === \"__v_raw\") {\n        return target;\n      }\n      return Reflect.get(shared.hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n    };\n  }\n  var mutableCollectionHandlers = {\n    get: createInstrumentationGetter(false, false)\n  };\n  var shallowCollectionHandlers = {\n    get: createInstrumentationGetter(false, true)\n  };\n  var readonlyCollectionHandlers = {\n    get: createInstrumentationGetter(true, false)\n  };\n  var shallowReadonlyCollectionHandlers = {\n    get: createInstrumentationGetter(true, true)\n  };\n  function checkIdentityKeys(target, has2, key) {\n    const rawKey = toRaw2(key);\n    if (rawKey !== key && has2.call(target, rawKey)) {\n      const type = shared.toRawType(target);\n      console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);\n    }\n  }\n  var reactiveMap = new WeakMap();\n  var shallowReactiveMap = new WeakMap();\n  var readonlyMap = new WeakMap();\n  var shallowReadonlyMap = new WeakMap();\n  function targetTypeMap(rawType) {\n    switch (rawType) {\n      case \"Object\":\n      case \"Array\":\n        return 1;\n      case \"Map\":\n      case \"Set\":\n      case \"WeakMap\":\n      case \"WeakSet\":\n        return 2;\n      default:\n        return 0;\n    }\n  }\n  function getTargetType(value) {\n    return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 : targetTypeMap(shared.toRawType(value));\n  }\n  function reactive3(target) {\n    if (target && target[\"__v_isReadonly\"]) {\n      return target;\n    }\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n  }\n  function shallowReactive(target) {\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n  }\n  function readonly(target) {\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n  }\n  function shallowReadonly(target) {\n    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n  }\n  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n    if (!shared.isObject(target)) {\n      {\n        console.warn(`value cannot be made reactive: ${String(target)}`);\n      }\n      return target;\n    }\n    if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n      return target;\n    }\n    const existingProxy = proxyMap.get(target);\n    if (existingProxy) {\n      return existingProxy;\n    }\n    const targetType = getTargetType(target);\n    if (targetType === 0) {\n      return target;\n    }\n    const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);\n    proxyMap.set(target, proxy);\n    return proxy;\n  }\n  function isReactive2(value) {\n    if (isReadonly(value)) {\n      return isReactive2(value[\"__v_raw\"]);\n    }\n    return !!(value && value[\"__v_isReactive\"]);\n  }\n  function isReadonly(value) {\n    return !!(value && value[\"__v_isReadonly\"]);\n  }\n  function isProxy(value) {\n    return isReactive2(value) || isReadonly(value);\n  }\n  function toRaw2(observed) {\n    return observed && toRaw2(observed[\"__v_raw\"]) || observed;\n  }\n  function markRaw(value) {\n    shared.def(value, \"__v_skip\", true);\n    return value;\n  }\n  var convert = (val) => shared.isObject(val) ? reactive3(val) : val;\n  function isRef(r) {\n    return Boolean(r && r.__v_isRef === true);\n  }\n  function ref(value) {\n    return createRef(value);\n  }\n  function shallowRef(value) {\n    return createRef(value, true);\n  }\n  var RefImpl = class {\n    constructor(_rawValue, _shallow = false) {\n      this._rawValue = _rawValue;\n      this._shallow = _shallow;\n      this.__v_isRef = true;\n      this._value = _shallow ? _rawValue : convert(_rawValue);\n    }\n    get value() {\n      track(toRaw2(this), \"get\", \"value\");\n      return this._value;\n    }\n    set value(newVal) {\n      if (shared.hasChanged(toRaw2(newVal), this._rawValue)) {\n        this._rawValue = newVal;\n        this._value = this._shallow ? newVal : convert(newVal);\n        trigger(toRaw2(this), \"set\", \"value\", newVal);\n      }\n    }\n  };\n  function createRef(rawValue, shallow = false) {\n    if (isRef(rawValue)) {\n      return rawValue;\n    }\n    return new RefImpl(rawValue, shallow);\n  }\n  function triggerRef(ref2) {\n    trigger(toRaw2(ref2), \"set\", \"value\", ref2.value);\n  }\n  function unref(ref2) {\n    return isRef(ref2) ? ref2.value : ref2;\n  }\n  var shallowUnwrapHandlers = {\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n    set: (target, key, value, receiver) => {\n      const oldValue = target[key];\n      if (isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      } else {\n        return Reflect.set(target, key, value, receiver);\n      }\n    }\n  };\n  function proxyRefs(objectWithRefs) {\n    return isReactive2(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n  }\n  var CustomRefImpl = class {\n    constructor(factory) {\n      this.__v_isRef = true;\n      const {get: get3, set: set3} = factory(() => track(this, \"get\", \"value\"), () => trigger(this, \"set\", \"value\"));\n      this._get = get3;\n      this._set = set3;\n    }\n    get value() {\n      return this._get();\n    }\n    set value(newVal) {\n      this._set(newVal);\n    }\n  };\n  function customRef(factory) {\n    return new CustomRefImpl(factory);\n  }\n  function toRefs(object) {\n    if (!isProxy(object)) {\n      console.warn(`toRefs() expects a reactive object but received a plain one.`);\n    }\n    const ret = shared.isArray(object) ? new Array(object.length) : {};\n    for (const key in object) {\n      ret[key] = toRef(object, key);\n    }\n    return ret;\n  }\n  var ObjectRefImpl = class {\n    constructor(_object, _key) {\n      this._object = _object;\n      this._key = _key;\n      this.__v_isRef = true;\n    }\n    get value() {\n      return this._object[this._key];\n    }\n    set value(newVal) {\n      this._object[this._key] = newVal;\n    }\n  };\n  function toRef(object, key) {\n    return isRef(object[key]) ? object[key] : new ObjectRefImpl(object, key);\n  }\n  var ComputedRefImpl = class {\n    constructor(getter, _setter, isReadonly2) {\n      this._setter = _setter;\n      this._dirty = true;\n      this.__v_isRef = true;\n      this.effect = effect3(getter, {\n        lazy: true,\n        scheduler: () => {\n          if (!this._dirty) {\n            this._dirty = true;\n            trigger(toRaw2(this), \"set\", \"value\");\n          }\n        }\n      });\n      this[\"__v_isReadonly\"] = isReadonly2;\n    }\n    get value() {\n      const self2 = toRaw2(this);\n      if (self2._dirty) {\n        self2._value = this.effect();\n        self2._dirty = false;\n      }\n      track(self2, \"get\", \"value\");\n      return self2._value;\n    }\n    set value(newValue) {\n      this._setter(newValue);\n    }\n  };\n  function computed(getterOrOptions) {\n    let getter;\n    let setter;\n    if (shared.isFunction(getterOrOptions)) {\n      getter = getterOrOptions;\n      setter = () => {\n        console.warn(\"Write operation failed: computed value is readonly\");\n      };\n    } else {\n      getter = getterOrOptions.get;\n      setter = getterOrOptions.set;\n    }\n    return new ComputedRefImpl(getter, setter, shared.isFunction(getterOrOptions) || !getterOrOptions.set);\n  }\n  exports.ITERATE_KEY = ITERATE_KEY;\n  exports.computed = computed;\n  exports.customRef = customRef;\n  exports.effect = effect3;\n  exports.enableTracking = enableTracking;\n  exports.isProxy = isProxy;\n  exports.isReactive = isReactive2;\n  exports.isReadonly = isReadonly;\n  exports.isRef = isRef;\n  exports.markRaw = markRaw;\n  exports.pauseTracking = pauseTracking;\n  exports.proxyRefs = proxyRefs;\n  exports.reactive = reactive3;\n  exports.readonly = readonly;\n  exports.ref = ref;\n  exports.resetTracking = resetTracking;\n  exports.shallowReactive = shallowReactive;\n  exports.shallowReadonly = shallowReadonly;\n  exports.shallowRef = shallowRef;\n  exports.stop = stop2;\n  exports.toRaw = toRaw2;\n  exports.toRef = toRef;\n  exports.toRefs = toRefs;\n  exports.track = track;\n  exports.trigger = trigger;\n  exports.triggerRef = triggerRef;\n  exports.unref = unref;\n});\n\n// node_modules/@vue/reactivity/index.js\nvar require_reactivity = __commonJS((exports, module) => {\n  \"use strict\";\n  if (false) {} else {\n    module.exports = require_reactivity_cjs();\n  }\n});\n\n// packages/alpinejs/src/scheduler.js\nvar flushPending = false;\nvar flushing = false;\nvar queue = [];\nfunction scheduler(callback) {\n  queueJob(callback);\n}\nfunction queueJob(job) {\n  if (!queue.includes(job))\n    queue.push(job);\n  queueFlush();\n}\nfunction queueFlush() {\n  if (!flushing && !flushPending) {\n    flushPending = true;\n    queueMicrotask(flushJobs);\n  }\n}\nfunction flushJobs() {\n  flushPending = false;\n  flushing = true;\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n  queue.length = 0;\n  flushing = false;\n}\n\n// packages/alpinejs/src/reactivity.js\nvar reactive;\nvar effect;\nvar release;\nvar raw;\nvar shouldSchedule = true;\nfunction disableEffectScheduling(callback) {\n  shouldSchedule = false;\n  callback();\n  shouldSchedule = true;\n}\nfunction setReactivityEngine(engine) {\n  reactive = engine.reactive;\n  release = engine.release;\n  effect = (callback) => engine.effect(callback, {scheduler: (task) => {\n    if (shouldSchedule) {\n      scheduler(task);\n    } else {\n      task();\n    }\n  }});\n  raw = engine.raw;\n}\nfunction overrideEffect(override) {\n  effect = override;\n}\nfunction elementBoundEffect(el) {\n  let cleanup = () => {\n  };\n  let wrappedEffect = (callback) => {\n    let effectReference = effect(callback);\n    if (!el._x_effects) {\n      el._x_effects = new Set();\n      el._x_runEffects = () => {\n        el._x_effects.forEach((i) => i());\n      };\n    }\n    el._x_effects.add(effectReference);\n    cleanup = () => {\n      if (effectReference === void 0)\n        return;\n      el._x_effects.delete(effectReference);\n      release(effectReference);\n    };\n  };\n  return [wrappedEffect, () => {\n    cleanup();\n  }];\n}\n\n// packages/alpinejs/src/mutation.js\nvar onAttributeAddeds = [];\nvar onElRemoveds = [];\nvar onElAddeds = [];\nfunction onElAdded(callback) {\n  onElAddeds.push(callback);\n}\nfunction onElRemoved(callback) {\n  onElRemoveds.push(callback);\n}\nfunction onAttributesAdded(callback) {\n  onAttributeAddeds.push(callback);\n}\nfunction onAttributeRemoved(el, name, callback) {\n  if (!el._x_attributeCleanups)\n    el._x_attributeCleanups = {};\n  if (!el._x_attributeCleanups[name])\n    el._x_attributeCleanups[name] = [];\n  el._x_attributeCleanups[name].push(callback);\n}\nfunction cleanupAttributes(el, names) {\n  if (!el._x_attributeCleanups)\n    return;\n  Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {\n    if (names === void 0 || names.includes(name)) {\n      value.forEach((i) => i());\n      delete el._x_attributeCleanups[name];\n    }\n  });\n}\nvar observer = new MutationObserver(onMutate);\nvar currentlyObserving = false;\nfunction startObservingMutations() {\n  observer.observe(document, {subtree: true, childList: true, attributes: true, attributeOldValue: true});\n  currentlyObserving = true;\n}\nfunction stopObservingMutations() {\n  flushObserver();\n  observer.disconnect();\n  currentlyObserving = false;\n}\nvar recordQueue = [];\nvar willProcessRecordQueue = false;\nfunction flushObserver() {\n  recordQueue = recordQueue.concat(observer.takeRecords());\n  if (recordQueue.length && !willProcessRecordQueue) {\n    willProcessRecordQueue = true;\n    queueMicrotask(() => {\n      processRecordQueue();\n      willProcessRecordQueue = false;\n    });\n  }\n}\nfunction processRecordQueue() {\n  onMutate(recordQueue);\n  recordQueue.length = 0;\n}\nfunction mutateDom(callback) {\n  if (!currentlyObserving)\n    return callback();\n  stopObservingMutations();\n  let result = callback();\n  startObservingMutations();\n  return result;\n}\nvar isCollecting = false;\nvar deferredMutations = [];\nfunction deferMutations() {\n  isCollecting = true;\n}\nfunction flushAndStopDeferringMutations() {\n  isCollecting = false;\n  onMutate(deferredMutations);\n  deferredMutations = [];\n}\nfunction onMutate(mutations) {\n  if (isCollecting) {\n    deferredMutations = deferredMutations.concat(mutations);\n    return;\n  }\n  let addedNodes = [];\n  let removedNodes = [];\n  let addedAttributes = new Map();\n  let removedAttributes = new Map();\n  for (let i = 0; i < mutations.length; i++) {\n    if (mutations[i].target._x_ignoreMutationObserver)\n      continue;\n    if (mutations[i].type === \"childList\") {\n      mutations[i].addedNodes.forEach((node) => node.nodeType === 1 && addedNodes.push(node));\n      mutations[i].removedNodes.forEach((node) => node.nodeType === 1 && removedNodes.push(node));\n    }\n    if (mutations[i].type === \"attributes\") {\n      let el = mutations[i].target;\n      let name = mutations[i].attributeName;\n      let oldValue = mutations[i].oldValue;\n      let add = () => {\n        if (!addedAttributes.has(el))\n          addedAttributes.set(el, []);\n        addedAttributes.get(el).push({name, value: el.getAttribute(name)});\n      };\n      let remove = () => {\n        if (!removedAttributes.has(el))\n          removedAttributes.set(el, []);\n        removedAttributes.get(el).push(name);\n      };\n      if (el.hasAttribute(name) && oldValue === null) {\n        add();\n      } else if (el.hasAttribute(name)) {\n        remove();\n        add();\n      } else {\n        remove();\n      }\n    }\n  }\n  removedAttributes.forEach((attrs, el) => {\n    cleanupAttributes(el, attrs);\n  });\n  addedAttributes.forEach((attrs, el) => {\n    onAttributeAddeds.forEach((i) => i(el, attrs));\n  });\n  addedNodes.forEach((node) => {\n    node._x_ignoreSelf = true;\n    node._x_ignore = true;\n  });\n  for (let node of addedNodes) {\n    if (removedNodes.includes(node))\n      continue;\n    delete node._x_ignoreSelf;\n    delete node._x_ignore;\n    onElAddeds.forEach((i) => i(node));\n    node._x_ignore = true;\n    node._x_ignoreSelf = true;\n  }\n  addedNodes.forEach((node) => {\n    delete node._x_ignoreSelf;\n    delete node._x_ignore;\n  });\n  for (let node of removedNodes) {\n    if (addedNodes.includes(node))\n      continue;\n    onElRemoveds.forEach((i) => i(node));\n  }\n  addedNodes = null;\n  removedNodes = null;\n  addedAttributes = null;\n  removedAttributes = null;\n}\n\n// packages/alpinejs/src/scope.js\nfunction addScopeToNode(node, data2, referenceNode) {\n  node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];\n  return () => {\n    node._x_dataStack = node._x_dataStack.filter((i) => i !== data2);\n  };\n}\nfunction refreshScope(element, scope) {\n  let existingScope = element._x_dataStack[0];\n  Object.entries(scope).forEach(([key, value]) => {\n    existingScope[key] = value;\n  });\n}\nfunction closestDataStack(node) {\n  if (node._x_dataStack)\n    return node._x_dataStack;\n  if (typeof ShadowRoot === \"function\" && node instanceof ShadowRoot) {\n    return closestDataStack(node.host);\n  }\n  if (!node.parentNode) {\n    return [];\n  }\n  return closestDataStack(node.parentNode);\n}\nfunction mergeProxies(objects) {\n  let thisProxy = new Proxy({}, {\n    ownKeys: () => {\n      return Array.from(new Set(objects.flatMap((i) => Object.keys(i))));\n    },\n    has: (target, name) => {\n      return objects.some((obj) => obj.hasOwnProperty(name));\n    },\n    get: (target, name) => {\n      return (objects.find((obj) => {\n        if (obj.hasOwnProperty(name)) {\n          let descriptor = Object.getOwnPropertyDescriptor(obj, name);\n          if (descriptor.get && descriptor.get._x_alreadyBound || descriptor.set && descriptor.set._x_alreadyBound) {\n            return true;\n          }\n          if ((descriptor.get || descriptor.set) && descriptor.enumerable) {\n            let getter = descriptor.get;\n            let setter = descriptor.set;\n            let property = descriptor;\n            getter = getter && getter.bind(thisProxy);\n            setter = setter && setter.bind(thisProxy);\n            if (getter)\n              getter._x_alreadyBound = true;\n            if (setter)\n              setter._x_alreadyBound = true;\n            Object.defineProperty(obj, name, {\n              ...property,\n              get: getter,\n              set: setter\n            });\n          }\n          return true;\n        }\n        return false;\n      }) || {})[name];\n    },\n    set: (target, name, value) => {\n      let closestObjectWithKey = objects.find((obj) => obj.hasOwnProperty(name));\n      if (closestObjectWithKey) {\n        closestObjectWithKey[name] = value;\n      } else {\n        objects[objects.length - 1][name] = value;\n      }\n      return true;\n    }\n  });\n  return thisProxy;\n}\n\n// packages/alpinejs/src/interceptor.js\nfunction initInterceptors(data2) {\n  let isObject = (val) => typeof val === \"object\" && !Array.isArray(val) && val !== null;\n  let recurse = (obj, basePath = \"\") => {\n    Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, {value, enumerable}]) => {\n      if (enumerable === false || value === void 0)\n        return;\n      let path = basePath === \"\" ? key : `${basePath}.${key}`;\n      if (typeof value === \"object\" && value !== null && value._x_interceptor) {\n        obj[key] = value.initialize(data2, path, key);\n      } else {\n        if (isObject(value) && value !== obj && !(value instanceof Element)) {\n          recurse(value, path);\n        }\n      }\n    });\n  };\n  return recurse(data2);\n}\nfunction interceptor(callback, mutateObj = () => {\n}) {\n  let obj = {\n    initialValue: void 0,\n    _x_interceptor: true,\n    initialize(data2, path, key) {\n      return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);\n    }\n  };\n  mutateObj(obj);\n  return (initialValue) => {\n    if (typeof initialValue === \"object\" && initialValue !== null && initialValue._x_interceptor) {\n      let initialize = obj.initialize.bind(obj);\n      obj.initialize = (data2, path, key) => {\n        let innerValue = initialValue.initialize(data2, path, key);\n        obj.initialValue = innerValue;\n        return initialize(data2, path, key);\n      };\n    } else {\n      obj.initialValue = initialValue;\n    }\n    return obj;\n  };\n}\nfunction get(obj, path) {\n  return path.split(\".\").reduce((carry, segment) => carry[segment], obj);\n}\nfunction set(obj, path, value) {\n  if (typeof path === \"string\")\n    path = path.split(\".\");\n  if (path.length === 1)\n    obj[path[0]] = value;\n  else if (path.length === 0)\n    throw error;\n  else {\n    if (obj[path[0]])\n      return set(obj[path[0]], path.slice(1), value);\n    else {\n      obj[path[0]] = {};\n      return set(obj[path[0]], path.slice(1), value);\n    }\n  }\n}\n\n// packages/alpinejs/src/magics.js\nvar magics = {};\nfunction magic(name, callback) {\n  magics[name] = callback;\n}\nfunction injectMagics(obj, el) {\n  Object.entries(magics).forEach(([name, callback]) => {\n    Object.defineProperty(obj, `$${name}`, {\n      get() {\n        return callback(el, {Alpine: alpine_default, interceptor});\n      },\n      enumerable: false\n    });\n  });\n  return obj;\n}\n\n// packages/alpinejs/src/utils/error.js\nfunction tryCatch(el, expression, callback, ...args) {\n  try {\n    return callback(...args);\n  } catch (e) {\n    handleError(e, el, expression);\n  }\n}\nfunction handleError(error2, el, expression = void 0) {\n  Object.assign(error2, {el, expression});\n  console.warn(`Alpine Expression Error: ${error2.message}\n\n${expression ? 'Expression: \"' + expression + '\"\\n\\n' : \"\"}`, el);\n  setTimeout(() => {\n    throw error2;\n  }, 0);\n}\n\n// packages/alpinejs/src/evaluator.js\nfunction evaluate(el, expression, extras = {}) {\n  let result;\n  evaluateLater(el, expression)((value) => result = value, extras);\n  return result;\n}\nfunction evaluateLater(...args) {\n  return theEvaluatorFunction(...args);\n}\nvar theEvaluatorFunction = normalEvaluator;\nfunction setEvaluator(newEvaluator) {\n  theEvaluatorFunction = newEvaluator;\n}\nfunction normalEvaluator(el, expression) {\n  let overriddenMagics = {};\n  injectMagics(overriddenMagics, el);\n  let dataStack = [overriddenMagics, ...closestDataStack(el)];\n  if (typeof expression === \"function\") {\n    return generateEvaluatorFromFunction(dataStack, expression);\n  }\n  let evaluator = generateEvaluatorFromString(dataStack, expression, el);\n  return tryCatch.bind(null, el, expression, evaluator);\n}\nfunction generateEvaluatorFromFunction(dataStack, func) {\n  return (receiver = () => {\n  }, {scope = {}, params = []} = {}) => {\n    let result = func.apply(mergeProxies([scope, ...dataStack]), params);\n    runIfTypeOfFunction(receiver, result);\n  };\n}\nvar evaluatorMemo = {};\nfunction generateFunctionFromString(expression, el) {\n  if (evaluatorMemo[expression]) {\n    return evaluatorMemo[expression];\n  }\n  let AsyncFunction = Object.getPrototypeOf(async function() {\n  }).constructor;\n  let rightSideSafeExpression = /^[\\n\\s]*if.*\\(.*\\)/.test(expression) || /^(let|const)\\s/.test(expression) ? `(() => { ${expression} })()` : expression;\n  const safeAsyncFunction = () => {\n    try {\n      return new AsyncFunction([\"__self\", \"scope\"], `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`);\n    } catch (error2) {\n      handleError(error2, el, expression);\n      return Promise.resolve();\n    }\n  };\n  let func = safeAsyncFunction();\n  evaluatorMemo[expression] = func;\n  return func;\n}\nfunction generateEvaluatorFromString(dataStack, expression, el) {\n  let func = generateFunctionFromString(expression, el);\n  return (receiver = () => {\n  }, {scope = {}, params = []} = {}) => {\n    func.result = void 0;\n    func.finished = false;\n    let completeScope = mergeProxies([scope, ...dataStack]);\n    if (typeof func === \"function\") {\n      let promise = func(func, completeScope).catch((error2) => handleError(error2, el, expression));\n      if (func.finished) {\n        runIfTypeOfFunction(receiver, func.result, completeScope, params, el);\n        func.result = void 0;\n      } else {\n        promise.then((result) => {\n          runIfTypeOfFunction(receiver, result, completeScope, params, el);\n        }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);\n      }\n    }\n  };\n}\nfunction runIfTypeOfFunction(receiver, value, scope, params, el) {\n  if (typeof value === \"function\") {\n    let result = value.apply(scope, params);\n    if (result instanceof Promise) {\n      result.then((i) => runIfTypeOfFunction(receiver, i, scope, params)).catch((error2) => handleError(error2, el, value));\n    } else {\n      receiver(result);\n    }\n  } else {\n    receiver(value);\n  }\n}\n\n// packages/alpinejs/src/directives.js\nvar prefixAsString = \"x-\";\nfunction prefix(subject = \"\") {\n  return prefixAsString + subject;\n}\nfunction setPrefix(newPrefix) {\n  prefixAsString = newPrefix;\n}\nvar directiveHandlers = {};\nfunction directive(name, callback) {\n  directiveHandlers[name] = callback;\n}\nfunction directives(el, attributes, originalAttributeOverride) {\n  let transformedAttributeMap = {};\n  let directives2 = Array.from(attributes).map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);\n  return directives2.map((directive2) => {\n    return getDirectiveHandler(el, directive2);\n  });\n}\nfunction attributesOnly(attributes) {\n  return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));\n}\nvar isDeferringHandlers = false;\nvar directiveHandlerStacks = new Map();\nvar currentHandlerStackKey = Symbol();\nfunction deferHandlingDirectives(callback) {\n  isDeferringHandlers = true;\n  let key = Symbol();\n  currentHandlerStackKey = key;\n  directiveHandlerStacks.set(key, []);\n  let flushHandlers = () => {\n    while (directiveHandlerStacks.get(key).length)\n      directiveHandlerStacks.get(key).shift()();\n    directiveHandlerStacks.delete(key);\n  };\n  let stopDeferring = () => {\n    isDeferringHandlers = false;\n    flushHandlers();\n  };\n  callback(flushHandlers);\n  stopDeferring();\n}\nfunction getDirectiveHandler(el, directive2) {\n  let noop = () => {\n  };\n  let handler3 = directiveHandlers[directive2.type] || noop;\n  let cleanups = [];\n  let cleanup = (callback) => cleanups.push(callback);\n  let [effect3, cleanupEffect] = elementBoundEffect(el);\n  cleanups.push(cleanupEffect);\n  let utilities = {\n    Alpine: alpine_default,\n    effect: effect3,\n    cleanup,\n    evaluateLater: evaluateLater.bind(evaluateLater, el),\n    evaluate: evaluate.bind(evaluate, el)\n  };\n  let doCleanup = () => cleanups.forEach((i) => i());\n  onAttributeRemoved(el, directive2.original, doCleanup);\n  let fullHandler = () => {\n    if (el._x_ignore || el._x_ignoreSelf)\n      return;\n    handler3.inline && handler3.inline(el, directive2, utilities);\n    handler3 = handler3.bind(handler3, el, directive2, utilities);\n    isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler3) : handler3();\n  };\n  fullHandler.runCleanups = doCleanup;\n  return fullHandler;\n}\nvar startingWith = (subject, replacement) => ({name, value}) => {\n  if (name.startsWith(subject))\n    name = name.replace(subject, replacement);\n  return {name, value};\n};\nvar into = (i) => i;\nfunction toTransformedAttributes(callback = () => {\n}) {\n  return ({name, value}) => {\n    let {name: newName, value: newValue} = attributeTransformers.reduce((carry, transform) => {\n      return transform(carry);\n    }, {name, value});\n    if (newName !== name)\n      callback(newName, name);\n    return {name: newName, value: newValue};\n  };\n}\nvar attributeTransformers = [];\nfunction mapAttributes(callback) {\n  attributeTransformers.push(callback);\n}\nfunction outNonAlpineAttributes({name}) {\n  return alpineAttributeRegex().test(name);\n}\nvar alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\\\b`);\nfunction toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {\n  return ({name, value}) => {\n    let typeMatch = name.match(alpineAttributeRegex());\n    let valueMatch = name.match(/:([a-zA-Z0-9\\-:]+)/);\n    let modifiers = name.match(/\\.[^.\\]]+(?=[^\\]]*$)/g) || [];\n    let original = originalAttributeOverride || transformedAttributeMap[name] || name;\n    return {\n      type: typeMatch ? typeMatch[1] : null,\n      value: valueMatch ? valueMatch[1] : null,\n      modifiers: modifiers.map((i) => i.replace(\".\", \"\")),\n      expression: value,\n      original\n    };\n  };\n}\nvar DEFAULT = \"DEFAULT\";\nvar directiveOrder = [\n  \"ignore\",\n  \"ref\",\n  \"data\",\n  \"bind\",\n  \"init\",\n  \"for\",\n  \"model\",\n  \"transition\",\n  \"show\",\n  \"if\",\n  DEFAULT,\n  \"element\"\n];\nfunction byPriority(a, b) {\n  let typeA = directiveOrder.indexOf(a.type) === -1 ? DEFAULT : a.type;\n  let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;\n  return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);\n}\n\n// packages/alpinejs/src/utils/dispatch.js\nfunction dispatch(el, name, detail = {}) {\n  el.dispatchEvent(new CustomEvent(name, {\n    detail,\n    bubbles: true,\n    composed: true,\n    cancelable: true\n  }));\n}\n\n// packages/alpinejs/src/nextTick.js\nvar tickStack = [];\nvar isHolding = false;\nfunction nextTick(callback) {\n  tickStack.push(callback);\n  queueMicrotask(() => {\n    isHolding || setTimeout(() => {\n      releaseNextTicks();\n    });\n  });\n}\nfunction releaseNextTicks() {\n  isHolding = false;\n  while (tickStack.length)\n    tickStack.shift()();\n}\nfunction holdNextTicks() {\n  isHolding = true;\n}\n\n// packages/alpinejs/src/utils/walk.js\nfunction walk(el, callback) {\n  if (typeof ShadowRoot === \"function\" && el instanceof ShadowRoot) {\n    Array.from(el.children).forEach((el2) => walk(el2, callback));\n    return;\n  }\n  let skip = false;\n  callback(el, () => skip = true);\n  if (skip)\n    return;\n  let node = el.firstElementChild;\n  while (node) {\n    walk(node, callback, false);\n    node = node.nextElementSibling;\n  }\n}\n\n// packages/alpinejs/src/utils/warn.js\nfunction warn(message, ...args) {\n  console.warn(`Alpine Warning: ${message}`, ...args);\n}\n\n// packages/alpinejs/src/lifecycle.js\nfunction start() {\n  if (!document.body)\n    warn(\"Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?\");\n  dispatch(document, \"alpine:init\");\n  dispatch(document, \"alpine:initializing\");\n  startObservingMutations();\n  onElAdded((el) => initTree(el, walk));\n  onElRemoved((el) => nextTick(() => destroyTree(el)));\n  onAttributesAdded((el, attrs) => {\n    directives(el, attrs).forEach((handle) => handle());\n  });\n  let outNestedComponents = (el) => !closestRoot(el.parentElement, true);\n  Array.from(document.querySelectorAll(allSelectors())).filter(outNestedComponents).forEach((el) => {\n    initTree(el);\n  });\n  dispatch(document, \"alpine:initialized\");\n}\nvar rootSelectorCallbacks = [];\nvar initSelectorCallbacks = [];\nfunction rootSelectors() {\n  return rootSelectorCallbacks.map((fn) => fn());\n}\nfunction allSelectors() {\n  return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());\n}\nfunction addRootSelector(selectorCallback) {\n  rootSelectorCallbacks.push(selectorCallback);\n}\nfunction addInitSelector(selectorCallback) {\n  initSelectorCallbacks.push(selectorCallback);\n}\nfunction closestRoot(el, includeInitSelectors = false) {\n  if (!el)\n    return;\n  const selectors = includeInitSelectors ? allSelectors() : rootSelectors();\n  if (selectors.some((selector) => el.matches(selector)))\n    return el;\n  if (!el.parentElement)\n    return;\n  return closestRoot(el.parentElement, includeInitSelectors);\n}\nfunction isRoot(el) {\n  return rootSelectors().some((selector) => el.matches(selector));\n}\nfunction initTree(el, walker = walk) {\n  deferHandlingDirectives(() => {\n    walker(el, (el2, skip) => {\n      directives(el2, el2.attributes).forEach((handle) => handle());\n      el2._x_ignore && skip();\n    });\n  });\n}\nfunction destroyTree(root) {\n  walk(root, (el) => cleanupAttributes(el));\n}\n\n// packages/alpinejs/src/utils/classes.js\nfunction setClasses(el, value) {\n  if (Array.isArray(value)) {\n    return setClassesFromString(el, value.join(\" \"));\n  } else if (typeof value === \"object\" && value !== null) {\n    return setClassesFromObject(el, value);\n  } else if (typeof value === \"function\") {\n    return setClasses(el, value());\n  }\n  return setClassesFromString(el, value);\n}\nfunction setClassesFromString(el, classString) {\n  let split = (classString2) => classString2.split(\" \").filter(Boolean);\n  let missingClasses = (classString2) => classString2.split(\" \").filter((i) => !el.classList.contains(i)).filter(Boolean);\n  let addClassesAndReturnUndo = (classes) => {\n    el.classList.add(...classes);\n    return () => {\n      el.classList.remove(...classes);\n    };\n  };\n  classString = classString === true ? classString = \"\" : classString || \"\";\n  return addClassesAndReturnUndo(missingClasses(classString));\n}\nfunction setClassesFromObject(el, classObject) {\n  let split = (classString) => classString.split(\" \").filter(Boolean);\n  let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);\n  let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);\n  let added = [];\n  let removed = [];\n  forRemove.forEach((i) => {\n    if (el.classList.contains(i)) {\n      el.classList.remove(i);\n      removed.push(i);\n    }\n  });\n  forAdd.forEach((i) => {\n    if (!el.classList.contains(i)) {\n      el.classList.add(i);\n      added.push(i);\n    }\n  });\n  return () => {\n    removed.forEach((i) => el.classList.add(i));\n    added.forEach((i) => el.classList.remove(i));\n  };\n}\n\n// packages/alpinejs/src/utils/styles.js\nfunction setStyles(el, value) {\n  if (typeof value === \"object\" && value !== null) {\n    return setStylesFromObject(el, value);\n  }\n  return setStylesFromString(el, value);\n}\nfunction setStylesFromObject(el, value) {\n  let previousStyles = {};\n  Object.entries(value).forEach(([key, value2]) => {\n    previousStyles[key] = el.style[key];\n    el.style.setProperty(kebabCase(key), value2);\n  });\n  setTimeout(() => {\n    if (el.style.length === 0) {\n      el.removeAttribute(\"style\");\n    }\n  });\n  return () => {\n    setStyles(el, previousStyles);\n  };\n}\nfunction setStylesFromString(el, value) {\n  let cache = el.getAttribute(\"style\", value);\n  el.setAttribute(\"style\", value);\n  return () => {\n    el.setAttribute(\"style\", cache);\n  };\n}\nfunction kebabCase(subject) {\n  return subject.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n\n// packages/alpinejs/src/utils/once.js\nfunction once(callback, fallback = () => {\n}) {\n  let called = false;\n  return function() {\n    if (!called) {\n      called = true;\n      callback.apply(this, arguments);\n    } else {\n      fallback.apply(this, arguments);\n    }\n  };\n}\n\n// packages/alpinejs/src/directives/x-transition.js\ndirective(\"transition\", (el, {value, modifiers, expression}, {evaluate: evaluate2}) => {\n  if (typeof expression === \"function\")\n    expression = evaluate2(expression);\n  if (!expression) {\n    registerTransitionsFromHelper(el, modifiers, value);\n  } else {\n    registerTransitionsFromClassString(el, expression, value);\n  }\n});\nfunction registerTransitionsFromClassString(el, classString, stage) {\n  registerTransitionObject(el, setClasses, \"\");\n  let directiveStorageMap = {\n    enter: (classes) => {\n      el._x_transition.enter.during = classes;\n    },\n    \"enter-start\": (classes) => {\n      el._x_transition.enter.start = classes;\n    },\n    \"enter-end\": (classes) => {\n      el._x_transition.enter.end = classes;\n    },\n    leave: (classes) => {\n      el._x_transition.leave.during = classes;\n    },\n    \"leave-start\": (classes) => {\n      el._x_transition.leave.start = classes;\n    },\n    \"leave-end\": (classes) => {\n      el._x_transition.leave.end = classes;\n    }\n  };\n  directiveStorageMap[stage](classString);\n}\nfunction registerTransitionsFromHelper(el, modifiers, stage) {\n  registerTransitionObject(el, setStyles);\n  let doesntSpecify = !modifiers.includes(\"in\") && !modifiers.includes(\"out\") && !stage;\n  let transitioningIn = doesntSpecify || modifiers.includes(\"in\") || [\"enter\"].includes(stage);\n  let transitioningOut = doesntSpecify || modifiers.includes(\"out\") || [\"leave\"].includes(stage);\n  if (modifiers.includes(\"in\") && !doesntSpecify) {\n    modifiers = modifiers.filter((i, index) => index < modifiers.indexOf(\"out\"));\n  }\n  if (modifiers.includes(\"out\") && !doesntSpecify) {\n    modifiers = modifiers.filter((i, index) => index > modifiers.indexOf(\"out\"));\n  }\n  let wantsAll = !modifiers.includes(\"opacity\") && !modifiers.includes(\"scale\");\n  let wantsOpacity = wantsAll || modifiers.includes(\"opacity\");\n  let wantsScale = wantsAll || modifiers.includes(\"scale\");\n  let opacityValue = wantsOpacity ? 0 : 1;\n  let scaleValue = wantsScale ? modifierValue(modifiers, \"scale\", 95) / 100 : 1;\n  let delay = modifierValue(modifiers, \"delay\", 0);\n  let origin = modifierValue(modifiers, \"origin\", \"center\");\n  let property = \"opacity, transform\";\n  let durationIn = modifierValue(modifiers, \"duration\", 150) / 1e3;\n  let durationOut = modifierValue(modifiers, \"duration\", 75) / 1e3;\n  let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;\n  if (transitioningIn) {\n    el._x_transition.enter.during = {\n      transformOrigin: origin,\n      transitionDelay: delay,\n      transitionProperty: property,\n      transitionDuration: `${durationIn}s`,\n      transitionTimingFunction: easing\n    };\n    el._x_transition.enter.start = {\n      opacity: opacityValue,\n      transform: `scale(${scaleValue})`\n    };\n    el._x_transition.enter.end = {\n      opacity: 1,\n      transform: `scale(1)`\n    };\n  }\n  if (transitioningOut) {\n    el._x_transition.leave.during = {\n      transformOrigin: origin,\n      transitionDelay: delay,\n      transitionProperty: property,\n      transitionDuration: `${durationOut}s`,\n      transitionTimingFunction: easing\n    };\n    el._x_transition.leave.start = {\n      opacity: 1,\n      transform: `scale(1)`\n    };\n    el._x_transition.leave.end = {\n      opacity: opacityValue,\n      transform: `scale(${scaleValue})`\n    };\n  }\n}\nfunction registerTransitionObject(el, setFunction, defaultValue = {}) {\n  if (!el._x_transition)\n    el._x_transition = {\n      enter: {during: defaultValue, start: defaultValue, end: defaultValue},\n      leave: {during: defaultValue, start: defaultValue, end: defaultValue},\n      in(before = () => {\n      }, after = () => {\n      }) {\n        transition(el, setFunction, {\n          during: this.enter.during,\n          start: this.enter.start,\n          end: this.enter.end\n        }, before, after);\n      },\n      out(before = () => {\n      }, after = () => {\n      }) {\n        transition(el, setFunction, {\n          during: this.leave.during,\n          start: this.leave.start,\n          end: this.leave.end\n        }, before, after);\n      }\n    };\n}\nwindow.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {\n  let clickAwayCompatibleShow = () => {\n    document.visibilityState === \"visible\" ? requestAnimationFrame(show) : setTimeout(show);\n  };\n  if (value) {\n    if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {\n      el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();\n    } else {\n      el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();\n    }\n    return;\n  }\n  el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {\n    el._x_transition.out(() => {\n    }, () => resolve(hide));\n    el._x_transitioning.beforeCancel(() => reject({isFromCancelledTransition: true}));\n  }) : Promise.resolve(hide);\n  queueMicrotask(() => {\n    let closest = closestHide(el);\n    if (closest) {\n      if (!closest._x_hideChildren)\n        closest._x_hideChildren = [];\n      closest._x_hideChildren.push(el);\n    } else {\n      queueMicrotask(() => {\n        let hideAfterChildren = (el2) => {\n          let carry = Promise.all([\n            el2._x_hidePromise,\n            ...(el2._x_hideChildren || []).map(hideAfterChildren)\n          ]).then(([i]) => i());\n          delete el2._x_hidePromise;\n          delete el2._x_hideChildren;\n          return carry;\n        };\n        hideAfterChildren(el).catch((e) => {\n          if (!e.isFromCancelledTransition)\n            throw e;\n        });\n      });\n    }\n  });\n};\nfunction closestHide(el) {\n  let parent = el.parentNode;\n  if (!parent)\n    return;\n  return parent._x_hidePromise ? parent : closestHide(parent);\n}\nfunction transition(el, setFunction, {during, start: start2, end} = {}, before = () => {\n}, after = () => {\n}) {\n  if (el._x_transitioning)\n    el._x_transitioning.cancel();\n  if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {\n    before();\n    after();\n    return;\n  }\n  let undoStart, undoDuring, undoEnd;\n  performTransition(el, {\n    start() {\n      undoStart = setFunction(el, start2);\n    },\n    during() {\n      undoDuring = setFunction(el, during);\n    },\n    before,\n    end() {\n      undoStart();\n      undoEnd = setFunction(el, end);\n    },\n    after,\n    cleanup() {\n      undoDuring();\n      undoEnd();\n    }\n  });\n}\nfunction performTransition(el, stages) {\n  let interrupted, reachedBefore, reachedEnd;\n  let finish = once(() => {\n    mutateDom(() => {\n      interrupted = true;\n      if (!reachedBefore)\n        stages.before();\n      if (!reachedEnd) {\n        stages.end();\n        releaseNextTicks();\n      }\n      stages.after();\n      if (el.isConnected)\n        stages.cleanup();\n      delete el._x_transitioning;\n    });\n  });\n  el._x_transitioning = {\n    beforeCancels: [],\n    beforeCancel(callback) {\n      this.beforeCancels.push(callback);\n    },\n    cancel: once(function() {\n      while (this.beforeCancels.length) {\n        this.beforeCancels.shift()();\n      }\n      ;\n      finish();\n    }),\n    finish\n  };\n  mutateDom(() => {\n    stages.start();\n    stages.during();\n  });\n  holdNextTicks();\n  requestAnimationFrame(() => {\n    if (interrupted)\n      return;\n    let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, \"\").replace(\"s\", \"\")) * 1e3;\n    let delay = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, \"\").replace(\"s\", \"\")) * 1e3;\n    if (duration === 0)\n      duration = Number(getComputedStyle(el).animationDuration.replace(\"s\", \"\")) * 1e3;\n    mutateDom(() => {\n      stages.before();\n    });\n    reachedBefore = true;\n    requestAnimationFrame(() => {\n      if (interrupted)\n        return;\n      mutateDom(() => {\n        stages.end();\n      });\n      releaseNextTicks();\n      setTimeout(el._x_transitioning.finish, duration + delay);\n      reachedEnd = true;\n    });\n  });\n}\nfunction modifierValue(modifiers, key, fallback) {\n  if (modifiers.indexOf(key) === -1)\n    return fallback;\n  const rawValue = modifiers[modifiers.indexOf(key) + 1];\n  if (!rawValue)\n    return fallback;\n  if (key === \"scale\") {\n    if (isNaN(rawValue))\n      return fallback;\n  }\n  if (key === \"duration\") {\n    let match = rawValue.match(/([0-9]+)ms/);\n    if (match)\n      return match[1];\n  }\n  if (key === \"origin\") {\n    if ([\"top\", \"right\", \"left\", \"center\", \"bottom\"].includes(modifiers[modifiers.indexOf(key) + 2])) {\n      return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(\" \");\n    }\n  }\n  return rawValue;\n}\n\n// packages/alpinejs/src/clone.js\nvar isCloning = false;\nfunction skipDuringClone(callback, fallback = () => {\n}) {\n  return (...args) => isCloning ? fallback(...args) : callback(...args);\n}\nfunction clone(oldEl, newEl) {\n  if (!newEl._x_dataStack)\n    newEl._x_dataStack = oldEl._x_dataStack;\n  isCloning = true;\n  dontRegisterReactiveSideEffects(() => {\n    cloneTree(newEl);\n  });\n  isCloning = false;\n}\nfunction cloneTree(el) {\n  let hasRunThroughFirstEl = false;\n  let shallowWalker = (el2, callback) => {\n    walk(el2, (el3, skip) => {\n      if (hasRunThroughFirstEl && isRoot(el3))\n        return skip();\n      hasRunThroughFirstEl = true;\n      callback(el3, skip);\n    });\n  };\n  initTree(el, shallowWalker);\n}\nfunction dontRegisterReactiveSideEffects(callback) {\n  let cache = effect;\n  overrideEffect((callback2, el) => {\n    let storedEffect = cache(callback2);\n    release(storedEffect);\n    return () => {\n    };\n  });\n  callback();\n  overrideEffect(cache);\n}\n\n// packages/alpinejs/src/utils/debounce.js\nfunction debounce(func, wait) {\n  var timeout;\n  return function() {\n    var context = this, args = arguments;\n    var later = function() {\n      timeout = null;\n      func.apply(context, args);\n    };\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\n// packages/alpinejs/src/utils/throttle.js\nfunction throttle(func, limit) {\n  let inThrottle;\n  return function() {\n    let context = this, args = arguments;\n    if (!inThrottle) {\n      func.apply(context, args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n}\n\n// packages/alpinejs/src/plugin.js\nfunction plugin(callback) {\n  callback(alpine_default);\n}\n\n// packages/alpinejs/src/store.js\nvar stores = {};\nvar isReactive = false;\nfunction store(name, value) {\n  if (!isReactive) {\n    stores = reactive(stores);\n    isReactive = true;\n  }\n  if (value === void 0) {\n    return stores[name];\n  }\n  stores[name] = value;\n  if (typeof value === \"object\" && value !== null && value.hasOwnProperty(\"init\") && typeof value.init === \"function\") {\n    stores[name].init();\n  }\n  initInterceptors(stores[name]);\n}\nfunction getStores() {\n  return stores;\n}\n\n// packages/alpinejs/src/datas.js\nvar datas = {};\nfunction data(name, callback) {\n  datas[name] = callback;\n}\nfunction injectDataProviders(obj, context) {\n  Object.entries(datas).forEach(([name, callback]) => {\n    Object.defineProperty(obj, name, {\n      get() {\n        return (...args) => {\n          return callback.bind(context)(...args);\n        };\n      },\n      enumerable: false\n    });\n  });\n  return obj;\n}\n\n// packages/alpinejs/src/alpine.js\nvar Alpine = {\n  get reactive() {\n    return reactive;\n  },\n  get release() {\n    return release;\n  },\n  get effect() {\n    return effect;\n  },\n  get raw() {\n    return raw;\n  },\n  version: \"3.5.2\",\n  flushAndStopDeferringMutations,\n  disableEffectScheduling,\n  setReactivityEngine,\n  closestDataStack,\n  skipDuringClone,\n  addRootSelector,\n  deferMutations,\n  mapAttributes,\n  evaluateLater,\n  setEvaluator,\n  mergeProxies,\n  closestRoot,\n  interceptor,\n  transition,\n  setStyles,\n  mutateDom,\n  directive,\n  throttle,\n  debounce,\n  evaluate,\n  initTree,\n  nextTick,\n  prefix: setPrefix,\n  plugin,\n  magic,\n  store,\n  start,\n  clone,\n  data\n};\nvar alpine_default = Alpine;\n\n// packages/alpinejs/src/index.js\nvar import_reactivity9 = __toModule(require_reactivity());\n\n// packages/alpinejs/src/magics/$nextTick.js\nmagic(\"nextTick\", () => nextTick);\n\n// packages/alpinejs/src/magics/$dispatch.js\nmagic(\"dispatch\", (el) => dispatch.bind(dispatch, el));\n\n// packages/alpinejs/src/magics/$watch.js\nmagic(\"watch\", (el) => (key, callback) => {\n  let evaluate2 = evaluateLater(el, key);\n  let firstTime = true;\n  let oldValue;\n  effect(() => evaluate2((value) => {\n    let div = document.createElement(\"div\");\n    div.dataset.throwAway = value;\n    if (!firstTime) {\n      queueMicrotask(() => {\n        callback(value, oldValue);\n        oldValue = value;\n      });\n    } else {\n      oldValue = value;\n    }\n    firstTime = false;\n  }));\n});\n\n// packages/alpinejs/src/magics/$store.js\nmagic(\"store\", getStores);\n\n// packages/alpinejs/src/magics/$data.js\nmagic(\"data\", (el) => {\n  return mergeProxies(closestDataStack(el));\n});\n\n// packages/alpinejs/src/magics/$root.js\nmagic(\"root\", (el) => closestRoot(el));\n\n// packages/alpinejs/src/magics/$refs.js\nmagic(\"refs\", (el) => {\n  if (el._x_refs_proxy)\n    return el._x_refs_proxy;\n  el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));\n  return el._x_refs_proxy;\n});\nfunction getArrayOfRefObject(el) {\n  let refObjects = [];\n  let currentEl = el;\n  while (currentEl) {\n    if (currentEl._x_refs)\n      refObjects.push(currentEl._x_refs);\n    currentEl = currentEl.parentNode;\n  }\n  return refObjects;\n}\n\n// packages/alpinejs/src/magics/$el.js\nmagic(\"el\", (el) => el);\n\n// packages/alpinejs/src/directives/x-ignore.js\nvar handler = () => {\n};\nhandler.inline = (el, {modifiers}, {cleanup}) => {\n  modifiers.includes(\"self\") ? el._x_ignoreSelf = true : el._x_ignore = true;\n  cleanup(() => {\n    modifiers.includes(\"self\") ? delete el._x_ignoreSelf : delete el._x_ignore;\n  });\n};\ndirective(\"ignore\", handler);\n\n// packages/alpinejs/src/directives/x-effect.js\ndirective(\"effect\", (el, {expression}, {effect: effect3}) => effect3(evaluateLater(el, expression)));\n\n// packages/alpinejs/src/utils/bind.js\nfunction bind(el, name, value, modifiers = []) {\n  if (!el._x_bindings)\n    el._x_bindings = reactive({});\n  el._x_bindings[name] = value;\n  name = modifiers.includes(\"camel\") ? camelCase(name) : name;\n  switch (name) {\n    case \"value\":\n      bindInputValue(el, value);\n      break;\n    case \"style\":\n      bindStyles(el, value);\n      break;\n    case \"class\":\n      bindClasses(el, value);\n      break;\n    default:\n      bindAttribute(el, name, value);\n      break;\n  }\n}\nfunction bindInputValue(el, value) {\n  if (el.type === \"radio\") {\n    if (el.attributes.value === void 0) {\n      el.value = value;\n    }\n    if (window.fromModel) {\n      el.checked = checkedAttrLooseCompare(el.value, value);\n    }\n  } else if (el.type === \"checkbox\") {\n    if (Number.isInteger(value)) {\n      el.value = value;\n    } else if (!Number.isInteger(value) && !Array.isArray(value) && typeof value !== \"boolean\" && ![null, void 0].includes(value)) {\n      el.value = String(value);\n    } else {\n      if (Array.isArray(value)) {\n        el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));\n      } else {\n        el.checked = !!value;\n      }\n    }\n  } else if (el.tagName === \"SELECT\") {\n    updateSelect(el, value);\n  } else {\n    if (el.value === value)\n      return;\n    el.value = value;\n  }\n}\nfunction bindClasses(el, value) {\n  if (el._x_undoAddedClasses)\n    el._x_undoAddedClasses();\n  el._x_undoAddedClasses = setClasses(el, value);\n}\nfunction bindStyles(el, value) {\n  if (el._x_undoAddedStyles)\n    el._x_undoAddedStyles();\n  el._x_undoAddedStyles = setStyles(el, value);\n}\nfunction bindAttribute(el, name, value) {\n  if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {\n    el.removeAttribute(name);\n  } else {\n    if (isBooleanAttr(name))\n      value = name;\n    setIfChanged(el, name, value);\n  }\n}\nfunction setIfChanged(el, attrName, value) {\n  if (el.getAttribute(attrName) != value) {\n    el.setAttribute(attrName, value);\n  }\n}\nfunction updateSelect(el, value) {\n  const arrayWrappedValue = [].concat(value).map((value2) => {\n    return value2 + \"\";\n  });\n  Array.from(el.options).forEach((option) => {\n    option.selected = arrayWrappedValue.includes(option.value);\n  });\n}\nfunction camelCase(subject) {\n  return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n}\nfunction checkedAttrLooseCompare(valueA, valueB) {\n  return valueA == valueB;\n}\nfunction isBooleanAttr(attrName) {\n  const booleanAttributes = [\n    \"disabled\",\n    \"checked\",\n    \"required\",\n    \"readonly\",\n    \"hidden\",\n    \"open\",\n    \"selected\",\n    \"autofocus\",\n    \"itemscope\",\n    \"multiple\",\n    \"novalidate\",\n    \"allowfullscreen\",\n    \"allowpaymentrequest\",\n    \"formnovalidate\",\n    \"autoplay\",\n    \"controls\",\n    \"loop\",\n    \"muted\",\n    \"playsinline\",\n    \"default\",\n    \"ismap\",\n    \"reversed\",\n    \"async\",\n    \"defer\",\n    \"nomodule\"\n  ];\n  return booleanAttributes.includes(attrName);\n}\nfunction attributeShouldntBePreservedIfFalsy(name) {\n  return ![\"aria-pressed\", \"aria-checked\", \"aria-expanded\"].includes(name);\n}\n\n// packages/alpinejs/src/utils/on.js\nfunction on(el, event, modifiers, callback) {\n  let listenerTarget = el;\n  let handler3 = (e) => callback(e);\n  let options = {};\n  let wrapHandler = (callback2, wrapper) => (e) => wrapper(callback2, e);\n  if (modifiers.includes(\"dot\"))\n    event = dotSyntax(event);\n  if (modifiers.includes(\"camel\"))\n    event = camelCase2(event);\n  if (modifiers.includes(\"passive\"))\n    options.passive = true;\n  if (modifiers.includes(\"capture\"))\n    options.capture = true;\n  if (modifiers.includes(\"window\"))\n    listenerTarget = window;\n  if (modifiers.includes(\"document\"))\n    listenerTarget = document;\n  if (modifiers.includes(\"prevent\"))\n    handler3 = wrapHandler(handler3, (next, e) => {\n      e.preventDefault();\n      next(e);\n    });\n  if (modifiers.includes(\"stop\"))\n    handler3 = wrapHandler(handler3, (next, e) => {\n      e.stopPropagation();\n      next(e);\n    });\n  if (modifiers.includes(\"self\"))\n    handler3 = wrapHandler(handler3, (next, e) => {\n      e.target === el && next(e);\n    });\n  if (modifiers.includes(\"away\") || modifiers.includes(\"outside\")) {\n    listenerTarget = document;\n    handler3 = wrapHandler(handler3, (next, e) => {\n      if (el.contains(e.target))\n        return;\n      if (el.offsetWidth < 1 && el.offsetHeight < 1)\n        return;\n      if (el._x_isShown === false)\n        return;\n      next(e);\n    });\n  }\n  handler3 = wrapHandler(handler3, (next, e) => {\n    if (isKeyEvent(event)) {\n      if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {\n        return;\n      }\n    }\n    next(e);\n  });\n  if (modifiers.includes(\"debounce\")) {\n    let nextModifier = modifiers[modifiers.indexOf(\"debounce\") + 1] || \"invalid-wait\";\n    let wait = isNumeric(nextModifier.split(\"ms\")[0]) ? Number(nextModifier.split(\"ms\")[0]) : 250;\n    handler3 = debounce(handler3, wait);\n  }\n  if (modifiers.includes(\"throttle\")) {\n    let nextModifier = modifiers[modifiers.indexOf(\"throttle\") + 1] || \"invalid-wait\";\n    let wait = isNumeric(nextModifier.split(\"ms\")[0]) ? Number(nextModifier.split(\"ms\")[0]) : 250;\n    handler3 = throttle(handler3, wait);\n  }\n  if (modifiers.includes(\"once\")) {\n    handler3 = wrapHandler(handler3, (next, e) => {\n      next(e);\n      listenerTarget.removeEventListener(event, handler3, options);\n    });\n  }\n  listenerTarget.addEventListener(event, handler3, options);\n  return () => {\n    listenerTarget.removeEventListener(event, handler3, options);\n  };\n}\nfunction dotSyntax(subject) {\n  return subject.replace(/-/g, \".\");\n}\nfunction camelCase2(subject) {\n  return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n}\nfunction isNumeric(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\nfunction kebabCase2(subject) {\n  return subject.replace(/([a-z])([A-Z])/g, \"$1-$2\").replace(/[_\\s]/, \"-\").toLowerCase();\n}\nfunction isKeyEvent(event) {\n  return [\"keydown\", \"keyup\"].includes(event);\n}\nfunction isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {\n  let keyModifiers = modifiers.filter((i) => {\n    return ![\"window\", \"document\", \"prevent\", \"stop\", \"once\"].includes(i);\n  });\n  if (keyModifiers.includes(\"debounce\")) {\n    let debounceIndex = keyModifiers.indexOf(\"debounce\");\n    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || \"invalid-wait\").split(\"ms\")[0]) ? 2 : 1);\n  }\n  if (keyModifiers.length === 0)\n    return false;\n  if (keyModifiers.length === 1 && keyToModifiers(e.key).includes(keyModifiers[0]))\n    return false;\n  const systemKeyModifiers = [\"ctrl\", \"shift\", \"alt\", \"meta\", \"cmd\", \"super\"];\n  const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));\n  keyModifiers = keyModifiers.filter((i) => !selectedSystemKeyModifiers.includes(i));\n  if (selectedSystemKeyModifiers.length > 0) {\n    const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {\n      if (modifier === \"cmd\" || modifier === \"super\")\n        modifier = \"meta\";\n      return e[`${modifier}Key`];\n    });\n    if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {\n      if (keyToModifiers(e.key).includes(keyModifiers[0]))\n        return false;\n    }\n  }\n  return true;\n}\nfunction keyToModifiers(key) {\n  if (!key)\n    return [];\n  key = kebabCase2(key);\n  let modifierToKeyMap = {\n    ctrl: \"control\",\n    slash: \"/\",\n    space: \"-\",\n    spacebar: \"-\",\n    cmd: \"meta\",\n    esc: \"escape\",\n    up: \"arrow-up\",\n    down: \"arrow-down\",\n    left: \"arrow-left\",\n    right: \"arrow-right\",\n    period: \".\",\n    equal: \"=\"\n  };\n  modifierToKeyMap[key] = key;\n  return Object.keys(modifierToKeyMap).map((modifier) => {\n    if (modifierToKeyMap[modifier] === key)\n      return modifier;\n  }).filter((modifier) => modifier);\n}\n\n// packages/alpinejs/src/directives/x-model.js\ndirective(\"model\", (el, {modifiers, expression}, {effect: effect3, cleanup}) => {\n  let evaluate2 = evaluateLater(el, expression);\n  let assignmentExpression = `${expression} = rightSideOfExpression($event, ${expression})`;\n  let evaluateAssignment = evaluateLater(el, assignmentExpression);\n  var event = el.tagName.toLowerCase() === \"select\" || [\"checkbox\", \"radio\"].includes(el.type) || modifiers.includes(\"lazy\") ? \"change\" : \"input\";\n  let assigmentFunction = generateAssignmentFunction(el, modifiers, expression);\n  let removeListener = on(el, event, modifiers, (e) => {\n    evaluateAssignment(() => {\n    }, {scope: {\n      $event: e,\n      rightSideOfExpression: assigmentFunction\n    }});\n  });\n  cleanup(() => removeListener());\n  let evaluateSetModel = evaluateLater(el, `${expression} = __placeholder`);\n  el._x_model = {\n    get() {\n      let result;\n      evaluate2((value) => result = value);\n      return result;\n    },\n    set(value) {\n      evaluateSetModel(() => {\n      }, {scope: {__placeholder: value}});\n    }\n  };\n  el._x_forceModelUpdate = () => {\n    evaluate2((value) => {\n      if (value === void 0 && expression.match(/\\./))\n        value = \"\";\n      window.fromModel = true;\n      mutateDom(() => bind(el, \"value\", value));\n      delete window.fromModel;\n    });\n  };\n  effect3(() => {\n    if (modifiers.includes(\"unintrusive\") && document.activeElement.isSameNode(el))\n      return;\n    el._x_forceModelUpdate();\n  });\n});\nfunction generateAssignmentFunction(el, modifiers, expression) {\n  if (el.type === \"radio\") {\n    mutateDom(() => {\n      if (!el.hasAttribute(\"name\"))\n        el.setAttribute(\"name\", expression);\n    });\n  }\n  return (event, currentValue) => {\n    return mutateDom(() => {\n      if (event instanceof CustomEvent && event.detail !== void 0) {\n        return event.detail || event.target.value;\n      } else if (el.type === \"checkbox\") {\n        if (Array.isArray(currentValue)) {\n          let newValue = modifiers.includes(\"number\") ? safeParseNumber(event.target.value) : event.target.value;\n          return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));\n        } else {\n          return event.target.checked;\n        }\n      } else if (el.tagName.toLowerCase() === \"select\" && el.multiple) {\n        return modifiers.includes(\"number\") ? Array.from(event.target.selectedOptions).map((option) => {\n          let rawValue = option.value || option.text;\n          return safeParseNumber(rawValue);\n        }) : Array.from(event.target.selectedOptions).map((option) => {\n          return option.value || option.text;\n        });\n      } else {\n        let rawValue = event.target.value;\n        return modifiers.includes(\"number\") ? safeParseNumber(rawValue) : modifiers.includes(\"trim\") ? rawValue.trim() : rawValue;\n      }\n    });\n  };\n}\nfunction safeParseNumber(rawValue) {\n  let number = rawValue ? parseFloat(rawValue) : null;\n  return isNumeric2(number) ? number : rawValue;\n}\nfunction checkedAttrLooseCompare2(valueA, valueB) {\n  return valueA == valueB;\n}\nfunction isNumeric2(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\n\n// packages/alpinejs/src/directives/x-cloak.js\ndirective(\"cloak\", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix(\"cloak\")))));\n\n// packages/alpinejs/src/directives/x-init.js\naddInitSelector(() => `[${prefix(\"init\")}]`);\ndirective(\"init\", skipDuringClone((el, {expression}) => {\n  if (typeof expression === \"string\") {\n    return !!expression.trim() && evaluate(el, expression, {}, false);\n  }\n  return evaluate(el, expression, {}, false);\n}));\n\n// packages/alpinejs/src/directives/x-text.js\ndirective(\"text\", (el, {expression}, {effect: effect3, evaluateLater: evaluateLater2}) => {\n  let evaluate2 = evaluateLater2(expression);\n  effect3(() => {\n    evaluate2((value) => {\n      mutateDom(() => {\n        el.textContent = value;\n      });\n    });\n  });\n});\n\n// packages/alpinejs/src/directives/x-html.js\ndirective(\"html\", (el, {expression}, {effect: effect3, evaluateLater: evaluateLater2}) => {\n  let evaluate2 = evaluateLater2(expression);\n  effect3(() => {\n    evaluate2((value) => {\n      el.innerHTML = value;\n    });\n  });\n});\n\n// packages/alpinejs/src/directives/x-bind.js\nmapAttributes(startingWith(\":\", into(prefix(\"bind:\"))));\ndirective(\"bind\", (el, {value, modifiers, expression, original}, {effect: effect3}) => {\n  if (!value)\n    return applyBindingsObject(el, expression, original, effect3);\n  if (value === \"key\")\n    return storeKeyForXFor(el, expression);\n  let evaluate2 = evaluateLater(el, expression);\n  effect3(() => evaluate2((result) => {\n    if (result === void 0 && expression.match(/\\./))\n      result = \"\";\n    mutateDom(() => bind(el, value, result, modifiers));\n  }));\n});\nfunction applyBindingsObject(el, expression, original, effect3) {\n  let getBindings = evaluateLater(el, expression);\n  let cleanupRunners = [];\n  effect3(() => {\n    while (cleanupRunners.length)\n      cleanupRunners.pop()();\n    getBindings((bindings) => {\n      let attributes = Object.entries(bindings).map(([name, value]) => ({name, value}));\n      attributes = attributes.filter((attr) => {\n        return !(typeof attr.value === \"object\" && !Array.isArray(attr.value) && attr.value !== null);\n      });\n      let staticAttributes = attributesOnly(attributes);\n      attributes = attributes.map((attribute) => {\n        if (staticAttributes.find((attr) => attr.name === attribute.name)) {\n          return {\n            name: `x-bind:${attribute.name}`,\n            value: `\"${attribute.value}\"`\n          };\n        }\n        return attribute;\n      });\n      directives(el, attributes, original).map((handle) => {\n        cleanupRunners.push(handle.runCleanups);\n        handle();\n      });\n    });\n  });\n}\nfunction storeKeyForXFor(el, expression) {\n  el._x_keyExpression = expression;\n}\n\n// packages/alpinejs/src/directives/x-data.js\naddRootSelector(() => `[${prefix(\"data\")}]`);\ndirective(\"data\", skipDuringClone((el, {expression}, {cleanup}) => {\n  expression = expression === \"\" ? \"{}\" : expression;\n  let magicContext = {};\n  injectMagics(magicContext, el);\n  let dataProviderContext = {};\n  injectDataProviders(dataProviderContext, magicContext);\n  let data2 = evaluate(el, expression, {scope: dataProviderContext});\n  if (data2 === void 0)\n    data2 = {};\n  injectMagics(data2, el);\n  let reactiveData = reactive(data2);\n  initInterceptors(reactiveData);\n  let undo = addScopeToNode(el, reactiveData);\n  reactiveData[\"init\"] && evaluate(el, reactiveData[\"init\"]);\n  cleanup(() => {\n    undo();\n    reactiveData[\"destroy\"] && evaluate(el, reactiveData[\"destroy\"]);\n  });\n}));\n\n// packages/alpinejs/src/directives/x-show.js\ndirective(\"show\", (el, {modifiers, expression}, {effect: effect3}) => {\n  let evaluate2 = evaluateLater(el, expression);\n  let hide = () => mutateDom(() => {\n    el.style.display = \"none\";\n    el._x_isShown = false;\n  });\n  let show = () => mutateDom(() => {\n    if (el.style.length === 1 && el.style.display === \"none\") {\n      el.removeAttribute(\"style\");\n    } else {\n      el.style.removeProperty(\"display\");\n    }\n    el._x_isShown = true;\n  });\n  let clickAwayCompatibleShow = () => setTimeout(show);\n  let toggle = once((value) => value ? show() : hide(), (value) => {\n    if (typeof el._x_toggleAndCascadeWithTransitions === \"function\") {\n      el._x_toggleAndCascadeWithTransitions(el, value, show, hide);\n    } else {\n      value ? clickAwayCompatibleShow() : hide();\n    }\n  });\n  let oldValue;\n  let firstTime = true;\n  effect3(() => evaluate2((value) => {\n    if (!firstTime && value === oldValue)\n      return;\n    if (modifiers.includes(\"immediate\"))\n      value ? clickAwayCompatibleShow() : hide();\n    toggle(value);\n    oldValue = value;\n    firstTime = false;\n  }));\n});\n\n// packages/alpinejs/src/directives/x-for.js\ndirective(\"for\", (el, {expression}, {effect: effect3, cleanup}) => {\n  let iteratorNames = parseForExpression(expression);\n  let evaluateItems = evaluateLater(el, iteratorNames.items);\n  let evaluateKey = evaluateLater(el, el._x_keyExpression || \"index\");\n  el._x_prevKeys = [];\n  el._x_lookup = {};\n  effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));\n  cleanup(() => {\n    Object.values(el._x_lookup).forEach((el2) => el2.remove());\n    delete el._x_prevKeys;\n    delete el._x_lookup;\n  });\n});\nfunction loop(el, iteratorNames, evaluateItems, evaluateKey) {\n  let isObject = (i) => typeof i === \"object\" && !Array.isArray(i);\n  let templateEl = el;\n  evaluateItems((items) => {\n    if (isNumeric3(items) && items >= 0) {\n      items = Array.from(Array(items).keys(), (i) => i + 1);\n    }\n    if (items === void 0)\n      items = [];\n    let lookup = el._x_lookup;\n    let prevKeys = el._x_prevKeys;\n    let scopes = [];\n    let keys = [];\n    if (isObject(items)) {\n      items = Object.entries(items).map(([key, value]) => {\n        let scope = getIterationScopeVariables(iteratorNames, value, key, items);\n        evaluateKey((value2) => keys.push(value2), {scope: {index: key, ...scope}});\n        scopes.push(scope);\n      });\n    } else {\n      for (let i = 0; i < items.length; i++) {\n        let scope = getIterationScopeVariables(iteratorNames, items[i], i, items);\n        evaluateKey((value) => keys.push(value), {scope: {index: i, ...scope}});\n        scopes.push(scope);\n      }\n    }\n    let adds = [];\n    let moves = [];\n    let removes = [];\n    let sames = [];\n    for (let i = 0; i < prevKeys.length; i++) {\n      let key = prevKeys[i];\n      if (keys.indexOf(key) === -1)\n        removes.push(key);\n    }\n    prevKeys = prevKeys.filter((key) => !removes.includes(key));\n    let lastKey = \"template\";\n    for (let i = 0; i < keys.length; i++) {\n      let key = keys[i];\n      let prevIndex = prevKeys.indexOf(key);\n      if (prevIndex === -1) {\n        prevKeys.splice(i, 0, key);\n        adds.push([lastKey, i]);\n      } else if (prevIndex !== i) {\n        let keyInSpot = prevKeys.splice(i, 1)[0];\n        let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];\n        prevKeys.splice(i, 0, keyForSpot);\n        prevKeys.splice(prevIndex, 0, keyInSpot);\n        moves.push([keyInSpot, keyForSpot]);\n      } else {\n        sames.push(key);\n      }\n      lastKey = key;\n    }\n    for (let i = 0; i < removes.length; i++) {\n      let key = removes[i];\n      lookup[key].remove();\n      lookup[key] = null;\n      delete lookup[key];\n    }\n    for (let i = 0; i < moves.length; i++) {\n      let [keyInSpot, keyForSpot] = moves[i];\n      let elInSpot = lookup[keyInSpot];\n      let elForSpot = lookup[keyForSpot];\n      let marker = document.createElement(\"div\");\n      mutateDom(() => {\n        elForSpot.after(marker);\n        elInSpot.after(elForSpot);\n        marker.before(elInSpot);\n        marker.remove();\n      });\n      refreshScope(elForSpot, scopes[keys.indexOf(keyForSpot)]);\n    }\n    for (let i = 0; i < adds.length; i++) {\n      let [lastKey2, index] = adds[i];\n      let lastEl = lastKey2 === \"template\" ? templateEl : lookup[lastKey2];\n      let scope = scopes[index];\n      let key = keys[index];\n      let clone2 = document.importNode(templateEl.content, true).firstElementChild;\n      addScopeToNode(clone2, reactive(scope), templateEl);\n      mutateDom(() => {\n        lastEl.after(clone2);\n        initTree(clone2);\n      });\n      if (typeof key === \"object\") {\n        warn(\"x-for key cannot be an object, it must be a string or an integer\", templateEl);\n      }\n      lookup[key] = clone2;\n    }\n    for (let i = 0; i < sames.length; i++) {\n      refreshScope(lookup[sames[i]], scopes[keys.indexOf(sames[i])]);\n    }\n    templateEl._x_prevKeys = keys;\n  });\n}\nfunction parseForExpression(expression) {\n  let forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  let stripParensRE = /^\\s*\\(|\\)\\s*$/g;\n  let forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n  let inMatch = expression.match(forAliasRE);\n  if (!inMatch)\n    return;\n  let res = {};\n  res.items = inMatch[2].trim();\n  let item = inMatch[1].replace(stripParensRE, \"\").trim();\n  let iteratorMatch = item.match(forIteratorRE);\n  if (iteratorMatch) {\n    res.item = item.replace(forIteratorRE, \"\").trim();\n    res.index = iteratorMatch[1].trim();\n    if (iteratorMatch[2]) {\n      res.collection = iteratorMatch[2].trim();\n    }\n  } else {\n    res.item = item;\n  }\n  return res;\n}\nfunction getIterationScopeVariables(iteratorNames, item, index, items) {\n  let scopeVariables = {};\n  if (/^\\[.*\\]$/.test(iteratorNames.item) && Array.isArray(item)) {\n    let names = iteratorNames.item.replace(\"[\", \"\").replace(\"]\", \"\").split(\",\").map((i) => i.trim());\n    names.forEach((name, i) => {\n      scopeVariables[name] = item[i];\n    });\n  } else if (/^\\{.*\\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === \"object\") {\n    let names = iteratorNames.item.replace(\"{\", \"\").replace(\"}\", \"\").split(\",\").map((i) => i.trim());\n    names.forEach((name) => {\n      scopeVariables[name] = item[name];\n    });\n  } else {\n    scopeVariables[iteratorNames.item] = item;\n  }\n  if (iteratorNames.index)\n    scopeVariables[iteratorNames.index] = index;\n  if (iteratorNames.collection)\n    scopeVariables[iteratorNames.collection] = items;\n  return scopeVariables;\n}\nfunction isNumeric3(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\n\n// packages/alpinejs/src/directives/x-ref.js\nfunction handler2() {\n}\nhandler2.inline = (el, {expression}, {cleanup}) => {\n  let root = closestRoot(el);\n  if (!root._x_refs)\n    root._x_refs = {};\n  root._x_refs[expression] = el;\n  cleanup(() => delete root._x_refs[expression]);\n};\ndirective(\"ref\", handler2);\n\n// packages/alpinejs/src/directives/x-if.js\ndirective(\"if\", (el, {expression}, {effect: effect3, cleanup}) => {\n  let evaluate2 = evaluateLater(el, expression);\n  let show = () => {\n    if (el._x_currentIfEl)\n      return el._x_currentIfEl;\n    let clone2 = el.content.cloneNode(true).firstElementChild;\n    addScopeToNode(clone2, {}, el);\n    mutateDom(() => {\n      el.after(clone2);\n      initTree(clone2);\n    });\n    el._x_currentIfEl = clone2;\n    el._x_undoIf = () => {\n      clone2.remove();\n      delete el._x_currentIfEl;\n    };\n    return clone2;\n  };\n  let hide = () => {\n    if (!el._x_undoIf)\n      return;\n    el._x_undoIf();\n    delete el._x_undoIf;\n  };\n  effect3(() => evaluate2((value) => {\n    value ? show() : hide();\n  }));\n  cleanup(() => el._x_undoIf && el._x_undoIf());\n});\n\n// packages/alpinejs/src/directives/x-on.js\nmapAttributes(startingWith(\"@\", into(prefix(\"on:\"))));\ndirective(\"on\", skipDuringClone((el, {value, modifiers, expression}, {cleanup}) => {\n  let evaluate2 = expression ? evaluateLater(el, expression) : () => {\n  };\n  let removeListener = on(el, value, modifiers, (e) => {\n    evaluate2(() => {\n    }, {scope: {$event: e}, params: [e]});\n  });\n  cleanup(() => removeListener());\n}));\n\n// packages/alpinejs/src/index.js\nalpine_default.setEvaluator(normalEvaluator);\nalpine_default.setReactivityEngine({reactive: import_reactivity9.reactive, effect: import_reactivity9.effect, release: import_reactivity9.stop, raw: import_reactivity9.toRaw});\nvar src_default = alpine_default;\n\n// packages/alpinejs/builds/module.js\nvar module_default = src_default;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWxwaW5lanMvZGlzdC9tb2R1bGUuZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsWUFBWTtBQUM5RTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0ZBQStGO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLG1FQUFtRSw2Q0FBNkMsR0FBRyxnQ0FBZ0M7QUFDdFA7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0EsZ0NBQWdDLCtCQUErQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSyxFQUFFLGlEQUFpRCxLQUFLLFNBQVM7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQSxNQUFNLEtBQUssRUFBRSxFQUVWLENBQUM7QUFDSjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZ0RBQWdEO0FBQ2hEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUIseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pELHdCQUF3Qix5QkFBeUIsWUFBWSxJQUFJO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTSxnRUFBZ0UsaUNBQWlDO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZUFBZTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNB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TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVLEdBQUcsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixXQUFXLEdBQUcsZ0JBQWdCOztBQUV4RDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLHlCQUF5QixzQkFBc0IsR0FBRyx5QkFBeUI7QUFDM0U7QUFDQSxnQ0FBZ0MsWUFBWSxrQ0FBa0MsV0FBVztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTixHQUFHO0FBQ0g7QUFDQSw4Q0FBOEMsWUFBWTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPLEdBQUcsUUFBUSxzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0Esb0NBQW9DO0FBQ3BDLENBQUM7O0FBRUQ7QUFDQSx3QkFBd0IsV0FBVyxHQUFHLCtDQUErQztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBLHdCQUF3QixXQUFXLEdBQUcsK0NBQStDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQSx3QkFBd0IsdUNBQXVDLEdBQUcsZ0JBQWdCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsWUFBWTtBQUNyRjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0MsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsZUFBZTtBQUN6Qyx3Q0FBd0MsV0FBVyxHQUFHLFFBQVE7QUFDOUQsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDJCQUEyQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0Esd0JBQXdCLHNCQUFzQixHQUFHLGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBLHVCQUF1QixXQUFXLEdBQUcseUJBQXlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRLHNCQUFzQjtBQUNsRjtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBLGtEQUFrRCxRQUFRLG9CQUFvQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxhQUFhLElBQUk7QUFDckIsNkNBQTZDLGlCQUFpQjtBQUM5RDtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXLEdBQUcsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixXQUFXLEdBQUcseUJBQXlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLHNDQUFzQyw2QkFBNkIsR0FBRyxRQUFRO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHLFFBQVEsVUFBVSxjQUFjO0FBQ3hDLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLG9DQUFvQywwSUFBMEk7QUFDOUs7O0FBRUE7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FscGluZWpzL2Rpc3QvbW9kdWxlLmVzbS5qcz8wMjdlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG52YXIgX19jb21tb25KUyA9IChjYWxsYmFjaywgbW9kdWxlKSA9PiAoKSA9PiB7XG4gIGlmICghbW9kdWxlKSB7XG4gICAgbW9kdWxlID0ge2V4cG9ydHM6IHt9fTtcbiAgICBjYWxsYmFjayhtb2R1bGUuZXhwb3J0cywgbW9kdWxlKTtcbiAgfVxuICByZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59O1xudmFyIF9fZXhwb3J0U3RhciA9ICh0YXJnZXQsIG1vZHVsZSwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlICYmIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHtnZXQ6ICgpID0+IG1vZHVsZVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUpID0+IHtcbiAgcmV0dXJuIF9fZXhwb3J0U3RhcihfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUgPyB7Z2V0OiAoKSA9PiBtb2R1bGUuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZX0gOiB7dmFsdWU6IG1vZHVsZSwgZW51bWVyYWJsZTogdHJ1ZX0pKSwgbW9kdWxlKTtcbn07XG5cbi8vIG5vZGVfbW9kdWxlcy9AdnVlL3NoYXJlZC9kaXN0L3NoYXJlZC5janMuanNcbnZhciByZXF1aXJlX3NoYXJlZF9janMgPSBfX2NvbW1vbkpTKChleHBvcnRzKSA9PiB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pO1xuICBmdW5jdGlvbiBtYWtlTWFwKHN0ciwgZXhwZWN0c0xvd2VyQ2FzZSkge1xuICAgIGNvbnN0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3QgbGlzdCA9IHN0ci5zcGxpdChcIixcIik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZSA/ICh2YWwpID0+ICEhbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXSA6ICh2YWwpID0+ICEhbWFwW3ZhbF07XG4gIH1cbiAgdmFyIFBhdGNoRmxhZ05hbWVzID0ge1xuICAgIFsxXTogYFRFWFRgLFxuICAgIFsyXTogYENMQVNTYCxcbiAgICBbNF06IGBTVFlMRWAsXG4gICAgWzhdOiBgUFJPUFNgLFxuICAgIFsxNl06IGBGVUxMX1BST1BTYCxcbiAgICBbMzJdOiBgSFlEUkFURV9FVkVOVFNgLFxuICAgIFs2NF06IGBTVEFCTEVfRlJBR01FTlRgLFxuICAgIFsxMjhdOiBgS0VZRURfRlJBR01FTlRgLFxuICAgIFsyNTZdOiBgVU5LRVlFRF9GUkFHTUVOVGAsXG4gICAgWzUxMl06IGBORUVEX1BBVENIYCxcbiAgICBbMTAyNF06IGBEWU5BTUlDX1NMT1RTYCxcbiAgICBbMjA0OF06IGBERVZfUk9PVF9GUkFHTUVOVGAsXG4gICAgWy0xXTogYEhPSVNURURgLFxuICAgIFstMl06IGBCQUlMYFxuICB9O1xuICB2YXIgc2xvdEZsYWdzVGV4dCA9IHtcbiAgICBbMV06IFwiU1RBQkxFXCIsXG4gICAgWzJdOiBcIkRZTkFNSUNcIixcbiAgICBbM106IFwiRk9SV0FSREVEXCJcbiAgfTtcbiAgdmFyIEdMT0JBTFNfV0hJVEVfTElTVEVEID0gXCJJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLHBhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LE1hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnRcIjtcbiAgdmFyIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKEdMT0JBTFNfV0hJVEVfTElTVEVEKTtcbiAgdmFyIHJhbmdlID0gMjtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUoc291cmNlLCBzdGFydDIgPSAwLCBlbmQgPSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgY29uc3QgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvdW50ICs9IGxpbmVzW2ldLmxlbmd0aCArIDE7XG4gICAgICBpZiAoY291bnQgPj0gc3RhcnQyKSB7XG4gICAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjb25zdCBsaW5lID0gaiArIDE7XG4gICAgICAgICAgcmVzLnB1c2goYCR7bGluZX0ke1wiIFwiLnJlcGVhdChNYXRoLm1heCgzIC0gU3RyaW5nKGxpbmUpLmxlbmd0aCwgMCkpfXwgICR7bGluZXNbal19YCk7XG4gICAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgICAgY29uc3QgcGFkID0gc3RhcnQyIC0gKGNvdW50IC0gbGluZUxlbmd0aCkgKyAxO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoMSwgZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnQyKTtcbiAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgXCIgXCIucmVwZWF0KHBhZCkgKyBcIl5cIi5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKSwgMSk7XG4gICAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgdmFyIHNwZWNpYWxCb29sZWFuQXR0cnMgPSBgaXRlbXNjb3BlLGFsbG93ZnVsbHNjcmVlbixmb3Jtbm92YWxpZGF0ZSxpc21hcCxub21vZHVsZSxub3ZhbGlkYXRlLHJlYWRvbmx5YDtcbiAgdmFyIGlzU3BlY2lhbEJvb2xlYW5BdHRyID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyk7XG4gIHZhciBpc0Jvb2xlYW5BdHRyMiA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMgKyBgLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjb250cm9scyxkZWZhdWx0LGRlZmVyLGRpc2FibGVkLGhpZGRlbixsb29wLG9wZW4scmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLGNoZWNrZWQsbXV0ZWQsbXVsdGlwbGUsc2VsZWN0ZWRgKTtcbiAgdmFyIHVuc2FmZUF0dHJDaGFyUkUgPSAvWz4vPVwiJ1xcdTAwMDlcXHUwMDBhXFx1MDAwY1xcdTAwMjBdLztcbiAgdmFyIGF0dHJWYWxpZGF0aW9uQ2FjaGUgPSB7fTtcbiAgZnVuY3Rpb24gaXNTU1JTYWZlQXR0ck5hbWUobmFtZSkge1xuICAgIGlmIChhdHRyVmFsaWRhdGlvbkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXTtcbiAgICB9XG4gICAgY29uc3QgaXNVbnNhZmUgPSB1bnNhZmVBdHRyQ2hhclJFLnRlc3QobmFtZSk7XG4gICAgaWYgKGlzVW5zYWZlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGB1bnNhZmUgYXR0cmlidXRlIG5hbWU6ICR7bmFtZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV0gPSAhaXNVbnNhZmU7XG4gIH1cbiAgdmFyIHByb3BzVG9BdHRyTWFwID0ge1xuICAgIGFjY2VwdENoYXJzZXQ6IFwiYWNjZXB0LWNoYXJzZXRcIixcbiAgICBjbGFzc05hbWU6IFwiY2xhc3NcIixcbiAgICBodG1sRm9yOiBcImZvclwiLFxuICAgIGh0dHBFcXVpdjogXCJodHRwLWVxdWl2XCJcbiAgfTtcbiAgdmFyIGlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcCA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKGBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50LGJvcmRlci1pbWFnZS1vdXRzZXQsYm9yZGVyLWltYWdlLXNsaWNlLGJvcmRlci1pbWFnZS13aWR0aCxib3gtZmxleCxib3gtZmxleC1ncm91cCxib3gtb3JkaW5hbC1ncm91cCxjb2x1bW4tY291bnQsY29sdW1ucyxmbGV4LGZsZXgtZ3JvdyxmbGV4LXBvc2l0aXZlLGZsZXgtc2hyaW5rLGZsZXgtbmVnYXRpdmUsZmxleC1vcmRlcixncmlkLXJvdyxncmlkLXJvdy1lbmQsZ3JpZC1yb3ctc3BhbixncmlkLXJvdy1zdGFydCxncmlkLWNvbHVtbixncmlkLWNvbHVtbi1lbmQsZ3JpZC1jb2x1bW4tc3BhbixncmlkLWNvbHVtbi1zdGFydCxmb250LXdlaWdodCxsaW5lLWNsYW1wLGxpbmUtaGVpZ2h0LG9wYWNpdHksb3JkZXIsb3JwaGFucyx0YWItc2l6ZSx3aWRvd3Msei1pbmRleCx6b29tLGZpbGwtb3BhY2l0eSxmbG9vZC1vcGFjaXR5LHN0b3Atb3BhY2l0eSxzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LHN0cm9rZS1taXRlcmxpbWl0LHN0cm9rZS1vcGFjaXR5LHN0cm9rZS13aWR0aGApO1xuICB2YXIgaXNLbm93bkF0dHIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChgYWNjZXB0LGFjY2VwdC1jaGFyc2V0LGFjY2Vzc2tleSxhY3Rpb24sYWxpZ24sYWxsb3csYWx0LGFzeW5jLGF1dG9jYXBpdGFsaXplLGF1dG9jb21wbGV0ZSxhdXRvZm9jdXMsYXV0b3BsYXksYmFja2dyb3VuZCxiZ2NvbG9yLGJvcmRlcixidWZmZXJlZCxjYXB0dXJlLGNoYWxsZW5nZSxjaGFyc2V0LGNoZWNrZWQsY2l0ZSxjbGFzcyxjb2RlLGNvZGViYXNlLGNvbG9yLGNvbHMsY29sc3Bhbixjb250ZW50LGNvbnRlbnRlZGl0YWJsZSxjb250ZXh0bWVudSxjb250cm9scyxjb29yZHMsY3Jvc3NvcmlnaW4sY3NwLGRhdGEsZGF0ZXRpbWUsZGVjb2RpbmcsZGVmYXVsdCxkZWZlcixkaXIsZGlybmFtZSxkaXNhYmxlZCxkb3dubG9hZCxkcmFnZ2FibGUsZHJvcHpvbmUsZW5jdHlwZSxlbnRlcmtleWhpbnQsZm9yLGZvcm0sZm9ybWFjdGlvbixmb3JtZW5jdHlwZSxmb3JtbWV0aG9kLGZvcm1ub3ZhbGlkYXRlLGZvcm10YXJnZXQsaGVhZGVycyxoZWlnaHQsaGlkZGVuLGhpZ2gsaHJlZixocmVmbGFuZyxodHRwLWVxdWl2LGljb24saWQsaW1wb3J0YW5jZSxpbnRlZ3JpdHksaXNtYXAsaXRlbXByb3Asa2V5dHlwZSxraW5kLGxhYmVsLGxhbmcsbGFuZ3VhZ2UsbG9hZGluZyxsaXN0LGxvb3AsbG93LG1hbmlmZXN0LG1heCxtYXhsZW5ndGgsbWlubGVuZ3RoLG1lZGlhLG1pbixtdWx0aXBsZSxtdXRlZCxuYW1lLG5vdmFsaWRhdGUsb3BlbixvcHRpbXVtLHBhdHRlcm4scGluZyxwbGFjZWhvbGRlcixwb3N0ZXIscHJlbG9hZCxyYWRpb2dyb3VwLHJlYWRvbmx5LHJlZmVycmVycG9saWN5LHJlbCxyZXF1aXJlZCxyZXZlcnNlZCxyb3dzLHJvd3NwYW4sc2FuZGJveCxzY29wZSxzY29wZWQsc2VsZWN0ZWQsc2hhcGUsc2l6ZSxzaXplcyxzbG90LHNwYW4sc3BlbGxjaGVjayxzcmMsc3JjZG9jLHNyY2xhbmcsc3Jjc2V0LHN0YXJ0LHN0ZXAsc3R5bGUsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHJhbnNsYXRlLHR5cGUsdXNlbWFwLHZhbHVlLHdpZHRoLHdyYXBgKTtcbiAgZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUodmFsdWUpIHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTdHlsZShpc1N0cmluZyhpdGVtKSA/IHBhcnNlU3RyaW5nU3R5bGUoaXRlbSkgOiBpdGVtKTtcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxpemVkKSB7XG4gICAgICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZWRba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgdmFyIGxpc3REZWxpbWl0ZXJSRSA9IC87KD8hW14oXSpcXCkpL2c7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlclJFID0gLzooLispLztcbiAgZnVuY3Rpb24gcGFyc2VTdHJpbmdTdHlsZShjc3NUZXh0KSB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyUkUpLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIGNvbnN0IHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXJSRSk7XG4gICAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXRbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlKHN0eWxlcykge1xuICAgIGxldCByZXQgPSBcIlwiO1xuICAgIGlmICghc3R5bGVzKSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzdHlsZXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV07XG4gICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0ga2V5LnN0YXJ0c1dpdGgoYC0tYCkgPyBrZXkgOiBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIGlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcChub3JtYWxpemVkS2V5KSkge1xuICAgICAgICByZXQgKz0gYCR7bm9ybWFsaXplZEtleX06JHt2YWx1ZX07YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBub3JtYWxpemVDbGFzcyh2YWx1ZSkge1xuICAgIGxldCByZXMgPSBcIlwiO1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHJlcyA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUNsYXNzKHZhbHVlW2ldKTtcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICByZXMgKz0gbm9ybWFsaXplZCArIFwiIFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWVbbmFtZV0pIHtcbiAgICAgICAgICByZXMgKz0gbmFtZSArIFwiIFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXMudHJpbSgpO1xuICB9XG4gIHZhciBIVE1MX1RBR1MgPSBcImh0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbixkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsc3VtbWFyeSx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdFwiO1xuICB2YXIgU1ZHX1RBR1MgPSBcInN2ZyxhbmltYXRlLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxjaXJjbGUsY2xpcFBhdGgsY29sb3ItcHJvZmlsZSxkZWZzLGRlc2MsZGlzY2FyZCxlbGxpcHNlLGZlQmxlbmQsZmVDb2xvck1hdHJpeCxmZUNvbXBvbmVudFRyYW5zZmVyLGZlQ29tcG9zaXRlLGZlQ29udm9sdmVNYXRyaXgsZmVEaWZmdXNlTGlnaHRpbmcsZmVEaXNwbGFjZW1lbnRNYXAsZmVEaXN0YW5jZUxpZ2h0LGZlRHJvcFNoYWRvdyxmZUZsb29kLGZlRnVuY0EsZmVGdW5jQixmZUZ1bmNHLGZlRnVuY1IsZmVHYXVzc2lhbkJsdXIsZmVJbWFnZSxmZU1lcmdlLGZlTWVyZ2VOb2RlLGZlTW9ycGhvbG9neSxmZU9mZnNldCxmZVBvaW50TGlnaHQsZmVTcGVjdWxhckxpZ2h0aW5nLGZlU3BvdExpZ2h0LGZlVGlsZSxmZVR1cmJ1bGVuY2UsZmlsdGVyLGZvcmVpZ25PYmplY3QsZyxoYXRjaCxoYXRjaHBhdGgsaW1hZ2UsbGluZSxsaW5lYXJHcmFkaWVudCxtYXJrZXIsbWFzayxtZXNoLG1lc2hncmFkaWVudCxtZXNocGF0Y2gsbWVzaHJvdyxtZXRhZGF0YSxtcGF0aCxwYXRoLHBhdHRlcm4scG9seWdvbixwb2x5bGluZSxyYWRpYWxHcmFkaWVudCxyZWN0LHNldCxzb2xpZGNvbG9yLHN0b3Asc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRQYXRoLHRpdGxlLHRzcGFuLHVua25vd24sdXNlLHZpZXdcIjtcbiAgdmFyIFZPSURfVEFHUyA9IFwiYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxocixpbWcsaW5wdXQsbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnJcIjtcbiAgdmFyIGlzSFRNTFRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKEhUTUxfVEFHUyk7XG4gIHZhciBpc1NWR1RhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFNWR19UQUdTKTtcbiAgdmFyIGlzVm9pZFRhZyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKFZPSURfVEFHUyk7XG4gIHZhciBlc2NhcGVSRSA9IC9bXCInJjw+XS87XG4gIGZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gICAgY29uc3Qgc3RyID0gXCJcIiArIHN0cmluZztcbiAgICBjb25zdCBtYXRjaCA9IGVzY2FwZVJFLmV4ZWMoc3RyKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBsZXQgaHRtbCA9IFwiXCI7XG4gICAgbGV0IGVzY2FwZWQ7XG4gICAgbGV0IGluZGV4O1xuICAgIGxldCBsYXN0SW5kZXggPSAwO1xuICAgIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgIGVzY2FwZWQgPSBcIiZxdW90O1wiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgIGVzY2FwZWQgPSBcIiZhbXA7XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgZXNjYXBlZCA9IFwiJiMzOTtcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2MDpcbiAgICAgICAgICBlc2NhcGVkID0gXCImbHQ7XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNjI6XG4gICAgICAgICAgZXNjYXBlZCA9IFwiJmd0O1wiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgICAgaHRtbCArPSBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgaHRtbCArPSBlc2NhcGVkO1xuICAgIH1cbiAgICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbiAgfVxuICB2YXIgY29tbWVudFN0cmlwUkUgPSAvXi0/Pnw8IS0tfC0tPnwtLSE+fDwhLSQvZztcbiAgZnVuY3Rpb24gZXNjYXBlSHRtbENvbW1lbnQoc3JjKSB7XG4gICAgcmV0dXJuIHNyYy5yZXBsYWNlKGNvbW1lbnRTdHJpcFJFLCBcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGVxdWFsID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgZXF1YWwgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVxdWFsID0gbG9vc2VFcXVhbChhW2ldLCBiW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGVxdWFsO1xuICB9XG4gIGZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGFWYWxpZFR5cGUgPSBpc0RhdGUoYSk7XG4gICAgbGV0IGJWYWxpZFR5cGUgPSBpc0RhdGUoYik7XG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKSA6IGZhbHNlO1xuICAgIH1cbiAgICBhVmFsaWRUeXBlID0gaXNBcnJheShhKTtcbiAgICBiVmFsaWRUeXBlID0gaXNBcnJheShiKTtcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIDogZmFsc2U7XG4gICAgfVxuICAgIGFWYWxpZFR5cGUgPSBpc09iamVjdChhKTtcbiAgICBiVmFsaWRUeXBlID0gaXNPYmplY3QoYik7XG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgICAgaWYgKCFhVmFsaWRUeXBlIHx8ICFiVmFsaWRUeXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhhKS5sZW5ndGg7XG4gICAgICBjb25zdCBiS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYikubGVuZ3RoO1xuICAgICAgaWYgKGFLZXlzQ291bnQgIT09IGJLZXlzQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgICAgICBjb25zdCBhSGFzS2V5ID0gYS5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgICBjb25zdCBiSGFzS2V5ID0gYi5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgICBpZiAoYUhhc0tleSAmJiAhYkhhc0tleSB8fCAhYUhhc0tleSAmJiBiSGFzS2V5IHx8ICFsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG4gIH1cbiAgZnVuY3Rpb24gbG9vc2VJbmRleE9mKGFyciwgdmFsKSB7XG4gICAgcmV0dXJuIGFyci5maW5kSW5kZXgoKGl0ZW0pID0+IGxvb3NlRXF1YWwoaXRlbSwgdmFsKSk7XG4gIH1cbiAgdmFyIHRvRGlzcGxheVN0cmluZyA9ICh2YWwpID0+IHtcbiAgICByZXR1cm4gdmFsID09IG51bGwgPyBcIlwiIDogaXNPYmplY3QodmFsKSA/IEpTT04uc3RyaW5naWZ5KHZhbCwgcmVwbGFjZXIsIDIpIDogU3RyaW5nKHZhbCk7XG4gIH07XG4gIHZhciByZXBsYWNlciA9IChfa2V5LCB2YWwpID0+IHtcbiAgICBpZiAoaXNNYXAodmFsKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW2BNYXAoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwuZW50cmllcygpXS5yZWR1Y2UoKGVudHJpZXMsIFtrZXksIHZhbDJdKSA9PiB7XG4gICAgICAgICAgZW50cmllc1tgJHtrZXl9ID0+YF0gPSB2YWwyO1xuICAgICAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgICAgICB9LCB7fSlcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpc1NldCh2YWwpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbYFNldCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC52YWx1ZXMoKV1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpICYmICFpc0FycmF5KHZhbCkgJiYgIWlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmV0dXJuIFN0cmluZyh2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9O1xuICB2YXIgYmFiZWxQYXJzZXJEZWZhdWx0UGx1Z2lucyA9IFtcbiAgICBcImJpZ0ludFwiLFxuICAgIFwib3B0aW9uYWxDaGFpbmluZ1wiLFxuICAgIFwibnVsbGlzaENvYWxlc2NpbmdPcGVyYXRvclwiXG4gIF07XG4gIHZhciBFTVBUWV9PQkogPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgdmFyIEVNUFRZX0FSUiA9IE9iamVjdC5mcmVlemUoW10pO1xuICB2YXIgTk9PUCA9ICgpID0+IHtcbiAgfTtcbiAgdmFyIE5PID0gKCkgPT4gZmFsc2U7XG4gIHZhciBvblJFID0gL15vblteYS16XS87XG4gIHZhciBpc09uID0gKGtleSkgPT4gb25SRS50ZXN0KGtleSk7XG4gIHZhciBpc01vZGVsTGlzdGVuZXIgPSAoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aChcIm9uVXBkYXRlOlwiKTtcbiAgdmFyIGV4dGVuZCA9IE9iamVjdC5hc3NpZ247XG4gIHZhciByZW1vdmUgPSAoYXJyLCBlbCkgPT4ge1xuICAgIGNvbnN0IGkgPSBhcnIuaW5kZXhPZihlbCk7XG4gICAgaWYgKGkgPiAtMSkge1xuICAgICAgYXJyLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH07XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4gIHZhciBpc01hcCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgTWFwXVwiO1xuICB2YXIgaXNTZXQgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IFNldF1cIjtcbiAgdmFyIGlzRGF0ZSA9ICh2YWwpID0+IHZhbCBpbnN0YW5jZW9mIERhdGU7XG4gIHZhciBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiO1xuICB2YXIgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiO1xuICB2YXIgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN5bWJvbFwiO1xuICB2YXIgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcbiAgICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC50aGVuKSAmJiBpc0Z1bmN0aW9uKHZhbC5jYXRjaCk7XG4gIH07XG4gIHZhciBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gIHZhciB0b1R5cGVTdHJpbmcgPSAodmFsdWUpID0+IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB2YXIgdG9SYXdUeXBlID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHRvVHlwZVN0cmluZyh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xuICB9O1xuICB2YXIgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xuICB2YXIgaXNJbnRlZ2VyS2V5ID0gKGtleSkgPT4gaXNTdHJpbmcoa2V5KSAmJiBrZXkgIT09IFwiTmFOXCIgJiYga2V5WzBdICE9PSBcIi1cIiAmJiBcIlwiICsgcGFyc2VJbnQoa2V5LCAxMCkgPT09IGtleTtcbiAgdmFyIGlzUmVzZXJ2ZWRQcm9wID0gLyogQF9fUFVSRV9fICovIG1ha2VNYXAoXCIsa2V5LHJlZixvblZub2RlQmVmb3JlTW91bnQsb25Wbm9kZU1vdW50ZWQsb25Wbm9kZUJlZm9yZVVwZGF0ZSxvblZub2RlVXBkYXRlZCxvblZub2RlQmVmb3JlVW5tb3VudCxvblZub2RlVW5tb3VudGVkXCIpO1xuICB2YXIgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gKHN0cikgPT4ge1xuICAgICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcbiAgICB9O1xuICB9O1xuICB2YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbiAgdmFyIGNhbWVsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiBjID8gYy50b1VwcGVyQ2FzZSgpIDogXCJcIik7XG4gIH0pO1xuICB2YXIgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xuICB2YXIgaHlwaGVuYXRlID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG4gIHZhciBjYXBpdGFsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSkpO1xuICB2YXIgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIgPyBgb24ke2NhcGl0YWxpemUoc3RyKX1gIDogYGApO1xuICB2YXIgaGFzQ2hhbmdlZCA9ICh2YWx1ZSwgb2xkVmFsdWUpID0+IHZhbHVlICE9PSBvbGRWYWx1ZSAmJiAodmFsdWUgPT09IHZhbHVlIHx8IG9sZFZhbHVlID09PSBvbGRWYWx1ZSk7XG4gIHZhciBpbnZva2VBcnJheUZucyA9IChmbnMsIGFyZykgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmbnNbaV0oYXJnKTtcbiAgICB9XG4gIH07XG4gIHZhciBkZWYgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH07XG4gIHZhciB0b051bWJlciA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG4gIH07XG4gIHZhciBfZ2xvYmFsVGhpcztcbiAgdmFyIGdldEdsb2JhbFRoaXMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaGlzIHx8IChfZ2xvYmFsVGhpcyA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pO1xuICB9O1xuICBleHBvcnRzLkVNUFRZX0FSUiA9IEVNUFRZX0FSUjtcbiAgZXhwb3J0cy5FTVBUWV9PQkogPSBFTVBUWV9PQko7XG4gIGV4cG9ydHMuTk8gPSBOTztcbiAgZXhwb3J0cy5OT09QID0gTk9PUDtcbiAgZXhwb3J0cy5QYXRjaEZsYWdOYW1lcyA9IFBhdGNoRmxhZ05hbWVzO1xuICBleHBvcnRzLmJhYmVsUGFyc2VyRGVmYXVsdFBsdWdpbnMgPSBiYWJlbFBhcnNlckRlZmF1bHRQbHVnaW5zO1xuICBleHBvcnRzLmNhbWVsaXplID0gY2FtZWxpemU7XG4gIGV4cG9ydHMuY2FwaXRhbGl6ZSA9IGNhcGl0YWxpemU7XG4gIGV4cG9ydHMuZGVmID0gZGVmO1xuICBleHBvcnRzLmVzY2FwZUh0bWwgPSBlc2NhcGVIdG1sO1xuICBleHBvcnRzLmVzY2FwZUh0bWxDb21tZW50ID0gZXNjYXBlSHRtbENvbW1lbnQ7XG4gIGV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xuICBleHBvcnRzLmdlbmVyYXRlQ29kZUZyYW1lID0gZ2VuZXJhdGVDb2RlRnJhbWU7XG4gIGV4cG9ydHMuZ2V0R2xvYmFsVGhpcyA9IGdldEdsb2JhbFRoaXM7XG4gIGV4cG9ydHMuaGFzQ2hhbmdlZCA9IGhhc0NoYW5nZWQ7XG4gIGV4cG9ydHMuaGFzT3duID0gaGFzT3duO1xuICBleHBvcnRzLmh5cGhlbmF0ZSA9IGh5cGhlbmF0ZTtcbiAgZXhwb3J0cy5pbnZva2VBcnJheUZucyA9IGludm9rZUFycmF5Rm5zO1xuICBleHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuICBleHBvcnRzLmlzQm9vbGVhbkF0dHIgPSBpc0Jvb2xlYW5BdHRyMjtcbiAgZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG4gIGV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gIGV4cG9ydHMuaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gaXNHbG9iYWxseVdoaXRlbGlzdGVkO1xuICBleHBvcnRzLmlzSFRNTFRhZyA9IGlzSFRNTFRhZztcbiAgZXhwb3J0cy5pc0ludGVnZXJLZXkgPSBpc0ludGVnZXJLZXk7XG4gIGV4cG9ydHMuaXNLbm93bkF0dHIgPSBpc0tub3duQXR0cjtcbiAgZXhwb3J0cy5pc01hcCA9IGlzTWFwO1xuICBleHBvcnRzLmlzTW9kZWxMaXN0ZW5lciA9IGlzTW9kZWxMaXN0ZW5lcjtcbiAgZXhwb3J0cy5pc05vVW5pdE51bWVyaWNTdHlsZVByb3AgPSBpc05vVW5pdE51bWVyaWNTdHlsZVByb3A7XG4gIGV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbiAgZXhwb3J0cy5pc09uID0gaXNPbjtcbiAgZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG4gIGV4cG9ydHMuaXNSZXNlcnZlZFByb3AgPSBpc1Jlc2VydmVkUHJvcDtcbiAgZXhwb3J0cy5pc1NTUlNhZmVBdHRyTmFtZSA9IGlzU1NSU2FmZUF0dHJOYW1lO1xuICBleHBvcnRzLmlzU1ZHVGFnID0gaXNTVkdUYWc7XG4gIGV4cG9ydHMuaXNTZXQgPSBpc1NldDtcbiAgZXhwb3J0cy5pc1NwZWNpYWxCb29sZWFuQXR0ciA9IGlzU3BlY2lhbEJvb2xlYW5BdHRyO1xuICBleHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG4gIGV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcbiAgZXhwb3J0cy5pc1ZvaWRUYWcgPSBpc1ZvaWRUYWc7XG4gIGV4cG9ydHMubG9vc2VFcXVhbCA9IGxvb3NlRXF1YWw7XG4gIGV4cG9ydHMubG9vc2VJbmRleE9mID0gbG9vc2VJbmRleE9mO1xuICBleHBvcnRzLm1ha2VNYXAgPSBtYWtlTWFwO1xuICBleHBvcnRzLm5vcm1hbGl6ZUNsYXNzID0gbm9ybWFsaXplQ2xhc3M7XG4gIGV4cG9ydHMubm9ybWFsaXplU3R5bGUgPSBub3JtYWxpemVTdHlsZTtcbiAgZXhwb3J0cy5vYmplY3RUb1N0cmluZyA9IG9iamVjdFRvU3RyaW5nO1xuICBleHBvcnRzLnBhcnNlU3RyaW5nU3R5bGUgPSBwYXJzZVN0cmluZ1N0eWxlO1xuICBleHBvcnRzLnByb3BzVG9BdHRyTWFwID0gcHJvcHNUb0F0dHJNYXA7XG4gIGV4cG9ydHMucmVtb3ZlID0gcmVtb3ZlO1xuICBleHBvcnRzLnNsb3RGbGFnc1RleHQgPSBzbG90RmxhZ3NUZXh0O1xuICBleHBvcnRzLnN0cmluZ2lmeVN0eWxlID0gc3RyaW5naWZ5U3R5bGU7XG4gIGV4cG9ydHMudG9EaXNwbGF5U3RyaW5nID0gdG9EaXNwbGF5U3RyaW5nO1xuICBleHBvcnRzLnRvSGFuZGxlcktleSA9IHRvSGFuZGxlcktleTtcbiAgZXhwb3J0cy50b051bWJlciA9IHRvTnVtYmVyO1xuICBleHBvcnRzLnRvUmF3VHlwZSA9IHRvUmF3VHlwZTtcbiAgZXhwb3J0cy50b1R5cGVTdHJpbmcgPSB0b1R5cGVTdHJpbmc7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0B2dWUvc2hhcmVkL2luZGV4LmpzXG52YXIgcmVxdWlyZV9zaGFyZWQgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIGlmIChmYWxzZSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVfc2hhcmVkX2NqcygpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0B2dWUvcmVhY3Rpdml0eS9kaXN0L3JlYWN0aXZpdHkuY2pzLmpzXG52YXIgcmVxdWlyZV9yZWFjdGl2aXR5X2NqcyA9IF9fY29tbW9uSlMoKGV4cG9ydHMpID0+IHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSk7XG4gIHZhciBzaGFyZWQgPSByZXF1aXJlX3NoYXJlZCgpO1xuICB2YXIgdGFyZ2V0TWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgdmFyIGVmZmVjdFN0YWNrID0gW107XG4gIHZhciBhY3RpdmVFZmZlY3Q7XG4gIHZhciBJVEVSQVRFX0tFWSA9IFN5bWJvbChcIml0ZXJhdGVcIik7XG4gIHZhciBNQVBfS0VZX0lURVJBVEVfS0VZID0gU3ltYm9sKFwiTWFwIGtleSBpdGVyYXRlXCIpO1xuICBmdW5jdGlvbiBpc0VmZmVjdChmbikge1xuICAgIHJldHVybiBmbiAmJiBmbi5faXNFZmZlY3QgPT09IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gZWZmZWN0Myhmbiwgb3B0aW9ucyA9IHNoYXJlZC5FTVBUWV9PQkopIHtcbiAgICBpZiAoaXNFZmZlY3QoZm4pKSB7XG4gICAgICBmbiA9IGZuLnJhdztcbiAgICB9XG4gICAgY29uc3QgZWZmZWN0NCA9IGNyZWF0ZVJlYWN0aXZlRWZmZWN0KGZuLCBvcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMubGF6eSkge1xuICAgICAgZWZmZWN0NCgpO1xuICAgIH1cbiAgICByZXR1cm4gZWZmZWN0NDtcbiAgfVxuICBmdW5jdGlvbiBzdG9wMihlZmZlY3Q0KSB7XG4gICAgaWYgKGVmZmVjdDQuYWN0aXZlKSB7XG4gICAgICBjbGVhbnVwKGVmZmVjdDQpO1xuICAgICAgaWYgKGVmZmVjdDQub3B0aW9ucy5vblN0b3ApIHtcbiAgICAgICAgZWZmZWN0NC5vcHRpb25zLm9uU3RvcCgpO1xuICAgICAgfVxuICAgICAgZWZmZWN0NC5hY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgdmFyIHVpZCA9IDA7XG4gIGZ1bmN0aW9uIGNyZWF0ZVJlYWN0aXZlRWZmZWN0KGZuLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZWZmZWN0NCA9IGZ1bmN0aW9uIHJlYWN0aXZlRWZmZWN0KCkge1xuICAgICAgaWYgKCFlZmZlY3Q0LmFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH1cbiAgICAgIGlmICghZWZmZWN0U3RhY2suaW5jbHVkZXMoZWZmZWN0NCkpIHtcbiAgICAgICAgY2xlYW51cChlZmZlY3Q0KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlbmFibGVUcmFja2luZygpO1xuICAgICAgICAgIGVmZmVjdFN0YWNrLnB1c2goZWZmZWN0NCk7XG4gICAgICAgICAgYWN0aXZlRWZmZWN0ID0gZWZmZWN0NDtcbiAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBlZmZlY3RTdGFjay5wb3AoKTtcbiAgICAgICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICAgICAgYWN0aXZlRWZmZWN0ID0gZWZmZWN0U3RhY2tbZWZmZWN0U3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGVmZmVjdDQuaWQgPSB1aWQrKztcbiAgICBlZmZlY3Q0LmFsbG93UmVjdXJzZSA9ICEhb3B0aW9ucy5hbGxvd1JlY3Vyc2U7XG4gICAgZWZmZWN0NC5faXNFZmZlY3QgPSB0cnVlO1xuICAgIGVmZmVjdDQuYWN0aXZlID0gdHJ1ZTtcbiAgICBlZmZlY3Q0LnJhdyA9IGZuO1xuICAgIGVmZmVjdDQuZGVwcyA9IFtdO1xuICAgIGVmZmVjdDQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIGVmZmVjdDQ7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYW51cChlZmZlY3Q0KSB7XG4gICAgY29uc3Qge2RlcHN9ID0gZWZmZWN0NDtcbiAgICBpZiAoZGVwcy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZXBzW2ldLmRlbGV0ZShlZmZlY3Q0KTtcbiAgICAgIH1cbiAgICAgIGRlcHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cbiAgdmFyIHNob3VsZFRyYWNrID0gdHJ1ZTtcbiAgdmFyIHRyYWNrU3RhY2sgPSBbXTtcbiAgZnVuY3Rpb24gcGF1c2VUcmFja2luZygpIHtcbiAgICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xuICAgIHNob3VsZFRyYWNrID0gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gZW5hYmxlVHJhY2tpbmcoKSB7XG4gICAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcbiAgICBzaG91bGRUcmFjayA9IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gcmVzZXRUcmFja2luZygpIHtcbiAgICBjb25zdCBsYXN0ID0gdHJhY2tTdGFjay5wb3AoKTtcbiAgICBzaG91bGRUcmFjayA9IGxhc3QgPT09IHZvaWQgMCA/IHRydWUgOiBsYXN0O1xuICB9XG4gIGZ1bmN0aW9uIHRyYWNrKHRhcmdldCwgdHlwZSwga2V5KSB7XG4gICAgaWYgKCFzaG91bGRUcmFjayB8fCBhY3RpdmVFZmZlY3QgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcbiAgICBpZiAoIWRlcHNNYXApIHtcbiAgICAgIHRhcmdldE1hcC5zZXQodGFyZ2V0LCBkZXBzTWFwID0gbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgbGV0IGRlcCA9IGRlcHNNYXAuZ2V0KGtleSk7XG4gICAgaWYgKCFkZXApIHtcbiAgICAgIGRlcHNNYXAuc2V0KGtleSwgZGVwID0gbmV3IFNldCgpKTtcbiAgICB9XG4gICAgaWYgKCFkZXAuaGFzKGFjdGl2ZUVmZmVjdCkpIHtcbiAgICAgIGRlcC5hZGQoYWN0aXZlRWZmZWN0KTtcbiAgICAgIGFjdGl2ZUVmZmVjdC5kZXBzLnB1c2goZGVwKTtcbiAgICAgIGlmIChhY3RpdmVFZmZlY3Qub3B0aW9ucy5vblRyYWNrKSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdC5vcHRpb25zLm9uVHJhY2soe1xuICAgICAgICAgIGVmZmVjdDogYWN0aXZlRWZmZWN0LFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGtleVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJpZ2dlcih0YXJnZXQsIHR5cGUsIGtleSwgbmV3VmFsdWUsIG9sZFZhbHVlLCBvbGRUYXJnZXQpIHtcbiAgICBjb25zdCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICAgIGlmICghZGVwc01hcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZmZlY3RzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGFkZDIgPSAoZWZmZWN0c1RvQWRkKSA9PiB7XG4gICAgICBpZiAoZWZmZWN0c1RvQWRkKSB7XG4gICAgICAgIGVmZmVjdHNUb0FkZC5mb3JFYWNoKChlZmZlY3Q0KSA9PiB7XG4gICAgICAgICAgaWYgKGVmZmVjdDQgIT09IGFjdGl2ZUVmZmVjdCB8fCBlZmZlY3Q0LmFsbG93UmVjdXJzZSkge1xuICAgICAgICAgICAgZWZmZWN0cy5hZGQoZWZmZWN0NCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICh0eXBlID09PSBcImNsZWFyXCIpIHtcbiAgICAgIGRlcHNNYXAuZm9yRWFjaChhZGQyKTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJsZW5ndGhcIiAmJiBzaGFyZWQuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICBkZXBzTWFwLmZvckVhY2goKGRlcCwga2V5MikgPT4ge1xuICAgICAgICBpZiAoa2V5MiA9PT0gXCJsZW5ndGhcIiB8fCBrZXkyID49IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgYWRkMihkZXApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGtleSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGFkZDIoZGVwc01hcC5nZXQoa2V5KSk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICAgIGlmICghc2hhcmVkLmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgICAgYWRkMihkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgaWYgKHNoYXJlZC5pc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgIGFkZDIoZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcmVkLmlzSW50ZWdlcktleShrZXkpKSB7XG4gICAgICAgICAgICBhZGQyKGRlcHNNYXAuZ2V0KFwibGVuZ3RoXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgICAgICBpZiAoIXNoYXJlZC5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgIGFkZDIoZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICAgIGlmIChzaGFyZWQuaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgICBhZGQyKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzZXRcIjpcbiAgICAgICAgICBpZiAoc2hhcmVkLmlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgIGFkZDIoZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJ1biA9IChlZmZlY3Q0KSA9PiB7XG4gICAgICBpZiAoZWZmZWN0NC5vcHRpb25zLm9uVHJpZ2dlcikge1xuICAgICAgICBlZmZlY3Q0Lm9wdGlvbnMub25UcmlnZ2VyKHtcbiAgICAgICAgICBlZmZlY3Q6IGVmZmVjdDQsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgIG9sZFZhbHVlLFxuICAgICAgICAgIG9sZFRhcmdldFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChlZmZlY3Q0Lm9wdGlvbnMuc2NoZWR1bGVyKSB7XG4gICAgICAgIGVmZmVjdDQub3B0aW9ucy5zY2hlZHVsZXIoZWZmZWN0NCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZmZlY3Q0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBlZmZlY3RzLmZvckVhY2gocnVuKTtcbiAgfVxuICB2YXIgaXNOb25UcmFja2FibGVLZXlzID0gLyogQF9fUFVSRV9fICovIHNoYXJlZC5tYWtlTWFwKGBfX3Byb3RvX18sX192X2lzUmVmLF9faXNWdWVgKTtcbiAgdmFyIGJ1aWx0SW5TeW1ib2xzID0gbmV3IFNldChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhTeW1ib2wpLm1hcCgoa2V5KSA9PiBTeW1ib2xba2V5XSkuZmlsdGVyKHNoYXJlZC5pc1N5bWJvbCkpO1xuICB2YXIgZ2V0MiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVHZXR0ZXIoKTtcbiAgdmFyIHNoYWxsb3dHZXQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlR2V0dGVyKGZhbHNlLCB0cnVlKTtcbiAgdmFyIHJlYWRvbmx5R2V0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUdldHRlcih0cnVlKTtcbiAgdmFyIHNoYWxsb3dSZWFkb25seUdldCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVHZXR0ZXIodHJ1ZSwgdHJ1ZSk7XG4gIHZhciBhcnJheUluc3RydW1lbnRhdGlvbnMgPSB7fTtcbiAgW1wiaW5jbHVkZXNcIiwgXCJpbmRleE9mXCIsIFwibGFzdEluZGV4T2ZcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3QgbWV0aG9kID0gQXJyYXkucHJvdG90eXBlW2tleV07XG4gICAgYXJyYXlJbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBjb25zdCBhcnIgPSB0b1JhdzIodGhpcyk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRyYWNrKGFyciwgXCJnZXRcIiwgaSArIFwiXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzID0gbWV0aG9kLmFwcGx5KGFyciwgYXJncyk7XG4gICAgICBpZiAocmVzID09PSAtMSB8fCByZXMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkoYXJyLCBhcmdzLm1hcCh0b1JhdzIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIFtcInB1c2hcIiwgXCJwb3BcIiwgXCJzaGlmdFwiLCBcInVuc2hpZnRcIiwgXCJzcGxpY2VcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3QgbWV0aG9kID0gQXJyYXkucHJvdG90eXBlW2tleV07XG4gICAgYXJyYXlJbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICBjb25zdCByZXMgPSBtZXRob2QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gIH0pO1xuICBmdW5jdGlvbiBjcmVhdGVHZXR0ZXIoaXNSZWFkb25seTIgPSBmYWxzZSwgc2hhbGxvdyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGdldDModGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XG4gICAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIpIHtcbiAgICAgICAgcmV0dXJuICFpc1JlYWRvbmx5MjtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIpIHtcbiAgICAgICAgcmV0dXJuIGlzUmVhZG9ubHkyO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiICYmIHJlY2VpdmVyID09PSAoaXNSZWFkb25seTIgPyBzaGFsbG93ID8gc2hhbGxvd1JlYWRvbmx5TWFwIDogcmVhZG9ubHlNYXAgOiBzaGFsbG93ID8gc2hhbGxvd1JlYWN0aXZlTWFwIDogcmVhY3RpdmVNYXApLmdldCh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gc2hhcmVkLmlzQXJyYXkodGFyZ2V0KTtcbiAgICAgIGlmICghaXNSZWFkb25seTIgJiYgdGFyZ2V0SXNBcnJheSAmJiBzaGFyZWQuaGFzT3duKGFycmF5SW5zdHJ1bWVudGF0aW9ucywga2V5KSkge1xuICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoYXJyYXlJbnN0cnVtZW50YXRpb25zLCBrZXksIHJlY2VpdmVyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlcyA9IFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcik7XG4gICAgICBpZiAoc2hhcmVkLmlzU3ltYm9sKGtleSkgPyBidWlsdEluU3ltYm9scy5oYXMoa2V5KSA6IGlzTm9uVHJhY2thYmxlS2V5cyhrZXkpKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgICBpZiAoIWlzUmVhZG9ubHkyKSB7XG4gICAgICAgIHRyYWNrKHRhcmdldCwgXCJnZXRcIiwga2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChzaGFsbG93KSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgICBpZiAoaXNSZWYocmVzKSkge1xuICAgICAgICBjb25zdCBzaG91bGRVbndyYXAgPSAhdGFyZ2V0SXNBcnJheSB8fCAhc2hhcmVkLmlzSW50ZWdlcktleShrZXkpO1xuICAgICAgICByZXR1cm4gc2hvdWxkVW53cmFwID8gcmVzLnZhbHVlIDogcmVzO1xuICAgICAgfVxuICAgICAgaWYgKHNoYXJlZC5pc09iamVjdChyZXMpKSB7XG4gICAgICAgIHJldHVybiBpc1JlYWRvbmx5MiA/IHJlYWRvbmx5KHJlcykgOiByZWFjdGl2ZTMocmVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgfVxuICB2YXIgc2V0MiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTZXR0ZXIoKTtcbiAgdmFyIHNoYWxsb3dTZXQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlU2V0dGVyKHRydWUpO1xuICBmdW5jdGlvbiBjcmVhdGVTZXR0ZXIoc2hhbGxvdyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNldDModGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgbGV0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgICBpZiAoIXNoYWxsb3cpIHtcbiAgICAgICAgdmFsdWUgPSB0b1JhdzIodmFsdWUpO1xuICAgICAgICBvbGRWYWx1ZSA9IHRvUmF3MihvbGRWYWx1ZSk7XG4gICAgICAgIGlmICghc2hhcmVkLmlzQXJyYXkodGFyZ2V0KSAmJiBpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGhhZEtleSA9IHNoYXJlZC5pc0FycmF5KHRhcmdldCkgJiYgc2hhcmVkLmlzSW50ZWdlcktleShrZXkpID8gTnVtYmVyKGtleSkgPCB0YXJnZXQubGVuZ3RoIDogc2hhcmVkLmhhc093bih0YXJnZXQsIGtleSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICAgIGlmICh0YXJnZXQgPT09IHRvUmF3MihyZWNlaXZlcikpIHtcbiAgICAgICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcmVkLmhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICAgIGNvbnN0IGhhZEtleSA9IHNoYXJlZC5oYXNPd24odGFyZ2V0LCBrZXkpO1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSk7XG4gICAgaWYgKHJlc3VsdCAmJiBoYWRLZXkpIHtcbiAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiLCBrZXksIHZvaWQgMCwgb2xkVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIGhhcyh0YXJnZXQsIGtleSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuaGFzKHRhcmdldCwga2V5KTtcbiAgICBpZiAoIXNoYXJlZC5pc1N5bWJvbChrZXkpIHx8ICFidWlsdEluU3ltYm9scy5oYXMoa2V5KSkge1xuICAgICAgdHJhY2sodGFyZ2V0LCBcImhhc1wiLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIG93bktleXModGFyZ2V0KSB7XG4gICAgdHJhY2sodGFyZ2V0LCBcIml0ZXJhdGVcIiwgc2hhcmVkLmlzQXJyYXkodGFyZ2V0KSA/IFwibGVuZ3RoXCIgOiBJVEVSQVRFX0tFWSk7XG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICB9XG4gIHZhciBtdXRhYmxlSGFuZGxlcnMgPSB7XG4gICAgZ2V0OiBnZXQyLFxuICAgIHNldDogc2V0MixcbiAgICBkZWxldGVQcm9wZXJ0eSxcbiAgICBoYXMsXG4gICAgb3duS2V5c1xuICB9O1xuICB2YXIgcmVhZG9ubHlIYW5kbGVycyA9IHtcbiAgICBnZXQ6IHJlYWRvbmx5R2V0LFxuICAgIHNldCh0YXJnZXQsIGtleSkge1xuICAgICAge1xuICAgICAgICBjb25zb2xlLndhcm4oYFNldCBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0YXJnZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICAgICAge1xuICAgICAgICBjb25zb2xlLndhcm4oYERlbGV0ZSBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0YXJnZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuICB2YXIgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMgPSBzaGFyZWQuZXh0ZW5kKHt9LCBtdXRhYmxlSGFuZGxlcnMsIHtcbiAgICBnZXQ6IHNoYWxsb3dHZXQsXG4gICAgc2V0OiBzaGFsbG93U2V0XG4gIH0pO1xuICB2YXIgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMgPSBzaGFyZWQuZXh0ZW5kKHt9LCByZWFkb25seUhhbmRsZXJzLCB7XG4gICAgZ2V0OiBzaGFsbG93UmVhZG9ubHlHZXRcbiAgfSk7XG4gIHZhciB0b1JlYWN0aXZlID0gKHZhbHVlKSA9PiBzaGFyZWQuaXNPYmplY3QodmFsdWUpID8gcmVhY3RpdmUzKHZhbHVlKSA6IHZhbHVlO1xuICB2YXIgdG9SZWFkb25seSA9ICh2YWx1ZSkgPT4gc2hhcmVkLmlzT2JqZWN0KHZhbHVlKSA/IHJlYWRvbmx5KHZhbHVlKSA6IHZhbHVlO1xuICB2YXIgdG9TaGFsbG93ID0gKHZhbHVlKSA9PiB2YWx1ZTtcbiAgdmFyIGdldFByb3RvID0gKHYpID0+IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yodik7XG4gIGZ1bmN0aW9uIGdldCQxKHRhcmdldCwga2V5LCBpc1JlYWRvbmx5MiA9IGZhbHNlLCBpc1NoYWxsb3cgPSBmYWxzZSkge1xuICAgIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIl07XG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcyKHRhcmdldCk7XG4gICAgY29uc3QgcmF3S2V5ID0gdG9SYXcyKGtleSk7XG4gICAgaWYgKGtleSAhPT0gcmF3S2V5KSB7XG4gICAgICAhaXNSZWFkb25seTIgJiYgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiLCBrZXkpO1xuICAgIH1cbiAgICAhaXNSZWFkb25seTIgJiYgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiLCByYXdLZXkpO1xuICAgIGNvbnN0IHtoYXM6IGhhczJ9ID0gZ2V0UHJvdG8ocmF3VGFyZ2V0KTtcbiAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seTIgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICBpZiAoaGFzMi5jYWxsKHJhd1RhcmdldCwga2V5KSkge1xuICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChrZXkpKTtcbiAgICB9IGVsc2UgaWYgKGhhczIuY2FsbChyYXdUYXJnZXQsIHJhd0tleSkpIHtcbiAgICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQocmF3S2V5KSk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQgIT09IHJhd1RhcmdldCkge1xuICAgICAgdGFyZ2V0LmdldChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoYXMkMShrZXksIGlzUmVhZG9ubHkyID0gZmFsc2UpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1JhdzIodGFyZ2V0KTtcbiAgICBjb25zdCByYXdLZXkgPSB0b1JhdzIoa2V5KTtcbiAgICBpZiAoa2V5ICE9PSByYXdLZXkpIHtcbiAgICAgICFpc1JlYWRvbmx5MiAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIsIGtleSk7XG4gICAgfVxuICAgICFpc1JlYWRvbmx5MiAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIsIHJhd0tleSk7XG4gICAgcmV0dXJuIGtleSA9PT0gcmF3S2V5ID8gdGFyZ2V0LmhhcyhrZXkpIDogdGFyZ2V0LmhhcyhrZXkpIHx8IHRhcmdldC5oYXMocmF3S2V5KTtcbiAgfVxuICBmdW5jdGlvbiBzaXplKHRhcmdldCwgaXNSZWFkb25seTIgPSBmYWxzZSkge1xuICAgIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIl07XG4gICAgIWlzUmVhZG9ubHkyICYmIHRyYWNrKHRvUmF3Mih0YXJnZXQpLCBcIml0ZXJhdGVcIiwgSVRFUkFURV9LRVkpO1xuICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIFwic2l6ZVwiLCB0YXJnZXQpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHZhbHVlID0gdG9SYXcyKHZhbHVlKTtcbiAgICBjb25zdCB0YXJnZXQgPSB0b1JhdzIodGhpcyk7XG4gICAgY29uc3QgcHJvdG8gPSBnZXRQcm90byh0YXJnZXQpO1xuICAgIGNvbnN0IGhhZEtleSA9IHByb3RvLmhhcy5jYWxsKHRhcmdldCwgdmFsdWUpO1xuICAgIGlmICghaGFkS2V5KSB7XG4gICAgICB0YXJnZXQuYWRkKHZhbHVlKTtcbiAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCB2YWx1ZSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmdW5jdGlvbiBzZXQkMShrZXksIHZhbHVlKSB7XG4gICAgdmFsdWUgPSB0b1JhdzIodmFsdWUpO1xuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3Mih0aGlzKTtcbiAgICBjb25zdCB7aGFzOiBoYXMyLCBnZXQ6IGdldDN9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgICBsZXQgaGFkS2V5ID0gaGFzMi5jYWxsKHRhcmdldCwga2V5KTtcbiAgICBpZiAoIWhhZEtleSkge1xuICAgICAga2V5ID0gdG9SYXcyKGtleSk7XG4gICAgICBoYWRLZXkgPSBoYXMyLmNhbGwodGFyZ2V0LCBrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhczIsIGtleSk7XG4gICAgfVxuICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0My5jYWxsKHRhcmdldCwga2V5KTtcbiAgICB0YXJnZXQuc2V0KGtleSwgdmFsdWUpO1xuICAgIGlmICghaGFkS2V5KSB7XG4gICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwga2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChzaGFyZWQuaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiwga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmdW5jdGlvbiBkZWxldGVFbnRyeShrZXkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0b1JhdzIodGhpcyk7XG4gICAgY29uc3Qge2hhczogaGFzMiwgZ2V0OiBnZXQzfSA9IGdldFByb3RvKHRhcmdldCk7XG4gICAgbGV0IGhhZEtleSA9IGhhczIuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgIGtleSA9IHRvUmF3MihrZXkpO1xuICAgICAgaGFkS2V5ID0gaGFzMi5jYWxsKHRhcmdldCwga2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMyLCBrZXkpO1xuICAgIH1cbiAgICBjb25zdCBvbGRWYWx1ZSA9IGdldDMgPyBnZXQzLmNhbGwodGFyZ2V0LCBrZXkpIDogdm9pZCAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5kZWxldGUoa2V5KTtcbiAgICBpZiAoaGFkS2V5KSB7XG4gICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiwga2V5LCB2b2lkIDAsIG9sZFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0b1JhdzIodGhpcyk7XG4gICAgY29uc3QgaGFkSXRlbXMgPSB0YXJnZXQuc2l6ZSAhPT0gMDtcbiAgICBjb25zdCBvbGRUYXJnZXQgPSBzaGFyZWQuaXNNYXAodGFyZ2V0KSA/IG5ldyBNYXAodGFyZ2V0KSA6IG5ldyBTZXQodGFyZ2V0KTtcbiAgICBjb25zdCByZXN1bHQgPSB0YXJnZXQuY2xlYXIoKTtcbiAgICBpZiAoaGFkSXRlbXMpIHtcbiAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImNsZWFyXCIsIHZvaWQgMCwgdm9pZCAwLCBvbGRUYXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUZvckVhY2goaXNSZWFkb25seTIsIGlzU2hhbGxvdykge1xuICAgIHJldHVybiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBjb25zdCBvYnNlcnZlZCA9IHRoaXM7XG4gICAgICBjb25zdCB0YXJnZXQgPSBvYnNlcnZlZFtcIl9fdl9yYXdcIl07XG4gICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1JhdzIodGFyZ2V0KTtcbiAgICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5MiA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICAgICAgIWlzUmVhZG9ubHkyICYmIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIsIElURVJBVEVfS0VZKTtcbiAgICAgIHJldHVybiB0YXJnZXQuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB3cmFwKHZhbHVlKSwgd3JhcChrZXkpLCBvYnNlcnZlZCk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgaXNSZWFkb25seTIsIGlzU2hhbGxvdykge1xuICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiXTtcbiAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3Mih0YXJnZXQpO1xuICAgICAgY29uc3QgdGFyZ2V0SXNNYXAgPSBzaGFyZWQuaXNNYXAocmF3VGFyZ2V0KTtcbiAgICAgIGNvbnN0IGlzUGFpciA9IG1ldGhvZCA9PT0gXCJlbnRyaWVzXCIgfHwgbWV0aG9kID09PSBTeW1ib2wuaXRlcmF0b3IgJiYgdGFyZ2V0SXNNYXA7XG4gICAgICBjb25zdCBpc0tleU9ubHkgPSBtZXRob2QgPT09IFwia2V5c1wiICYmIHRhcmdldElzTWFwO1xuICAgICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRhcmdldFttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkyID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgICAhaXNSZWFkb25seTIgJiYgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiwgaXNLZXlPbmx5ID8gTUFQX0tFWV9JVEVSQVRFX0tFWSA6IElURVJBVEVfS0VZKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgY29uc3Qge3ZhbHVlLCBkb25lfSA9IGlubmVySXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIHJldHVybiBkb25lID8ge3ZhbHVlLCBkb25lfSA6IHtcbiAgICAgICAgICAgIHZhbHVlOiBpc1BhaXIgPyBbd3JhcCh2YWx1ZVswXSksIHdyYXAodmFsdWVbMV0pXSA6IHdyYXAodmFsdWUpLFxuICAgICAgICAgICAgZG9uZVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlUmVhZG9ubHlNZXRob2QodHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICB7XG4gICAgICAgIGNvbnN0IGtleSA9IGFyZ3NbMF0gPyBgb24ga2V5IFwiJHthcmdzWzBdfVwiIGAgOiBgYDtcbiAgICAgICAgY29uc29sZS53YXJuKGAke3NoYXJlZC5jYXBpdGFsaXplKHR5cGUpfSBvcGVyYXRpb24gJHtrZXl9ZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdG9SYXcyKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlID09PSBcImRlbGV0ZVwiID8gZmFsc2UgOiB0aGlzO1xuICAgIH07XG4gIH1cbiAgdmFyIG11dGFibGVJbnN0cnVtZW50YXRpb25zID0ge1xuICAgIGdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXkpO1xuICAgIH0sXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gc2l6ZSh0aGlzKTtcbiAgICB9LFxuICAgIGhhczogaGFzJDEsXG4gICAgYWRkLFxuICAgIHNldDogc2V0JDEsXG4gICAgZGVsZXRlOiBkZWxldGVFbnRyeSxcbiAgICBjbGVhcixcbiAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCBmYWxzZSlcbiAgfTtcbiAgdmFyIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zID0ge1xuICAgIGdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXksIGZhbHNlLCB0cnVlKTtcbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIHNpemUodGhpcyk7XG4gICAgfSxcbiAgICBoYXM6IGhhcyQxLFxuICAgIGFkZCxcbiAgICBzZXQ6IHNldCQxLFxuICAgIGRlbGV0ZTogZGVsZXRlRW50cnksXG4gICAgY2xlYXIsXG4gICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaChmYWxzZSwgdHJ1ZSlcbiAgfTtcbiAgdmFyIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA9IHtcbiAgICBnZXQoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCB0cnVlKTtcbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICBoYXMoa2V5KSB7XG4gICAgICByZXR1cm4gaGFzJDEuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xuICAgIH0sXG4gICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiKSxcbiAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIpLFxuICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiksXG4gICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIiksXG4gICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCBmYWxzZSlcbiAgfTtcbiAgdmFyIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnMgPSB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfSxcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiBzaXplKHRoaXMsIHRydWUpO1xuICAgIH0sXG4gICAgaGFzKGtleSkge1xuICAgICAgcmV0dXJuIGhhcyQxLmNhbGwodGhpcywga2V5LCB0cnVlKTtcbiAgICB9LFxuICAgIGFkZDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJhZGRcIiksXG4gICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiKSxcbiAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIpLFxuICAgIGNsZWFyOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImNsZWFyXCIpLFxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2godHJ1ZSwgdHJ1ZSlcbiAgfTtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kcyA9IFtcImtleXNcIiwgXCJ2YWx1ZXNcIiwgXCJlbnRyaWVzXCIsIFN5bWJvbC5pdGVyYXRvcl07XG4gIGl0ZXJhdG9yTWV0aG9kcy5mb3JFYWNoKChtZXRob2QpID0+IHtcbiAgICBtdXRhYmxlSW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBmYWxzZSwgZmFsc2UpO1xuICAgIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCB0cnVlLCBmYWxzZSk7XG4gICAgc2hhbGxvd0luc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgZmFsc2UsIHRydWUpO1xuICAgIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgdHJ1ZSwgdHJ1ZSk7XG4gIH0pO1xuICBmdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoaXNSZWFkb25seTIsIHNoYWxsb3cpIHtcbiAgICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0gc2hhbGxvdyA/IGlzUmVhZG9ubHkyID8gc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA6IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zIDogaXNSZWFkb25seTIgPyByZWFkb25seUluc3RydW1lbnRhdGlvbnMgOiBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucztcbiAgICByZXR1cm4gKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFjdGl2ZVwiKSB7XG4gICAgICAgIHJldHVybiAhaXNSZWFkb25seTI7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiKSB7XG4gICAgICAgIHJldHVybiBpc1JlYWRvbmx5MjtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIikge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHNoYXJlZC5oYXNPd24oaW5zdHJ1bWVudGF0aW9ucywga2V5KSAmJiBrZXkgaW4gdGFyZ2V0ID8gaW5zdHJ1bWVudGF0aW9ucyA6IHRhcmdldCwga2V5LCByZWNlaXZlcik7XG4gICAgfTtcbiAgfVxuICB2YXIgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgICBnZXQ6IGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgZmFsc2UpXG4gIH07XG4gIHZhciBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICAgIGdldDogY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCB0cnVlKVxuICB9O1xuICB2YXIgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gICAgZ2V0OiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgZmFsc2UpXG4gIH07XG4gIHZhciBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gICAgZ2V0OiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgdHJ1ZSlcbiAgfTtcbiAgZnVuY3Rpb24gY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMyLCBrZXkpIHtcbiAgICBjb25zdCByYXdLZXkgPSB0b1JhdzIoa2V5KTtcbiAgICBpZiAocmF3S2V5ICE9PSBrZXkgJiYgaGFzMi5jYWxsKHRhcmdldCwgcmF3S2V5KSkge1xuICAgICAgY29uc3QgdHlwZSA9IHNoYXJlZC50b1Jhd1R5cGUodGFyZ2V0KTtcbiAgICAgIGNvbnNvbGUud2FybihgUmVhY3RpdmUgJHt0eXBlfSBjb250YWlucyBib3RoIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIG9mIHRoZSBzYW1lIG9iamVjdCR7dHlwZSA9PT0gYE1hcGAgPyBgIGFzIGtleXNgIDogYGB9LCB3aGljaCBjYW4gbGVhZCB0byBpbmNvbnNpc3RlbmNpZXMuIEF2b2lkIGRpZmZlcmVudGlhdGluZyBiZXR3ZWVuIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIG9mIGFuIG9iamVjdCBhbmQgb25seSB1c2UgdGhlIHJlYWN0aXZlIHZlcnNpb24gaWYgcG9zc2libGUuYCk7XG4gICAgfVxuICB9XG4gIHZhciByZWFjdGl2ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gIHZhciBzaGFsbG93UmVhY3RpdmVNYXAgPSBuZXcgV2Vha01hcCgpO1xuICB2YXIgcmVhZG9ubHlNYXAgPSBuZXcgV2Vha01hcCgpO1xuICB2YXIgc2hhbGxvd1JlYWRvbmx5TWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgZnVuY3Rpb24gdGFyZ2V0VHlwZU1hcChyYXdUeXBlKSB7XG4gICAgc3dpdGNoIChyYXdUeXBlKSB7XG4gICAgICBjYXNlIFwiT2JqZWN0XCI6XG4gICAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBjYXNlIFwiTWFwXCI6XG4gICAgICBjYXNlIFwiU2V0XCI6XG4gICAgICBjYXNlIFwiV2Vha01hcFwiOlxuICAgICAgY2FzZSBcIldlYWtTZXRcIjpcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VGFyZ2V0VHlwZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZVtcIl9fdl9za2lwXCJdIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSA/IDAgOiB0YXJnZXRUeXBlTWFwKHNoYXJlZC50b1Jhd1R5cGUodmFsdWUpKTtcbiAgfVxuICBmdW5jdGlvbiByZWFjdGl2ZTModGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldCAmJiB0YXJnZXRbXCJfX3ZfaXNSZWFkb25seVwiXSkge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgZmFsc2UsIG11dGFibGVIYW5kbGVycywgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycywgcmVhY3RpdmVNYXApO1xuICB9XG4gIGZ1bmN0aW9uIHNoYWxsb3dSZWFjdGl2ZSh0YXJnZXQpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBmYWxzZSwgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMsIHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMsIHNoYWxsb3dSZWFjdGl2ZU1hcCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVhZG9ubHkodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgdHJ1ZSwgcmVhZG9ubHlIYW5kbGVycywgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsIHJlYWRvbmx5TWFwKTtcbiAgfVxuICBmdW5jdGlvbiBzaGFsbG93UmVhZG9ubHkodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgdHJ1ZSwgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMsIHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycywgc2hhbGxvd1JlYWRvbmx5TWFwKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGlzUmVhZG9ubHkyLCBiYXNlSGFuZGxlcnMsIGNvbGxlY3Rpb25IYW5kbGVycywgcHJveHlNYXApIHtcbiAgICBpZiAoIXNoYXJlZC5pc09iamVjdCh0YXJnZXQpKSB7XG4gICAgICB7XG4gICAgICAgIGNvbnNvbGUud2FybihgdmFsdWUgY2Fubm90IGJlIG1hZGUgcmVhY3RpdmU6ICR7U3RyaW5nKHRhcmdldCl9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBpZiAodGFyZ2V0W1wiX192X3Jhd1wiXSAmJiAhKGlzUmVhZG9ubHkyICYmIHRhcmdldFtcIl9fdl9pc1JlYWN0aXZlXCJdKSkge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdQcm94eSA9IHByb3h5TWFwLmdldCh0YXJnZXQpO1xuICAgIGlmIChleGlzdGluZ1Byb3h5KSB7XG4gICAgICByZXR1cm4gZXhpc3RpbmdQcm94eTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0VHlwZSA9IGdldFRhcmdldFR5cGUodGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0VHlwZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkodGFyZ2V0LCB0YXJnZXRUeXBlID09PSAyID8gY29sbGVjdGlvbkhhbmRsZXJzIDogYmFzZUhhbmRsZXJzKTtcbiAgICBwcm94eU1hcC5zZXQodGFyZ2V0LCBwcm94eSk7XG4gICAgcmV0dXJuIHByb3h5O1xuICB9XG4gIGZ1bmN0aW9uIGlzUmVhY3RpdmUyKHZhbHVlKSB7XG4gICAgaWYgKGlzUmVhZG9ubHkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gaXNSZWFjdGl2ZTIodmFsdWVbXCJfX3ZfcmF3XCJdKTtcbiAgICB9XG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhY3RpdmVcIl0pO1xuICB9XG4gIGZ1bmN0aW9uIGlzUmVhZG9ubHkodmFsdWUpIHtcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFkb25seVwiXSk7XG4gIH1cbiAgZnVuY3Rpb24gaXNQcm94eSh2YWx1ZSkge1xuICAgIHJldHVybiBpc1JlYWN0aXZlMih2YWx1ZSkgfHwgaXNSZWFkb25seSh2YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdG9SYXcyKG9ic2VydmVkKSB7XG4gICAgcmV0dXJuIG9ic2VydmVkICYmIHRvUmF3MihvYnNlcnZlZFtcIl9fdl9yYXdcIl0pIHx8IG9ic2VydmVkO1xuICB9XG4gIGZ1bmN0aW9uIG1hcmtSYXcodmFsdWUpIHtcbiAgICBzaGFyZWQuZGVmKHZhbHVlLCBcIl9fdl9za2lwXCIsIHRydWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgY29udmVydCA9ICh2YWwpID0+IHNoYXJlZC5pc09iamVjdCh2YWwpID8gcmVhY3RpdmUzKHZhbCkgOiB2YWw7XG4gIGZ1bmN0aW9uIGlzUmVmKHIpIHtcbiAgICByZXR1cm4gQm9vbGVhbihyICYmIHIuX192X2lzUmVmID09PSB0cnVlKTtcbiAgfVxuICBmdW5jdGlvbiByZWYodmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiBzaGFsbG93UmVmKHZhbHVlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgdHJ1ZSk7XG4gIH1cbiAgdmFyIFJlZkltcGwgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoX3Jhd1ZhbHVlLCBfc2hhbGxvdyA9IGZhbHNlKSB7XG4gICAgICB0aGlzLl9yYXdWYWx1ZSA9IF9yYXdWYWx1ZTtcbiAgICAgIHRoaXMuX3NoYWxsb3cgPSBfc2hhbGxvdztcbiAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3ZhbHVlID0gX3NoYWxsb3cgPyBfcmF3VmFsdWUgOiBjb252ZXJ0KF9yYXdWYWx1ZSk7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgIHRyYWNrKHRvUmF3Mih0aGlzKSwgXCJnZXRcIiwgXCJ2YWx1ZVwiKTtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgICAgaWYgKHNoYXJlZC5oYXNDaGFuZ2VkKHRvUmF3MihuZXdWYWwpLCB0aGlzLl9yYXdWYWx1ZSkpIHtcbiAgICAgICAgdGhpcy5fcmF3VmFsdWUgPSBuZXdWYWw7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5fc2hhbGxvdyA/IG5ld1ZhbCA6IGNvbnZlcnQobmV3VmFsKTtcbiAgICAgICAgdHJpZ2dlcih0b1JhdzIodGhpcyksIFwic2V0XCIsIFwidmFsdWVcIiwgbmV3VmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZihyYXdWYWx1ZSwgc2hhbGxvdyA9IGZhbHNlKSB7XG4gICAgaWYgKGlzUmVmKHJhd1ZhbHVlKSkge1xuICAgICAgcmV0dXJuIHJhd1ZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZkltcGwocmF3VmFsdWUsIHNoYWxsb3cpO1xuICB9XG4gIGZ1bmN0aW9uIHRyaWdnZXJSZWYocmVmMikge1xuICAgIHRyaWdnZXIodG9SYXcyKHJlZjIpLCBcInNldFwiLCBcInZhbHVlXCIsIHJlZjIudmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIHVucmVmKHJlZjIpIHtcbiAgICByZXR1cm4gaXNSZWYocmVmMikgPyByZWYyLnZhbHVlIDogcmVmMjtcbiAgfVxuICB2YXIgc2hhbGxvd1Vud3JhcEhhbmRsZXJzID0ge1xuICAgIGdldDogKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4gdW5yZWYoUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSksXG4gICAgc2V0OiAodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikgPT4ge1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICAgIGlmIChpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIHByb3h5UmVmcyhvYmplY3RXaXRoUmVmcykge1xuICAgIHJldHVybiBpc1JlYWN0aXZlMihvYmplY3RXaXRoUmVmcykgPyBvYmplY3RXaXRoUmVmcyA6IG5ldyBQcm94eShvYmplY3RXaXRoUmVmcywgc2hhbGxvd1Vud3JhcEhhbmRsZXJzKTtcbiAgfVxuICB2YXIgQ3VzdG9tUmVmSW1wbCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3J5KSB7XG4gICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XG4gICAgICBjb25zdCB7Z2V0OiBnZXQzLCBzZXQ6IHNldDN9ID0gZmFjdG9yeSgoKSA9PiB0cmFjayh0aGlzLCBcImdldFwiLCBcInZhbHVlXCIpLCAoKSA9PiB0cmlnZ2VyKHRoaXMsIFwic2V0XCIsIFwidmFsdWVcIikpO1xuICAgICAgdGhpcy5fZ2V0ID0gZ2V0MztcbiAgICAgIHRoaXMuX3NldCA9IHNldDM7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXQoKTtcbiAgICB9XG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgICAgdGhpcy5fc2V0KG5ld1ZhbCk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBjdXN0b21SZWYoZmFjdG9yeSkge1xuICAgIHJldHVybiBuZXcgQ3VzdG9tUmVmSW1wbChmYWN0b3J5KTtcbiAgfVxuICBmdW5jdGlvbiB0b1JlZnMob2JqZWN0KSB7XG4gICAgaWYgKCFpc1Byb3h5KG9iamVjdCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihgdG9SZWZzKCkgZXhwZWN0cyBhIHJlYWN0aXZlIG9iamVjdCBidXQgcmVjZWl2ZWQgYSBwbGFpbiBvbmUuYCk7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHNoYXJlZC5pc0FycmF5KG9iamVjdCkgPyBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCkgOiB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgIHJldFtrZXldID0gdG9SZWYob2JqZWN0LCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIHZhciBPYmplY3RSZWZJbXBsID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKF9vYmplY3QsIF9rZXkpIHtcbiAgICAgIHRoaXMuX29iamVjdCA9IF9vYmplY3Q7XG4gICAgICB0aGlzLl9rZXkgPSBfa2V5O1xuICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqZWN0W3RoaXMuX2tleV07XG4gICAgfVxuICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcbiAgICAgIHRoaXMuX29iamVjdFt0aGlzLl9rZXldID0gbmV3VmFsO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gdG9SZWYob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNSZWYob2JqZWN0W2tleV0pID8gb2JqZWN0W2tleV0gOiBuZXcgT2JqZWN0UmVmSW1wbChvYmplY3QsIGtleSk7XG4gIH1cbiAgdmFyIENvbXB1dGVkUmVmSW1wbCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihnZXR0ZXIsIF9zZXR0ZXIsIGlzUmVhZG9ubHkyKSB7XG4gICAgICB0aGlzLl9zZXR0ZXIgPSBfc2V0dGVyO1xuICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgICAgdGhpcy5lZmZlY3QgPSBlZmZlY3QzKGdldHRlciwge1xuICAgICAgICBsYXp5OiB0cnVlLFxuICAgICAgICBzY2hlZHVsZXI6ICgpID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2RpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0cmlnZ2VyKHRvUmF3Mih0aGlzKSwgXCJzZXRcIiwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpc1tcIl9fdl9pc1JlYWRvbmx5XCJdID0gaXNSZWFkb25seTI7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgIGNvbnN0IHNlbGYyID0gdG9SYXcyKHRoaXMpO1xuICAgICAgaWYgKHNlbGYyLl9kaXJ0eSkge1xuICAgICAgICBzZWxmMi5fdmFsdWUgPSB0aGlzLmVmZmVjdCgpO1xuICAgICAgICBzZWxmMi5fZGlydHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRyYWNrKHNlbGYyLCBcImdldFwiLCBcInZhbHVlXCIpO1xuICAgICAgcmV0dXJuIHNlbGYyLl92YWx1ZTtcbiAgICB9XG4gICAgc2V0IHZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXR0ZXIobmV3VmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gY29tcHV0ZWQoZ2V0dGVyT3JPcHRpb25zKSB7XG4gICAgbGV0IGdldHRlcjtcbiAgICBsZXQgc2V0dGVyO1xuICAgIGlmIChzaGFyZWQuaXNGdW5jdGlvbihnZXR0ZXJPck9wdGlvbnMpKSB7XG4gICAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnM7XG4gICAgICBzZXR0ZXIgPSAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIldyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHZhbHVlIGlzIHJlYWRvbmx5XCIpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLmdldDtcbiAgICAgIHNldHRlciA9IGdldHRlck9yT3B0aW9ucy5zZXQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29tcHV0ZWRSZWZJbXBsKGdldHRlciwgc2V0dGVyLCBzaGFyZWQuaXNGdW5jdGlvbihnZXR0ZXJPck9wdGlvbnMpIHx8ICFnZXR0ZXJPck9wdGlvbnMuc2V0KTtcbiAgfVxuICBleHBvcnRzLklURVJBVEVfS0VZID0gSVRFUkFURV9LRVk7XG4gIGV4cG9ydHMuY29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgZXhwb3J0cy5jdXN0b21SZWYgPSBjdXN0b21SZWY7XG4gIGV4cG9ydHMuZWZmZWN0ID0gZWZmZWN0MztcbiAgZXhwb3J0cy5lbmFibGVUcmFja2luZyA9IGVuYWJsZVRyYWNraW5nO1xuICBleHBvcnRzLmlzUHJveHkgPSBpc1Byb3h5O1xuICBleHBvcnRzLmlzUmVhY3RpdmUgPSBpc1JlYWN0aXZlMjtcbiAgZXhwb3J0cy5pc1JlYWRvbmx5ID0gaXNSZWFkb25seTtcbiAgZXhwb3J0cy5pc1JlZiA9IGlzUmVmO1xuICBleHBvcnRzLm1hcmtSYXcgPSBtYXJrUmF3O1xuICBleHBvcnRzLnBhdXNlVHJhY2tpbmcgPSBwYXVzZVRyYWNraW5nO1xuICBleHBvcnRzLnByb3h5UmVmcyA9IHByb3h5UmVmcztcbiAgZXhwb3J0cy5yZWFjdGl2ZSA9IHJlYWN0aXZlMztcbiAgZXhwb3J0cy5yZWFkb25seSA9IHJlYWRvbmx5O1xuICBleHBvcnRzLnJlZiA9IHJlZjtcbiAgZXhwb3J0cy5yZXNldFRyYWNraW5nID0gcmVzZXRUcmFja2luZztcbiAgZXhwb3J0cy5zaGFsbG93UmVhY3RpdmUgPSBzaGFsbG93UmVhY3RpdmU7XG4gIGV4cG9ydHMuc2hhbGxvd1JlYWRvbmx5ID0gc2hhbGxvd1JlYWRvbmx5O1xuICBleHBvcnRzLnNoYWxsb3dSZWYgPSBzaGFsbG93UmVmO1xuICBleHBvcnRzLnN0b3AgPSBzdG9wMjtcbiAgZXhwb3J0cy50b1JhdyA9IHRvUmF3MjtcbiAgZXhwb3J0cy50b1JlZiA9IHRvUmVmO1xuICBleHBvcnRzLnRvUmVmcyA9IHRvUmVmcztcbiAgZXhwb3J0cy50cmFjayA9IHRyYWNrO1xuICBleHBvcnRzLnRyaWdnZXIgPSB0cmlnZ2VyO1xuICBleHBvcnRzLnRyaWdnZXJSZWYgPSB0cmlnZ2VyUmVmO1xuICBleHBvcnRzLnVucmVmID0gdW5yZWY7XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0B2dWUvcmVhY3Rpdml0eS9pbmRleC5qc1xudmFyIHJlcXVpcmVfcmVhY3Rpdml0eSA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZSkgPT4ge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgaWYgKGZhbHNlKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZV9yZWFjdGl2aXR5X2NqcygpO1xuICB9XG59KTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3NjaGVkdWxlci5qc1xudmFyIGZsdXNoUGVuZGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgcXVldWUgPSBbXTtcbmZ1bmN0aW9uIHNjaGVkdWxlcihjYWxsYmFjaykge1xuICBxdWV1ZUpvYihjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBxdWV1ZUpvYihqb2IpIHtcbiAgaWYgKCFxdWV1ZS5pbmNsdWRlcyhqb2IpKVxuICAgIHF1ZXVlLnB1c2goam9iKTtcbiAgcXVldWVGbHVzaCgpO1xufVxuZnVuY3Rpb24gcXVldWVGbHVzaCgpIHtcbiAgaWYgKCFmbHVzaGluZyAmJiAhZmx1c2hQZW5kaW5nKSB7XG4gICAgZmx1c2hQZW5kaW5nID0gdHJ1ZTtcbiAgICBxdWV1ZU1pY3JvdGFzayhmbHVzaEpvYnMpO1xuICB9XG59XG5mdW5jdGlvbiBmbHVzaEpvYnMoKSB7XG4gIGZsdXNoUGVuZGluZyA9IGZhbHNlO1xuICBmbHVzaGluZyA9IHRydWU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXSgpO1xuICB9XG4gIHF1ZXVlLmxlbmd0aCA9IDA7XG4gIGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9yZWFjdGl2aXR5LmpzXG52YXIgcmVhY3RpdmU7XG52YXIgZWZmZWN0O1xudmFyIHJlbGVhc2U7XG52YXIgcmF3O1xudmFyIHNob3VsZFNjaGVkdWxlID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVFZmZlY3RTY2hlZHVsaW5nKGNhbGxiYWNrKSB7XG4gIHNob3VsZFNjaGVkdWxlID0gZmFsc2U7XG4gIGNhbGxiYWNrKCk7XG4gIHNob3VsZFNjaGVkdWxlID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNldFJlYWN0aXZpdHlFbmdpbmUoZW5naW5lKSB7XG4gIHJlYWN0aXZlID0gZW5naW5lLnJlYWN0aXZlO1xuICByZWxlYXNlID0gZW5naW5lLnJlbGVhc2U7XG4gIGVmZmVjdCA9IChjYWxsYmFjaykgPT4gZW5naW5lLmVmZmVjdChjYWxsYmFjaywge3NjaGVkdWxlcjogKHRhc2spID0+IHtcbiAgICBpZiAoc2hvdWxkU2NoZWR1bGUpIHtcbiAgICAgIHNjaGVkdWxlcih0YXNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFzaygpO1xuICAgIH1cbiAgfX0pO1xuICByYXcgPSBlbmdpbmUucmF3O1xufVxuZnVuY3Rpb24gb3ZlcnJpZGVFZmZlY3Qob3ZlcnJpZGUpIHtcbiAgZWZmZWN0ID0gb3ZlcnJpZGU7XG59XG5mdW5jdGlvbiBlbGVtZW50Qm91bmRFZmZlY3QoZWwpIHtcbiAgbGV0IGNsZWFudXAgPSAoKSA9PiB7XG4gIH07XG4gIGxldCB3cmFwcGVkRWZmZWN0ID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgbGV0IGVmZmVjdFJlZmVyZW5jZSA9IGVmZmVjdChjYWxsYmFjayk7XG4gICAgaWYgKCFlbC5feF9lZmZlY3RzKSB7XG4gICAgICBlbC5feF9lZmZlY3RzID0gbmV3IFNldCgpO1xuICAgICAgZWwuX3hfcnVuRWZmZWN0cyA9ICgpID0+IHtcbiAgICAgICAgZWwuX3hfZWZmZWN0cy5mb3JFYWNoKChpKSA9PiBpKCkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZWwuX3hfZWZmZWN0cy5hZGQoZWZmZWN0UmVmZXJlbmNlKTtcbiAgICBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgaWYgKGVmZmVjdFJlZmVyZW5jZSA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm47XG4gICAgICBlbC5feF9lZmZlY3RzLmRlbGV0ZShlZmZlY3RSZWZlcmVuY2UpO1xuICAgICAgcmVsZWFzZShlZmZlY3RSZWZlcmVuY2UpO1xuICAgIH07XG4gIH07XG4gIHJldHVybiBbd3JhcHBlZEVmZmVjdCwgKCkgPT4ge1xuICAgIGNsZWFudXAoKTtcbiAgfV07XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tdXRhdGlvbi5qc1xudmFyIG9uQXR0cmlidXRlQWRkZWRzID0gW107XG52YXIgb25FbFJlbW92ZWRzID0gW107XG52YXIgb25FbEFkZGVkcyA9IFtdO1xuZnVuY3Rpb24gb25FbEFkZGVkKGNhbGxiYWNrKSB7XG4gIG9uRWxBZGRlZHMucHVzaChjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBvbkVsUmVtb3ZlZChjYWxsYmFjaykge1xuICBvbkVsUmVtb3ZlZHMucHVzaChjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBvbkF0dHJpYnV0ZXNBZGRlZChjYWxsYmFjaykge1xuICBvbkF0dHJpYnV0ZUFkZGVkcy5wdXNoKGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIG9uQXR0cmlidXRlUmVtb3ZlZChlbCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgaWYgKCFlbC5feF9hdHRyaWJ1dGVDbGVhbnVwcylcbiAgICBlbC5feF9hdHRyaWJ1dGVDbGVhbnVwcyA9IHt9O1xuICBpZiAoIWVsLl94X2F0dHJpYnV0ZUNsZWFudXBzW25hbWVdKVxuICAgIGVsLl94X2F0dHJpYnV0ZUNsZWFudXBzW25hbWVdID0gW107XG4gIGVsLl94X2F0dHJpYnV0ZUNsZWFudXBzW25hbWVdLnB1c2goY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gY2xlYW51cEF0dHJpYnV0ZXMoZWwsIG5hbWVzKSB7XG4gIGlmICghZWwuX3hfYXR0cmlidXRlQ2xlYW51cHMpXG4gICAgcmV0dXJuO1xuICBPYmplY3QuZW50cmllcyhlbC5feF9hdHRyaWJ1dGVDbGVhbnVwcykuZm9yRWFjaCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuICAgIGlmIChuYW1lcyA9PT0gdm9pZCAwIHx8IG5hbWVzLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKChpKSA9PiBpKCkpO1xuICAgICAgZGVsZXRlIGVsLl94X2F0dHJpYnV0ZUNsZWFudXBzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59XG52YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihvbk11dGF0ZSk7XG52YXIgY3VycmVudGx5T2JzZXJ2aW5nID0gZmFsc2U7XG5mdW5jdGlvbiBzdGFydE9ic2VydmluZ011dGF0aW9ucygpIHtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge3N1YnRyZWU6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgYXR0cmlidXRlczogdHJ1ZSwgYXR0cmlidXRlT2xkVmFsdWU6IHRydWV9KTtcbiAgY3VycmVudGx5T2JzZXJ2aW5nID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHN0b3BPYnNlcnZpbmdNdXRhdGlvbnMoKSB7XG4gIGZsdXNoT2JzZXJ2ZXIoKTtcbiAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICBjdXJyZW50bHlPYnNlcnZpbmcgPSBmYWxzZTtcbn1cbnZhciByZWNvcmRRdWV1ZSA9IFtdO1xudmFyIHdpbGxQcm9jZXNzUmVjb3JkUXVldWUgPSBmYWxzZTtcbmZ1bmN0aW9uIGZsdXNoT2JzZXJ2ZXIoKSB7XG4gIHJlY29yZFF1ZXVlID0gcmVjb3JkUXVldWUuY29uY2F0KG9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xuICBpZiAocmVjb3JkUXVldWUubGVuZ3RoICYmICF3aWxsUHJvY2Vzc1JlY29yZFF1ZXVlKSB7XG4gICAgd2lsbFByb2Nlc3NSZWNvcmRRdWV1ZSA9IHRydWU7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgcHJvY2Vzc1JlY29yZFF1ZXVlKCk7XG4gICAgICB3aWxsUHJvY2Vzc1JlY29yZFF1ZXVlID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NSZWNvcmRRdWV1ZSgpIHtcbiAgb25NdXRhdGUocmVjb3JkUXVldWUpO1xuICByZWNvcmRRdWV1ZS5sZW5ndGggPSAwO1xufVxuZnVuY3Rpb24gbXV0YXRlRG9tKGNhbGxiYWNrKSB7XG4gIGlmICghY3VycmVudGx5T2JzZXJ2aW5nKVxuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICBzdG9wT2JzZXJ2aW5nTXV0YXRpb25zKCk7XG4gIGxldCByZXN1bHQgPSBjYWxsYmFjaygpO1xuICBzdGFydE9ic2VydmluZ011dGF0aW9ucygpO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIGlzQ29sbGVjdGluZyA9IGZhbHNlO1xudmFyIGRlZmVycmVkTXV0YXRpb25zID0gW107XG5mdW5jdGlvbiBkZWZlck11dGF0aW9ucygpIHtcbiAgaXNDb2xsZWN0aW5nID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGZsdXNoQW5kU3RvcERlZmVycmluZ011dGF0aW9ucygpIHtcbiAgaXNDb2xsZWN0aW5nID0gZmFsc2U7XG4gIG9uTXV0YXRlKGRlZmVycmVkTXV0YXRpb25zKTtcbiAgZGVmZXJyZWRNdXRhdGlvbnMgPSBbXTtcbn1cbmZ1bmN0aW9uIG9uTXV0YXRlKG11dGF0aW9ucykge1xuICBpZiAoaXNDb2xsZWN0aW5nKSB7XG4gICAgZGVmZXJyZWRNdXRhdGlvbnMgPSBkZWZlcnJlZE11dGF0aW9ucy5jb25jYXQobXV0YXRpb25zKTtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGFkZGVkTm9kZXMgPSBbXTtcbiAgbGV0IHJlbW92ZWROb2RlcyA9IFtdO1xuICBsZXQgYWRkZWRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICBsZXQgcmVtb3ZlZEF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG11dGF0aW9uc1tpXS50YXJnZXQuX3hfaWdub3JlTXV0YXRpb25PYnNlcnZlcilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmIChtdXRhdGlvbnNbaV0udHlwZSA9PT0gXCJjaGlsZExpc3RcIikge1xuICAgICAgbXV0YXRpb25zW2ldLmFkZGVkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBhZGRlZE5vZGVzLnB1c2gobm9kZSkpO1xuICAgICAgbXV0YXRpb25zW2ldLnJlbW92ZWROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSAxICYmIHJlbW92ZWROb2Rlcy5wdXNoKG5vZGUpKTtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9uc1tpXS50eXBlID09PSBcImF0dHJpYnV0ZXNcIikge1xuICAgICAgbGV0IGVsID0gbXV0YXRpb25zW2ldLnRhcmdldDtcbiAgICAgIGxldCBuYW1lID0gbXV0YXRpb25zW2ldLmF0dHJpYnV0ZU5hbWU7XG4gICAgICBsZXQgb2xkVmFsdWUgPSBtdXRhdGlvbnNbaV0ub2xkVmFsdWU7XG4gICAgICBsZXQgYWRkID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWFkZGVkQXR0cmlidXRlcy5oYXMoZWwpKVxuICAgICAgICAgIGFkZGVkQXR0cmlidXRlcy5zZXQoZWwsIFtdKTtcbiAgICAgICAgYWRkZWRBdHRyaWJ1dGVzLmdldChlbCkucHVzaCh7bmFtZSwgdmFsdWU6IGVsLmdldEF0dHJpYnV0ZShuYW1lKX0pO1xuICAgICAgfTtcbiAgICAgIGxldCByZW1vdmUgPSAoKSA9PiB7XG4gICAgICAgIGlmICghcmVtb3ZlZEF0dHJpYnV0ZXMuaGFzKGVsKSlcbiAgICAgICAgICByZW1vdmVkQXR0cmlidXRlcy5zZXQoZWwsIFtdKTtcbiAgICAgICAgcmVtb3ZlZEF0dHJpYnV0ZXMuZ2V0KGVsKS5wdXNoKG5hbWUpO1xuICAgICAgfTtcbiAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUobmFtZSkgJiYgb2xkVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgYWRkKCk7XG4gICAgICB9IGVsc2UgaWYgKGVsLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgYWRkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVtb3ZlZEF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cnMsIGVsKSA9PiB7XG4gICAgY2xlYW51cEF0dHJpYnV0ZXMoZWwsIGF0dHJzKTtcbiAgfSk7XG4gIGFkZGVkQXR0cmlidXRlcy5mb3JFYWNoKChhdHRycywgZWwpID0+IHtcbiAgICBvbkF0dHJpYnV0ZUFkZGVkcy5mb3JFYWNoKChpKSA9PiBpKGVsLCBhdHRycykpO1xuICB9KTtcbiAgYWRkZWROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgbm9kZS5feF9pZ25vcmVTZWxmID0gdHJ1ZTtcbiAgICBub2RlLl94X2lnbm9yZSA9IHRydWU7XG4gIH0pO1xuICBmb3IgKGxldCBub2RlIG9mIGFkZGVkTm9kZXMpIHtcbiAgICBpZiAocmVtb3ZlZE5vZGVzLmluY2x1ZGVzKG5vZGUpKVxuICAgICAgY29udGludWU7XG4gICAgZGVsZXRlIG5vZGUuX3hfaWdub3JlU2VsZjtcbiAgICBkZWxldGUgbm9kZS5feF9pZ25vcmU7XG4gICAgb25FbEFkZGVkcy5mb3JFYWNoKChpKSA9PiBpKG5vZGUpKTtcbiAgICBub2RlLl94X2lnbm9yZSA9IHRydWU7XG4gICAgbm9kZS5feF9pZ25vcmVTZWxmID0gdHJ1ZTtcbiAgfVxuICBhZGRlZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICBkZWxldGUgbm9kZS5feF9pZ25vcmVTZWxmO1xuICAgIGRlbGV0ZSBub2RlLl94X2lnbm9yZTtcbiAgfSk7XG4gIGZvciAobGV0IG5vZGUgb2YgcmVtb3ZlZE5vZGVzKSB7XG4gICAgaWYgKGFkZGVkTm9kZXMuaW5jbHVkZXMobm9kZSkpXG4gICAgICBjb250aW51ZTtcbiAgICBvbkVsUmVtb3ZlZHMuZm9yRWFjaCgoaSkgPT4gaShub2RlKSk7XG4gIH1cbiAgYWRkZWROb2RlcyA9IG51bGw7XG4gIHJlbW92ZWROb2RlcyA9IG51bGw7XG4gIGFkZGVkQXR0cmlidXRlcyA9IG51bGw7XG4gIHJlbW92ZWRBdHRyaWJ1dGVzID0gbnVsbDtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3Njb3BlLmpzXG5mdW5jdGlvbiBhZGRTY29wZVRvTm9kZShub2RlLCBkYXRhMiwgcmVmZXJlbmNlTm9kZSkge1xuICBub2RlLl94X2RhdGFTdGFjayA9IFtkYXRhMiwgLi4uY2xvc2VzdERhdGFTdGFjayhyZWZlcmVuY2VOb2RlIHx8IG5vZGUpXTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBub2RlLl94X2RhdGFTdGFjayA9IG5vZGUuX3hfZGF0YVN0YWNrLmZpbHRlcigoaSkgPT4gaSAhPT0gZGF0YTIpO1xuICB9O1xufVxuZnVuY3Rpb24gcmVmcmVzaFNjb3BlKGVsZW1lbnQsIHNjb3BlKSB7XG4gIGxldCBleGlzdGluZ1Njb3BlID0gZWxlbWVudC5feF9kYXRhU3RhY2tbMF07XG4gIE9iamVjdC5lbnRyaWVzKHNjb3BlKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBleGlzdGluZ1Njb3BlW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjbG9zZXN0RGF0YVN0YWNrKG5vZGUpIHtcbiAgaWYgKG5vZGUuX3hfZGF0YVN0YWNrKVxuICAgIHJldHVybiBub2RlLl94X2RhdGFTdGFjaztcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSBcImZ1bmN0aW9uXCIgJiYgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICByZXR1cm4gY2xvc2VzdERhdGFTdGFjayhub2RlLmhvc3QpO1xuICB9XG4gIGlmICghbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBjbG9zZXN0RGF0YVN0YWNrKG5vZGUucGFyZW50Tm9kZSk7XG59XG5mdW5jdGlvbiBtZXJnZVByb3hpZXMob2JqZWN0cykge1xuICBsZXQgdGhpc1Byb3h5ID0gbmV3IFByb3h5KHt9LCB7XG4gICAgb3duS2V5czogKCkgPT4ge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChvYmplY3RzLmZsYXRNYXAoKGkpID0+IE9iamVjdC5rZXlzKGkpKSkpO1xuICAgIH0sXG4gICAgaGFzOiAodGFyZ2V0LCBuYW1lKSA9PiB7XG4gICAgICByZXR1cm4gb2JqZWN0cy5zb21lKChvYmopID0+IG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKSk7XG4gICAgfSxcbiAgICBnZXQ6ICh0YXJnZXQsIG5hbWUpID0+IHtcbiAgICAgIHJldHVybiAob2JqZWN0cy5maW5kKChvYmopID0+IHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIGxldCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIG5hbWUpO1xuICAgICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCAmJiBkZXNjcmlwdG9yLmdldC5feF9hbHJlYWR5Qm91bmQgfHwgZGVzY3JpcHRvci5zZXQgJiYgZGVzY3JpcHRvci5zZXQuX3hfYWxyZWFkeUJvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChkZXNjcmlwdG9yLmdldCB8fCBkZXNjcmlwdG9yLnNldCkgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgICBsZXQgZ2V0dGVyID0gZGVzY3JpcHRvci5nZXQ7XG4gICAgICAgICAgICBsZXQgc2V0dGVyID0gZGVzY3JpcHRvci5zZXQ7XG4gICAgICAgICAgICBsZXQgcHJvcGVydHkgPSBkZXNjcmlwdG9yO1xuICAgICAgICAgICAgZ2V0dGVyID0gZ2V0dGVyICYmIGdldHRlci5iaW5kKHRoaXNQcm94eSk7XG4gICAgICAgICAgICBzZXR0ZXIgPSBzZXR0ZXIgJiYgc2V0dGVyLmJpbmQodGhpc1Byb3h5KTtcbiAgICAgICAgICAgIGlmIChnZXR0ZXIpXG4gICAgICAgICAgICAgIGdldHRlci5feF9hbHJlYWR5Qm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHNldHRlcilcbiAgICAgICAgICAgICAgc2V0dGVyLl94X2FscmVhZHlCb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICAgICAgICAgIC4uLnByb3BlcnR5LFxuICAgICAgICAgICAgICBnZXQ6IGdldHRlcixcbiAgICAgICAgICAgICAgc2V0OiBzZXR0ZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KSB8fCB7fSlbbmFtZV07XG4gICAgfSxcbiAgICBzZXQ6ICh0YXJnZXQsIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICBsZXQgY2xvc2VzdE9iamVjdFdpdGhLZXkgPSBvYmplY3RzLmZpbmQoKG9iaikgPT4gb2JqLmhhc093blByb3BlcnR5KG5hbWUpKTtcbiAgICAgIGlmIChjbG9zZXN0T2JqZWN0V2l0aEtleSkge1xuICAgICAgICBjbG9zZXN0T2JqZWN0V2l0aEtleVtuYW1lXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0c1tvYmplY3RzLmxlbmd0aCAtIDFdW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGhpc1Byb3h5O1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvaW50ZXJjZXB0b3IuanNcbmZ1bmN0aW9uIGluaXRJbnRlcmNlcHRvcnMoZGF0YTIpIHtcbiAgbGV0IGlzT2JqZWN0ID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWwpICYmIHZhbCAhPT0gbnVsbDtcbiAgbGV0IHJlY3Vyc2UgPSAob2JqLCBiYXNlUGF0aCA9IFwiXCIpID0+IHtcbiAgICBPYmplY3QuZW50cmllcyhPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopKS5mb3JFYWNoKChba2V5LCB7dmFsdWUsIGVudW1lcmFibGV9XSkgPT4ge1xuICAgICAgaWYgKGVudW1lcmFibGUgPT09IGZhbHNlIHx8IHZhbHVlID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBwYXRoID0gYmFzZVBhdGggPT09IFwiXCIgPyBrZXkgOiBgJHtiYXNlUGF0aH0uJHtrZXl9YDtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUuX3hfaW50ZXJjZXB0b3IpIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZS5pbml0aWFsaXplKGRhdGEyLCBwYXRoLCBrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZSAhPT0gb2JqICYmICEodmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICAgIHJlY3Vyc2UodmFsdWUsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiByZWN1cnNlKGRhdGEyKTtcbn1cbmZ1bmN0aW9uIGludGVyY2VwdG9yKGNhbGxiYWNrLCBtdXRhdGVPYmogPSAoKSA9PiB7XG59KSB7XG4gIGxldCBvYmogPSB7XG4gICAgaW5pdGlhbFZhbHVlOiB2b2lkIDAsXG4gICAgX3hfaW50ZXJjZXB0b3I6IHRydWUsXG4gICAgaW5pdGlhbGl6ZShkYXRhMiwgcGF0aCwga2V5KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5pbml0aWFsVmFsdWUsICgpID0+IGdldChkYXRhMiwgcGF0aCksICh2YWx1ZSkgPT4gc2V0KGRhdGEyLCBwYXRoLCB2YWx1ZSksIHBhdGgsIGtleSk7XG4gICAgfVxuICB9O1xuICBtdXRhdGVPYmoob2JqKTtcbiAgcmV0dXJuIChpbml0aWFsVmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIGluaXRpYWxWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBpbml0aWFsVmFsdWUgIT09IG51bGwgJiYgaW5pdGlhbFZhbHVlLl94X2ludGVyY2VwdG9yKSB7XG4gICAgICBsZXQgaW5pdGlhbGl6ZSA9IG9iai5pbml0aWFsaXplLmJpbmQob2JqKTtcbiAgICAgIG9iai5pbml0aWFsaXplID0gKGRhdGEyLCBwYXRoLCBrZXkpID0+IHtcbiAgICAgICAgbGV0IGlubmVyVmFsdWUgPSBpbml0aWFsVmFsdWUuaW5pdGlhbGl6ZShkYXRhMiwgcGF0aCwga2V5KTtcbiAgICAgICAgb2JqLmluaXRpYWxWYWx1ZSA9IGlubmVyVmFsdWU7XG4gICAgICAgIHJldHVybiBpbml0aWFsaXplKGRhdGEyLCBwYXRoLCBrZXkpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqLmluaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldChvYmosIHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguc3BsaXQoXCIuXCIpLnJlZHVjZSgoY2FycnksIHNlZ21lbnQpID0+IGNhcnJ5W3NlZ21lbnRdLCBvYmopO1xufVxuZnVuY3Rpb24gc2V0KG9iaiwgcGF0aCwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiKVxuICAgIHBhdGggPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAxKVxuICAgIG9ialtwYXRoWzBdXSA9IHZhbHVlO1xuICBlbHNlIGlmIChwYXRoLmxlbmd0aCA9PT0gMClcbiAgICB0aHJvdyBlcnJvcjtcbiAgZWxzZSB7XG4gICAgaWYgKG9ialtwYXRoWzBdXSlcbiAgICAgIHJldHVybiBzZXQob2JqW3BhdGhbMF1dLCBwYXRoLnNsaWNlKDEpLCB2YWx1ZSk7XG4gICAgZWxzZSB7XG4gICAgICBvYmpbcGF0aFswXV0gPSB7fTtcbiAgICAgIHJldHVybiBzZXQob2JqW3BhdGhbMF1dLCBwYXRoLnNsaWNlKDEpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MuanNcbnZhciBtYWdpY3MgPSB7fTtcbmZ1bmN0aW9uIG1hZ2ljKG5hbWUsIGNhbGxiYWNrKSB7XG4gIG1hZ2ljc1tuYW1lXSA9IGNhbGxiYWNrO1xufVxuZnVuY3Rpb24gaW5qZWN0TWFnaWNzKG9iaiwgZWwpIHtcbiAgT2JqZWN0LmVudHJpZXMobWFnaWNzKS5mb3JFYWNoKChbbmFtZSwgY2FsbGJhY2tdKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgYCQke25hbWV9YCwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZWwsIHtBbHBpbmU6IGFscGluZV9kZWZhdWx0LCBpbnRlcmNlcHRvcn0pO1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2JqO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvZXJyb3IuanNcbmZ1bmN0aW9uIHRyeUNhdGNoKGVsLCBleHByZXNzaW9uLCBjYWxsYmFjaywgLi4uYXJncykge1xuICB0cnkge1xuICAgIHJldHVybiBjYWxsYmFjayguLi5hcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIGVsLCBleHByZXNzaW9uKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyb3IyLCBlbCwgZXhwcmVzc2lvbiA9IHZvaWQgMCkge1xuICBPYmplY3QuYXNzaWduKGVycm9yMiwge2VsLCBleHByZXNzaW9ufSk7XG4gIGNvbnNvbGUud2FybihgQWxwaW5lIEV4cHJlc3Npb24gRXJyb3I6ICR7ZXJyb3IyLm1lc3NhZ2V9XG5cbiR7ZXhwcmVzc2lvbiA/ICdFeHByZXNzaW9uOiBcIicgKyBleHByZXNzaW9uICsgJ1wiXFxuXFxuJyA6IFwiXCJ9YCwgZWwpO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0aHJvdyBlcnJvcjI7XG4gIH0sIDApO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZXZhbHVhdG9yLmpzXG5mdW5jdGlvbiBldmFsdWF0ZShlbCwgZXhwcmVzc2lvbiwgZXh0cmFzID0ge30pIHtcbiAgbGV0IHJlc3VsdDtcbiAgZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbikoKHZhbHVlKSA9PiByZXN1bHQgPSB2YWx1ZSwgZXh0cmFzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlTGF0ZXIoLi4uYXJncykge1xuICByZXR1cm4gdGhlRXZhbHVhdG9yRnVuY3Rpb24oLi4uYXJncyk7XG59XG52YXIgdGhlRXZhbHVhdG9yRnVuY3Rpb24gPSBub3JtYWxFdmFsdWF0b3I7XG5mdW5jdGlvbiBzZXRFdmFsdWF0b3IobmV3RXZhbHVhdG9yKSB7XG4gIHRoZUV2YWx1YXRvckZ1bmN0aW9uID0gbmV3RXZhbHVhdG9yO1xufVxuZnVuY3Rpb24gbm9ybWFsRXZhbHVhdG9yKGVsLCBleHByZXNzaW9uKSB7XG4gIGxldCBvdmVycmlkZGVuTWFnaWNzID0ge307XG4gIGluamVjdE1hZ2ljcyhvdmVycmlkZGVuTWFnaWNzLCBlbCk7XG4gIGxldCBkYXRhU3RhY2sgPSBbb3ZlcnJpZGRlbk1hZ2ljcywgLi4uY2xvc2VzdERhdGFTdGFjayhlbCldO1xuICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBnZW5lcmF0ZUV2YWx1YXRvckZyb21GdW5jdGlvbihkYXRhU3RhY2ssIGV4cHJlc3Npb24pO1xuICB9XG4gIGxldCBldmFsdWF0b3IgPSBnZW5lcmF0ZUV2YWx1YXRvckZyb21TdHJpbmcoZGF0YVN0YWNrLCBleHByZXNzaW9uLCBlbCk7XG4gIHJldHVybiB0cnlDYXRjaC5iaW5kKG51bGwsIGVsLCBleHByZXNzaW9uLCBldmFsdWF0b3IpO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVFdmFsdWF0b3JGcm9tRnVuY3Rpb24oZGF0YVN0YWNrLCBmdW5jKSB7XG4gIHJldHVybiAocmVjZWl2ZXIgPSAoKSA9PiB7XG4gIH0sIHtzY29wZSA9IHt9LCBwYXJhbXMgPSBbXX0gPSB7fSkgPT4ge1xuICAgIGxldCByZXN1bHQgPSBmdW5jLmFwcGx5KG1lcmdlUHJveGllcyhbc2NvcGUsIC4uLmRhdGFTdGFja10pLCBwYXJhbXMpO1xuICAgIHJ1bklmVHlwZU9mRnVuY3Rpb24ocmVjZWl2ZXIsIHJlc3VsdCk7XG4gIH07XG59XG52YXIgZXZhbHVhdG9yTWVtbyA9IHt9O1xuZnVuY3Rpb24gZ2VuZXJhdGVGdW5jdGlvbkZyb21TdHJpbmcoZXhwcmVzc2lvbiwgZWwpIHtcbiAgaWYgKGV2YWx1YXRvck1lbW9bZXhwcmVzc2lvbl0pIHtcbiAgICByZXR1cm4gZXZhbHVhdG9yTWVtb1tleHByZXNzaW9uXTtcbiAgfVxuICBsZXQgQXN5bmNGdW5jdGlvbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhc3luYyBmdW5jdGlvbigpIHtcbiAgfSkuY29uc3RydWN0b3I7XG4gIGxldCByaWdodFNpZGVTYWZlRXhwcmVzc2lvbiA9IC9eW1xcblxcc10qaWYuKlxcKC4qXFwpLy50ZXN0KGV4cHJlc3Npb24pIHx8IC9eKGxldHxjb25zdClcXHMvLnRlc3QoZXhwcmVzc2lvbikgPyBgKCgpID0+IHsgJHtleHByZXNzaW9ufSB9KSgpYCA6IGV4cHJlc3Npb247XG4gIGNvbnN0IHNhZmVBc3luY0Z1bmN0aW9uID0gKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IEFzeW5jRnVuY3Rpb24oW1wiX19zZWxmXCIsIFwic2NvcGVcIl0sIGB3aXRoIChzY29wZSkgeyBfX3NlbGYucmVzdWx0ID0gJHtyaWdodFNpZGVTYWZlRXhwcmVzc2lvbn0gfTsgX19zZWxmLmZpbmlzaGVkID0gdHJ1ZTsgcmV0dXJuIF9fc2VsZi5yZXN1bHQ7YCk7XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlcnJvcjIsIGVsLCBleHByZXNzaW9uKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gIH07XG4gIGxldCBmdW5jID0gc2FmZUFzeW5jRnVuY3Rpb24oKTtcbiAgZXZhbHVhdG9yTWVtb1tleHByZXNzaW9uXSA9IGZ1bmM7XG4gIHJldHVybiBmdW5jO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVFdmFsdWF0b3JGcm9tU3RyaW5nKGRhdGFTdGFjaywgZXhwcmVzc2lvbiwgZWwpIHtcbiAgbGV0IGZ1bmMgPSBnZW5lcmF0ZUZ1bmN0aW9uRnJvbVN0cmluZyhleHByZXNzaW9uLCBlbCk7XG4gIHJldHVybiAocmVjZWl2ZXIgPSAoKSA9PiB7XG4gIH0sIHtzY29wZSA9IHt9LCBwYXJhbXMgPSBbXX0gPSB7fSkgPT4ge1xuICAgIGZ1bmMucmVzdWx0ID0gdm9pZCAwO1xuICAgIGZ1bmMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICBsZXQgY29tcGxldGVTY29wZSA9IG1lcmdlUHJveGllcyhbc2NvcGUsIC4uLmRhdGFTdGFja10pO1xuICAgIGlmICh0eXBlb2YgZnVuYyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBsZXQgcHJvbWlzZSA9IGZ1bmMoZnVuYywgY29tcGxldGVTY29wZSkuY2F0Y2goKGVycm9yMikgPT4gaGFuZGxlRXJyb3IoZXJyb3IyLCBlbCwgZXhwcmVzc2lvbikpO1xuICAgICAgaWYgKGZ1bmMuZmluaXNoZWQpIHtcbiAgICAgICAgcnVuSWZUeXBlT2ZGdW5jdGlvbihyZWNlaXZlciwgZnVuYy5yZXN1bHQsIGNvbXBsZXRlU2NvcGUsIHBhcmFtcywgZWwpO1xuICAgICAgICBmdW5jLnJlc3VsdCA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2UudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgcnVuSWZUeXBlT2ZGdW5jdGlvbihyZWNlaXZlciwgcmVzdWx0LCBjb21wbGV0ZVNjb3BlLCBwYXJhbXMsIGVsKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycm9yMikgPT4gaGFuZGxlRXJyb3IoZXJyb3IyLCBlbCwgZXhwcmVzc2lvbikpLmZpbmFsbHkoKCkgPT4gZnVuYy5yZXN1bHQgPSB2b2lkIDApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJ1bklmVHlwZU9mRnVuY3Rpb24ocmVjZWl2ZXIsIHZhbHVlLCBzY29wZSwgcGFyYW1zLCBlbCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBsZXQgcmVzdWx0ID0gdmFsdWUuYXBwbHkoc2NvcGUsIHBhcmFtcyk7XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHJlc3VsdC50aGVuKChpKSA9PiBydW5JZlR5cGVPZkZ1bmN0aW9uKHJlY2VpdmVyLCBpLCBzY29wZSwgcGFyYW1zKSkuY2F0Y2goKGVycm9yMikgPT4gaGFuZGxlRXJyb3IoZXJyb3IyLCBlbCwgdmFsdWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjZWl2ZXIocmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVjZWl2ZXIodmFsdWUpO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzLmpzXG52YXIgcHJlZml4QXNTdHJpbmcgPSBcIngtXCI7XG5mdW5jdGlvbiBwcmVmaXgoc3ViamVjdCA9IFwiXCIpIHtcbiAgcmV0dXJuIHByZWZpeEFzU3RyaW5nICsgc3ViamVjdDtcbn1cbmZ1bmN0aW9uIHNldFByZWZpeChuZXdQcmVmaXgpIHtcbiAgcHJlZml4QXNTdHJpbmcgPSBuZXdQcmVmaXg7XG59XG52YXIgZGlyZWN0aXZlSGFuZGxlcnMgPSB7fTtcbmZ1bmN0aW9uIGRpcmVjdGl2ZShuYW1lLCBjYWxsYmFjaykge1xuICBkaXJlY3RpdmVIYW5kbGVyc1tuYW1lXSA9IGNhbGxiYWNrO1xufVxuZnVuY3Rpb24gZGlyZWN0aXZlcyhlbCwgYXR0cmlidXRlcywgb3JpZ2luYWxBdHRyaWJ1dGVPdmVycmlkZSkge1xuICBsZXQgdHJhbnNmb3JtZWRBdHRyaWJ1dGVNYXAgPSB7fTtcbiAgbGV0IGRpcmVjdGl2ZXMyID0gQXJyYXkuZnJvbShhdHRyaWJ1dGVzKS5tYXAodG9UcmFuc2Zvcm1lZEF0dHJpYnV0ZXMoKG5ld05hbWUsIG9sZE5hbWUpID0+IHRyYW5zZm9ybWVkQXR0cmlidXRlTWFwW25ld05hbWVdID0gb2xkTmFtZSkpLmZpbHRlcihvdXROb25BbHBpbmVBdHRyaWJ1dGVzKS5tYXAodG9QYXJzZWREaXJlY3RpdmVzKHRyYW5zZm9ybWVkQXR0cmlidXRlTWFwLCBvcmlnaW5hbEF0dHJpYnV0ZU92ZXJyaWRlKSkuc29ydChieVByaW9yaXR5KTtcbiAgcmV0dXJuIGRpcmVjdGl2ZXMyLm1hcCgoZGlyZWN0aXZlMikgPT4ge1xuICAgIHJldHVybiBnZXREaXJlY3RpdmVIYW5kbGVyKGVsLCBkaXJlY3RpdmUyKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhdHRyaWJ1dGVzT25seShhdHRyaWJ1dGVzKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGF0dHJpYnV0ZXMpLm1hcCh0b1RyYW5zZm9ybWVkQXR0cmlidXRlcygpKS5maWx0ZXIoKGF0dHIpID0+ICFvdXROb25BbHBpbmVBdHRyaWJ1dGVzKGF0dHIpKTtcbn1cbnZhciBpc0RlZmVycmluZ0hhbmRsZXJzID0gZmFsc2U7XG52YXIgZGlyZWN0aXZlSGFuZGxlclN0YWNrcyA9IG5ldyBNYXAoKTtcbnZhciBjdXJyZW50SGFuZGxlclN0YWNrS2V5ID0gU3ltYm9sKCk7XG5mdW5jdGlvbiBkZWZlckhhbmRsaW5nRGlyZWN0aXZlcyhjYWxsYmFjaykge1xuICBpc0RlZmVycmluZ0hhbmRsZXJzID0gdHJ1ZTtcbiAgbGV0IGtleSA9IFN5bWJvbCgpO1xuICBjdXJyZW50SGFuZGxlclN0YWNrS2V5ID0ga2V5O1xuICBkaXJlY3RpdmVIYW5kbGVyU3RhY2tzLnNldChrZXksIFtdKTtcbiAgbGV0IGZsdXNoSGFuZGxlcnMgPSAoKSA9PiB7XG4gICAgd2hpbGUgKGRpcmVjdGl2ZUhhbmRsZXJTdGFja3MuZ2V0KGtleSkubGVuZ3RoKVxuICAgICAgZGlyZWN0aXZlSGFuZGxlclN0YWNrcy5nZXQoa2V5KS5zaGlmdCgpKCk7XG4gICAgZGlyZWN0aXZlSGFuZGxlclN0YWNrcy5kZWxldGUoa2V5KTtcbiAgfTtcbiAgbGV0IHN0b3BEZWZlcnJpbmcgPSAoKSA9PiB7XG4gICAgaXNEZWZlcnJpbmdIYW5kbGVycyA9IGZhbHNlO1xuICAgIGZsdXNoSGFuZGxlcnMoKTtcbiAgfTtcbiAgY2FsbGJhY2soZmx1c2hIYW5kbGVycyk7XG4gIHN0b3BEZWZlcnJpbmcoKTtcbn1cbmZ1bmN0aW9uIGdldERpcmVjdGl2ZUhhbmRsZXIoZWwsIGRpcmVjdGl2ZTIpIHtcbiAgbGV0IG5vb3AgPSAoKSA9PiB7XG4gIH07XG4gIGxldCBoYW5kbGVyMyA9IGRpcmVjdGl2ZUhhbmRsZXJzW2RpcmVjdGl2ZTIudHlwZV0gfHwgbm9vcDtcbiAgbGV0IGNsZWFudXBzID0gW107XG4gIGxldCBjbGVhbnVwID0gKGNhbGxiYWNrKSA9PiBjbGVhbnVwcy5wdXNoKGNhbGxiYWNrKTtcbiAgbGV0IFtlZmZlY3QzLCBjbGVhbnVwRWZmZWN0XSA9IGVsZW1lbnRCb3VuZEVmZmVjdChlbCk7XG4gIGNsZWFudXBzLnB1c2goY2xlYW51cEVmZmVjdCk7XG4gIGxldCB1dGlsaXRpZXMgPSB7XG4gICAgQWxwaW5lOiBhbHBpbmVfZGVmYXVsdCxcbiAgICBlZmZlY3Q6IGVmZmVjdDMsXG4gICAgY2xlYW51cCxcbiAgICBldmFsdWF0ZUxhdGVyOiBldmFsdWF0ZUxhdGVyLmJpbmQoZXZhbHVhdGVMYXRlciwgZWwpLFxuICAgIGV2YWx1YXRlOiBldmFsdWF0ZS5iaW5kKGV2YWx1YXRlLCBlbClcbiAgfTtcbiAgbGV0IGRvQ2xlYW51cCA9ICgpID0+IGNsZWFudXBzLmZvckVhY2goKGkpID0+IGkoKSk7XG4gIG9uQXR0cmlidXRlUmVtb3ZlZChlbCwgZGlyZWN0aXZlMi5vcmlnaW5hbCwgZG9DbGVhbnVwKTtcbiAgbGV0IGZ1bGxIYW5kbGVyID0gKCkgPT4ge1xuICAgIGlmIChlbC5feF9pZ25vcmUgfHwgZWwuX3hfaWdub3JlU2VsZilcbiAgICAgIHJldHVybjtcbiAgICBoYW5kbGVyMy5pbmxpbmUgJiYgaGFuZGxlcjMuaW5saW5lKGVsLCBkaXJlY3RpdmUyLCB1dGlsaXRpZXMpO1xuICAgIGhhbmRsZXIzID0gaGFuZGxlcjMuYmluZChoYW5kbGVyMywgZWwsIGRpcmVjdGl2ZTIsIHV0aWxpdGllcyk7XG4gICAgaXNEZWZlcnJpbmdIYW5kbGVycyA/IGRpcmVjdGl2ZUhhbmRsZXJTdGFja3MuZ2V0KGN1cnJlbnRIYW5kbGVyU3RhY2tLZXkpLnB1c2goaGFuZGxlcjMpIDogaGFuZGxlcjMoKTtcbiAgfTtcbiAgZnVsbEhhbmRsZXIucnVuQ2xlYW51cHMgPSBkb0NsZWFudXA7XG4gIHJldHVybiBmdWxsSGFuZGxlcjtcbn1cbnZhciBzdGFydGluZ1dpdGggPSAoc3ViamVjdCwgcmVwbGFjZW1lbnQpID0+ICh7bmFtZSwgdmFsdWV9KSA9PiB7XG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoc3ViamVjdCkpXG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZShzdWJqZWN0LCByZXBsYWNlbWVudCk7XG4gIHJldHVybiB7bmFtZSwgdmFsdWV9O1xufTtcbnZhciBpbnRvID0gKGkpID0+IGk7XG5mdW5jdGlvbiB0b1RyYW5zZm9ybWVkQXR0cmlidXRlcyhjYWxsYmFjayA9ICgpID0+IHtcbn0pIHtcbiAgcmV0dXJuICh7bmFtZSwgdmFsdWV9KSA9PiB7XG4gICAgbGV0IHtuYW1lOiBuZXdOYW1lLCB2YWx1ZTogbmV3VmFsdWV9ID0gYXR0cmlidXRlVHJhbnNmb3JtZXJzLnJlZHVjZSgoY2FycnksIHRyYW5zZm9ybSkgPT4ge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybShjYXJyeSk7XG4gICAgfSwge25hbWUsIHZhbHVlfSk7XG4gICAgaWYgKG5ld05hbWUgIT09IG5hbWUpXG4gICAgICBjYWxsYmFjayhuZXdOYW1lLCBuYW1lKTtcbiAgICByZXR1cm4ge25hbWU6IG5ld05hbWUsIHZhbHVlOiBuZXdWYWx1ZX07XG4gIH07XG59XG52YXIgYXR0cmlidXRlVHJhbnNmb3JtZXJzID0gW107XG5mdW5jdGlvbiBtYXBBdHRyaWJ1dGVzKGNhbGxiYWNrKSB7XG4gIGF0dHJpYnV0ZVRyYW5zZm9ybWVycy5wdXNoKGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIG91dE5vbkFscGluZUF0dHJpYnV0ZXMoe25hbWV9KSB7XG4gIHJldHVybiBhbHBpbmVBdHRyaWJ1dGVSZWdleCgpLnRlc3QobmFtZSk7XG59XG52YXIgYWxwaW5lQXR0cmlidXRlUmVnZXggPSAoKSA9PiBuZXcgUmVnRXhwKGBeJHtwcmVmaXhBc1N0cmluZ30oW146Xi5dKylcXFxcYmApO1xuZnVuY3Rpb24gdG9QYXJzZWREaXJlY3RpdmVzKHRyYW5zZm9ybWVkQXR0cmlidXRlTWFwLCBvcmlnaW5hbEF0dHJpYnV0ZU92ZXJyaWRlKSB7XG4gIHJldHVybiAoe25hbWUsIHZhbHVlfSkgPT4ge1xuICAgIGxldCB0eXBlTWF0Y2ggPSBuYW1lLm1hdGNoKGFscGluZUF0dHJpYnV0ZVJlZ2V4KCkpO1xuICAgIGxldCB2YWx1ZU1hdGNoID0gbmFtZS5tYXRjaCgvOihbYS16QS1aMC05XFwtOl0rKS8pO1xuICAgIGxldCBtb2RpZmllcnMgPSBuYW1lLm1hdGNoKC9cXC5bXi5cXF1dKyg/PVteXFxdXSokKS9nKSB8fCBbXTtcbiAgICBsZXQgb3JpZ2luYWwgPSBvcmlnaW5hbEF0dHJpYnV0ZU92ZXJyaWRlIHx8IHRyYW5zZm9ybWVkQXR0cmlidXRlTWFwW25hbWVdIHx8IG5hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHR5cGVNYXRjaCA/IHR5cGVNYXRjaFsxXSA6IG51bGwsXG4gICAgICB2YWx1ZTogdmFsdWVNYXRjaCA/IHZhbHVlTWF0Y2hbMV0gOiBudWxsLFxuICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnMubWFwKChpKSA9PiBpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKSxcbiAgICAgIGV4cHJlc3Npb246IHZhbHVlLFxuICAgICAgb3JpZ2luYWxcbiAgICB9O1xuICB9O1xufVxudmFyIERFRkFVTFQgPSBcIkRFRkFVTFRcIjtcbnZhciBkaXJlY3RpdmVPcmRlciA9IFtcbiAgXCJpZ25vcmVcIixcbiAgXCJyZWZcIixcbiAgXCJkYXRhXCIsXG4gIFwiYmluZFwiLFxuICBcImluaXRcIixcbiAgXCJmb3JcIixcbiAgXCJtb2RlbFwiLFxuICBcInRyYW5zaXRpb25cIixcbiAgXCJzaG93XCIsXG4gIFwiaWZcIixcbiAgREVGQVVMVCxcbiAgXCJlbGVtZW50XCJcbl07XG5mdW5jdGlvbiBieVByaW9yaXR5KGEsIGIpIHtcbiAgbGV0IHR5cGVBID0gZGlyZWN0aXZlT3JkZXIuaW5kZXhPZihhLnR5cGUpID09PSAtMSA/IERFRkFVTFQgOiBhLnR5cGU7XG4gIGxldCB0eXBlQiA9IGRpcmVjdGl2ZU9yZGVyLmluZGV4T2YoYi50eXBlKSA9PT0gLTEgPyBERUZBVUxUIDogYi50eXBlO1xuICByZXR1cm4gZGlyZWN0aXZlT3JkZXIuaW5kZXhPZih0eXBlQSkgLSBkaXJlY3RpdmVPcmRlci5pbmRleE9mKHR5cGVCKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL2Rpc3BhdGNoLmpzXG5mdW5jdGlvbiBkaXNwYXRjaChlbCwgbmFtZSwgZGV0YWlsID0ge30pIHtcbiAgZWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQobmFtZSwge1xuICAgIGRldGFpbCxcbiAgICBidWJibGVzOiB0cnVlLFxuICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgIGNhbmNlbGFibGU6IHRydWVcbiAgfSkpO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbmV4dFRpY2suanNcbnZhciB0aWNrU3RhY2sgPSBbXTtcbnZhciBpc0hvbGRpbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIG5leHRUaWNrKGNhbGxiYWNrKSB7XG4gIHRpY2tTdGFjay5wdXNoKGNhbGxiYWNrKTtcbiAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgIGlzSG9sZGluZyB8fCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlbGVhc2VOZXh0VGlja3MoKTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZWxlYXNlTmV4dFRpY2tzKCkge1xuICBpc0hvbGRpbmcgPSBmYWxzZTtcbiAgd2hpbGUgKHRpY2tTdGFjay5sZW5ndGgpXG4gICAgdGlja1N0YWNrLnNoaWZ0KCkoKTtcbn1cbmZ1bmN0aW9uIGhvbGROZXh0VGlja3MoKSB7XG4gIGlzSG9sZGluZyA9IHRydWU7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy93YWxrLmpzXG5mdW5jdGlvbiB3YWxrKGVsLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09IFwiZnVuY3Rpb25cIiAmJiBlbCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICBBcnJheS5mcm9tKGVsLmNoaWxkcmVuKS5mb3JFYWNoKChlbDIpID0+IHdhbGsoZWwyLCBjYWxsYmFjaykpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc2tpcCA9IGZhbHNlO1xuICBjYWxsYmFjayhlbCwgKCkgPT4gc2tpcCA9IHRydWUpO1xuICBpZiAoc2tpcClcbiAgICByZXR1cm47XG4gIGxldCBub2RlID0gZWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgd2Fsayhub2RlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgIG5vZGUgPSBub2RlLm5leHRFbGVtZW50U2libGluZztcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvd2Fybi5qc1xuZnVuY3Rpb24gd2FybihtZXNzYWdlLCAuLi5hcmdzKSB7XG4gIGNvbnNvbGUud2FybihgQWxwaW5lIFdhcm5pbmc6ICR7bWVzc2FnZX1gLCAuLi5hcmdzKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2xpZmVjeWNsZS5qc1xuZnVuY3Rpb24gc3RhcnQoKSB7XG4gIGlmICghZG9jdW1lbnQuYm9keSlcbiAgICB3YXJuKFwiVW5hYmxlIHRvIGluaXRpYWxpemUuIFRyeWluZyB0byBsb2FkIEFscGluZSBiZWZvcmUgYDxib2R5PmAgaXMgYXZhaWxhYmxlLiBEaWQgeW91IGZvcmdldCB0byBhZGQgYGRlZmVyYCBpbiBBbHBpbmUncyBgPHNjcmlwdD5gIHRhZz9cIik7XG4gIGRpc3BhdGNoKGRvY3VtZW50LCBcImFscGluZTppbml0XCIpO1xuICBkaXNwYXRjaChkb2N1bWVudCwgXCJhbHBpbmU6aW5pdGlhbGl6aW5nXCIpO1xuICBzdGFydE9ic2VydmluZ011dGF0aW9ucygpO1xuICBvbkVsQWRkZWQoKGVsKSA9PiBpbml0VHJlZShlbCwgd2FsaykpO1xuICBvbkVsUmVtb3ZlZCgoZWwpID0+IG5leHRUaWNrKCgpID0+IGRlc3Ryb3lUcmVlKGVsKSkpO1xuICBvbkF0dHJpYnV0ZXNBZGRlZCgoZWwsIGF0dHJzKSA9PiB7XG4gICAgZGlyZWN0aXZlcyhlbCwgYXR0cnMpLmZvckVhY2goKGhhbmRsZSkgPT4gaGFuZGxlKCkpO1xuICB9KTtcbiAgbGV0IG91dE5lc3RlZENvbXBvbmVudHMgPSAoZWwpID0+ICFjbG9zZXN0Um9vdChlbC5wYXJlbnRFbGVtZW50LCB0cnVlKTtcbiAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGFsbFNlbGVjdG9ycygpKSkuZmlsdGVyKG91dE5lc3RlZENvbXBvbmVudHMpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgaW5pdFRyZWUoZWwpO1xuICB9KTtcbiAgZGlzcGF0Y2goZG9jdW1lbnQsIFwiYWxwaW5lOmluaXRpYWxpemVkXCIpO1xufVxudmFyIHJvb3RTZWxlY3RvckNhbGxiYWNrcyA9IFtdO1xudmFyIGluaXRTZWxlY3RvckNhbGxiYWNrcyA9IFtdO1xuZnVuY3Rpb24gcm9vdFNlbGVjdG9ycygpIHtcbiAgcmV0dXJuIHJvb3RTZWxlY3RvckNhbGxiYWNrcy5tYXAoKGZuKSA9PiBmbigpKTtcbn1cbmZ1bmN0aW9uIGFsbFNlbGVjdG9ycygpIHtcbiAgcmV0dXJuIHJvb3RTZWxlY3RvckNhbGxiYWNrcy5jb25jYXQoaW5pdFNlbGVjdG9yQ2FsbGJhY2tzKS5tYXAoKGZuKSA9PiBmbigpKTtcbn1cbmZ1bmN0aW9uIGFkZFJvb3RTZWxlY3RvcihzZWxlY3RvckNhbGxiYWNrKSB7XG4gIHJvb3RTZWxlY3RvckNhbGxiYWNrcy5wdXNoKHNlbGVjdG9yQ2FsbGJhY2spO1xufVxuZnVuY3Rpb24gYWRkSW5pdFNlbGVjdG9yKHNlbGVjdG9yQ2FsbGJhY2spIHtcbiAgaW5pdFNlbGVjdG9yQ2FsbGJhY2tzLnB1c2goc2VsZWN0b3JDYWxsYmFjayk7XG59XG5mdW5jdGlvbiBjbG9zZXN0Um9vdChlbCwgaW5jbHVkZUluaXRTZWxlY3RvcnMgPSBmYWxzZSkge1xuICBpZiAoIWVsKVxuICAgIHJldHVybjtcbiAgY29uc3Qgc2VsZWN0b3JzID0gaW5jbHVkZUluaXRTZWxlY3RvcnMgPyBhbGxTZWxlY3RvcnMoKSA6IHJvb3RTZWxlY3RvcnMoKTtcbiAgaWYgKHNlbGVjdG9ycy5zb21lKChzZWxlY3RvcikgPT4gZWwubWF0Y2hlcyhzZWxlY3RvcikpKVxuICAgIHJldHVybiBlbDtcbiAgaWYgKCFlbC5wYXJlbnRFbGVtZW50KVxuICAgIHJldHVybjtcbiAgcmV0dXJuIGNsb3Nlc3RSb290KGVsLnBhcmVudEVsZW1lbnQsIGluY2x1ZGVJbml0U2VsZWN0b3JzKTtcbn1cbmZ1bmN0aW9uIGlzUm9vdChlbCkge1xuICByZXR1cm4gcm9vdFNlbGVjdG9ycygpLnNvbWUoKHNlbGVjdG9yKSA9PiBlbC5tYXRjaGVzKHNlbGVjdG9yKSk7XG59XG5mdW5jdGlvbiBpbml0VHJlZShlbCwgd2Fsa2VyID0gd2Fsaykge1xuICBkZWZlckhhbmRsaW5nRGlyZWN0aXZlcygoKSA9PiB7XG4gICAgd2Fsa2VyKGVsLCAoZWwyLCBza2lwKSA9PiB7XG4gICAgICBkaXJlY3RpdmVzKGVsMiwgZWwyLmF0dHJpYnV0ZXMpLmZvckVhY2goKGhhbmRsZSkgPT4gaGFuZGxlKCkpO1xuICAgICAgZWwyLl94X2lnbm9yZSAmJiBza2lwKCk7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZGVzdHJveVRyZWUocm9vdCkge1xuICB3YWxrKHJvb3QsIChlbCkgPT4gY2xlYW51cEF0dHJpYnV0ZXMoZWwpKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL2NsYXNzZXMuanNcbmZ1bmN0aW9uIHNldENsYXNzZXMoZWwsIHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzZXRDbGFzc2VzRnJvbVN0cmluZyhlbCwgdmFsdWUuam9pbihcIiBcIikpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzZXRDbGFzc2VzRnJvbU9iamVjdChlbCwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHNldENsYXNzZXMoZWwsIHZhbHVlKCkpO1xuICB9XG4gIHJldHVybiBzZXRDbGFzc2VzRnJvbVN0cmluZyhlbCwgdmFsdWUpO1xufVxuZnVuY3Rpb24gc2V0Q2xhc3Nlc0Zyb21TdHJpbmcoZWwsIGNsYXNzU3RyaW5nKSB7XG4gIGxldCBzcGxpdCA9IChjbGFzc1N0cmluZzIpID0+IGNsYXNzU3RyaW5nMi5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pO1xuICBsZXQgbWlzc2luZ0NsYXNzZXMgPSAoY2xhc3NTdHJpbmcyKSA9PiBjbGFzc1N0cmluZzIuc3BsaXQoXCIgXCIpLmZpbHRlcigoaSkgPT4gIWVsLmNsYXNzTGlzdC5jb250YWlucyhpKSkuZmlsdGVyKEJvb2xlYW4pO1xuICBsZXQgYWRkQ2xhc3Nlc0FuZFJldHVyblVuZG8gPSAoY2xhc3NlcykgPT4ge1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3Nlcyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3Nlcyk7XG4gICAgfTtcbiAgfTtcbiAgY2xhc3NTdHJpbmcgPSBjbGFzc1N0cmluZyA9PT0gdHJ1ZSA/IGNsYXNzU3RyaW5nID0gXCJcIiA6IGNsYXNzU3RyaW5nIHx8IFwiXCI7XG4gIHJldHVybiBhZGRDbGFzc2VzQW5kUmV0dXJuVW5kbyhtaXNzaW5nQ2xhc3NlcyhjbGFzc1N0cmluZykpO1xufVxuZnVuY3Rpb24gc2V0Q2xhc3Nlc0Zyb21PYmplY3QoZWwsIGNsYXNzT2JqZWN0KSB7XG4gIGxldCBzcGxpdCA9IChjbGFzc1N0cmluZykgPT4gY2xhc3NTdHJpbmcuc3BsaXQoXCIgXCIpLmZpbHRlcihCb29sZWFuKTtcbiAgbGV0IGZvckFkZCA9IE9iamVjdC5lbnRyaWVzKGNsYXNzT2JqZWN0KS5mbGF0TWFwKChbY2xhc3NTdHJpbmcsIGJvb2xdKSA9PiBib29sID8gc3BsaXQoY2xhc3NTdHJpbmcpIDogZmFsc2UpLmZpbHRlcihCb29sZWFuKTtcbiAgbGV0IGZvclJlbW92ZSA9IE9iamVjdC5lbnRyaWVzKGNsYXNzT2JqZWN0KS5mbGF0TWFwKChbY2xhc3NTdHJpbmcsIGJvb2xdKSA9PiAhYm9vbCA/IHNwbGl0KGNsYXNzU3RyaW5nKSA6IGZhbHNlKS5maWx0ZXIoQm9vbGVhbik7XG4gIGxldCBhZGRlZCA9IFtdO1xuICBsZXQgcmVtb3ZlZCA9IFtdO1xuICBmb3JSZW1vdmUuZm9yRWFjaCgoaSkgPT4ge1xuICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoaSkpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoaSk7XG4gICAgICByZW1vdmVkLnB1c2goaSk7XG4gICAgfVxuICB9KTtcbiAgZm9yQWRkLmZvckVhY2goKGkpID0+IHtcbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5jb250YWlucyhpKSkge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChpKTtcbiAgICAgIGFkZGVkLnB1c2goaSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICByZW1vdmVkLmZvckVhY2goKGkpID0+IGVsLmNsYXNzTGlzdC5hZGQoaSkpO1xuICAgIGFkZGVkLmZvckVhY2goKGkpID0+IGVsLmNsYXNzTGlzdC5yZW1vdmUoaSkpO1xuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvc3R5bGVzLmpzXG5mdW5jdGlvbiBzZXRTdHlsZXMoZWwsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc2V0U3R5bGVzRnJvbU9iamVjdChlbCwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBzZXRTdHlsZXNGcm9tU3RyaW5nKGVsLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRTdHlsZXNGcm9tT2JqZWN0KGVsLCB2YWx1ZSkge1xuICBsZXQgcHJldmlvdXNTdHlsZXMgPSB7fTtcbiAgT2JqZWN0LmVudHJpZXModmFsdWUpLmZvckVhY2goKFtrZXksIHZhbHVlMl0pID0+IHtcbiAgICBwcmV2aW91c1N0eWxlc1trZXldID0gZWwuc3R5bGVba2V5XTtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShrZWJhYkNhc2Uoa2V5KSwgdmFsdWUyKTtcbiAgfSk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmIChlbC5zdHlsZS5sZW5ndGggPT09IDApIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgc2V0U3R5bGVzKGVsLCBwcmV2aW91c1N0eWxlcyk7XG4gIH07XG59XG5mdW5jdGlvbiBzZXRTdHlsZXNGcm9tU3RyaW5nKGVsLCB2YWx1ZSkge1xuICBsZXQgY2FjaGUgPSBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCB2YWx1ZSk7XG4gIGVsLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIHZhbHVlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBjYWNoZSk7XG4gIH07XG59XG5mdW5jdGlvbiBrZWJhYkNhc2Uoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9vbmNlLmpzXG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrLCBmYWxsYmFjayA9ICgpID0+IHtcbn0pIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC10cmFuc2l0aW9uLmpzXG5kaXJlY3RpdmUoXCJ0cmFuc2l0aW9uXCIsIChlbCwge3ZhbHVlLCBtb2RpZmllcnMsIGV4cHJlc3Npb259LCB7ZXZhbHVhdGU6IGV2YWx1YXRlMn0pID0+IHtcbiAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSBcImZ1bmN0aW9uXCIpXG4gICAgZXhwcmVzc2lvbiA9IGV2YWx1YXRlMihleHByZXNzaW9uKTtcbiAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgcmVnaXN0ZXJUcmFuc2l0aW9uc0Zyb21IZWxwZXIoZWwsIG1vZGlmaWVycywgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJlZ2lzdGVyVHJhbnNpdGlvbnNGcm9tQ2xhc3NTdHJpbmcoZWwsIGV4cHJlc3Npb24sIHZhbHVlKTtcbiAgfVxufSk7XG5mdW5jdGlvbiByZWdpc3RlclRyYW5zaXRpb25zRnJvbUNsYXNzU3RyaW5nKGVsLCBjbGFzc1N0cmluZywgc3RhZ2UpIHtcbiAgcmVnaXN0ZXJUcmFuc2l0aW9uT2JqZWN0KGVsLCBzZXRDbGFzc2VzLCBcIlwiKTtcbiAgbGV0IGRpcmVjdGl2ZVN0b3JhZ2VNYXAgPSB7XG4gICAgZW50ZXI6IChjbGFzc2VzKSA9PiB7XG4gICAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyLmR1cmluZyA9IGNsYXNzZXM7XG4gICAgfSxcbiAgICBcImVudGVyLXN0YXJ0XCI6IChjbGFzc2VzKSA9PiB7XG4gICAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyLnN0YXJ0ID0gY2xhc3NlcztcbiAgICB9LFxuICAgIFwiZW50ZXItZW5kXCI6IChjbGFzc2VzKSA9PiB7XG4gICAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyLmVuZCA9IGNsYXNzZXM7XG4gICAgfSxcbiAgICBsZWF2ZTogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuZHVyaW5nID0gY2xhc3NlcztcbiAgICB9LFxuICAgIFwibGVhdmUtc3RhcnRcIjogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuc3RhcnQgPSBjbGFzc2VzO1xuICAgIH0sXG4gICAgXCJsZWF2ZS1lbmRcIjogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuZW5kID0gY2xhc3NlcztcbiAgICB9XG4gIH07XG4gIGRpcmVjdGl2ZVN0b3JhZ2VNYXBbc3RhZ2VdKGNsYXNzU3RyaW5nKTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyVHJhbnNpdGlvbnNGcm9tSGVscGVyKGVsLCBtb2RpZmllcnMsIHN0YWdlKSB7XG4gIHJlZ2lzdGVyVHJhbnNpdGlvbk9iamVjdChlbCwgc2V0U3R5bGVzKTtcbiAgbGV0IGRvZXNudFNwZWNpZnkgPSAhbW9kaWZpZXJzLmluY2x1ZGVzKFwiaW5cIikgJiYgIW1vZGlmaWVycy5pbmNsdWRlcyhcIm91dFwiKSAmJiAhc3RhZ2U7XG4gIGxldCB0cmFuc2l0aW9uaW5nSW4gPSBkb2VzbnRTcGVjaWZ5IHx8IG1vZGlmaWVycy5pbmNsdWRlcyhcImluXCIpIHx8IFtcImVudGVyXCJdLmluY2x1ZGVzKHN0YWdlKTtcbiAgbGV0IHRyYW5zaXRpb25pbmdPdXQgPSBkb2VzbnRTcGVjaWZ5IHx8IG1vZGlmaWVycy5pbmNsdWRlcyhcIm91dFwiKSB8fCBbXCJsZWF2ZVwiXS5pbmNsdWRlcyhzdGFnZSk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJpblwiKSAmJiAhZG9lc250U3BlY2lmeSkge1xuICAgIG1vZGlmaWVycyA9IG1vZGlmaWVycy5maWx0ZXIoKGksIGluZGV4KSA9PiBpbmRleCA8IG1vZGlmaWVycy5pbmRleE9mKFwib3V0XCIpKTtcbiAgfVxuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwib3V0XCIpICYmICFkb2VzbnRTcGVjaWZ5KSB7XG4gICAgbW9kaWZpZXJzID0gbW9kaWZpZXJzLmZpbHRlcigoaSwgaW5kZXgpID0+IGluZGV4ID4gbW9kaWZpZXJzLmluZGV4T2YoXCJvdXRcIikpO1xuICB9XG4gIGxldCB3YW50c0FsbCA9ICFtb2RpZmllcnMuaW5jbHVkZXMoXCJvcGFjaXR5XCIpICYmICFtb2RpZmllcnMuaW5jbHVkZXMoXCJzY2FsZVwiKTtcbiAgbGV0IHdhbnRzT3BhY2l0eSA9IHdhbnRzQWxsIHx8IG1vZGlmaWVycy5pbmNsdWRlcyhcIm9wYWNpdHlcIik7XG4gIGxldCB3YW50c1NjYWxlID0gd2FudHNBbGwgfHwgbW9kaWZpZXJzLmluY2x1ZGVzKFwic2NhbGVcIik7XG4gIGxldCBvcGFjaXR5VmFsdWUgPSB3YW50c09wYWNpdHkgPyAwIDogMTtcbiAgbGV0IHNjYWxlVmFsdWUgPSB3YW50c1NjYWxlID8gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwic2NhbGVcIiwgOTUpIC8gMTAwIDogMTtcbiAgbGV0IGRlbGF5ID0gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwiZGVsYXlcIiwgMCk7XG4gIGxldCBvcmlnaW4gPSBtb2RpZmllclZhbHVlKG1vZGlmaWVycywgXCJvcmlnaW5cIiwgXCJjZW50ZXJcIik7XG4gIGxldCBwcm9wZXJ0eSA9IFwib3BhY2l0eSwgdHJhbnNmb3JtXCI7XG4gIGxldCBkdXJhdGlvbkluID0gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwiZHVyYXRpb25cIiwgMTUwKSAvIDFlMztcbiAgbGV0IGR1cmF0aW9uT3V0ID0gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwiZHVyYXRpb25cIiwgNzUpIC8gMWUzO1xuICBsZXQgZWFzaW5nID0gYGN1YmljLWJlemllcigwLjQsIDAuMCwgMC4yLCAxKWA7XG4gIGlmICh0cmFuc2l0aW9uaW5nSW4pIHtcbiAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyLmR1cmluZyA9IHtcbiAgICAgIHRyYW5zZm9ybU9yaWdpbjogb3JpZ2luLFxuICAgICAgdHJhbnNpdGlvbkRlbGF5OiBkZWxheSxcbiAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogcHJvcGVydHksXG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGAke2R1cmF0aW9uSW59c2AsXG4gICAgICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGVhc2luZ1xuICAgIH07XG4gICAgZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5zdGFydCA9IHtcbiAgICAgIG9wYWNpdHk6IG9wYWNpdHlWYWx1ZSxcbiAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7c2NhbGVWYWx1ZX0pYFxuICAgIH07XG4gICAgZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5lbmQgPSB7XG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoMSlgXG4gICAgfTtcbiAgfVxuICBpZiAodHJhbnNpdGlvbmluZ091dCkge1xuICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuZHVyaW5nID0ge1xuICAgICAgdHJhbnNmb3JtT3JpZ2luOiBvcmlnaW4sXG4gICAgICB0cmFuc2l0aW9uRGVsYXk6IGRlbGF5LFxuICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiBwcm9wZXJ0eSxcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogYCR7ZHVyYXRpb25PdXR9c2AsXG4gICAgICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGVhc2luZ1xuICAgIH07XG4gICAgZWwuX3hfdHJhbnNpdGlvbi5sZWF2ZS5zdGFydCA9IHtcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICB0cmFuc2Zvcm06IGBzY2FsZSgxKWBcbiAgICB9O1xuICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuZW5kID0ge1xuICAgICAgb3BhY2l0eTogb3BhY2l0eVZhbHVlLFxuICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoJHtzY2FsZVZhbHVlfSlgXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJUcmFuc2l0aW9uT2JqZWN0KGVsLCBzZXRGdW5jdGlvbiwgZGVmYXVsdFZhbHVlID0ge30pIHtcbiAgaWYgKCFlbC5feF90cmFuc2l0aW9uKVxuICAgIGVsLl94X3RyYW5zaXRpb24gPSB7XG4gICAgICBlbnRlcjoge2R1cmluZzogZGVmYXVsdFZhbHVlLCBzdGFydDogZGVmYXVsdFZhbHVlLCBlbmQ6IGRlZmF1bHRWYWx1ZX0sXG4gICAgICBsZWF2ZToge2R1cmluZzogZGVmYXVsdFZhbHVlLCBzdGFydDogZGVmYXVsdFZhbHVlLCBlbmQ6IGRlZmF1bHRWYWx1ZX0sXG4gICAgICBpbihiZWZvcmUgPSAoKSA9PiB7XG4gICAgICB9LCBhZnRlciA9ICgpID0+IHtcbiAgICAgIH0pIHtcbiAgICAgICAgdHJhbnNpdGlvbihlbCwgc2V0RnVuY3Rpb24sIHtcbiAgICAgICAgICBkdXJpbmc6IHRoaXMuZW50ZXIuZHVyaW5nLFxuICAgICAgICAgIHN0YXJ0OiB0aGlzLmVudGVyLnN0YXJ0LFxuICAgICAgICAgIGVuZDogdGhpcy5lbnRlci5lbmRcbiAgICAgICAgfSwgYmVmb3JlLCBhZnRlcik7XG4gICAgICB9LFxuICAgICAgb3V0KGJlZm9yZSA9ICgpID0+IHtcbiAgICAgIH0sIGFmdGVyID0gKCkgPT4ge1xuICAgICAgfSkge1xuICAgICAgICB0cmFuc2l0aW9uKGVsLCBzZXRGdW5jdGlvbiwge1xuICAgICAgICAgIGR1cmluZzogdGhpcy5sZWF2ZS5kdXJpbmcsXG4gICAgICAgICAgc3RhcnQ6IHRoaXMubGVhdmUuc3RhcnQsXG4gICAgICAgICAgZW5kOiB0aGlzLmxlYXZlLmVuZFxuICAgICAgICB9LCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgIH1cbiAgICB9O1xufVxud2luZG93LkVsZW1lbnQucHJvdG90eXBlLl94X3RvZ2dsZUFuZENhc2NhZGVXaXRoVHJhbnNpdGlvbnMgPSBmdW5jdGlvbihlbCwgdmFsdWUsIHNob3csIGhpZGUpIHtcbiAgbGV0IGNsaWNrQXdheUNvbXBhdGlibGVTaG93ID0gKCkgPT4ge1xuICAgIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJ2aXNpYmxlXCIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2hvdykgOiBzZXRUaW1lb3V0KHNob3cpO1xuICB9O1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoZWwuX3hfdHJhbnNpdGlvbiAmJiAoZWwuX3hfdHJhbnNpdGlvbi5lbnRlciB8fCBlbC5feF90cmFuc2l0aW9uLmxlYXZlKSkge1xuICAgICAgZWwuX3hfdHJhbnNpdGlvbi5lbnRlciAmJiAoT2JqZWN0LmVudHJpZXMoZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5kdXJpbmcpLmxlbmd0aCB8fCBPYmplY3QuZW50cmllcyhlbC5feF90cmFuc2l0aW9uLmVudGVyLnN0YXJ0KS5sZW5ndGggfHwgT2JqZWN0LmVudHJpZXMoZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5lbmQpLmxlbmd0aCkgPyBlbC5feF90cmFuc2l0aW9uLmluKHNob3cpIDogY2xpY2tBd2F5Q29tcGF0aWJsZVNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuX3hfdHJhbnNpdGlvbiA/IGVsLl94X3RyYW5zaXRpb24uaW4oc2hvdykgOiBjbGlja0F3YXlDb21wYXRpYmxlU2hvdygpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgZWwuX3hfaGlkZVByb21pc2UgPSBlbC5feF90cmFuc2l0aW9uID8gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGVsLl94X3RyYW5zaXRpb24ub3V0KCgpID0+IHtcbiAgICB9LCAoKSA9PiByZXNvbHZlKGhpZGUpKTtcbiAgICBlbC5feF90cmFuc2l0aW9uaW5nLmJlZm9yZUNhbmNlbCgoKSA9PiByZWplY3Qoe2lzRnJvbUNhbmNlbGxlZFRyYW5zaXRpb246IHRydWV9KSk7XG4gIH0pIDogUHJvbWlzZS5yZXNvbHZlKGhpZGUpO1xuICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgbGV0IGNsb3Nlc3QgPSBjbG9zZXN0SGlkZShlbCk7XG4gICAgaWYgKGNsb3Nlc3QpIHtcbiAgICAgIGlmICghY2xvc2VzdC5feF9oaWRlQ2hpbGRyZW4pXG4gICAgICAgIGNsb3Nlc3QuX3hfaGlkZUNoaWxkcmVuID0gW107XG4gICAgICBjbG9zZXN0Ll94X2hpZGVDaGlsZHJlbi5wdXNoKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBsZXQgaGlkZUFmdGVyQ2hpbGRyZW4gPSAoZWwyKSA9PiB7XG4gICAgICAgICAgbGV0IGNhcnJ5ID0gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgZWwyLl94X2hpZGVQcm9taXNlLFxuICAgICAgICAgICAgLi4uKGVsMi5feF9oaWRlQ2hpbGRyZW4gfHwgW10pLm1hcChoaWRlQWZ0ZXJDaGlsZHJlbilcbiAgICAgICAgICBdKS50aGVuKChbaV0pID0+IGkoKSk7XG4gICAgICAgICAgZGVsZXRlIGVsMi5feF9oaWRlUHJvbWlzZTtcbiAgICAgICAgICBkZWxldGUgZWwyLl94X2hpZGVDaGlsZHJlbjtcbiAgICAgICAgICByZXR1cm4gY2Fycnk7XG4gICAgICAgIH07XG4gICAgICAgIGhpZGVBZnRlckNoaWxkcmVuKGVsKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIGlmICghZS5pc0Zyb21DYW5jZWxsZWRUcmFuc2l0aW9uKVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcbmZ1bmN0aW9uIGNsb3Nlc3RIaWRlKGVsKSB7XG4gIGxldCBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICBpZiAoIXBhcmVudClcbiAgICByZXR1cm47XG4gIHJldHVybiBwYXJlbnQuX3hfaGlkZVByb21pc2UgPyBwYXJlbnQgOiBjbG9zZXN0SGlkZShwYXJlbnQpO1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbihlbCwgc2V0RnVuY3Rpb24sIHtkdXJpbmcsIHN0YXJ0OiBzdGFydDIsIGVuZH0gPSB7fSwgYmVmb3JlID0gKCkgPT4ge1xufSwgYWZ0ZXIgPSAoKSA9PiB7XG59KSB7XG4gIGlmIChlbC5feF90cmFuc2l0aW9uaW5nKVxuICAgIGVsLl94X3RyYW5zaXRpb25pbmcuY2FuY2VsKCk7XG4gIGlmIChPYmplY3Qua2V5cyhkdXJpbmcpLmxlbmd0aCA9PT0gMCAmJiBPYmplY3Qua2V5cyhzdGFydDIpLmxlbmd0aCA9PT0gMCAmJiBPYmplY3Qua2V5cyhlbmQpLmxlbmd0aCA9PT0gMCkge1xuICAgIGJlZm9yZSgpO1xuICAgIGFmdGVyKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCB1bmRvU3RhcnQsIHVuZG9EdXJpbmcsIHVuZG9FbmQ7XG4gIHBlcmZvcm1UcmFuc2l0aW9uKGVsLCB7XG4gICAgc3RhcnQoKSB7XG4gICAgICB1bmRvU3RhcnQgPSBzZXRGdW5jdGlvbihlbCwgc3RhcnQyKTtcbiAgICB9LFxuICAgIGR1cmluZygpIHtcbiAgICAgIHVuZG9EdXJpbmcgPSBzZXRGdW5jdGlvbihlbCwgZHVyaW5nKTtcbiAgICB9LFxuICAgIGJlZm9yZSxcbiAgICBlbmQoKSB7XG4gICAgICB1bmRvU3RhcnQoKTtcbiAgICAgIHVuZG9FbmQgPSBzZXRGdW5jdGlvbihlbCwgZW5kKTtcbiAgICB9LFxuICAgIGFmdGVyLFxuICAgIGNsZWFudXAoKSB7XG4gICAgICB1bmRvRHVyaW5nKCk7XG4gICAgICB1bmRvRW5kKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBlcmZvcm1UcmFuc2l0aW9uKGVsLCBzdGFnZXMpIHtcbiAgbGV0IGludGVycnVwdGVkLCByZWFjaGVkQmVmb3JlLCByZWFjaGVkRW5kO1xuICBsZXQgZmluaXNoID0gb25jZSgoKSA9PiB7XG4gICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgIGludGVycnVwdGVkID0gdHJ1ZTtcbiAgICAgIGlmICghcmVhY2hlZEJlZm9yZSlcbiAgICAgICAgc3RhZ2VzLmJlZm9yZSgpO1xuICAgICAgaWYgKCFyZWFjaGVkRW5kKSB7XG4gICAgICAgIHN0YWdlcy5lbmQoKTtcbiAgICAgICAgcmVsZWFzZU5leHRUaWNrcygpO1xuICAgICAgfVxuICAgICAgc3RhZ2VzLmFmdGVyKCk7XG4gICAgICBpZiAoZWwuaXNDb25uZWN0ZWQpXG4gICAgICAgIHN0YWdlcy5jbGVhbnVwKCk7XG4gICAgICBkZWxldGUgZWwuX3hfdHJhbnNpdGlvbmluZztcbiAgICB9KTtcbiAgfSk7XG4gIGVsLl94X3RyYW5zaXRpb25pbmcgPSB7XG4gICAgYmVmb3JlQ2FuY2VsczogW10sXG4gICAgYmVmb3JlQ2FuY2VsKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmJlZm9yZUNhbmNlbHMucHVzaChjYWxsYmFjayk7XG4gICAgfSxcbiAgICBjYW5jZWw6IG9uY2UoZnVuY3Rpb24oKSB7XG4gICAgICB3aGlsZSAodGhpcy5iZWZvcmVDYW5jZWxzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmJlZm9yZUNhbmNlbHMuc2hpZnQoKSgpO1xuICAgICAgfVxuICAgICAgO1xuICAgICAgZmluaXNoKCk7XG4gICAgfSksXG4gICAgZmluaXNoXG4gIH07XG4gIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgc3RhZ2VzLnN0YXJ0KCk7XG4gICAgc3RhZ2VzLmR1cmluZygpO1xuICB9KTtcbiAgaG9sZE5leHRUaWNrcygpO1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIGlmIChpbnRlcnJ1cHRlZClcbiAgICAgIHJldHVybjtcbiAgICBsZXQgZHVyYXRpb24gPSBOdW1iZXIoZ2V0Q29tcHV0ZWRTdHlsZShlbCkudHJhbnNpdGlvbkR1cmF0aW9uLnJlcGxhY2UoLywuKi8sIFwiXCIpLnJlcGxhY2UoXCJzXCIsIFwiXCIpKSAqIDFlMztcbiAgICBsZXQgZGVsYXkgPSBOdW1iZXIoZ2V0Q29tcHV0ZWRTdHlsZShlbCkudHJhbnNpdGlvbkRlbGF5LnJlcGxhY2UoLywuKi8sIFwiXCIpLnJlcGxhY2UoXCJzXCIsIFwiXCIpKSAqIDFlMztcbiAgICBpZiAoZHVyYXRpb24gPT09IDApXG4gICAgICBkdXJhdGlvbiA9IE51bWJlcihnZXRDb21wdXRlZFN0eWxlKGVsKS5hbmltYXRpb25EdXJhdGlvbi5yZXBsYWNlKFwic1wiLCBcIlwiKSkgKiAxZTM7XG4gICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgIHN0YWdlcy5iZWZvcmUoKTtcbiAgICB9KTtcbiAgICByZWFjaGVkQmVmb3JlID0gdHJ1ZTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgaWYgKGludGVycnVwdGVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgICBzdGFnZXMuZW5kKCk7XG4gICAgICB9KTtcbiAgICAgIHJlbGVhc2VOZXh0VGlja3MoKTtcbiAgICAgIHNldFRpbWVvdXQoZWwuX3hfdHJhbnNpdGlvbmluZy5maW5pc2gsIGR1cmF0aW9uICsgZGVsYXkpO1xuICAgICAgcmVhY2hlZEVuZCA9IHRydWU7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIGtleSwgZmFsbGJhY2spIHtcbiAgaWYgKG1vZGlmaWVycy5pbmRleE9mKGtleSkgPT09IC0xKVxuICAgIHJldHVybiBmYWxsYmFjaztcbiAgY29uc3QgcmF3VmFsdWUgPSBtb2RpZmllcnNbbW9kaWZpZXJzLmluZGV4T2Yoa2V5KSArIDFdO1xuICBpZiAoIXJhd1ZhbHVlKVxuICAgIHJldHVybiBmYWxsYmFjaztcbiAgaWYgKGtleSA9PT0gXCJzY2FsZVwiKSB7XG4gICAgaWYgKGlzTmFOKHJhd1ZhbHVlKSlcbiAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgfVxuICBpZiAoa2V5ID09PSBcImR1cmF0aW9uXCIpIHtcbiAgICBsZXQgbWF0Y2ggPSByYXdWYWx1ZS5tYXRjaCgvKFswLTldKyltcy8pO1xuICAgIGlmIChtYXRjaClcbiAgICAgIHJldHVybiBtYXRjaFsxXTtcbiAgfVxuICBpZiAoa2V5ID09PSBcIm9yaWdpblwiKSB7XG4gICAgaWYgKFtcInRvcFwiLCBcInJpZ2h0XCIsIFwibGVmdFwiLCBcImNlbnRlclwiLCBcImJvdHRvbVwiXS5pbmNsdWRlcyhtb2RpZmllcnNbbW9kaWZpZXJzLmluZGV4T2Yoa2V5KSArIDJdKSkge1xuICAgICAgcmV0dXJuIFtyYXdWYWx1ZSwgbW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKGtleSkgKyAyXV0uam9pbihcIiBcIik7XG4gICAgfVxuICB9XG4gIHJldHVybiByYXdWYWx1ZTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2Nsb25lLmpzXG52YXIgaXNDbG9uaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBza2lwRHVyaW5nQ2xvbmUoY2FsbGJhY2ssIGZhbGxiYWNrID0gKCkgPT4ge1xufSkge1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IGlzQ2xvbmluZyA/IGZhbGxiYWNrKC4uLmFyZ3MpIDogY2FsbGJhY2soLi4uYXJncyk7XG59XG5mdW5jdGlvbiBjbG9uZShvbGRFbCwgbmV3RWwpIHtcbiAgaWYgKCFuZXdFbC5feF9kYXRhU3RhY2spXG4gICAgbmV3RWwuX3hfZGF0YVN0YWNrID0gb2xkRWwuX3hfZGF0YVN0YWNrO1xuICBpc0Nsb25pbmcgPSB0cnVlO1xuICBkb250UmVnaXN0ZXJSZWFjdGl2ZVNpZGVFZmZlY3RzKCgpID0+IHtcbiAgICBjbG9uZVRyZWUobmV3RWwpO1xuICB9KTtcbiAgaXNDbG9uaW5nID0gZmFsc2U7XG59XG5mdW5jdGlvbiBjbG9uZVRyZWUoZWwpIHtcbiAgbGV0IGhhc1J1blRocm91Z2hGaXJzdEVsID0gZmFsc2U7XG4gIGxldCBzaGFsbG93V2Fsa2VyID0gKGVsMiwgY2FsbGJhY2spID0+IHtcbiAgICB3YWxrKGVsMiwgKGVsMywgc2tpcCkgPT4ge1xuICAgICAgaWYgKGhhc1J1blRocm91Z2hGaXJzdEVsICYmIGlzUm9vdChlbDMpKVxuICAgICAgICByZXR1cm4gc2tpcCgpO1xuICAgICAgaGFzUnVuVGhyb3VnaEZpcnN0RWwgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soZWwzLCBza2lwKTtcbiAgICB9KTtcbiAgfTtcbiAgaW5pdFRyZWUoZWwsIHNoYWxsb3dXYWxrZXIpO1xufVxuZnVuY3Rpb24gZG9udFJlZ2lzdGVyUmVhY3RpdmVTaWRlRWZmZWN0cyhjYWxsYmFjaykge1xuICBsZXQgY2FjaGUgPSBlZmZlY3Q7XG4gIG92ZXJyaWRlRWZmZWN0KChjYWxsYmFjazIsIGVsKSA9PiB7XG4gICAgbGV0IHN0b3JlZEVmZmVjdCA9IGNhY2hlKGNhbGxiYWNrMik7XG4gICAgcmVsZWFzZShzdG9yZWRFZmZlY3QpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgfTtcbiAgfSk7XG4gIGNhbGxiYWNrKCk7XG4gIG92ZXJyaWRlRWZmZWN0KGNhY2hlKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL2RlYm91bmNlLmpzXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0KSB7XG4gIHZhciB0aW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH07XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL3Rocm90dGxlLmpzXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCBsaW1pdCkge1xuICBsZXQgaW5UaHJvdHRsZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGxldCBjb250ZXh0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICBpZiAoIWluVGhyb3R0bGUpIHtcbiAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpblRocm90dGxlID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gaW5UaHJvdHRsZSA9IGZhbHNlLCBsaW1pdCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvcGx1Z2luLmpzXG5mdW5jdGlvbiBwbHVnaW4oY2FsbGJhY2spIHtcbiAgY2FsbGJhY2soYWxwaW5lX2RlZmF1bHQpO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvc3RvcmUuanNcbnZhciBzdG9yZXMgPSB7fTtcbnZhciBpc1JlYWN0aXZlID0gZmFsc2U7XG5mdW5jdGlvbiBzdG9yZShuYW1lLCB2YWx1ZSkge1xuICBpZiAoIWlzUmVhY3RpdmUpIHtcbiAgICBzdG9yZXMgPSByZWFjdGl2ZShzdG9yZXMpO1xuICAgIGlzUmVhY3RpdmUgPSB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHN0b3Jlc1tuYW1lXTtcbiAgfVxuICBzdG9yZXNbbmFtZV0gPSB2YWx1ZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eShcImluaXRcIikgJiYgdHlwZW9mIHZhbHVlLmluaXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHN0b3Jlc1tuYW1lXS5pbml0KCk7XG4gIH1cbiAgaW5pdEludGVyY2VwdG9ycyhzdG9yZXNbbmFtZV0pO1xufVxuZnVuY3Rpb24gZ2V0U3RvcmVzKCkge1xuICByZXR1cm4gc3RvcmVzO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGF0YXMuanNcbnZhciBkYXRhcyA9IHt9O1xuZnVuY3Rpb24gZGF0YShuYW1lLCBjYWxsYmFjaykge1xuICBkYXRhc1tuYW1lXSA9IGNhbGxiYWNrO1xufVxuZnVuY3Rpb24gaW5qZWN0RGF0YVByb3ZpZGVycyhvYmosIGNvbnRleHQpIHtcbiAgT2JqZWN0LmVudHJpZXMoZGF0YXMpLmZvckVhY2goKFtuYW1lLCBjYWxsYmFja10pID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5iaW5kKGNvbnRleHQpKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2JqO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvYWxwaW5lLmpzXG52YXIgQWxwaW5lID0ge1xuICBnZXQgcmVhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHJlYWN0aXZlO1xuICB9LFxuICBnZXQgcmVsZWFzZSgpIHtcbiAgICByZXR1cm4gcmVsZWFzZTtcbiAgfSxcbiAgZ2V0IGVmZmVjdCgpIHtcbiAgICByZXR1cm4gZWZmZWN0O1xuICB9LFxuICBnZXQgcmF3KCkge1xuICAgIHJldHVybiByYXc7XG4gIH0sXG4gIHZlcnNpb246IFwiMy41LjJcIixcbiAgZmx1c2hBbmRTdG9wRGVmZXJyaW5nTXV0YXRpb25zLFxuICBkaXNhYmxlRWZmZWN0U2NoZWR1bGluZyxcbiAgc2V0UmVhY3Rpdml0eUVuZ2luZSxcbiAgY2xvc2VzdERhdGFTdGFjayxcbiAgc2tpcER1cmluZ0Nsb25lLFxuICBhZGRSb290U2VsZWN0b3IsXG4gIGRlZmVyTXV0YXRpb25zLFxuICBtYXBBdHRyaWJ1dGVzLFxuICBldmFsdWF0ZUxhdGVyLFxuICBzZXRFdmFsdWF0b3IsXG4gIG1lcmdlUHJveGllcyxcbiAgY2xvc2VzdFJvb3QsXG4gIGludGVyY2VwdG9yLFxuICB0cmFuc2l0aW9uLFxuICBzZXRTdHlsZXMsXG4gIG11dGF0ZURvbSxcbiAgZGlyZWN0aXZlLFxuICB0aHJvdHRsZSxcbiAgZGVib3VuY2UsXG4gIGV2YWx1YXRlLFxuICBpbml0VHJlZSxcbiAgbmV4dFRpY2ssXG4gIHByZWZpeDogc2V0UHJlZml4LFxuICBwbHVnaW4sXG4gIG1hZ2ljLFxuICBzdG9yZSxcbiAgc3RhcnQsXG4gIGNsb25lLFxuICBkYXRhXG59O1xudmFyIGFscGluZV9kZWZhdWx0ID0gQWxwaW5lO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvaW5kZXguanNcbnZhciBpbXBvcnRfcmVhY3Rpdml0eTkgPSBfX3RvTW9kdWxlKHJlcXVpcmVfcmVhY3Rpdml0eSgpKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy8kbmV4dFRpY2suanNcbm1hZ2ljKFwibmV4dFRpY2tcIiwgKCkgPT4gbmV4dFRpY2spO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbWFnaWNzLyRkaXNwYXRjaC5qc1xubWFnaWMoXCJkaXNwYXRjaFwiLCAoZWwpID0+IGRpc3BhdGNoLmJpbmQoZGlzcGF0Y2gsIGVsKSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJHdhdGNoLmpzXG5tYWdpYyhcIndhdGNoXCIsIChlbCkgPT4gKGtleSwgY2FsbGJhY2spID0+IHtcbiAgbGV0IGV2YWx1YXRlMiA9IGV2YWx1YXRlTGF0ZXIoZWwsIGtleSk7XG4gIGxldCBmaXJzdFRpbWUgPSB0cnVlO1xuICBsZXQgb2xkVmFsdWU7XG4gIGVmZmVjdCgoKSA9PiBldmFsdWF0ZTIoKHZhbHVlKSA9PiB7XG4gICAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LmRhdGFzZXQudGhyb3dBd2F5ID0gdmFsdWU7XG4gICAgaWYgKCFmaXJzdFRpbWUpIHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgY2FsbGJhY2sodmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgb2xkVmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbGRWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgfSkpO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJHN0b3JlLmpzXG5tYWdpYyhcInN0b3JlXCIsIGdldFN0b3Jlcyk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJGRhdGEuanNcbm1hZ2ljKFwiZGF0YVwiLCAoZWwpID0+IHtcbiAgcmV0dXJuIG1lcmdlUHJveGllcyhjbG9zZXN0RGF0YVN0YWNrKGVsKSk7XG59KTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy8kcm9vdC5qc1xubWFnaWMoXCJyb290XCIsIChlbCkgPT4gY2xvc2VzdFJvb3QoZWwpKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy8kcmVmcy5qc1xubWFnaWMoXCJyZWZzXCIsIChlbCkgPT4ge1xuICBpZiAoZWwuX3hfcmVmc19wcm94eSlcbiAgICByZXR1cm4gZWwuX3hfcmVmc19wcm94eTtcbiAgZWwuX3hfcmVmc19wcm94eSA9IG1lcmdlUHJveGllcyhnZXRBcnJheU9mUmVmT2JqZWN0KGVsKSk7XG4gIHJldHVybiBlbC5feF9yZWZzX3Byb3h5O1xufSk7XG5mdW5jdGlvbiBnZXRBcnJheU9mUmVmT2JqZWN0KGVsKSB7XG4gIGxldCByZWZPYmplY3RzID0gW107XG4gIGxldCBjdXJyZW50RWwgPSBlbDtcbiAgd2hpbGUgKGN1cnJlbnRFbCkge1xuICAgIGlmIChjdXJyZW50RWwuX3hfcmVmcylcbiAgICAgIHJlZk9iamVjdHMucHVzaChjdXJyZW50RWwuX3hfcmVmcyk7XG4gICAgY3VycmVudEVsID0gY3VycmVudEVsLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIHJlZk9iamVjdHM7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJGVsLmpzXG5tYWdpYyhcImVsXCIsIChlbCkgPT4gZWwpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWlnbm9yZS5qc1xudmFyIGhhbmRsZXIgPSAoKSA9PiB7XG59O1xuaGFuZGxlci5pbmxpbmUgPSAoZWwsIHttb2RpZmllcnN9LCB7Y2xlYW51cH0pID0+IHtcbiAgbW9kaWZpZXJzLmluY2x1ZGVzKFwic2VsZlwiKSA/IGVsLl94X2lnbm9yZVNlbGYgPSB0cnVlIDogZWwuX3hfaWdub3JlID0gdHJ1ZTtcbiAgY2xlYW51cCgoKSA9PiB7XG4gICAgbW9kaWZpZXJzLmluY2x1ZGVzKFwic2VsZlwiKSA/IGRlbGV0ZSBlbC5feF9pZ25vcmVTZWxmIDogZGVsZXRlIGVsLl94X2lnbm9yZTtcbiAgfSk7XG59O1xuZGlyZWN0aXZlKFwiaWdub3JlXCIsIGhhbmRsZXIpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWVmZmVjdC5qc1xuZGlyZWN0aXZlKFwiZWZmZWN0XCIsIChlbCwge2V4cHJlc3Npb259LCB7ZWZmZWN0OiBlZmZlY3QzfSkgPT4gZWZmZWN0MyhldmFsdWF0ZUxhdGVyKGVsLCBleHByZXNzaW9uKSkpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvYmluZC5qc1xuZnVuY3Rpb24gYmluZChlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycyA9IFtdKSB7XG4gIGlmICghZWwuX3hfYmluZGluZ3MpXG4gICAgZWwuX3hfYmluZGluZ3MgPSByZWFjdGl2ZSh7fSk7XG4gIGVsLl94X2JpbmRpbmdzW25hbWVdID0gdmFsdWU7XG4gIG5hbWUgPSBtb2RpZmllcnMuaW5jbHVkZXMoXCJjYW1lbFwiKSA/IGNhbWVsQ2FzZShuYW1lKSA6IG5hbWU7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgYmluZElucHV0VmFsdWUoZWwsIHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgYmluZFN0eWxlcyhlbCwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICBiaW5kQ2xhc3NlcyhlbCwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJpbmRBdHRyaWJ1dGUoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5mdW5jdGlvbiBiaW5kSW5wdXRWYWx1ZShlbCwgdmFsdWUpIHtcbiAgaWYgKGVsLnR5cGUgPT09IFwicmFkaW9cIikge1xuICAgIGlmIChlbC5hdHRyaWJ1dGVzLnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIGVsLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGlmICh3aW5kb3cuZnJvbU1vZGVsKSB7XG4gICAgICBlbC5jaGVja2VkID0gY2hlY2tlZEF0dHJMb29zZUNvbXBhcmUoZWwudmFsdWUsIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZWwudHlwZSA9PT0gXCJjaGVja2JveFwiKSB7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICBlbC52YWx1ZSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoIU51bWJlci5pc0ludGVnZXIodmFsdWUpICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwiYm9vbGVhblwiICYmICFbbnVsbCwgdm9pZCAwXS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgIGVsLnZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSB2YWx1ZS5zb21lKCh2YWwpID0+IGNoZWNrZWRBdHRyTG9vc2VDb21wYXJlKHZhbCwgZWwudmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSAhIXZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChlbC50YWdOYW1lID09PSBcIlNFTEVDVFwiKSB7XG4gICAgdXBkYXRlU2VsZWN0KGVsLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVsLnZhbHVlID09PSB2YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBlbC52YWx1ZSA9IHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBiaW5kQ2xhc3NlcyhlbCwgdmFsdWUpIHtcbiAgaWYgKGVsLl94X3VuZG9BZGRlZENsYXNzZXMpXG4gICAgZWwuX3hfdW5kb0FkZGVkQ2xhc3NlcygpO1xuICBlbC5feF91bmRvQWRkZWRDbGFzc2VzID0gc2V0Q2xhc3NlcyhlbCwgdmFsdWUpO1xufVxuZnVuY3Rpb24gYmluZFN0eWxlcyhlbCwgdmFsdWUpIHtcbiAgaWYgKGVsLl94X3VuZG9BZGRlZFN0eWxlcylcbiAgICBlbC5feF91bmRvQWRkZWRTdHlsZXMoKTtcbiAgZWwuX3hfdW5kb0FkZGVkU3R5bGVzID0gc2V0U3R5bGVzKGVsLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBiaW5kQXR0cmlidXRlKGVsLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAoW251bGwsIHZvaWQgMCwgZmFsc2VdLmluY2x1ZGVzKHZhbHVlKSAmJiBhdHRyaWJ1dGVTaG91bGRudEJlUHJlc2VydmVkSWZGYWxzeShuYW1lKSkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNCb29sZWFuQXR0cihuYW1lKSlcbiAgICAgIHZhbHVlID0gbmFtZTtcbiAgICBzZXRJZkNoYW5nZWQoZWwsIG5hbWUsIHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0SWZDaGFuZ2VkKGVsLCBhdHRyTmFtZSwgdmFsdWUpIHtcbiAgaWYgKGVsLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkgIT0gdmFsdWUpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlU2VsZWN0KGVsLCB2YWx1ZSkge1xuICBjb25zdCBhcnJheVdyYXBwZWRWYWx1ZSA9IFtdLmNvbmNhdCh2YWx1ZSkubWFwKCh2YWx1ZTIpID0+IHtcbiAgICByZXR1cm4gdmFsdWUyICsgXCJcIjtcbiAgfSk7XG4gIEFycmF5LmZyb20oZWwub3B0aW9ucykuZm9yRWFjaCgob3B0aW9uKSA9PiB7XG4gICAgb3B0aW9uLnNlbGVjdGVkID0gYXJyYXlXcmFwcGVkVmFsdWUuaW5jbHVkZXMob3B0aW9uLnZhbHVlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjYW1lbENhc2Uoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oXFx3KS9nLCAobWF0Y2gsIGNoYXIpID0+IGNoYXIudG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBjaGVja2VkQXR0ckxvb3NlQ29tcGFyZSh2YWx1ZUEsIHZhbHVlQikge1xuICByZXR1cm4gdmFsdWVBID09IHZhbHVlQjtcbn1cbmZ1bmN0aW9uIGlzQm9vbGVhbkF0dHIoYXR0ck5hbWUpIHtcbiAgY29uc3QgYm9vbGVhbkF0dHJpYnV0ZXMgPSBbXG4gICAgXCJkaXNhYmxlZFwiLFxuICAgIFwiY2hlY2tlZFwiLFxuICAgIFwicmVxdWlyZWRcIixcbiAgICBcInJlYWRvbmx5XCIsXG4gICAgXCJoaWRkZW5cIixcbiAgICBcIm9wZW5cIixcbiAgICBcInNlbGVjdGVkXCIsXG4gICAgXCJhdXRvZm9jdXNcIixcbiAgICBcIml0ZW1zY29wZVwiLFxuICAgIFwibXVsdGlwbGVcIixcbiAgICBcIm5vdmFsaWRhdGVcIixcbiAgICBcImFsbG93ZnVsbHNjcmVlblwiLFxuICAgIFwiYWxsb3dwYXltZW50cmVxdWVzdFwiLFxuICAgIFwiZm9ybW5vdmFsaWRhdGVcIixcbiAgICBcImF1dG9wbGF5XCIsXG4gICAgXCJjb250cm9sc1wiLFxuICAgIFwibG9vcFwiLFxuICAgIFwibXV0ZWRcIixcbiAgICBcInBsYXlzaW5saW5lXCIsXG4gICAgXCJkZWZhdWx0XCIsXG4gICAgXCJpc21hcFwiLFxuICAgIFwicmV2ZXJzZWRcIixcbiAgICBcImFzeW5jXCIsXG4gICAgXCJkZWZlclwiLFxuICAgIFwibm9tb2R1bGVcIlxuICBdO1xuICByZXR1cm4gYm9vbGVhbkF0dHJpYnV0ZXMuaW5jbHVkZXMoYXR0ck5hbWUpO1xufVxuZnVuY3Rpb24gYXR0cmlidXRlU2hvdWxkbnRCZVByZXNlcnZlZElmRmFsc3kobmFtZSkge1xuICByZXR1cm4gIVtcImFyaWEtcHJlc3NlZFwiLCBcImFyaWEtY2hlY2tlZFwiLCBcImFyaWEtZXhwYW5kZWRcIl0uaW5jbHVkZXMobmFtZSk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9vbi5qc1xuZnVuY3Rpb24gb24oZWwsIGV2ZW50LCBtb2RpZmllcnMsIGNhbGxiYWNrKSB7XG4gIGxldCBsaXN0ZW5lclRhcmdldCA9IGVsO1xuICBsZXQgaGFuZGxlcjMgPSAoZSkgPT4gY2FsbGJhY2soZSk7XG4gIGxldCBvcHRpb25zID0ge307XG4gIGxldCB3cmFwSGFuZGxlciA9IChjYWxsYmFjazIsIHdyYXBwZXIpID0+IChlKSA9PiB3cmFwcGVyKGNhbGxiYWNrMiwgZSk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJkb3RcIikpXG4gICAgZXZlbnQgPSBkb3RTeW50YXgoZXZlbnQpO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiY2FtZWxcIikpXG4gICAgZXZlbnQgPSBjYW1lbENhc2UyKGV2ZW50KTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInBhc3NpdmVcIikpXG4gICAgb3B0aW9ucy5wYXNzaXZlID0gdHJ1ZTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcImNhcHR1cmVcIikpXG4gICAgb3B0aW9ucy5jYXB0dXJlID0gdHJ1ZTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcIndpbmRvd1wiKSlcbiAgICBsaXN0ZW5lclRhcmdldCA9IHdpbmRvdztcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcImRvY3VtZW50XCIpKVxuICAgIGxpc3RlbmVyVGFyZ2V0ID0gZG9jdW1lbnQ7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJwcmV2ZW50XCIpKVxuICAgIGhhbmRsZXIzID0gd3JhcEhhbmRsZXIoaGFuZGxlcjMsIChuZXh0LCBlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBuZXh0KGUpO1xuICAgIH0pO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwic3RvcFwiKSlcbiAgICBoYW5kbGVyMyA9IHdyYXBIYW5kbGVyKGhhbmRsZXIzLCAobmV4dCwgZSkgPT4ge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIG5leHQoZSk7XG4gICAgfSk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJzZWxmXCIpKVxuICAgIGhhbmRsZXIzID0gd3JhcEhhbmRsZXIoaGFuZGxlcjMsIChuZXh0LCBlKSA9PiB7XG4gICAgICBlLnRhcmdldCA9PT0gZWwgJiYgbmV4dChlKTtcbiAgICB9KTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcImF3YXlcIikgfHwgbW9kaWZpZXJzLmluY2x1ZGVzKFwib3V0c2lkZVwiKSkge1xuICAgIGxpc3RlbmVyVGFyZ2V0ID0gZG9jdW1lbnQ7XG4gICAgaGFuZGxlcjMgPSB3cmFwSGFuZGxlcihoYW5kbGVyMywgKG5leHQsIGUpID0+IHtcbiAgICAgIGlmIChlbC5jb250YWlucyhlLnRhcmdldCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChlbC5vZmZzZXRXaWR0aCA8IDEgJiYgZWwub2Zmc2V0SGVpZ2h0IDwgMSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKGVsLl94X2lzU2hvd24gPT09IGZhbHNlKVxuICAgICAgICByZXR1cm47XG4gICAgICBuZXh0KGUpO1xuICAgIH0pO1xuICB9XG4gIGhhbmRsZXIzID0gd3JhcEhhbmRsZXIoaGFuZGxlcjMsIChuZXh0LCBlKSA9PiB7XG4gICAgaWYgKGlzS2V5RXZlbnQoZXZlbnQpKSB7XG4gICAgICBpZiAoaXNMaXN0ZW5pbmdGb3JBU3BlY2lmaWNLZXlUaGF0SGFzbnRCZWVuUHJlc3NlZChlLCBtb2RpZmllcnMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgbmV4dChlKTtcbiAgfSk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJkZWJvdW5jZVwiKSkge1xuICAgIGxldCBuZXh0TW9kaWZpZXIgPSBtb2RpZmllcnNbbW9kaWZpZXJzLmluZGV4T2YoXCJkZWJvdW5jZVwiKSArIDFdIHx8IFwiaW52YWxpZC13YWl0XCI7XG4gICAgbGV0IHdhaXQgPSBpc051bWVyaWMobmV4dE1vZGlmaWVyLnNwbGl0KFwibXNcIilbMF0pID8gTnVtYmVyKG5leHRNb2RpZmllci5zcGxpdChcIm1zXCIpWzBdKSA6IDI1MDtcbiAgICBoYW5kbGVyMyA9IGRlYm91bmNlKGhhbmRsZXIzLCB3YWl0KTtcbiAgfVxuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwidGhyb3R0bGVcIikpIHtcbiAgICBsZXQgbmV4dE1vZGlmaWVyID0gbW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKFwidGhyb3R0bGVcIikgKyAxXSB8fCBcImludmFsaWQtd2FpdFwiO1xuICAgIGxldCB3YWl0ID0gaXNOdW1lcmljKG5leHRNb2RpZmllci5zcGxpdChcIm1zXCIpWzBdKSA/IE51bWJlcihuZXh0TW9kaWZpZXIuc3BsaXQoXCJtc1wiKVswXSkgOiAyNTA7XG4gICAgaGFuZGxlcjMgPSB0aHJvdHRsZShoYW5kbGVyMywgd2FpdCk7XG4gIH1cbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcIm9uY2VcIikpIHtcbiAgICBoYW5kbGVyMyA9IHdyYXBIYW5kbGVyKGhhbmRsZXIzLCAobmV4dCwgZSkgPT4ge1xuICAgICAgbmV4dChlKTtcbiAgICAgIGxpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIzLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICBsaXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyMywgb3B0aW9ucyk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcjMsIG9wdGlvbnMpO1xuICB9O1xufVxuZnVuY3Rpb24gZG90U3ludGF4KHN1YmplY3QpIHtcbiAgcmV0dXJuIHN1YmplY3QucmVwbGFjZSgvLS9nLCBcIi5cIik7XG59XG5mdW5jdGlvbiBjYW1lbENhc2UyKHN1YmplY3QpIHtcbiAgcmV0dXJuIHN1YmplY3QudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tKFxcdykvZywgKG1hdGNoLCBjaGFyKSA9PiBjaGFyLnRvVXBwZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gaXNOdW1lcmljKHN1YmplY3QpIHtcbiAgcmV0dXJuICFBcnJheS5pc0FycmF5KHN1YmplY3QpICYmICFpc05hTihzdWJqZWN0KTtcbn1cbmZ1bmN0aW9uIGtlYmFiQ2FzZTIoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxLSQyXCIpLnJlcGxhY2UoL1tfXFxzXS8sIFwiLVwiKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gaXNLZXlFdmVudChldmVudCkge1xuICByZXR1cm4gW1wia2V5ZG93blwiLCBcImtleXVwXCJdLmluY2x1ZGVzKGV2ZW50KTtcbn1cbmZ1bmN0aW9uIGlzTGlzdGVuaW5nRm9yQVNwZWNpZmljS2V5VGhhdEhhc250QmVlblByZXNzZWQoZSwgbW9kaWZpZXJzKSB7XG4gIGxldCBrZXlNb2RpZmllcnMgPSBtb2RpZmllcnMuZmlsdGVyKChpKSA9PiB7XG4gICAgcmV0dXJuICFbXCJ3aW5kb3dcIiwgXCJkb2N1bWVudFwiLCBcInByZXZlbnRcIiwgXCJzdG9wXCIsIFwib25jZVwiXS5pbmNsdWRlcyhpKTtcbiAgfSk7XG4gIGlmIChrZXlNb2RpZmllcnMuaW5jbHVkZXMoXCJkZWJvdW5jZVwiKSkge1xuICAgIGxldCBkZWJvdW5jZUluZGV4ID0ga2V5TW9kaWZpZXJzLmluZGV4T2YoXCJkZWJvdW5jZVwiKTtcbiAgICBrZXlNb2RpZmllcnMuc3BsaWNlKGRlYm91bmNlSW5kZXgsIGlzTnVtZXJpYygoa2V5TW9kaWZpZXJzW2RlYm91bmNlSW5kZXggKyAxXSB8fCBcImludmFsaWQtd2FpdFwiKS5zcGxpdChcIm1zXCIpWzBdKSA/IDIgOiAxKTtcbiAgfVxuICBpZiAoa2V5TW9kaWZpZXJzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChrZXlNb2RpZmllcnMubGVuZ3RoID09PSAxICYmIGtleVRvTW9kaWZpZXJzKGUua2V5KS5pbmNsdWRlcyhrZXlNb2RpZmllcnNbMF0pKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgc3lzdGVtS2V5TW9kaWZpZXJzID0gW1wiY3RybFwiLCBcInNoaWZ0XCIsIFwiYWx0XCIsIFwibWV0YVwiLCBcImNtZFwiLCBcInN1cGVyXCJdO1xuICBjb25zdCBzZWxlY3RlZFN5c3RlbUtleU1vZGlmaWVycyA9IHN5c3RlbUtleU1vZGlmaWVycy5maWx0ZXIoKG1vZGlmaWVyKSA9PiBrZXlNb2RpZmllcnMuaW5jbHVkZXMobW9kaWZpZXIpKTtcbiAga2V5TW9kaWZpZXJzID0ga2V5TW9kaWZpZXJzLmZpbHRlcigoaSkgPT4gIXNlbGVjdGVkU3lzdGVtS2V5TW9kaWZpZXJzLmluY2x1ZGVzKGkpKTtcbiAgaWYgKHNlbGVjdGVkU3lzdGVtS2V5TW9kaWZpZXJzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBhY3RpdmVseVByZXNzZWRLZXlNb2RpZmllcnMgPSBzZWxlY3RlZFN5c3RlbUtleU1vZGlmaWVycy5maWx0ZXIoKG1vZGlmaWVyKSA9PiB7XG4gICAgICBpZiAobW9kaWZpZXIgPT09IFwiY21kXCIgfHwgbW9kaWZpZXIgPT09IFwic3VwZXJcIilcbiAgICAgICAgbW9kaWZpZXIgPSBcIm1ldGFcIjtcbiAgICAgIHJldHVybiBlW2Ake21vZGlmaWVyfUtleWBdO1xuICAgIH0pO1xuICAgIGlmIChhY3RpdmVseVByZXNzZWRLZXlNb2RpZmllcnMubGVuZ3RoID09PSBzZWxlY3RlZFN5c3RlbUtleU1vZGlmaWVycy5sZW5ndGgpIHtcbiAgICAgIGlmIChrZXlUb01vZGlmaWVycyhlLmtleSkuaW5jbHVkZXMoa2V5TW9kaWZpZXJzWzBdKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGtleVRvTW9kaWZpZXJzKGtleSkge1xuICBpZiAoIWtleSlcbiAgICByZXR1cm4gW107XG4gIGtleSA9IGtlYmFiQ2FzZTIoa2V5KTtcbiAgbGV0IG1vZGlmaWVyVG9LZXlNYXAgPSB7XG4gICAgY3RybDogXCJjb250cm9sXCIsXG4gICAgc2xhc2g6IFwiL1wiLFxuICAgIHNwYWNlOiBcIi1cIixcbiAgICBzcGFjZWJhcjogXCItXCIsXG4gICAgY21kOiBcIm1ldGFcIixcbiAgICBlc2M6IFwiZXNjYXBlXCIsXG4gICAgdXA6IFwiYXJyb3ctdXBcIixcbiAgICBkb3duOiBcImFycm93LWRvd25cIixcbiAgICBsZWZ0OiBcImFycm93LWxlZnRcIixcbiAgICByaWdodDogXCJhcnJvdy1yaWdodFwiLFxuICAgIHBlcmlvZDogXCIuXCIsXG4gICAgZXF1YWw6IFwiPVwiXG4gIH07XG4gIG1vZGlmaWVyVG9LZXlNYXBba2V5XSA9IGtleTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1vZGlmaWVyVG9LZXlNYXApLm1hcCgobW9kaWZpZXIpID0+IHtcbiAgICBpZiAobW9kaWZpZXJUb0tleU1hcFttb2RpZmllcl0gPT09IGtleSlcbiAgICAgIHJldHVybiBtb2RpZmllcjtcbiAgfSkuZmlsdGVyKChtb2RpZmllcikgPT4gbW9kaWZpZXIpO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LW1vZGVsLmpzXG5kaXJlY3RpdmUoXCJtb2RlbFwiLCAoZWwsIHttb2RpZmllcnMsIGV4cHJlc3Npb259LCB7ZWZmZWN0OiBlZmZlY3QzLCBjbGVhbnVwfSkgPT4ge1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbik7XG4gIGxldCBhc3NpZ25tZW50RXhwcmVzc2lvbiA9IGAke2V4cHJlc3Npb259ID0gcmlnaHRTaWRlT2ZFeHByZXNzaW9uKCRldmVudCwgJHtleHByZXNzaW9ufSlgO1xuICBsZXQgZXZhbHVhdGVBc3NpZ25tZW50ID0gZXZhbHVhdGVMYXRlcihlbCwgYXNzaWdubWVudEV4cHJlc3Npb24pO1xuICB2YXIgZXZlbnQgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic2VsZWN0XCIgfHwgW1wiY2hlY2tib3hcIiwgXCJyYWRpb1wiXS5pbmNsdWRlcyhlbC50eXBlKSB8fCBtb2RpZmllcnMuaW5jbHVkZXMoXCJsYXp5XCIpID8gXCJjaGFuZ2VcIiA6IFwiaW5wdXRcIjtcbiAgbGV0IGFzc2lnbWVudEZ1bmN0aW9uID0gZ2VuZXJhdGVBc3NpZ25tZW50RnVuY3Rpb24oZWwsIG1vZGlmaWVycywgZXhwcmVzc2lvbik7XG4gIGxldCByZW1vdmVMaXN0ZW5lciA9IG9uKGVsLCBldmVudCwgbW9kaWZpZXJzLCAoZSkgPT4ge1xuICAgIGV2YWx1YXRlQXNzaWdubWVudCgoKSA9PiB7XG4gICAgfSwge3Njb3BlOiB7XG4gICAgICAkZXZlbnQ6IGUsXG4gICAgICByaWdodFNpZGVPZkV4cHJlc3Npb246IGFzc2lnbWVudEZ1bmN0aW9uXG4gICAgfX0pO1xuICB9KTtcbiAgY2xlYW51cCgoKSA9PiByZW1vdmVMaXN0ZW5lcigpKTtcbiAgbGV0IGV2YWx1YXRlU2V0TW9kZWwgPSBldmFsdWF0ZUxhdGVyKGVsLCBgJHtleHByZXNzaW9ufSA9IF9fcGxhY2Vob2xkZXJgKTtcbiAgZWwuX3hfbW9kZWwgPSB7XG4gICAgZ2V0KCkge1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIGV2YWx1YXRlMigodmFsdWUpID0+IHJlc3VsdCA9IHZhbHVlKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGV2YWx1YXRlU2V0TW9kZWwoKCkgPT4ge1xuICAgICAgfSwge3Njb3BlOiB7X19wbGFjZWhvbGRlcjogdmFsdWV9fSk7XG4gICAgfVxuICB9O1xuICBlbC5feF9mb3JjZU1vZGVsVXBkYXRlID0gKCkgPT4ge1xuICAgIGV2YWx1YXRlMigodmFsdWUpID0+IHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwICYmIGV4cHJlc3Npb24ubWF0Y2goL1xcLi8pKVxuICAgICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICB3aW5kb3cuZnJvbU1vZGVsID0gdHJ1ZTtcbiAgICAgIG11dGF0ZURvbSgoKSA9PiBiaW5kKGVsLCBcInZhbHVlXCIsIHZhbHVlKSk7XG4gICAgICBkZWxldGUgd2luZG93LmZyb21Nb2RlbDtcbiAgICB9KTtcbiAgfTtcbiAgZWZmZWN0MygoKSA9PiB7XG4gICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInVuaW50cnVzaXZlXCIpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuaXNTYW1lTm9kZShlbCkpXG4gICAgICByZXR1cm47XG4gICAgZWwuX3hfZm9yY2VNb2RlbFVwZGF0ZSgpO1xuICB9KTtcbn0pO1xuZnVuY3Rpb24gZ2VuZXJhdGVBc3NpZ25tZW50RnVuY3Rpb24oZWwsIG1vZGlmaWVycywgZXhwcmVzc2lvbikge1xuICBpZiAoZWwudHlwZSA9PT0gXCJyYWRpb1wiKSB7XG4gICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgIGlmICghZWwuaGFzQXR0cmlidXRlKFwibmFtZVwiKSlcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBleHByZXNzaW9uKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gKGV2ZW50LCBjdXJyZW50VmFsdWUpID0+IHtcbiAgICByZXR1cm4gbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEN1c3RvbUV2ZW50ICYmIGV2ZW50LmRldGFpbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBldmVudC5kZXRhaWwgfHwgZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChlbC50eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFZhbHVlKSkge1xuICAgICAgICAgIGxldCBuZXdWYWx1ZSA9IG1vZGlmaWVycy5pbmNsdWRlcyhcIm51bWJlclwiKSA/IHNhZmVQYXJzZU51bWJlcihldmVudC50YXJnZXQudmFsdWUpIDogZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgIHJldHVybiBldmVudC50YXJnZXQuY2hlY2tlZCA/IGN1cnJlbnRWYWx1ZS5jb25jYXQoW25ld1ZhbHVlXSkgOiBjdXJyZW50VmFsdWUuZmlsdGVyKChlbDIpID0+ICFjaGVja2VkQXR0ckxvb3NlQ29tcGFyZTIoZWwyLCBuZXdWYWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBldmVudC50YXJnZXQuY2hlY2tlZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic2VsZWN0XCIgJiYgZWwubXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVycy5pbmNsdWRlcyhcIm51bWJlclwiKSA/IEFycmF5LmZyb20oZXZlbnQudGFyZ2V0LnNlbGVjdGVkT3B0aW9ucykubWFwKChvcHRpb24pID0+IHtcbiAgICAgICAgICBsZXQgcmF3VmFsdWUgPSBvcHRpb24udmFsdWUgfHwgb3B0aW9uLnRleHQ7XG4gICAgICAgICAgcmV0dXJuIHNhZmVQYXJzZU51bWJlcihyYXdWYWx1ZSk7XG4gICAgICAgIH0pIDogQXJyYXkuZnJvbShldmVudC50YXJnZXQuc2VsZWN0ZWRPcHRpb25zKS5tYXAoKG9wdGlvbikgPT4ge1xuICAgICAgICAgIHJldHVybiBvcHRpb24udmFsdWUgfHwgb3B0aW9uLnRleHQ7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHJhd1ZhbHVlID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgICByZXR1cm4gbW9kaWZpZXJzLmluY2x1ZGVzKFwibnVtYmVyXCIpID8gc2FmZVBhcnNlTnVtYmVyKHJhd1ZhbHVlKSA6IG1vZGlmaWVycy5pbmNsdWRlcyhcInRyaW1cIikgPyByYXdWYWx1ZS50cmltKCkgOiByYXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNhZmVQYXJzZU51bWJlcihyYXdWYWx1ZSkge1xuICBsZXQgbnVtYmVyID0gcmF3VmFsdWUgPyBwYXJzZUZsb2F0KHJhd1ZhbHVlKSA6IG51bGw7XG4gIHJldHVybiBpc051bWVyaWMyKG51bWJlcikgPyBudW1iZXIgOiByYXdWYWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrZWRBdHRyTG9vc2VDb21wYXJlMih2YWx1ZUEsIHZhbHVlQikge1xuICByZXR1cm4gdmFsdWVBID09IHZhbHVlQjtcbn1cbmZ1bmN0aW9uIGlzTnVtZXJpYzIoc3ViamVjdCkge1xuICByZXR1cm4gIUFycmF5LmlzQXJyYXkoc3ViamVjdCkgJiYgIWlzTmFOKHN1YmplY3QpO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWNsb2FrLmpzXG5kaXJlY3RpdmUoXCJjbG9ha1wiLCAoZWwpID0+IHF1ZXVlTWljcm90YXNrKCgpID0+IG11dGF0ZURvbSgoKSA9PiBlbC5yZW1vdmVBdHRyaWJ1dGUocHJlZml4KFwiY2xvYWtcIikpKSkpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWluaXQuanNcbmFkZEluaXRTZWxlY3RvcigoKSA9PiBgWyR7cHJlZml4KFwiaW5pdFwiKX1dYCk7XG5kaXJlY3RpdmUoXCJpbml0XCIsIHNraXBEdXJpbmdDbG9uZSgoZWwsIHtleHByZXNzaW9ufSkgPT4ge1xuICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gISFleHByZXNzaW9uLnRyaW0oKSAmJiBldmFsdWF0ZShlbCwgZXhwcmVzc2lvbiwge30sIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gZXZhbHVhdGUoZWwsIGV4cHJlc3Npb24sIHt9LCBmYWxzZSk7XG59KSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtdGV4dC5qc1xuZGlyZWN0aXZlKFwidGV4dFwiLCAoZWwsIHtleHByZXNzaW9ufSwge2VmZmVjdDogZWZmZWN0MywgZXZhbHVhdGVMYXRlcjogZXZhbHVhdGVMYXRlcjJ9KSA9PiB7XG4gIGxldCBldmFsdWF0ZTIgPSBldmFsdWF0ZUxhdGVyMihleHByZXNzaW9uKTtcbiAgZWZmZWN0MygoKSA9PiB7XG4gICAgZXZhbHVhdGUyKCh2YWx1ZSkgPT4ge1xuICAgICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWh0bWwuanNcbmRpcmVjdGl2ZShcImh0bWxcIiwgKGVsLCB7ZXhwcmVzc2lvbn0sIHtlZmZlY3Q6IGVmZmVjdDMsIGV2YWx1YXRlTGF0ZXI6IGV2YWx1YXRlTGF0ZXIyfSkgPT4ge1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcjIoZXhwcmVzc2lvbik7XG4gIGVmZmVjdDMoKCkgPT4ge1xuICAgIGV2YWx1YXRlMigodmFsdWUpID0+IHtcbiAgICAgIGVsLmlubmVySFRNTCA9IHZhbHVlO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWJpbmQuanNcbm1hcEF0dHJpYnV0ZXMoc3RhcnRpbmdXaXRoKFwiOlwiLCBpbnRvKHByZWZpeChcImJpbmQ6XCIpKSkpO1xuZGlyZWN0aXZlKFwiYmluZFwiLCAoZWwsIHt2YWx1ZSwgbW9kaWZpZXJzLCBleHByZXNzaW9uLCBvcmlnaW5hbH0sIHtlZmZlY3Q6IGVmZmVjdDN9KSA9PiB7XG4gIGlmICghdmFsdWUpXG4gICAgcmV0dXJuIGFwcGx5QmluZGluZ3NPYmplY3QoZWwsIGV4cHJlc3Npb24sIG9yaWdpbmFsLCBlZmZlY3QzKTtcbiAgaWYgKHZhbHVlID09PSBcImtleVwiKVxuICAgIHJldHVybiBzdG9yZUtleUZvclhGb3IoZWwsIGV4cHJlc3Npb24pO1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbik7XG4gIGVmZmVjdDMoKCkgPT4gZXZhbHVhdGUyKChyZXN1bHQpID0+IHtcbiAgICBpZiAocmVzdWx0ID09PSB2b2lkIDAgJiYgZXhwcmVzc2lvbi5tYXRjaCgvXFwuLykpXG4gICAgICByZXN1bHQgPSBcIlwiO1xuICAgIG11dGF0ZURvbSgoKSA9PiBiaW5kKGVsLCB2YWx1ZSwgcmVzdWx0LCBtb2RpZmllcnMpKTtcbiAgfSkpO1xufSk7XG5mdW5jdGlvbiBhcHBseUJpbmRpbmdzT2JqZWN0KGVsLCBleHByZXNzaW9uLCBvcmlnaW5hbCwgZWZmZWN0Mykge1xuICBsZXQgZ2V0QmluZGluZ3MgPSBldmFsdWF0ZUxhdGVyKGVsLCBleHByZXNzaW9uKTtcbiAgbGV0IGNsZWFudXBSdW5uZXJzID0gW107XG4gIGVmZmVjdDMoKCkgPT4ge1xuICAgIHdoaWxlIChjbGVhbnVwUnVubmVycy5sZW5ndGgpXG4gICAgICBjbGVhbnVwUnVubmVycy5wb3AoKSgpO1xuICAgIGdldEJpbmRpbmdzKChiaW5kaW5ncykgPT4ge1xuICAgICAgbGV0IGF0dHJpYnV0ZXMgPSBPYmplY3QuZW50cmllcyhiaW5kaW5ncykubWFwKChbbmFtZSwgdmFsdWVdKSA9PiAoe25hbWUsIHZhbHVlfSkpO1xuICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuZmlsdGVyKChhdHRyKSA9PiB7XG4gICAgICAgIHJldHVybiAhKHR5cGVvZiBhdHRyLnZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGF0dHIudmFsdWUpICYmIGF0dHIudmFsdWUgIT09IG51bGwpO1xuICAgICAgfSk7XG4gICAgICBsZXQgc3RhdGljQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXNPbmx5KGF0dHJpYnV0ZXMpO1xuICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMubWFwKChhdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgaWYgKHN0YXRpY0F0dHJpYnV0ZXMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSBhdHRyaWJ1dGUubmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogYHgtYmluZDoke2F0dHJpYnV0ZS5uYW1lfWAsXG4gICAgICAgICAgICB2YWx1ZTogYFwiJHthdHRyaWJ1dGUudmFsdWV9XCJgXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0cmlidXRlO1xuICAgICAgfSk7XG4gICAgICBkaXJlY3RpdmVzKGVsLCBhdHRyaWJ1dGVzLCBvcmlnaW5hbCkubWFwKChoYW5kbGUpID0+IHtcbiAgICAgICAgY2xlYW51cFJ1bm5lcnMucHVzaChoYW5kbGUucnVuQ2xlYW51cHMpO1xuICAgICAgICBoYW5kbGUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHN0b3JlS2V5Rm9yWEZvcihlbCwgZXhwcmVzc2lvbikge1xuICBlbC5feF9rZXlFeHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1kYXRhLmpzXG5hZGRSb290U2VsZWN0b3IoKCkgPT4gYFske3ByZWZpeChcImRhdGFcIil9XWApO1xuZGlyZWN0aXZlKFwiZGF0YVwiLCBza2lwRHVyaW5nQ2xvbmUoKGVsLCB7ZXhwcmVzc2lvbn0sIHtjbGVhbnVwfSkgPT4ge1xuICBleHByZXNzaW9uID0gZXhwcmVzc2lvbiA9PT0gXCJcIiA/IFwie31cIiA6IGV4cHJlc3Npb247XG4gIGxldCBtYWdpY0NvbnRleHQgPSB7fTtcbiAgaW5qZWN0TWFnaWNzKG1hZ2ljQ29udGV4dCwgZWwpO1xuICBsZXQgZGF0YVByb3ZpZGVyQ29udGV4dCA9IHt9O1xuICBpbmplY3REYXRhUHJvdmlkZXJzKGRhdGFQcm92aWRlckNvbnRleHQsIG1hZ2ljQ29udGV4dCk7XG4gIGxldCBkYXRhMiA9IGV2YWx1YXRlKGVsLCBleHByZXNzaW9uLCB7c2NvcGU6IGRhdGFQcm92aWRlckNvbnRleHR9KTtcbiAgaWYgKGRhdGEyID09PSB2b2lkIDApXG4gICAgZGF0YTIgPSB7fTtcbiAgaW5qZWN0TWFnaWNzKGRhdGEyLCBlbCk7XG4gIGxldCByZWFjdGl2ZURhdGEgPSByZWFjdGl2ZShkYXRhMik7XG4gIGluaXRJbnRlcmNlcHRvcnMocmVhY3RpdmVEYXRhKTtcbiAgbGV0IHVuZG8gPSBhZGRTY29wZVRvTm9kZShlbCwgcmVhY3RpdmVEYXRhKTtcbiAgcmVhY3RpdmVEYXRhW1wiaW5pdFwiXSAmJiBldmFsdWF0ZShlbCwgcmVhY3RpdmVEYXRhW1wiaW5pdFwiXSk7XG4gIGNsZWFudXAoKCkgPT4ge1xuICAgIHVuZG8oKTtcbiAgICByZWFjdGl2ZURhdGFbXCJkZXN0cm95XCJdICYmIGV2YWx1YXRlKGVsLCByZWFjdGl2ZURhdGFbXCJkZXN0cm95XCJdKTtcbiAgfSk7XG59KSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtc2hvdy5qc1xuZGlyZWN0aXZlKFwic2hvd1wiLCAoZWwsIHttb2RpZmllcnMsIGV4cHJlc3Npb259LCB7ZWZmZWN0OiBlZmZlY3QzfSkgPT4ge1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbik7XG4gIGxldCBoaWRlID0gKCkgPT4gbXV0YXRlRG9tKCgpID0+IHtcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgZWwuX3hfaXNTaG93biA9IGZhbHNlO1xuICB9KTtcbiAgbGV0IHNob3cgPSAoKSA9PiBtdXRhdGVEb20oKCkgPT4ge1xuICAgIGlmIChlbC5zdHlsZS5sZW5ndGggPT09IDEgJiYgZWwuc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImRpc3BsYXlcIik7XG4gICAgfVxuICAgIGVsLl94X2lzU2hvd24gPSB0cnVlO1xuICB9KTtcbiAgbGV0IGNsaWNrQXdheUNvbXBhdGlibGVTaG93ID0gKCkgPT4gc2V0VGltZW91dChzaG93KTtcbiAgbGV0IHRvZ2dsZSA9IG9uY2UoKHZhbHVlKSA9PiB2YWx1ZSA/IHNob3coKSA6IGhpZGUoKSwgKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBlbC5feF90b2dnbGVBbmRDYXNjYWRlV2l0aFRyYW5zaXRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGVsLl94X3RvZ2dsZUFuZENhc2NhZGVXaXRoVHJhbnNpdGlvbnMoZWwsIHZhbHVlLCBzaG93LCBoaWRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPyBjbGlja0F3YXlDb21wYXRpYmxlU2hvdygpIDogaGlkZSgpO1xuICAgIH1cbiAgfSk7XG4gIGxldCBvbGRWYWx1ZTtcbiAgbGV0IGZpcnN0VGltZSA9IHRydWU7XG4gIGVmZmVjdDMoKCkgPT4gZXZhbHVhdGUyKCh2YWx1ZSkgPT4ge1xuICAgIGlmICghZmlyc3RUaW1lICYmIHZhbHVlID09PSBvbGRWYWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiaW1tZWRpYXRlXCIpKVxuICAgICAgdmFsdWUgPyBjbGlja0F3YXlDb21wYXRpYmxlU2hvdygpIDogaGlkZSgpO1xuICAgIHRvZ2dsZSh2YWx1ZSk7XG4gICAgb2xkVmFsdWUgPSB2YWx1ZTtcbiAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgfSkpO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtZm9yLmpzXG5kaXJlY3RpdmUoXCJmb3JcIiwgKGVsLCB7ZXhwcmVzc2lvbn0sIHtlZmZlY3Q6IGVmZmVjdDMsIGNsZWFudXB9KSA9PiB7XG4gIGxldCBpdGVyYXRvck5hbWVzID0gcGFyc2VGb3JFeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICBsZXQgZXZhbHVhdGVJdGVtcyA9IGV2YWx1YXRlTGF0ZXIoZWwsIGl0ZXJhdG9yTmFtZXMuaXRlbXMpO1xuICBsZXQgZXZhbHVhdGVLZXkgPSBldmFsdWF0ZUxhdGVyKGVsLCBlbC5feF9rZXlFeHByZXNzaW9uIHx8IFwiaW5kZXhcIik7XG4gIGVsLl94X3ByZXZLZXlzID0gW107XG4gIGVsLl94X2xvb2t1cCA9IHt9O1xuICBlZmZlY3QzKCgpID0+IGxvb3AoZWwsIGl0ZXJhdG9yTmFtZXMsIGV2YWx1YXRlSXRlbXMsIGV2YWx1YXRlS2V5KSk7XG4gIGNsZWFudXAoKCkgPT4ge1xuICAgIE9iamVjdC52YWx1ZXMoZWwuX3hfbG9va3VwKS5mb3JFYWNoKChlbDIpID0+IGVsMi5yZW1vdmUoKSk7XG4gICAgZGVsZXRlIGVsLl94X3ByZXZLZXlzO1xuICAgIGRlbGV0ZSBlbC5feF9sb29rdXA7XG4gIH0pO1xufSk7XG5mdW5jdGlvbiBsb29wKGVsLCBpdGVyYXRvck5hbWVzLCBldmFsdWF0ZUl0ZW1zLCBldmFsdWF0ZUtleSkge1xuICBsZXQgaXNPYmplY3QgPSAoaSkgPT4gdHlwZW9mIGkgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoaSk7XG4gIGxldCB0ZW1wbGF0ZUVsID0gZWw7XG4gIGV2YWx1YXRlSXRlbXMoKGl0ZW1zKSA9PiB7XG4gICAgaWYgKGlzTnVtZXJpYzMoaXRlbXMpICYmIGl0ZW1zID49IDApIHtcbiAgICAgIGl0ZW1zID0gQXJyYXkuZnJvbShBcnJheShpdGVtcykua2V5cygpLCAoaSkgPT4gaSArIDEpO1xuICAgIH1cbiAgICBpZiAoaXRlbXMgPT09IHZvaWQgMClcbiAgICAgIGl0ZW1zID0gW107XG4gICAgbGV0IGxvb2t1cCA9IGVsLl94X2xvb2t1cDtcbiAgICBsZXQgcHJldktleXMgPSBlbC5feF9wcmV2S2V5cztcbiAgICBsZXQgc2NvcGVzID0gW107XG4gICAgbGV0IGtleXMgPSBbXTtcbiAgICBpZiAoaXNPYmplY3QoaXRlbXMpKSB7XG4gICAgICBpdGVtcyA9IE9iamVjdC5lbnRyaWVzKGl0ZW1zKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBsZXQgc2NvcGUgPSBnZXRJdGVyYXRpb25TY29wZVZhcmlhYmxlcyhpdGVyYXRvck5hbWVzLCB2YWx1ZSwga2V5LCBpdGVtcyk7XG4gICAgICAgIGV2YWx1YXRlS2V5KCh2YWx1ZTIpID0+IGtleXMucHVzaCh2YWx1ZTIpLCB7c2NvcGU6IHtpbmRleDoga2V5LCAuLi5zY29wZX19KTtcbiAgICAgICAgc2NvcGVzLnB1c2goc2NvcGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHNjb3BlID0gZ2V0SXRlcmF0aW9uU2NvcGVWYXJpYWJsZXMoaXRlcmF0b3JOYW1lcywgaXRlbXNbaV0sIGksIGl0ZW1zKTtcbiAgICAgICAgZXZhbHVhdGVLZXkoKHZhbHVlKSA9PiBrZXlzLnB1c2godmFsdWUpLCB7c2NvcGU6IHtpbmRleDogaSwgLi4uc2NvcGV9fSk7XG4gICAgICAgIHNjb3Blcy5wdXNoKHNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGFkZHMgPSBbXTtcbiAgICBsZXQgbW92ZXMgPSBbXTtcbiAgICBsZXQgcmVtb3ZlcyA9IFtdO1xuICAgIGxldCBzYW1lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBrZXkgPSBwcmV2S2V5c1tpXTtcbiAgICAgIGlmIChrZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpXG4gICAgICAgIHJlbW92ZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBwcmV2S2V5cyA9IHByZXZLZXlzLmZpbHRlcigoa2V5KSA9PiAhcmVtb3Zlcy5pbmNsdWRlcyhrZXkpKTtcbiAgICBsZXQgbGFzdEtleSA9IFwidGVtcGxhdGVcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBrZXkgPSBrZXlzW2ldO1xuICAgICAgbGV0IHByZXZJbmRleCA9IHByZXZLZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgIGlmIChwcmV2SW5kZXggPT09IC0xKSB7XG4gICAgICAgIHByZXZLZXlzLnNwbGljZShpLCAwLCBrZXkpO1xuICAgICAgICBhZGRzLnB1c2goW2xhc3RLZXksIGldKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldkluZGV4ICE9PSBpKSB7XG4gICAgICAgIGxldCBrZXlJblNwb3QgPSBwcmV2S2V5cy5zcGxpY2UoaSwgMSlbMF07XG4gICAgICAgIGxldCBrZXlGb3JTcG90ID0gcHJldktleXMuc3BsaWNlKHByZXZJbmRleCAtIDEsIDEpWzBdO1xuICAgICAgICBwcmV2S2V5cy5zcGxpY2UoaSwgMCwga2V5Rm9yU3BvdCk7XG4gICAgICAgIHByZXZLZXlzLnNwbGljZShwcmV2SW5kZXgsIDAsIGtleUluU3BvdCk7XG4gICAgICAgIG1vdmVzLnB1c2goW2tleUluU3BvdCwga2V5Rm9yU3BvdF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2FtZXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgICAgbGFzdEtleSA9IGtleTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQga2V5ID0gcmVtb3Zlc1tpXTtcbiAgICAgIGxvb2t1cFtrZXldLnJlbW92ZSgpO1xuICAgICAgbG9va3VwW2tleV0gPSBudWxsO1xuICAgICAgZGVsZXRlIGxvb2t1cFtrZXldO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgW2tleUluU3BvdCwga2V5Rm9yU3BvdF0gPSBtb3Zlc1tpXTtcbiAgICAgIGxldCBlbEluU3BvdCA9IGxvb2t1cFtrZXlJblNwb3RdO1xuICAgICAgbGV0IGVsRm9yU3BvdCA9IGxvb2t1cFtrZXlGb3JTcG90XTtcbiAgICAgIGxldCBtYXJrZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgICAgZWxGb3JTcG90LmFmdGVyKG1hcmtlcik7XG4gICAgICAgIGVsSW5TcG90LmFmdGVyKGVsRm9yU3BvdCk7XG4gICAgICAgIG1hcmtlci5iZWZvcmUoZWxJblNwb3QpO1xuICAgICAgICBtYXJrZXIucmVtb3ZlKCk7XG4gICAgICB9KTtcbiAgICAgIHJlZnJlc2hTY29wZShlbEZvclNwb3QsIHNjb3Blc1trZXlzLmluZGV4T2Yoa2V5Rm9yU3BvdCldKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgW2xhc3RLZXkyLCBpbmRleF0gPSBhZGRzW2ldO1xuICAgICAgbGV0IGxhc3RFbCA9IGxhc3RLZXkyID09PSBcInRlbXBsYXRlXCIgPyB0ZW1wbGF0ZUVsIDogbG9va3VwW2xhc3RLZXkyXTtcbiAgICAgIGxldCBzY29wZSA9IHNjb3Blc1tpbmRleF07XG4gICAgICBsZXQga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICBsZXQgY2xvbmUyID0gZG9jdW1lbnQuaW1wb3J0Tm9kZSh0ZW1wbGF0ZUVsLmNvbnRlbnQsIHRydWUpLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgYWRkU2NvcGVUb05vZGUoY2xvbmUyLCByZWFjdGl2ZShzY29wZSksIHRlbXBsYXRlRWwpO1xuICAgICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgICAgbGFzdEVsLmFmdGVyKGNsb25lMik7XG4gICAgICAgIGluaXRUcmVlKGNsb25lMik7XG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHdhcm4oXCJ4LWZvciBrZXkgY2Fubm90IGJlIGFuIG9iamVjdCwgaXQgbXVzdCBiZSBhIHN0cmluZyBvciBhbiBpbnRlZ2VyXCIsIHRlbXBsYXRlRWwpO1xuICAgICAgfVxuICAgICAgbG9va3VwW2tleV0gPSBjbG9uZTI7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlZnJlc2hTY29wZShsb29rdXBbc2FtZXNbaV1dLCBzY29wZXNba2V5cy5pbmRleE9mKHNhbWVzW2ldKV0pO1xuICAgIH1cbiAgICB0ZW1wbGF0ZUVsLl94X3ByZXZLZXlzID0ga2V5cztcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZUZvckV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICBsZXQgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcbiAgbGV0IHN0cmlwUGFyZW5zUkUgPSAvXlxccypcXCh8XFwpXFxzKiQvZztcbiAgbGV0IGZvckFsaWFzUkUgPSAvKFtcXHNcXFNdKj8pXFxzKyg/OmlufG9mKVxccysoW1xcc1xcU10qKS87XG4gIGxldCBpbk1hdGNoID0gZXhwcmVzc2lvbi5tYXRjaChmb3JBbGlhc1JFKTtcbiAgaWYgKCFpbk1hdGNoKVxuICAgIHJldHVybjtcbiAgbGV0IHJlcyA9IHt9O1xuICByZXMuaXRlbXMgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgbGV0IGl0ZW0gPSBpbk1hdGNoWzFdLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgXCJcIikudHJpbSgpO1xuICBsZXQgaXRlcmF0b3JNYXRjaCA9IGl0ZW0ubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgcmVzLml0ZW0gPSBpdGVtLnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgXCJcIikudHJpbSgpO1xuICAgIHJlcy5pbmRleCA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XG4gICAgICByZXMuY29sbGVjdGlvbiA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXMuaXRlbSA9IGl0ZW07XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdldEl0ZXJhdGlvblNjb3BlVmFyaWFibGVzKGl0ZXJhdG9yTmFtZXMsIGl0ZW0sIGluZGV4LCBpdGVtcykge1xuICBsZXQgc2NvcGVWYXJpYWJsZXMgPSB7fTtcbiAgaWYgKC9eXFxbLipcXF0kLy50ZXN0KGl0ZXJhdG9yTmFtZXMuaXRlbSkgJiYgQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgIGxldCBuYW1lcyA9IGl0ZXJhdG9yTmFtZXMuaXRlbS5yZXBsYWNlKFwiW1wiLCBcIlwiKS5yZXBsYWNlKFwiXVwiLCBcIlwiKS5zcGxpdChcIixcIikubWFwKChpKSA9PiBpLnRyaW0oKSk7XG4gICAgbmFtZXMuZm9yRWFjaCgobmFtZSwgaSkgPT4ge1xuICAgICAgc2NvcGVWYXJpYWJsZXNbbmFtZV0gPSBpdGVtW2ldO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKC9eXFx7LipcXH0kLy50ZXN0KGl0ZXJhdG9yTmFtZXMuaXRlbSkgJiYgIUFycmF5LmlzQXJyYXkoaXRlbSkgJiYgdHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIpIHtcbiAgICBsZXQgbmFtZXMgPSBpdGVyYXRvck5hbWVzLml0ZW0ucmVwbGFjZShcIntcIiwgXCJcIikucmVwbGFjZShcIn1cIiwgXCJcIikuc3BsaXQoXCIsXCIpLm1hcCgoaSkgPT4gaS50cmltKCkpO1xuICAgIG5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIHNjb3BlVmFyaWFibGVzW25hbWVdID0gaXRlbVtuYW1lXTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzY29wZVZhcmlhYmxlc1tpdGVyYXRvck5hbWVzLml0ZW1dID0gaXRlbTtcbiAgfVxuICBpZiAoaXRlcmF0b3JOYW1lcy5pbmRleClcbiAgICBzY29wZVZhcmlhYmxlc1tpdGVyYXRvck5hbWVzLmluZGV4XSA9IGluZGV4O1xuICBpZiAoaXRlcmF0b3JOYW1lcy5jb2xsZWN0aW9uKVxuICAgIHNjb3BlVmFyaWFibGVzW2l0ZXJhdG9yTmFtZXMuY29sbGVjdGlvbl0gPSBpdGVtcztcbiAgcmV0dXJuIHNjb3BlVmFyaWFibGVzO1xufVxuZnVuY3Rpb24gaXNOdW1lcmljMyhzdWJqZWN0KSB7XG4gIHJldHVybiAhQXJyYXkuaXNBcnJheShzdWJqZWN0KSAmJiAhaXNOYU4oc3ViamVjdCk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtcmVmLmpzXG5mdW5jdGlvbiBoYW5kbGVyMigpIHtcbn1cbmhhbmRsZXIyLmlubGluZSA9IChlbCwge2V4cHJlc3Npb259LCB7Y2xlYW51cH0pID0+IHtcbiAgbGV0IHJvb3QgPSBjbG9zZXN0Um9vdChlbCk7XG4gIGlmICghcm9vdC5feF9yZWZzKVxuICAgIHJvb3QuX3hfcmVmcyA9IHt9O1xuICByb290Ll94X3JlZnNbZXhwcmVzc2lvbl0gPSBlbDtcbiAgY2xlYW51cCgoKSA9PiBkZWxldGUgcm9vdC5feF9yZWZzW2V4cHJlc3Npb25dKTtcbn07XG5kaXJlY3RpdmUoXCJyZWZcIiwgaGFuZGxlcjIpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWlmLmpzXG5kaXJlY3RpdmUoXCJpZlwiLCAoZWwsIHtleHByZXNzaW9ufSwge2VmZmVjdDogZWZmZWN0MywgY2xlYW51cH0pID0+IHtcbiAgbGV0IGV2YWx1YXRlMiA9IGV2YWx1YXRlTGF0ZXIoZWwsIGV4cHJlc3Npb24pO1xuICBsZXQgc2hvdyA9ICgpID0+IHtcbiAgICBpZiAoZWwuX3hfY3VycmVudElmRWwpXG4gICAgICByZXR1cm4gZWwuX3hfY3VycmVudElmRWw7XG4gICAgbGV0IGNsb25lMiA9IGVsLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpLmZpcnN0RWxlbWVudENoaWxkO1xuICAgIGFkZFNjb3BlVG9Ob2RlKGNsb25lMiwge30sIGVsKTtcbiAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgZWwuYWZ0ZXIoY2xvbmUyKTtcbiAgICAgIGluaXRUcmVlKGNsb25lMik7XG4gICAgfSk7XG4gICAgZWwuX3hfY3VycmVudElmRWwgPSBjbG9uZTI7XG4gICAgZWwuX3hfdW5kb0lmID0gKCkgPT4ge1xuICAgICAgY2xvbmUyLnJlbW92ZSgpO1xuICAgICAgZGVsZXRlIGVsLl94X2N1cnJlbnRJZkVsO1xuICAgIH07XG4gICAgcmV0dXJuIGNsb25lMjtcbiAgfTtcbiAgbGV0IGhpZGUgPSAoKSA9PiB7XG4gICAgaWYgKCFlbC5feF91bmRvSWYpXG4gICAgICByZXR1cm47XG4gICAgZWwuX3hfdW5kb0lmKCk7XG4gICAgZGVsZXRlIGVsLl94X3VuZG9JZjtcbiAgfTtcbiAgZWZmZWN0MygoKSA9PiBldmFsdWF0ZTIoKHZhbHVlKSA9PiB7XG4gICAgdmFsdWUgPyBzaG93KCkgOiBoaWRlKCk7XG4gIH0pKTtcbiAgY2xlYW51cCgoKSA9PiBlbC5feF91bmRvSWYgJiYgZWwuX3hfdW5kb0lmKCkpO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtb24uanNcbm1hcEF0dHJpYnV0ZXMoc3RhcnRpbmdXaXRoKFwiQFwiLCBpbnRvKHByZWZpeChcIm9uOlwiKSkpKTtcbmRpcmVjdGl2ZShcIm9uXCIsIHNraXBEdXJpbmdDbG9uZSgoZWwsIHt2YWx1ZSwgbW9kaWZpZXJzLCBleHByZXNzaW9ufSwge2NsZWFudXB9KSA9PiB7XG4gIGxldCBldmFsdWF0ZTIgPSBleHByZXNzaW9uID8gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbikgOiAoKSA9PiB7XG4gIH07XG4gIGxldCByZW1vdmVMaXN0ZW5lciA9IG9uKGVsLCB2YWx1ZSwgbW9kaWZpZXJzLCAoZSkgPT4ge1xuICAgIGV2YWx1YXRlMigoKSA9PiB7XG4gICAgfSwge3Njb3BlOiB7JGV2ZW50OiBlfSwgcGFyYW1zOiBbZV19KTtcbiAgfSk7XG4gIGNsZWFudXAoKCkgPT4gcmVtb3ZlTGlzdGVuZXIoKSk7XG59KSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9pbmRleC5qc1xuYWxwaW5lX2RlZmF1bHQuc2V0RXZhbHVhdG9yKG5vcm1hbEV2YWx1YXRvcik7XG5hbHBpbmVfZGVmYXVsdC5zZXRSZWFjdGl2aXR5RW5naW5lKHtyZWFjdGl2ZTogaW1wb3J0X3JlYWN0aXZpdHk5LnJlYWN0aXZlLCBlZmZlY3Q6IGltcG9ydF9yZWFjdGl2aXR5OS5lZmZlY3QsIHJlbGVhc2U6IGltcG9ydF9yZWFjdGl2aXR5OS5zdG9wLCByYXc6IGltcG9ydF9yZWFjdGl2aXR5OS50b1Jhd30pO1xudmFyIHNyY19kZWZhdWx0ID0gYWxwaW5lX2RlZmF1bHQ7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL2J1aWxkcy9tb2R1bGUuanNcbnZhciBtb2R1bGVfZGVmYXVsdCA9IHNyY19kZWZhdWx0O1xuZXhwb3J0IHtcbiAgbW9kdWxlX2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/alpinejs/dist/module.esm.js\n");

/***/ }),

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var alpinejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alpinejs */ \"./node_modules/alpinejs/dist/module.esm.js\");\n__webpack_require__(/*! ./components */ \"./resources/js/components.js\");\n\n__webpack_require__(/*! ./bootstrap */ \"./resources/js/bootstrap.js\");\n\n__webpack_require__(/*! ./datepicker */ \"./resources/js/datepicker.js\");\n\n\nwindow.Alpine = alpinejs__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\nalpinejs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].start();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvYXBwLmpzLmpzIiwibWFwcGluZ3MiOiI7O0FBQUFBLG1CQUFPLENBQUMsa0RBQUQsQ0FBUDs7QUFDQUEsbUJBQU8sQ0FBQyxnREFBRCxDQUFQOztBQUNBQSxtQkFBTyxDQUFDLGtEQUFELENBQVA7O0FBRUE7QUFDQUUsTUFBTSxDQUFDRCxNQUFQLEdBQWdCQSxnREFBaEI7QUFDQUEsc0RBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvYXBwLmpzP2NlZDYiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi9jb21wb25lbnRzJyk7XHJcbnJlcXVpcmUoJy4vYm9vdHN0cmFwJyk7XHJcbnJlcXVpcmUoJy4vZGF0ZXBpY2tlcicpO1xyXG5cclxuaW1wb3J0IEFscGluZSBmcm9tICdhbHBpbmVqcyc7XHJcbndpbmRvdy5BbHBpbmUgPSBBbHBpbmU7XHJcbkFscGluZS5zdGFydCgpOyJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiQWxwaW5lIiwid2luZG93Iiwic3RhcnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/app.js\n");

/***/ }),

/***/ "./resources/js/bootstrap.js":
/*!***********************************!*\
  !*** ./resources/js/bootstrap.js ***!
  \***********************************/
/***/ (() => {

eval("/**\r\n * Echo exposes an expressive API for subscribing to channels and listening\r\n * for events that are broadcast by Laravel. Echo and event broadcasting\r\n * allows your team to easily build robust real-time web applications.\r\n */\n// import Echo from 'laravel-echo'\n// window.Pusher = require('pusher-js');\n// window.Echo = new Echo({\n//     broadcaster: 'pusher',\n//     key: process.env.MIX_PUSHER_APP_KEY,\n//     cluster: process.env.MIX_PUSHER_APP_CLUSTER,\n//     forceTLS: true\n// });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvYm9vdHN0cmFwLmpzPzZkZTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJcclxuLyoqXHJcbiAqIEVjaG8gZXhwb3NlcyBhbiBleHByZXNzaXZlIEFQSSBmb3Igc3Vic2NyaWJpbmcgdG8gY2hhbm5lbHMgYW5kIGxpc3RlbmluZ1xyXG4gKiBmb3IgZXZlbnRzIHRoYXQgYXJlIGJyb2FkY2FzdCBieSBMYXJhdmVsLiBFY2hvIGFuZCBldmVudCBicm9hZGNhc3RpbmdcclxuICogYWxsb3dzIHlvdXIgdGVhbSB0byBlYXNpbHkgYnVpbGQgcm9idXN0IHJlYWwtdGltZSB3ZWIgYXBwbGljYXRpb25zLlxyXG4gKi9cclxuXHJcbi8vIGltcG9ydCBFY2hvIGZyb20gJ2xhcmF2ZWwtZWNobydcclxuXHJcbi8vIHdpbmRvdy5QdXNoZXIgPSByZXF1aXJlKCdwdXNoZXItanMnKTtcclxuXHJcbi8vIHdpbmRvdy5FY2hvID0gbmV3IEVjaG8oe1xyXG4vLyAgICAgYnJvYWRjYXN0ZXI6ICdwdXNoZXInLFxyXG4vLyAgICAga2V5OiBwcm9jZXNzLmVudi5NSVhfUFVTSEVSX0FQUF9LRVksXHJcbi8vICAgICBjbHVzdGVyOiBwcm9jZXNzLmVudi5NSVhfUFVTSEVSX0FQUF9DTFVTVEVSLFxyXG4vLyAgICAgZm9yY2VUTFM6IHRydWVcclxuLy8gfSk7XHJcbiJdLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvYm9vdHN0cmFwLmpzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/bootstrap.js\n");

/***/ }),

/***/ "./resources/js/components.js":
/*!************************************!*\
  !*** ./resources/js/components.js ***!
  \************************************/
/***/ (() => {

eval("function _defineEnumerableProperties(obj, descs) { for (var key in descs) { var desc = descs[key]; desc.configurable = desc.enumerable = true; if (\"value\" in desc) desc.writable = true; Object.defineProperty(obj, key, desc); } if (Object.getOwnPropertySymbols) { var objectSymbols = Object.getOwnPropertySymbols(descs); for (var i = 0; i < objectSymbols.length; i++) { var sym = objectSymbols[i]; var desc = descs[sym]; desc.configurable = desc.enumerable = true; if (\"value\" in desc) desc.writable = true; Object.defineProperty(obj, sym, desc); } } return obj; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// import DateRangePicker from '@themesberg/tailwind-datepicker/DateRangePicker';\n// const dateRangePickerEl = document.querySelector(\"[date-rangepicker]\");\n// new DateRangePicker(dateRangePickerEl, {\n//     // options\n//     autohide : true,\n//     format : \"mm/dd/yyyy\",\n//     orientation : \"bottom right\",\n//     // title : \"Select Date\"\n// });\nwindow.Components = {}, window.Components.listbox = function (t) {\n  var _ref, _objectSpread2, _mutatorMap;\n\n  return _objectSpread((_objectSpread2 = {\n    init: function init() {\n      var _this = this;\n\n      this.optionCount = this.$refs.listbox.children.length, this.$watch(\"activeIndex\", function (t) {\n        _this.open && (null !== _this.activeIndex ? _this.activeDescendant = _this.$refs.listbox.children[_this.activeIndex].id : _this.activeDescendant = \"\");\n      });\n    },\n    activeDescendant: null,\n    optionCount: null,\n    open: !1,\n    activeIndex: null,\n    selectedIndex: 0,\n\n    get active() {\n      return this.items[this.activeIndex];\n    }\n\n  }, _ref = t.modelName || \"selected\", _mutatorMap = {}, _mutatorMap[_ref] = _mutatorMap[_ref] || {}, _mutatorMap[_ref].get = function () {\n    return this.items[this.selectedIndex];\n  }, _defineProperty(_objectSpread2, \"choose\", function choose(t) {\n    this.selectedIndex = t, this.open = !1;\n  }), _defineProperty(_objectSpread2, \"onButtonClick\", function onButtonClick() {\n    var _this2 = this;\n\n    this.open || (this.activeIndex = this.selectedIndex, this.open = !0, this.$nextTick(function () {\n      _this2.$refs.listbox.focus(), _this2.$refs.listbox.children[_this2.activeIndex].scrollIntoView({\n        block: \"nearest\"\n      });\n    }));\n  }), _defineProperty(_objectSpread2, \"onOptionSelect\", function onOptionSelect() {\n    null !== this.activeIndex && (this.selectedIndex = this.activeIndex), this.open = !1, this.$refs.button.focus();\n  }), _defineProperty(_objectSpread2, \"onEscape\", function onEscape() {\n    this.open = !1, this.$refs.button.focus();\n  }), _defineProperty(_objectSpread2, \"onArrowUp\", function onArrowUp() {\n    this.activeIndex = this.activeIndex - 1 < 0 ? this.optionCount - 1 : this.activeIndex - 1, this.$refs.listbox.children[this.activeIndex].scrollIntoView({\n      block: \"nearest\"\n    });\n  }), _defineProperty(_objectSpread2, \"onArrowDown\", function onArrowDown() {\n    this.activeIndex = this.activeIndex + 1 > this.optionCount - 1 ? 0 : this.activeIndex + 1, this.$refs.listbox.children[this.activeIndex].scrollIntoView({\n      block: \"nearest\"\n    });\n  }), _defineEnumerableProperties(_objectSpread2, _mutatorMap), _objectSpread2), t);\n}, window.Components.menu = function () {\n  var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    open: !1\n  };\n  return {\n    init: function init() {\n      var _this3 = this;\n\n      this.items = Array.from(this.$el.querySelectorAll('[role=\"menuitem\"]')), this.$watch(\"open\", function () {\n        _this3.open && (_this3.activeIndex = -1);\n      });\n    },\n    activeDescendant: null,\n    activeIndex: null,\n    items: null,\n    open: t.open,\n    focusButton: function focusButton() {\n      this.$refs.button.focus();\n    },\n    onButtonClick: function onButtonClick() {\n      var _this4 = this;\n\n      this.open = !this.open, this.open && this.$nextTick(function () {\n        _this4.$refs[\"menu-items\"].focus();\n      });\n    },\n    onButtonEnter: function onButtonEnter() {\n      var _this5 = this;\n\n      this.open = !this.open, this.open && (this.activeIndex = 0, this.activeDescendant = this.items[this.activeIndex].id, this.$nextTick(function () {\n        _this5.$refs[\"menu-items\"].focus();\n      }));\n    },\n    onArrowUp: function onArrowUp() {\n      if (!this.open) return this.open = !0, this.activeIndex = this.items.length - 1, void (this.activeDescendant = this.items[this.activeIndex].id);\n      0 !== this.activeIndex && (this.activeIndex = -1 === this.activeIndex ? this.items.length - 1 : this.activeIndex - 1, this.activeDescendant = this.items[this.activeIndex].id);\n    },\n    onArrowDown: function onArrowDown() {\n      if (!this.open) return this.open = !0, this.activeIndex = 0, void (this.activeDescendant = this.items[this.activeIndex].id);\n      this.activeIndex !== this.items.length - 1 && (this.activeIndex = this.activeIndex + 1, this.activeDescendant = this.items[this.activeIndex].id);\n    },\n    onClickAway: function onClickAway(t) {\n      if (this.open) {\n        var e = [\"[contentEditable=true]\", \"[tabindex]\", \"a[href]\", \"area[href]\", \"button:not([disabled])\", \"iframe\", \"input:not([disabled])\", \"select:not([disabled])\", \"textarea:not([disabled])\"].map(function (t) {\n          return \"\".concat(t, \":not([tabindex='-1'])\");\n        }).join(\",\");\n        this.open = !1, t.target.closest(e) || this.focusButton();\n      }\n    }\n  };\n}, window.Components.popoverGroup = function () {\n  return {\n    __type: \"popoverGroup\",\n    init: function init() {\n      var _this6 = this;\n\n      var t = function t(e) {\n        document.body.contains(_this6.$el) ? e.target instanceof Element && !_this6.$el.contains(e.target) && window.dispatchEvent(new CustomEvent(\"close-popover-group\", {\n          detail: _this6.$el\n        })) : window.removeEventListener(\"focus\", t, !0);\n      };\n\n      window.addEventListener(\"focus\", t, !0);\n    }\n  };\n}, window.Components.popover = function () {\n  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref2$open = _ref2.open,\n      t = _ref2$open === void 0 ? !1 : _ref2$open,\n      _ref2$focus = _ref2.focus,\n      e = _ref2$focus === void 0 ? !1 : _ref2$focus;\n\n  var i = [\"[contentEditable=true]\", \"[tabindex]\", \"a[href]\", \"area[href]\", \"button:not([disabled])\", \"iframe\", \"input:not([disabled])\", \"select:not([disabled])\", \"textarea:not([disabled])\"].map(function (t) {\n    return \"\".concat(t, \":not([tabindex='-1'])\");\n  }).join(\",\");\n  return {\n    __type: \"popover\",\n    open: t,\n    init: function init() {\n      var _this7 = this;\n\n      e && this.$watch(\"open\", function (t) {\n        t && _this7.$nextTick(function () {\n          !function (t) {\n            var e = Array.from(t.querySelectorAll(i));\n            !function t(i) {\n              void 0 !== i && (i.focus({\n                preventScroll: !0\n              }), document.activeElement !== i && t(e[e.indexOf(i) + 1]));\n            }(e[0]);\n          }(_this7.$refs.panel);\n        });\n      });\n\n      var t = function t(i) {\n        if (!document.body.contains(_this7.$el)) return void window.removeEventListener(\"focus\", t, !0);\n        var n = e ? _this7.$refs.panel : _this7.$el;\n\n        if (_this7.open && i.target instanceof Element && !n.contains(i.target)) {\n          var _t = _this7.$el;\n\n          for (; _t.parentNode;) {\n            if (_t = _t.parentNode, _t.__x instanceof _this7.constructor) {\n              if (\"popoverGroup\" === _t.__x.$data.__type) return;\n              if (\"popover\" === _t.__x.$data.__type) break;\n            }\n          }\n\n          _this7.open = !1;\n        }\n      };\n\n      window.addEventListener(\"focus\", t, !0);\n    },\n    onEscape: function onEscape() {\n      this.open = !1, this.restoreEl && this.restoreEl.focus();\n    },\n    onClosePopoverGroup: function onClosePopoverGroup(t) {\n      t.detail.contains(this.$el) && (this.open = !1);\n    },\n    toggle: function toggle(t) {\n      this.open = !this.open, this.open ? this.restoreEl = t.currentTarget : this.restoreEl && this.restoreEl.focus();\n    }\n  };\n}, window.Components.radioGroup = function () {\n  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref3$initialCheckedI = _ref3.initialCheckedIndex,\n      t = _ref3$initialCheckedI === void 0 ? 0 : _ref3$initialCheckedI;\n\n  return {\n    value: void 0,\n    init: function init() {\n      var _Array$from$t;\n\n      this.value = (_Array$from$t = Array.from(this.$el.querySelectorAll(\"input\"))[t]) === null || _Array$from$t === void 0 ? void 0 : _Array$from$t.value;\n    }\n  };\n}, window.Components.desc = function () {\n  var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref4$open = _ref4.open,\n      t = _ref4$open === void 0 ? 1 : _ref4$open;\n\n  return {\n    __type: \"desc\",\n    open: t\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy5qcz9kM2UwIl0sIm5hbWVzIjpbIndpbmRvdyIsIkNvbXBvbmVudHMiLCJsaXN0Ym94IiwidCIsImluaXQiLCJvcHRpb25Db3VudCIsIiRyZWZzIiwiY2hpbGRyZW4iLCJsZW5ndGgiLCIkd2F0Y2giLCJvcGVuIiwiYWN0aXZlSW5kZXgiLCJhY3RpdmVEZXNjZW5kYW50IiwiaWQiLCJzZWxlY3RlZEluZGV4IiwiYWN0aXZlIiwiaXRlbXMiLCJtb2RlbE5hbWUiLCIkbmV4dFRpY2siLCJmb2N1cyIsInNjcm9sbEludG9WaWV3IiwiYmxvY2siLCJidXR0b24iLCJtZW51IiwiQXJyYXkiLCJmcm9tIiwiJGVsIiwicXVlcnlTZWxlY3RvckFsbCIsImZvY3VzQnV0dG9uIiwib25CdXR0b25DbGljayIsIm9uQnV0dG9uRW50ZXIiLCJvbkFycm93VXAiLCJvbkFycm93RG93biIsIm9uQ2xpY2tBd2F5IiwiZSIsIm1hcCIsImpvaW4iLCJ0YXJnZXQiLCJjbG9zZXN0IiwicG9wb3Zlckdyb3VwIiwiX190eXBlIiwiZG9jdW1lbnQiLCJib2R5IiwiY29udGFpbnMiLCJFbGVtZW50IiwiZGlzcGF0Y2hFdmVudCIsIkN1c3RvbUV2ZW50IiwiZGV0YWlsIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJwb3BvdmVyIiwiaSIsInByZXZlbnRTY3JvbGwiLCJhY3RpdmVFbGVtZW50IiwiaW5kZXhPZiIsInBhbmVsIiwibiIsInBhcmVudE5vZGUiLCJfX3giLCJjb25zdHJ1Y3RvciIsIiRkYXRhIiwib25Fc2NhcGUiLCJyZXN0b3JlRWwiLCJvbkNsb3NlUG9wb3Zlckdyb3VwIiwidG9nZ2xlIiwiY3VycmVudFRhcmdldCIsInJhZGlvR3JvdXAiLCJpbml0aWFsQ2hlY2tlZEluZGV4IiwidmFsdWUiLCJkZXNjIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNB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bkNFO0FBb0NIc0QsSUFBQUEsTUFwQ0csa0JBb0NJN0QsQ0FwQ0osRUFvQ087QUFDTixXQUFLTyxJQUFMLEdBQVksQ0FBQyxLQUFLQSxJQUFsQixFQUF3QixLQUFLQSxJQUFMLEdBQVksS0FBS29ELFNBQUwsR0FBaUIzRCxDQUFDLENBQUM4RCxhQUEvQixHQUErQyxLQUFLSCxTQUFMLElBQWtCLEtBQUtBLFNBQUwsQ0FBZTNDLEtBQWYsRUFBekY7QUFDSDtBQXRDRSxHQUFQO0FBd0NILENBbkpELEVBcUpBbkIsTUFBTSxDQUFDQyxVQUFQLENBQWtCaUUsVUFBbEIsR0FBK0IsWUFBOEM7QUFBQSxrRkFBSixFQUFJO0FBQUEsb0NBQW5DQyxtQkFBbUM7QUFBQSxNQUFkaEUsQ0FBYyxzQ0FBVixDQUFVOztBQUN6RSxTQUFPO0FBQ0hpRSxJQUFBQSxLQUFLLEVBQUUsS0FBSyxDQURUO0FBRUhoRSxJQUFBQSxJQUZHLGtCQUVJO0FBQUE7O0FBQ0gsV0FBS2dFLEtBQUwsb0JBQWE1QyxLQUFLLENBQUNDLElBQU4sQ0FBVyxLQUFLQyxHQUFMLENBQVNDLGdCQUFULENBQTBCLE9BQTFCLENBQVgsRUFBK0N4QixDQUEvQyxDQUFiLGtEQUFhLGNBQW1EaUUsS0FBaEU7QUFDSDtBQUpFLEdBQVA7QUFNSCxDQTVKRCxFQThKQXBFLE1BQU0sQ0FBQ0MsVUFBUCxDQUFrQm9FLElBQWxCLEdBQXlCLFlBQStCO0FBQUEsa0ZBQUosRUFBSTtBQUFBLHlCQUFwQjNELElBQW9CO0FBQUEsTUFBZFAsQ0FBYywyQkFBVixDQUFVOztBQUNwRCxTQUFPO0FBQ0hxQyxJQUFBQSxNQUFNLEVBQUUsTUFETDtBQUVIOUIsSUFBQUEsSUFBSSxFQUFFUDtBQUZILEdBQVA7QUFJSCxDQW5LRCIsInNvdXJjZXNDb250ZW50IjpbIlxyXG4vLyBpbXBvcnQgRGF0ZVJhbmdlUGlja2VyIGZyb20gJ0B0aGVtZXNiZXJnL3RhaWx3aW5kLWRhdGVwaWNrZXIvRGF0ZVJhbmdlUGlja2VyJztcclxuLy8gY29uc3QgZGF0ZVJhbmdlUGlja2VyRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGUtcmFuZ2VwaWNrZXJdXCIpO1xyXG4vLyBuZXcgRGF0ZVJhbmdlUGlja2VyKGRhdGVSYW5nZVBpY2tlckVsLCB7XHJcbi8vICAgICAvLyBvcHRpb25zXHJcbi8vICAgICBhdXRvaGlkZSA6IHRydWUsXHJcbi8vICAgICBmb3JtYXQgOiBcIm1tL2RkL3l5eXlcIixcclxuLy8gICAgIG9yaWVudGF0aW9uIDogXCJib3R0b20gcmlnaHRcIixcclxuLy8gICAgIC8vIHRpdGxlIDogXCJTZWxlY3QgRGF0ZVwiXHJcbi8vIH0pO1xyXG5cclxuXHJcblxyXG53aW5kb3cuQ29tcG9uZW50cyA9IHt9LCBcclxuXHJcbndpbmRvdy5Db21wb25lbnRzLmxpc3Rib3ggPSBmdW5jdGlvbih0KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGluaXQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uQ291bnQgPSB0aGlzLiRyZWZzLmxpc3Rib3guY2hpbGRyZW4ubGVuZ3RoLCB0aGlzLiR3YXRjaChcImFjdGl2ZUluZGV4XCIsICh0ID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3BlbiAmJiAobnVsbCAhPT0gdGhpcy5hY3RpdmVJbmRleCA/IHRoaXMuYWN0aXZlRGVzY2VuZGFudCA9IHRoaXMuJHJlZnMubGlzdGJveC5jaGlsZHJlblt0aGlzLmFjdGl2ZUluZGV4XS5pZCA6IHRoaXMuYWN0aXZlRGVzY2VuZGFudCA9IFwiXCIpXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWN0aXZlRGVzY2VuZGFudDogbnVsbCxcclxuICAgICAgICBvcHRpb25Db3VudDogbnVsbCxcclxuICAgICAgICBvcGVuOiAhMSxcclxuICAgICAgICBhY3RpdmVJbmRleDogbnVsbCxcclxuICAgICAgICBzZWxlY3RlZEluZGV4OiAwLFxyXG4gICAgICAgIGdldCBhY3RpdmUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zW3RoaXMuYWN0aXZlSW5kZXhdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgW3QubW9kZWxOYW1lIHx8IFwic2VsZWN0ZWRcIl0oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zW3RoaXMuc2VsZWN0ZWRJbmRleF1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNob29zZSh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHQsIHRoaXMub3BlbiA9ICExXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkJ1dHRvbkNsaWNrKCkge1xyXG4gICAgICAgICAgICB0aGlzLm9wZW4gfHwgKHRoaXMuYWN0aXZlSW5kZXggPSB0aGlzLnNlbGVjdGVkSW5kZXgsIHRoaXMub3BlbiA9ICEwLCB0aGlzLiRuZXh0VGljaygoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kcmVmcy5saXN0Ym94LmZvY3VzKCksIHRoaXMuJHJlZnMubGlzdGJveC5jaGlsZHJlblt0aGlzLmFjdGl2ZUluZGV4XS5zY3JvbGxJbnRvVmlldyh7XHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KSkpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbk9wdGlvblNlbGVjdCgpIHtcclxuICAgICAgICAgICAgbnVsbCAhPT0gdGhpcy5hY3RpdmVJbmRleCAmJiAodGhpcy5zZWxlY3RlZEluZGV4ID0gdGhpcy5hY3RpdmVJbmRleCksIHRoaXMub3BlbiA9ICExLCB0aGlzLiRyZWZzLmJ1dHRvbi5mb2N1cygpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkVzY2FwZSgpIHtcclxuICAgICAgICAgICAgdGhpcy5vcGVuID0gITEsIHRoaXMuJHJlZnMuYnV0dG9uLmZvY3VzKClcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQXJyb3dVcCgpIHtcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmVJbmRleCA9IHRoaXMuYWN0aXZlSW5kZXggLSAxIDwgMCA/IHRoaXMub3B0aW9uQ291bnQgLSAxIDogdGhpcy5hY3RpdmVJbmRleCAtIDEsIHRoaXMuJHJlZnMubGlzdGJveC5jaGlsZHJlblt0aGlzLmFjdGl2ZUluZGV4XS5zY3JvbGxJbnRvVmlldyh7XHJcbiAgICAgICAgICAgICAgICBibG9jazogXCJuZWFyZXN0XCJcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQXJyb3dEb3duKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUluZGV4ID0gdGhpcy5hY3RpdmVJbmRleCArIDEgPiB0aGlzLm9wdGlvbkNvdW50IC0gMSA/IDAgOiB0aGlzLmFjdGl2ZUluZGV4ICsgMSwgdGhpcy4kcmVmcy5saXN0Ym94LmNoaWxkcmVuW3RoaXMuYWN0aXZlSW5kZXhdLnNjcm9sbEludG9WaWV3KHtcclxuICAgICAgICAgICAgICAgIGJsb2NrOiBcIm5lYXJlc3RcIlxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLi4udFxyXG4gICAgfVxyXG59LCBcclxuXHJcbndpbmRvdy5Db21wb25lbnRzLm1lbnUgPSBmdW5jdGlvbih0ID0geyBvcGVuOiAhMSB9KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGluaXQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXRlbXMgPSBBcnJheS5mcm9tKHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tyb2xlPVwibWVudWl0ZW1cIl0nKSksIHRoaXMuJHdhdGNoKFwib3BlblwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuICYmICh0aGlzLmFjdGl2ZUluZGV4ID0gLTEpXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWN0aXZlRGVzY2VuZGFudDogbnVsbCxcclxuICAgICAgICBhY3RpdmVJbmRleDogbnVsbCxcclxuICAgICAgICBpdGVtczogbnVsbCxcclxuICAgICAgICBvcGVuOiB0Lm9wZW4sXHJcbiAgICAgICAgZm9jdXNCdXR0b24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJHJlZnMuYnV0dG9uLmZvY3VzKClcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQnV0dG9uQ2xpY2soKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3BlbiA9ICF0aGlzLm9wZW4sIHRoaXMub3BlbiAmJiB0aGlzLiRuZXh0VGljaygoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kcmVmc1tcIm1lbnUtaXRlbXNcIl0uZm9jdXMoKVxyXG4gICAgICAgICAgICB9KSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQnV0dG9uRW50ZXIoKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3BlbiA9ICF0aGlzLm9wZW4sIHRoaXMub3BlbiAmJiAodGhpcy5hY3RpdmVJbmRleCA9IDAsIHRoaXMuYWN0aXZlRGVzY2VuZGFudCA9IHRoaXMuaXRlbXNbdGhpcy5hY3RpdmVJbmRleF0uaWQsIHRoaXMuJG5leHRUaWNrKCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRyZWZzW1wibWVudS1pdGVtc1wiXS5mb2N1cygpXHJcbiAgICAgICAgICAgIH0pKSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQXJyb3dVcCgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wZW4pIHJldHVybiB0aGlzLm9wZW4gPSAhMCwgdGhpcy5hY3RpdmVJbmRleCA9IHRoaXMuaXRlbXMubGVuZ3RoIC0gMSwgdm9pZCh0aGlzLmFjdGl2ZURlc2NlbmRhbnQgPSB0aGlzLml0ZW1zW3RoaXMuYWN0aXZlSW5kZXhdLmlkKTtcclxuICAgICAgICAgICAgMCAhPT0gdGhpcy5hY3RpdmVJbmRleCAmJiAodGhpcy5hY3RpdmVJbmRleCA9IC0xID09PSB0aGlzLmFjdGl2ZUluZGV4ID8gdGhpcy5pdGVtcy5sZW5ndGggLSAxIDogdGhpcy5hY3RpdmVJbmRleCAtIDEsIHRoaXMuYWN0aXZlRGVzY2VuZGFudCA9IHRoaXMuaXRlbXNbdGhpcy5hY3RpdmVJbmRleF0uaWQpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkFycm93RG93bigpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wZW4pIHJldHVybiB0aGlzLm9wZW4gPSAhMCwgdGhpcy5hY3RpdmVJbmRleCA9IDAsIHZvaWQodGhpcy5hY3RpdmVEZXNjZW5kYW50ID0gdGhpcy5pdGVtc1t0aGlzLmFjdGl2ZUluZGV4XS5pZCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSW5kZXggIT09IHRoaXMuaXRlbXMubGVuZ3RoIC0gMSAmJiAodGhpcy5hY3RpdmVJbmRleCA9IHRoaXMuYWN0aXZlSW5kZXggKyAxLCB0aGlzLmFjdGl2ZURlc2NlbmRhbnQgPSB0aGlzLml0ZW1zW3RoaXMuYWN0aXZlSW5kZXhdLmlkKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25DbGlja0F3YXkodCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcGVuKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gW1wiW2NvbnRlbnRFZGl0YWJsZT10cnVlXVwiLCBcIlt0YWJpbmRleF1cIiwgXCJhW2hyZWZdXCIsIFwiYXJlYVtocmVmXVwiLCBcImJ1dHRvbjpub3QoW2Rpc2FibGVkXSlcIiwgXCJpZnJhbWVcIiwgXCJpbnB1dDpub3QoW2Rpc2FibGVkXSlcIiwgXCJzZWxlY3Q6bm90KFtkaXNhYmxlZF0pXCIsIFwidGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pXCJdLm1hcCgodCA9PiBgJHt0fTpub3QoW3RhYmluZGV4PSctMSddKWApKS5qb2luKFwiLFwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3BlbiA9ICExLCB0LnRhcmdldC5jbG9zZXN0KGUpIHx8IHRoaXMuZm9jdXNCdXR0b24oKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59LCBcclxuXHJcbndpbmRvdy5Db21wb25lbnRzLnBvcG92ZXJHcm91cCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBfX3R5cGU6IFwicG9wb3Zlckdyb3VwXCIsXHJcbiAgICAgICAgaW5pdCgpIHtcclxuICAgICAgICAgICAgbGV0IHQgPSBlID0+IHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY29udGFpbnModGhpcy4kZWwpID8gZS50YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50ICYmICF0aGlzLiRlbC5jb250YWlucyhlLnRhcmdldCkgJiYgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiY2xvc2UtcG9wb3Zlci1ncm91cFwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB0aGlzLiRlbFxyXG4gICAgICAgICAgICAgICAgfSkpIDogd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0LCAhMClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0LCAhMClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0sIFxyXG5cclxud2luZG93LkNvbXBvbmVudHMucG9wb3ZlciA9IGZ1bmN0aW9uKHsgb3BlbjogdCA9ICExLCBmb2N1czogZSA9ICExIH0gPSB7fSkge1xyXG4gICAgY29uc3QgaSA9IFtcIltjb250ZW50RWRpdGFibGU9dHJ1ZV1cIiwgXCJbdGFiaW5kZXhdXCIsIFwiYVtocmVmXVwiLCBcImFyZWFbaHJlZl1cIiwgXCJidXR0b246bm90KFtkaXNhYmxlZF0pXCIsIFwiaWZyYW1lXCIsIFwiaW5wdXQ6bm90KFtkaXNhYmxlZF0pXCIsIFwic2VsZWN0Om5vdChbZGlzYWJsZWRdKVwiLCBcInRleHRhcmVhOm5vdChbZGlzYWJsZWRdKVwiXS5tYXAoKHQgPT4gYCR7dH06bm90KFt0YWJpbmRleD0nLTEnXSlgKSkuam9pbihcIixcIik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIF9fdHlwZTogXCJwb3BvdmVyXCIsXHJcbiAgICAgICAgb3BlbjogdCxcclxuICAgICAgICBpbml0KCkge1xyXG4gICAgICAgICAgICBlICYmIHRoaXMuJHdhdGNoKFwib3BlblwiLCAodCA9PiB7XHJcbiAgICAgICAgICAgICAgICB0ICYmIHRoaXMuJG5leHRUaWNrKCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgISBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBBcnJheS5mcm9tKHQucXVlcnlTZWxlY3RvckFsbChpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICEgZnVuY3Rpb24gdChpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGkgJiYgKGkuZm9jdXMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnRTY3JvbGw6ICEwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gaSAmJiB0KGVbZS5pbmRleE9mKGkpICsgMV0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KGVbMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgfSh0aGlzLiRyZWZzLnBhbmVsKVxyXG4gICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgbGV0IHQgPSBpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLiRlbCkpIHJldHVybiB2b2lkIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdCwgITApO1xyXG4gICAgICAgICAgICAgICAgbGV0IG4gPSBlID8gdGhpcy4kcmVmcy5wYW5lbCA6IHRoaXMuJGVsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3BlbiAmJiBpLnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgIW4uY29udGFpbnMoaS50YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHQgPSB0aGlzLiRlbDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgdC5wYXJlbnROb2RlOylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgPSB0LnBhcmVudE5vZGUsIHQuX194IGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwicG9wb3Zlckdyb3VwXCIgPT09IHQuX194LiRkYXRhLl9fdHlwZSkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwicG9wb3ZlclwiID09PSB0Ll9feC4kZGF0YS5fX3R5cGUpIGJyZWFrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gdGhpcy5vcGVuID0gITFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0LCAhMClcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uRXNjYXBlKCkge1xyXG4gICAgICAgICAgICB0aGlzLm9wZW4gPSAhMSwgdGhpcy5yZXN0b3JlRWwgJiYgdGhpcy5yZXN0b3JlRWwuZm9jdXMoKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25DbG9zZVBvcG92ZXJHcm91cCh0KSB7XHJcbiAgICAgICAgICAgIHQuZGV0YWlsLmNvbnRhaW5zKHRoaXMuJGVsKSAmJiAodGhpcy5vcGVuID0gITEpXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b2dnbGUodCkge1xyXG4gICAgICAgICAgICB0aGlzLm9wZW4gPSAhdGhpcy5vcGVuLCB0aGlzLm9wZW4gPyB0aGlzLnJlc3RvcmVFbCA9IHQuY3VycmVudFRhcmdldCA6IHRoaXMucmVzdG9yZUVsICYmIHRoaXMucmVzdG9yZUVsLmZvY3VzKClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0sXHJcblxyXG53aW5kb3cuQ29tcG9uZW50cy5yYWRpb0dyb3VwID0gZnVuY3Rpb24oeyBpbml0aWFsQ2hlY2tlZEluZGV4OiB0ID0gMCB9ID0ge30pIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmFsdWU6IHZvaWQgMCxcclxuICAgICAgICBpbml0KCkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gQXJyYXkuZnJvbSh0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRcIikpW3RdPy52YWx1ZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSwgXHJcblxyXG53aW5kb3cuQ29tcG9uZW50cy5kZXNjID0gZnVuY3Rpb24oeyBvcGVuOiB0ID0gMSB9ID0ge30pIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgX190eXBlOiBcImRlc2NcIixcclxuICAgICAgICBvcGVuOiB0XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG4iXSwiZmlsZSI6Ii4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMuanMuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components.js\n");

/***/ }),

/***/ "./resources/js/datepicker.js":
/*!************************************!*\
  !*** ./resources/js/datepicker.js ***!
  \************************************/
/***/ (() => {

eval("function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/******/\n(function () {\n  // webpackBootstrap\n\n  /******/\n  \"use strict\";\n\n  var __webpack_exports__ = {};\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/lib/utils.js\n\n  function hasProperty(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n\n  function lastItemOf(arr) {\n    return arr[arr.length - 1];\n  } // push only the items not included in the array\n\n\n  function pushUnique(arr) {\n    for (var _len = arguments.length, items = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      items[_key - 1] = arguments[_key];\n    }\n\n    items.forEach(function (item) {\n      if (arr.includes(item)) {\n        return;\n      }\n\n      arr.push(item);\n    });\n    return arr;\n  }\n\n  function stringToArray(str, separator) {\n    // convert empty string to an empty array\n    return str ? str.split(separator) : [];\n  }\n\n  function isInRange(testVal, min, max) {\n    var minOK = min === undefined || testVal >= min;\n    var maxOK = max === undefined || testVal <= max;\n    return minOK && maxOK;\n  }\n\n  function limitToRange(val, min, max) {\n    if (val < min) {\n      return min;\n    }\n\n    if (val > max) {\n      return max;\n    }\n\n    return val;\n  }\n\n  function createTagRepeat(tagName, repeat) {\n    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var html = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';\n    var openTagSrc = Object.keys(attributes).reduce(function (src, attr) {\n      var val = attributes[attr];\n\n      if (typeof val === 'function') {\n        val = val(index);\n      }\n\n      return \"\".concat(src, \" \").concat(attr, \"=\\\"\").concat(val, \"\\\"\");\n    }, tagName);\n    html += \"<\".concat(openTagSrc, \"></\").concat(tagName, \">\");\n    var next = index + 1;\n    return next < repeat ? createTagRepeat(tagName, repeat, attributes, next, html) : html;\n  } // Remove the spacing surrounding tags for HTML parser not to create text nodes\n  // before/after elements\n\n\n  function optimizeTemplateHTML(html) {\n    return html.replace(/>\\s+/g, '>').replace(/\\s+</, '<');\n  }\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/lib/date.js\n\n  function stripTime(timeValue) {\n    return new Date(timeValue).setHours(0, 0, 0, 0);\n  }\n\n  function today() {\n    return new Date().setHours(0, 0, 0, 0);\n  } // Get the time value of the start of given date or year, month and day\n\n\n  function dateValue() {\n    switch (arguments.length) {\n      case 0:\n        return today();\n\n      case 1:\n        return stripTime(arguments.length <= 0 ? undefined : arguments[0]);\n    } // use setFullYear() to keep 2-digit year from being mapped to 1900-1999\n\n\n    var newDate = new Date(0);\n    newDate.setFullYear.apply(newDate, arguments);\n    return newDate.setHours(0, 0, 0, 0);\n  }\n\n  function addDays(date, amount) {\n    var newDate = new Date(date);\n    return newDate.setDate(newDate.getDate() + amount);\n  }\n\n  function addWeeks(date, amount) {\n    return addDays(date, amount * 7);\n  }\n\n  function addMonths(date, amount) {\n    // If the day of the date is not in the new month, the last day of the new\n    // month will be returned. e.g. Jan 31 + 1 month  Feb 28 (not Mar 03)\n    var newDate = new Date(date);\n    var monthsToSet = newDate.getMonth() + amount;\n    var expectedMonth = monthsToSet % 12;\n\n    if (expectedMonth < 0) {\n      expectedMonth += 12;\n    }\n\n    var time = newDate.setMonth(monthsToSet);\n    return newDate.getMonth() !== expectedMonth ? newDate.setDate(0) : time;\n  }\n\n  function addYears(date, amount) {\n    // If the date is Feb 29 and the new year is not a leap year, Feb 28 of the\n    // new year will be returned.\n    var newDate = new Date(date);\n    var expectedMonth = newDate.getMonth();\n    var time = newDate.setFullYear(newDate.getFullYear() + amount);\n    return expectedMonth === 1 && newDate.getMonth() === 2 ? newDate.setDate(0) : time;\n  } // Calculate the distance bettwen 2 days of the week\n\n\n  function dayDiff(day, from) {\n    return (day - from + 7) % 7;\n  } // Get the date of the specified day of the week of given base date\n\n\n  function dayOfTheWeekOf(baseDate, dayOfWeek) {\n    var weekStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var baseDay = new Date(baseDate).getDay();\n    return addDays(baseDate, dayDiff(dayOfWeek, weekStart) - dayDiff(baseDay, weekStart));\n  } // Get the ISO week of a date\n\n\n  function getWeek(date) {\n    // start of ISO week is Monday\n    var thuOfTheWeek = dayOfTheWeekOf(date, 4, 1); // 1st week == the week where the 4th of January is in\n\n    var firstThu = dayOfTheWeekOf(new Date(thuOfTheWeek).setMonth(0, 4), 4, 1);\n    return Math.round((thuOfTheWeek - firstThu) / 604800000) + 1;\n  } // Get the start year of the period of years that includes given date\n  // years: length of the year period\n\n\n  function startOfYearPeriod(date, years) {\n    /* @see https://en.wikipedia.org/wiki/Year_zero#ISO_8601 */\n    var year = new Date(date).getFullYear();\n    return Math.floor(year / years) * years;\n  }\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/lib/date-format.js\n  // pattern for format parts\n\n  var reFormatTokens = /dd?|DD?|mm?|MM?|yy?(?:yy)?/; // pattern for non date parts\n\n  var reNonDateParts = /[\\s!-/:-@[-`{-~]+/; // cache for persed formats\n\n  var knownFormats = {}; // parse funtions for date parts\n\n  var parseFns = {\n    y: function y(date, year) {\n      return new Date(date).setFullYear(parseInt(year, 10));\n    },\n    m: function m(date, month, locale) {\n      var newDate = new Date(date);\n      var monthIndex = parseInt(month, 10) - 1;\n\n      if (isNaN(monthIndex)) {\n        if (!month) {\n          return NaN;\n        }\n\n        var monthName = month.toLowerCase();\n\n        var compareNames = function compareNames(name) {\n          return name.toLowerCase().startsWith(monthName);\n        }; // compare with both short and full names because some locales have periods\n        // in the short names (not equal to the first X letters of the full names)\n\n\n        monthIndex = locale.monthsShort.findIndex(compareNames);\n\n        if (monthIndex < 0) {\n          monthIndex = locale.months.findIndex(compareNames);\n        }\n\n        if (monthIndex < 0) {\n          return NaN;\n        }\n      }\n\n      newDate.setMonth(monthIndex);\n      return newDate.getMonth() !== normalizeMonth(monthIndex) ? newDate.setDate(0) : newDate.getTime();\n    },\n    d: function d(date, day) {\n      return new Date(date).setDate(parseInt(day, 10));\n    }\n  }; // format functions for date parts\n\n  var formatFns = {\n    d: function d(date) {\n      return date.getDate();\n    },\n    dd: function dd(date) {\n      return padZero(date.getDate(), 2);\n    },\n    D: function D(date, locale) {\n      return locale.daysShort[date.getDay()];\n    },\n    DD: function DD(date, locale) {\n      return locale.days[date.getDay()];\n    },\n    m: function m(date) {\n      return date.getMonth() + 1;\n    },\n    mm: function mm(date) {\n      return padZero(date.getMonth() + 1, 2);\n    },\n    M: function M(date, locale) {\n      return locale.monthsShort[date.getMonth()];\n    },\n    MM: function MM(date, locale) {\n      return locale.months[date.getMonth()];\n    },\n    y: function y(date) {\n      return date.getFullYear();\n    },\n    yy: function yy(date) {\n      return padZero(date.getFullYear(), 2).slice(-2);\n    },\n    yyyy: function yyyy(date) {\n      return padZero(date.getFullYear(), 4);\n    }\n  }; // get month index in normal range (0 - 11) from any number\n\n  function normalizeMonth(monthIndex) {\n    return monthIndex > -1 ? monthIndex % 12 : normalizeMonth(monthIndex + 12);\n  }\n\n  function padZero(num, length) {\n    return num.toString().padStart(length, '0');\n  }\n\n  function parseFormatString(format) {\n    if (typeof format !== 'string') {\n      throw new Error(\"Invalid date format.\");\n    }\n\n    if (format in knownFormats) {\n      return knownFormats[format];\n    } // sprit the format string into parts and seprators\n\n\n    var separators = format.split(reFormatTokens);\n    var parts = format.match(new RegExp(reFormatTokens, 'g'));\n\n    if (separators.length === 0 || !parts) {\n      throw new Error(\"Invalid date format.\");\n    } // collect format functions used in the format\n\n\n    var partFormatters = parts.map(function (token) {\n      return formatFns[token];\n    }); // collect parse function keys used in the format\n    // iterate over parseFns' keys in order to keep the order of the keys.\n\n    var partParserKeys = Object.keys(parseFns).reduce(function (keys, key) {\n      var token = parts.find(function (part) {\n        return part[0] !== 'D' && part[0].toLowerCase() === key;\n      });\n\n      if (token) {\n        keys.push(key);\n      }\n\n      return keys;\n    }, []);\n    return knownFormats[format] = {\n      parser: function parser(dateStr, locale) {\n        var dateParts = dateStr.split(reNonDateParts).reduce(function (dtParts, part, index) {\n          if (part.length > 0 && parts[index]) {\n            var token = parts[index][0];\n\n            if (token === 'M') {\n              dtParts.m = part;\n            } else if (token !== 'D') {\n              dtParts[token] = part;\n            }\n          }\n\n          return dtParts;\n        }, {}); // iterate over partParserkeys so that the parsing is made in the oder\n        // of year, month and day to prevent the day parser from correcting last\n        // day of month wrongly\n\n        return partParserKeys.reduce(function (origDate, key) {\n          var newDate = parseFns[key](origDate, dateParts[key], locale); // ingnore the part failed to parse\n\n          return isNaN(newDate) ? origDate : newDate;\n        }, today());\n      },\n      formatter: function formatter(date, locale) {\n        var dateStr = partFormatters.reduce(function (str, fn, index) {\n          return str += \"\".concat(separators[index]).concat(fn(date, locale));\n        }, ''); // separators' length is always parts' length + 1,\n\n        return dateStr += lastItemOf(separators);\n      }\n    };\n  }\n\n  function _parseDate(dateStr, format, locale) {\n    if (dateStr instanceof Date || typeof dateStr === 'number') {\n      var date = stripTime(dateStr);\n      return isNaN(date) ? undefined : date;\n    }\n\n    if (!dateStr) {\n      return undefined;\n    }\n\n    if (dateStr === 'today') {\n      return today();\n    }\n\n    if (format && format.toValue) {\n      var _date = format.toValue(dateStr, format, locale);\n\n      return isNaN(_date) ? undefined : stripTime(_date);\n    }\n\n    return parseFormatString(format).parser(dateStr, locale);\n  }\n\n  function _formatDate(date, format, locale) {\n    if (isNaN(date) || !date && date !== 0) {\n      return '';\n    }\n\n    var dateObj = typeof date === 'number' ? new Date(date) : date;\n\n    if (format.toDisplay) {\n      return format.toDisplay(dateObj, format, locale);\n    }\n\n    return parseFormatString(format).formatter(dateObj, locale);\n  }\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/lib/event.js\n\n  var listenerRegistry = new WeakMap();\n  var _EventTarget$prototyp = EventTarget.prototype,\n      addEventListener = _EventTarget$prototyp.addEventListener,\n      removeEventListener = _EventTarget$prototyp.removeEventListener; // Register event listeners to a key object\n  // listeners: array of listener definitions;\n  //   - each definition must be a flat array of event target and the arguments\n  //     used to call addEventListener() on the target\n\n  function registerListeners(keyObj, listeners) {\n    var registered = listenerRegistry.get(keyObj);\n\n    if (!registered) {\n      registered = [];\n      listenerRegistry.set(keyObj, registered);\n    }\n\n    listeners.forEach(function (listener) {\n      addEventListener.call.apply(addEventListener, _toConsumableArray(listener));\n      registered.push(listener);\n    });\n  }\n\n  function unregisterListeners(keyObj) {\n    var listeners = listenerRegistry.get(keyObj);\n\n    if (!listeners) {\n      return;\n    }\n\n    listeners.forEach(function (listener) {\n      removeEventListener.call.apply(removeEventListener, _toConsumableArray(listener));\n    });\n    listenerRegistry[\"delete\"](keyObj);\n  } // Event.composedPath() polyfill for Edge\n  // based on https://gist.github.com/kleinfreund/e9787d73776c0e3750dcfcdc89f100ec\n\n\n  if (!Event.prototype.composedPath) {\n    var getComposedPath = function getComposedPath(node) {\n      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      path.push(node);\n      var parent;\n\n      if (node.parentNode) {\n        parent = node.parentNode;\n      } else if (node.host) {\n        // ShadowRoot\n        parent = node.host;\n      } else if (node.defaultView) {\n        // Document\n        parent = node.defaultView;\n      }\n\n      return parent ? getComposedPath(parent, path) : path;\n    };\n\n    Event.prototype.composedPath = function () {\n      return getComposedPath(this.target);\n    };\n  }\n\n  function findFromPath(path, criteria, currentTarget) {\n    var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var el = path[index];\n\n    if (criteria(el)) {\n      return el;\n    } else if (el === currentTarget || !el.parentElement) {\n      // stop when reaching currentTarget or <html>\n      return;\n    }\n\n    return findFromPath(path, criteria, currentTarget, index + 1);\n  } // Search for the actual target of a delegated event\n\n\n  function findElementInEventPath(ev, selector) {\n    var criteria = typeof selector === 'function' ? selector : function (el) {\n      return el.matches(selector);\n    };\n    return findFromPath(ev.composedPath(), criteria, ev.currentTarget);\n  }\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/i18n/base-locales.js\n  // default locales\n\n  var locales = {\n    en: {\n      days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n      daysShort: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n      daysMin: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"],\n      months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n      monthsShort: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n      today: \"Today\",\n      clear: \"Clear\",\n      titleFormat: \"MM y\"\n    }\n  };\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/options/defaultOptions.js\n  // config options updatable by setOptions() and their default values\n\n  var defaultOptions = {\n    autohide: false,\n    beforeShowDay: null,\n    beforeShowDecade: null,\n    beforeShowMonth: null,\n    beforeShowYear: null,\n    calendarWeeks: false,\n    clearBtn: false,\n    dateDelimiter: ',',\n    datesDisabled: [],\n    daysOfWeekDisabled: [],\n    daysOfWeekHighlighted: [],\n    defaultViewDate: undefined,\n    // placeholder, defaults to today() by the program\n    disableTouchKeyboard: false,\n    format: 'mm/dd/yyyy',\n    language: 'en',\n    maxDate: null,\n    maxNumberOfDates: 1,\n    maxView: 3,\n    minDate: null,\n    nextArrow: '<svg class=\"w-4 h-4\" fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" d=\"M12.293 5.293a1 1 0 011.414 0l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-2.293-2.293a1 1 0 010-1.414z\" clip-rule=\"evenodd\"></path></svg>',\n    orientation: 'auto',\n    pickLevel: 0,\n    prevArrow: '<svg class=\"w-4 h-4\" fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" d=\"M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z\" clip-rule=\"evenodd\"></path></svg>',\n    showDaysOfWeek: true,\n    showOnClick: true,\n    showOnFocus: true,\n    startView: 0,\n    title: '',\n    todayBtn: false,\n    todayBtnMode: 0,\n    todayHighlight: false,\n    updateOnBlur: true,\n    weekStart: 0\n  };\n  /* harmony default export */\n\n  var options_defaultOptions = defaultOptions;\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/lib/dom.js\n\n  var range = document.createRange();\n\n  function parseHTML(html) {\n    return range.createContextualFragment(html);\n  } // equivalent to jQuery's :visble\n\n\n  function isVisible(el) {\n    return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length);\n  }\n\n  function hideElement(el) {\n    if (el.style.display === 'none') {\n      return;\n    } // back up the existing display setting in data-style-display\n\n\n    if (el.style.display) {\n      el.dataset.styleDisplay = el.style.display;\n    }\n\n    el.style.display = 'none';\n  }\n\n  function showElement(el) {\n    if (el.style.display !== 'none') {\n      return;\n    }\n\n    if (el.dataset.styleDisplay) {\n      // restore backed-up dispay property\n      el.style.display = el.dataset.styleDisplay;\n      delete el.dataset.styleDisplay;\n    } else {\n      el.style.display = '';\n    }\n  }\n\n  function emptyChildNodes(el) {\n    if (el.firstChild) {\n      el.removeChild(el.firstChild);\n      emptyChildNodes(el);\n    }\n  }\n\n  function replaceChildNodes(el, newChildNodes) {\n    emptyChildNodes(el);\n\n    if (newChildNodes instanceof DocumentFragment) {\n      el.appendChild(newChildNodes);\n    } else if (typeof newChildNodes === 'string') {\n      el.appendChild(parseHTML(newChildNodes));\n    } else if (typeof newChildNodes.forEach === 'function') {\n      newChildNodes.forEach(function (node) {\n        el.appendChild(node);\n      });\n    }\n  }\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/options/processOptions.js\n\n  var defaultLang = options_defaultOptions.language,\n      defaultFormat = options_defaultOptions.format,\n      defaultWeekStart = options_defaultOptions.weekStart; // Reducer function to filter out invalid day-of-week from the input\n\n  function sanitizeDOW(dow, day) {\n    return dow.length < 6 && day >= 0 && day < 7 ? pushUnique(dow, day) : dow;\n  }\n\n  function calcEndOfWeek(startOfWeek) {\n    return (startOfWeek + 6) % 7;\n  } // validate input date. if invalid, fallback to the original value\n\n\n  function validateDate(value, format, locale, origValue) {\n    var date = _parseDate(value, format, locale);\n\n    return date !== undefined ? date : origValue;\n  } // Validate viewId. if invalid, fallback to the original value\n\n\n  function validateViewId(value, origValue) {\n    var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;\n    var viewId = parseInt(value, 10);\n    return viewId >= 0 && viewId <= max ? viewId : origValue;\n  } // Create Datepicker configuration to set\n\n\n  function processOptions(options, datepicker) {\n    var inOpts = Object.assign({}, options);\n    var config = {};\n    var locales = datepicker.constructor.locales;\n\n    var _ref = datepicker.config || {},\n        format = _ref.format,\n        language = _ref.language,\n        locale = _ref.locale,\n        maxDate = _ref.maxDate,\n        maxView = _ref.maxView,\n        minDate = _ref.minDate,\n        pickLevel = _ref.pickLevel,\n        startView = _ref.startView,\n        weekStart = _ref.weekStart;\n\n    if (inOpts.language) {\n      var lang;\n\n      if (inOpts.language !== language) {\n        if (locales[inOpts.language]) {\n          lang = inOpts.language;\n        } else {\n          // Check if langauge + region tag can fallback to the one without\n          // region (e.g. fr-CA  fr)\n          lang = inOpts.language.split('-')[0];\n\n          if (locales[lang] === undefined) {\n            lang = false;\n          }\n        }\n      }\n\n      delete inOpts.language;\n\n      if (lang) {\n        language = config.language = lang; // update locale as well when updating language\n\n        var origLocale = locale || locales[defaultLang]; // use default language's properties for the fallback\n\n        locale = Object.assign({\n          format: defaultFormat,\n          weekStart: defaultWeekStart\n        }, locales[defaultLang]);\n\n        if (language !== defaultLang) {\n          Object.assign(locale, locales[language]);\n        }\n\n        config.locale = locale; // if format and/or weekStart are the same as old locale's defaults,\n        // update them to new locale's defaults\n\n        if (format === origLocale.format) {\n          format = config.format = locale.format;\n        }\n\n        if (weekStart === origLocale.weekStart) {\n          weekStart = config.weekStart = locale.weekStart;\n          config.weekEnd = calcEndOfWeek(locale.weekStart);\n        }\n      }\n    }\n\n    if (inOpts.format) {\n      var hasToDisplay = typeof inOpts.format.toDisplay === 'function';\n      var hasToValue = typeof inOpts.format.toValue === 'function';\n      var validFormatString = reFormatTokens.test(inOpts.format);\n\n      if (hasToDisplay && hasToValue || validFormatString) {\n        format = config.format = inOpts.format;\n      }\n\n      delete inOpts.format;\n    } //*** dates ***//\n    // while min and maxDate for \"no limit\" in the options are better to be null\n    // (especially when updating), the ones in the config have to be undefined\n    // because null is treated as 0 (= unix epoch) when comparing with time value\n\n\n    var minDt = minDate;\n    var maxDt = maxDate;\n\n    if (inOpts.minDate !== undefined) {\n      minDt = inOpts.minDate === null ? dateValue(0, 0, 1) // set 0000-01-01 to prevent negative values for year\n      : validateDate(inOpts.minDate, format, locale, minDt);\n      delete inOpts.minDate;\n    }\n\n    if (inOpts.maxDate !== undefined) {\n      maxDt = inOpts.maxDate === null ? undefined : validateDate(inOpts.maxDate, format, locale, maxDt);\n      delete inOpts.maxDate;\n    }\n\n    if (maxDt < minDt) {\n      minDate = config.minDate = maxDt;\n      maxDate = config.maxDate = minDt;\n    } else {\n      if (minDate !== minDt) {\n        minDate = config.minDate = minDt;\n      }\n\n      if (maxDate !== maxDt) {\n        maxDate = config.maxDate = maxDt;\n      }\n    }\n\n    if (inOpts.datesDisabled) {\n      config.datesDisabled = inOpts.datesDisabled.reduce(function (dates, dt) {\n        var date = _parseDate(dt, format, locale);\n\n        return date !== undefined ? pushUnique(dates, date) : dates;\n      }, []);\n      delete inOpts.datesDisabled;\n    }\n\n    if (inOpts.defaultViewDate !== undefined) {\n      var viewDate = _parseDate(inOpts.defaultViewDate, format, locale);\n\n      if (viewDate !== undefined) {\n        config.defaultViewDate = viewDate;\n      }\n\n      delete inOpts.defaultViewDate;\n    } //*** days of week ***//\n\n\n    if (inOpts.weekStart !== undefined) {\n      var wkStart = Number(inOpts.weekStart) % 7;\n\n      if (!isNaN(wkStart)) {\n        weekStart = config.weekStart = wkStart;\n        config.weekEnd = calcEndOfWeek(wkStart);\n      }\n\n      delete inOpts.weekStart;\n    }\n\n    if (inOpts.daysOfWeekDisabled) {\n      config.daysOfWeekDisabled = inOpts.daysOfWeekDisabled.reduce(sanitizeDOW, []);\n      delete inOpts.daysOfWeekDisabled;\n    }\n\n    if (inOpts.daysOfWeekHighlighted) {\n      config.daysOfWeekHighlighted = inOpts.daysOfWeekHighlighted.reduce(sanitizeDOW, []);\n      delete inOpts.daysOfWeekHighlighted;\n    } //*** multi date ***//\n\n\n    if (inOpts.maxNumberOfDates !== undefined) {\n      var maxNumberOfDates = parseInt(inOpts.maxNumberOfDates, 10);\n\n      if (maxNumberOfDates >= 0) {\n        config.maxNumberOfDates = maxNumberOfDates;\n        config.multidate = maxNumberOfDates !== 1;\n      }\n\n      delete inOpts.maxNumberOfDates;\n    }\n\n    if (inOpts.dateDelimiter) {\n      config.dateDelimiter = String(inOpts.dateDelimiter);\n      delete inOpts.dateDelimiter;\n    } //*** pick level & view ***//\n\n\n    var newPickLevel = pickLevel;\n\n    if (inOpts.pickLevel !== undefined) {\n      newPickLevel = validateViewId(inOpts.pickLevel, 2);\n      delete inOpts.pickLevel;\n    }\n\n    if (newPickLevel !== pickLevel) {\n      pickLevel = config.pickLevel = newPickLevel;\n    }\n\n    var newMaxView = maxView;\n\n    if (inOpts.maxView !== undefined) {\n      newMaxView = validateViewId(inOpts.maxView, maxView);\n      delete inOpts.maxView;\n    } // ensure max view >= pick level\n\n\n    newMaxView = pickLevel > newMaxView ? pickLevel : newMaxView;\n\n    if (newMaxView !== maxView) {\n      maxView = config.maxView = newMaxView;\n    }\n\n    var newStartView = startView;\n\n    if (inOpts.startView !== undefined) {\n      newStartView = validateViewId(inOpts.startView, newStartView);\n      delete inOpts.startView;\n    } // ensure pick level <= start view <= max view\n\n\n    if (newStartView < pickLevel) {\n      newStartView = pickLevel;\n    } else if (newStartView > maxView) {\n      newStartView = maxView;\n    }\n\n    if (newStartView !== startView) {\n      config.startView = newStartView;\n    } //*** template ***//\n\n\n    if (inOpts.prevArrow) {\n      var prevArrow = parseHTML(inOpts.prevArrow);\n\n      if (prevArrow.childNodes.length > 0) {\n        config.prevArrow = prevArrow.childNodes;\n      }\n\n      delete inOpts.prevArrow;\n    }\n\n    if (inOpts.nextArrow) {\n      var nextArrow = parseHTML(inOpts.nextArrow);\n\n      if (nextArrow.childNodes.length > 0) {\n        config.nextArrow = nextArrow.childNodes;\n      }\n\n      delete inOpts.nextArrow;\n    } //*** misc ***//\n\n\n    if (inOpts.disableTouchKeyboard !== undefined) {\n      config.disableTouchKeyboard = 'ontouchstart' in document && !!inOpts.disableTouchKeyboard;\n      delete inOpts.disableTouchKeyboard;\n    }\n\n    if (inOpts.orientation) {\n      var orientation = inOpts.orientation.toLowerCase().split(/\\s+/g);\n      config.orientation = {\n        x: orientation.find(function (x) {\n          return x === 'left' || x === 'right';\n        }) || 'auto',\n        y: orientation.find(function (y) {\n          return y === 'top' || y === 'bottom';\n        }) || 'auto'\n      };\n      delete inOpts.orientation;\n    }\n\n    if (inOpts.todayBtnMode !== undefined) {\n      switch (inOpts.todayBtnMode) {\n        case 0:\n        case 1:\n          config.todayBtnMode = inOpts.todayBtnMode;\n      }\n\n      delete inOpts.todayBtnMode;\n    } //*** copy the rest ***//\n\n\n    Object.keys(inOpts).forEach(function (key) {\n      if (inOpts[key] !== undefined && hasProperty(options_defaultOptions, key)) {\n        config[key] = inOpts[key];\n      }\n    });\n    return config;\n  }\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/picker/templates/pickerTemplate.js\n\n  var pickerTemplate = optimizeTemplateHTML(\"<div class=\\\"datepicker hidden\\\">\\n  <div class=\\\"datepicker-picker inline-block rounded-lg bg-white dark:bg-gray-700 shadow-lg p-4\\\">\\n    <div class=\\\"datepicker-header\\\">\\n      <div class=\\\"datepicker-title bg-white dark:bg-gray-700 dark:text-white px-2 py-3 text-center font-semibold\\\"></div>\\n      <div class=\\\"datepicker-controls flex justify-between mb-2\\\">\\n        <button type=\\\"button\\\" class=\\\"bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 prev-btn\\\"></button>\\n        <button type=\\\"button\\\" class=\\\"text-sm rounded-lg text-gray-900 dark:text-white bg-white dark:bg-gray-700 font-semibold py-2.5 px-5 hover:bg-gray-100 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-200 view-switch\\\"></button>\\n        <button type=\\\"button\\\" class=\\\"bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 next-btn\\\"></button>\\n      </div>\\n    </div>\\n    <div class=\\\"datepicker-main p-1\\\"></div>\\n    <div class=\\\"datepicker-footer\\\">\\n      <div class=\\\"datepicker-controls flex space-x-2 mt-2\\\">\\n        <button type=\\\"button\\\" class=\\\"%buttonClass% today-btn text-white bg-blue-700 dark:bg-blue-600 hover:bg-blue-800 dark:hover:bg-blue-700 focus:ring-4 focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2\\\"></button>\\n        <button type=\\\"button\\\" class=\\\"%buttonClass% clear-btn text-gray-900 dark:text-white bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-600 focus:ring-4 focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2\\\"></button>\\n      </div>\\n    </div>\\n  </div>\\n</div>\");\n  /* harmony default export */\n\n  var templates_pickerTemplate = pickerTemplate;\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/picker/templates/daysTemplate.js\n\n  var daysTemplate = optimizeTemplateHTML(\"<div class=\\\"days\\\">\\n  <div class=\\\"days-of-week grid grid-cols-7 mb-1\\\">\".concat(createTagRepeat('span', 7, {\n    \"class\": 'dow block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm'\n  }), \"</div>\\n  <div class=\\\"datepicker-grid w-64 grid grid-cols-7\\\">\").concat(createTagRepeat('span', 42, {\n    \"class\": 'block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400'\n  }), \"</div>\\n</div>\"));\n  /* harmony default export */\n\n  var templates_daysTemplate = daysTemplate;\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/picker/templates/calendarWeeksTemplate.js\n\n  var calendarWeeksTemplate = optimizeTemplateHTML(\"<div class=\\\"calendar-weeks\\\">\\n  <div class=\\\"days-of-week flex\\\"><span class=\\\"dow h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400\\\"></span></div>\\n  <div class=\\\"weeks\\\">\".concat(createTagRepeat('span', 6, {\n    \"class\": 'week block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm'\n  }), \"</div>\\n</div>\"));\n  /* harmony default export */\n\n  var templates_calendarWeeksTemplate = calendarWeeksTemplate;\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/picker/views/View.js\n  // Base class of the view classes\n\n  var View = /*#__PURE__*/function () {\n    function View(picker, config) {\n      _classCallCheck(this, View);\n\n      Object.assign(this, config, {\n        picker: picker,\n        element: parseHTML(\"<div class=\\\"datepicker-view flex\\\"></div>\").firstChild,\n        selected: []\n      });\n      this.init(this.picker.datepicker.config);\n    }\n\n    _createClass(View, [{\n      key: \"init\",\n      value: function init(options) {\n        if (options.pickLevel !== undefined) {\n          this.isMinView = this.id === options.pickLevel;\n        }\n\n        this.setOptions(options);\n        this.updateFocus();\n        this.updateSelection();\n      } // Execute beforeShow() callback and apply the result to the element\n      // args:\n      // - current - current value on the iteration on view rendering\n      // - timeValue - time value of the date to pass to beforeShow()\n\n    }, {\n      key: \"performBeforeHook\",\n      value: function performBeforeHook(el, current, timeValue) {\n        var result = this.beforeShow(new Date(timeValue));\n\n        switch (_typeof(result)) {\n          case 'boolean':\n            result = {\n              enabled: result\n            };\n            break;\n\n          case 'string':\n            result = {\n              classes: result\n            };\n        }\n\n        if (result) {\n          if (result.enabled === false) {\n            el.classList.add('disabled');\n            pushUnique(this.disabled, current);\n          }\n\n          if (result.classes) {\n            var _el$classList;\n\n            var extraClasses = result.classes.split(/\\s+/);\n\n            (_el$classList = el.classList).add.apply(_el$classList, _toConsumableArray(extraClasses));\n\n            if (extraClasses.includes('disabled')) {\n              pushUnique(this.disabled, current);\n            }\n          }\n\n          if (result.content) {\n            replaceChildNodes(el, result.content);\n          }\n        }\n      }\n    }]);\n\n    return View;\n  }();\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/picker/views/DaysView.js\n\n  var DaysView = /*#__PURE__*/function (_View) {\n    _inherits(DaysView, _View);\n\n    var _super = _createSuper(DaysView);\n\n    function DaysView(picker) {\n      _classCallCheck(this, DaysView);\n\n      return _super.call(this, picker, {\n        id: 0,\n        name: 'days',\n        cellClass: 'day'\n      });\n    }\n\n    _createClass(DaysView, [{\n      key: \"init\",\n      value: function init(options) {\n        var onConstruction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (onConstruction) {\n          var inner = parseHTML(templates_daysTemplate).firstChild;\n          this.dow = inner.firstChild;\n          this.grid = inner.lastChild;\n          this.element.appendChild(inner);\n        }\n\n        _get(_getPrototypeOf(DaysView.prototype), \"init\", this).call(this, options);\n      }\n    }, {\n      key: \"setOptions\",\n      value: function setOptions(options) {\n        var _this = this;\n\n        var updateDOW;\n\n        if (hasProperty(options, 'minDate')) {\n          this.minDate = options.minDate;\n        }\n\n        if (hasProperty(options, 'maxDate')) {\n          this.maxDate = options.maxDate;\n        }\n\n        if (options.datesDisabled) {\n          this.datesDisabled = options.datesDisabled;\n        }\n\n        if (options.daysOfWeekDisabled) {\n          this.daysOfWeekDisabled = options.daysOfWeekDisabled;\n          updateDOW = true;\n        }\n\n        if (options.daysOfWeekHighlighted) {\n          this.daysOfWeekHighlighted = options.daysOfWeekHighlighted;\n        }\n\n        if (options.todayHighlight !== undefined) {\n          this.todayHighlight = options.todayHighlight;\n        }\n\n        if (options.weekStart !== undefined) {\n          this.weekStart = options.weekStart;\n          this.weekEnd = options.weekEnd;\n          updateDOW = true;\n        }\n\n        if (options.locale) {\n          var locale = this.locale = options.locale;\n          this.dayNames = locale.daysMin;\n          this.switchLabelFormat = locale.titleFormat;\n          updateDOW = true;\n        }\n\n        if (options.beforeShowDay !== undefined) {\n          this.beforeShow = typeof options.beforeShowDay === 'function' ? options.beforeShowDay : undefined;\n        }\n\n        if (options.calendarWeeks !== undefined) {\n          if (options.calendarWeeks && !this.calendarWeeks) {\n            var weeksElem = parseHTML(templates_calendarWeeksTemplate).firstChild;\n            this.calendarWeeks = {\n              element: weeksElem,\n              dow: weeksElem.firstChild,\n              weeks: weeksElem.lastChild\n            };\n            this.element.insertBefore(weeksElem, this.element.firstChild);\n          } else if (this.calendarWeeks && !options.calendarWeeks) {\n            this.element.removeChild(this.calendarWeeks.element);\n            this.calendarWeeks = null;\n          }\n        }\n\n        if (options.showDaysOfWeek !== undefined) {\n          if (options.showDaysOfWeek) {\n            showElement(this.dow);\n\n            if (this.calendarWeeks) {\n              showElement(this.calendarWeeks.dow);\n            }\n          } else {\n            hideElement(this.dow);\n\n            if (this.calendarWeeks) {\n              hideElement(this.calendarWeeks.dow);\n            }\n          }\n        } // update days-of-week when locale, daysOfweekDisabled or weekStart is changed\n\n\n        if (updateDOW) {\n          Array.from(this.dow.children).forEach(function (el, index) {\n            var dow = (_this.weekStart + index) % 7;\n            el.textContent = _this.dayNames[dow];\n            el.className = _this.daysOfWeekDisabled.includes(dow) ? 'dow disabled text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400 cursor-not-allowed' : 'dow text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400';\n          });\n        }\n      } // Apply update on the focused date to view's settings\n\n    }, {\n      key: \"updateFocus\",\n      value: function updateFocus() {\n        var viewDate = new Date(this.picker.viewDate);\n        var viewYear = viewDate.getFullYear();\n        var viewMonth = viewDate.getMonth();\n        var firstOfMonth = dateValue(viewYear, viewMonth, 1);\n        var start = dayOfTheWeekOf(firstOfMonth, this.weekStart, this.weekStart);\n        this.first = firstOfMonth;\n        this.last = dateValue(viewYear, viewMonth + 1, 0);\n        this.start = start;\n        this.focused = this.picker.viewDate;\n      } // Apply update on the selected dates to view's settings\n\n    }, {\n      key: \"updateSelection\",\n      value: function updateSelection() {\n        var _this$picker$datepick = this.picker.datepicker,\n            dates = _this$picker$datepick.dates,\n            rangepicker = _this$picker$datepick.rangepicker;\n        this.selected = dates;\n\n        if (rangepicker) {\n          this.range = rangepicker.dates;\n        }\n      } // Update the entire view UI\n\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this2 = this;\n\n        // update today marker on ever render\n        this.today = this.todayHighlight ? today() : undefined; // refresh disabled dates on every render in order to clear the ones added\n        // by beforeShow hook at previous render\n\n        this.disabled = _toConsumableArray(this.datesDisabled);\n\n        var switchLabel = _formatDate(this.focused, this.switchLabelFormat, this.locale);\n\n        this.picker.setViewSwitchLabel(switchLabel);\n        this.picker.setPrevBtnDisabled(this.first <= this.minDate);\n        this.picker.setNextBtnDisabled(this.last >= this.maxDate);\n\n        if (this.calendarWeeks) {\n          // start of the UTC week (Monday) of the 1st of the month\n          var startOfWeek = dayOfTheWeekOf(this.first, 1, 1);\n          Array.from(this.calendarWeeks.weeks.children).forEach(function (el, index) {\n            el.textContent = getWeek(addWeeks(startOfWeek, index));\n          });\n        }\n\n        Array.from(this.grid.children).forEach(function (el, index) {\n          var classList = el.classList;\n          var current = addDays(_this2.start, index);\n          var date = new Date(current);\n          var day = date.getDay();\n          el.className = \"datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm \".concat(_this2.cellClass);\n          el.dataset.date = current;\n          el.textContent = date.getDate();\n\n          if (current < _this2.first) {\n            classList.add('prev', 'text-gray-500', 'dark:text-white');\n          } else if (current > _this2.last) {\n            classList.add('next', 'text-gray-500', 'dark:text-white');\n          }\n\n          if (_this2.today === current) {\n            classList.add('today', 'bg-gray-100', 'dark:bg-gray-600', 'dark:bg-gray-600');\n          }\n\n          if (current < _this2.minDate || current > _this2.maxDate || _this2.disabled.includes(current)) {\n            classList.add('disabled', 'cursor-not-allowed');\n          }\n\n          if (_this2.daysOfWeekDisabled.includes(day)) {\n            classList.add('disabled', 'cursor-not-allowed');\n            pushUnique(_this2.disabled, current);\n          }\n\n          if (_this2.daysOfWeekHighlighted.includes(day)) {\n            classList.add('highlighted');\n          }\n\n          if (_this2.range) {\n            var _this2$range = _slicedToArray(_this2.range, 2),\n                rangeStart = _this2$range[0],\n                rangeEnd = _this2$range[1];\n\n            if (current > rangeStart && current < rangeEnd) {\n              classList.add('range', 'bg-gray-200', 'dark:bg-gray-600');\n              classList.remove('rounded-lg', 'rounded-l-lg', 'rounded-r-lg');\n            }\n\n            if (current === rangeStart) {\n              classList.add('range-start', 'bg-gray-100', 'dark:bg-gray-600', 'rounded-l-lg');\n              classList.remove('rounded-lg', 'rounded-r-lg');\n            }\n\n            if (current === rangeEnd) {\n              classList.add('range-end', 'bg-gray-100', 'dark:bg-gray-600', 'rounded-r-lg');\n              classList.remove('rounded-lg', 'rounded-l-lg');\n            }\n          }\n\n          if (_this2.selected.includes(current)) {\n            classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');\n            classList.remove('text-gray-900', 'text-gray-500', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');\n          }\n\n          if (current === _this2.focused) {\n            classList.add('focused');\n          }\n\n          if (_this2.beforeShow) {\n            _this2.performBeforeHook(el, current, current);\n          }\n        });\n      } // Update the view UI by applying the changes of selected and focused items\n\n    }, {\n      key: \"refresh\",\n      value: function refresh() {\n        var _this3 = this;\n\n        var _ref2 = this.range || [],\n            _ref3 = _slicedToArray(_ref2, 2),\n            rangeStart = _ref3[0],\n            rangeEnd = _ref3[1];\n\n        this.grid.querySelectorAll('.range, .range-start, .range-end, .selected, .focused').forEach(function (el) {\n          el.classList.remove('range', 'range-start', 'range-end', 'selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white', 'focused', 'bg-gray-100', 'dark:bg-gray-600');\n          el.classList.add('text-gray-900', 'rounded-lg', 'dark:text-white');\n        });\n        Array.from(this.grid.children).forEach(function (el) {\n          var current = Number(el.dataset.date);\n          var classList = el.classList;\n\n          if (current > rangeStart && current < rangeEnd) {\n            classList.add('range', 'bg-gray-200', 'dark:bg-gray-600');\n            classList.remove('rounded-lg');\n          }\n\n          if (current === rangeStart) {\n            classList.add('range-start', 'bg-gray-200', 'dark:bg-gray-600', 'rounded-l-lg');\n            classList.remove('rounded-lg', 'rounded-r-lg');\n          }\n\n          if (current === rangeEnd) {\n            classList.add('range-end', 'bg-gray-200', 'dark:bg-gray-600', 'rounded-r-lg');\n            classList.remove('rounded-lg', 'rounded-l-lg');\n          }\n\n          if (_this3.selected.includes(current)) {\n            classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');\n            classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');\n          }\n\n          if (current === _this3.focused) {\n            classList.add('focused', 'bg-gray-100', 'dark:bg-gray-600');\n          }\n        });\n      } // Update the view UI by applying the change of focused item\n\n    }, {\n      key: \"refreshFocus\",\n      value: function refreshFocus() {\n        var index = Math.round((this.focused - this.start) / 86400000);\n        this.grid.querySelectorAll('.focused').forEach(function (el) {\n          el.classList.remove('focused', 'bg-gray-100', 'dark:bg-gray-600');\n        });\n        this.grid.children[index].classList.add('focused', 'bg-gray-100', 'dark:bg-gray-600');\n      }\n    }]);\n\n    return DaysView;\n  }(View);\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/picker/views/MonthsView.js\n\n  function computeMonthRange(range, thisYear) {\n    if (!range || !range[0] || !range[1]) {\n      return;\n    }\n\n    var _range = _slicedToArray(range, 2),\n        _range$ = _slicedToArray(_range[0], 2),\n        startY = _range$[0],\n        startM = _range$[1],\n        _range$2 = _slicedToArray(_range[1], 2),\n        endY = _range$2[0],\n        endM = _range$2[1];\n\n    if (startY > thisYear || endY < thisYear) {\n      return;\n    }\n\n    return [startY === thisYear ? startM : -1, endY === thisYear ? endM : 12];\n  }\n\n  var MonthsView = /*#__PURE__*/function (_View2) {\n    _inherits(MonthsView, _View2);\n\n    var _super2 = _createSuper(MonthsView);\n\n    function MonthsView(picker) {\n      _classCallCheck(this, MonthsView);\n\n      return _super2.call(this, picker, {\n        id: 1,\n        name: 'months',\n        cellClass: 'month'\n      });\n    }\n\n    _createClass(MonthsView, [{\n      key: \"init\",\n      value: function init(options) {\n        var onConstruction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (onConstruction) {\n          this.grid = this.element;\n          this.element.classList.add('months', 'datepicker-grid', 'w-64', 'grid', 'grid-cols-4');\n          this.grid.appendChild(parseHTML(createTagRepeat('span', 12, {\n            'data-month': function dataMonth(ix) {\n              return ix;\n            }\n          })));\n        }\n\n        _get(_getPrototypeOf(MonthsView.prototype), \"init\", this).call(this, options);\n      }\n    }, {\n      key: \"setOptions\",\n      value: function setOptions(options) {\n        if (options.locale) {\n          this.monthNames = options.locale.monthsShort;\n        }\n\n        if (hasProperty(options, 'minDate')) {\n          if (options.minDate === undefined) {\n            this.minYear = this.minMonth = this.minDate = undefined;\n          } else {\n            var minDateObj = new Date(options.minDate);\n            this.minYear = minDateObj.getFullYear();\n            this.minMonth = minDateObj.getMonth();\n            this.minDate = minDateObj.setDate(1);\n          }\n        }\n\n        if (hasProperty(options, 'maxDate')) {\n          if (options.maxDate === undefined) {\n            this.maxYear = this.maxMonth = this.maxDate = undefined;\n          } else {\n            var maxDateObj = new Date(options.maxDate);\n            this.maxYear = maxDateObj.getFullYear();\n            this.maxMonth = maxDateObj.getMonth();\n            this.maxDate = dateValue(this.maxYear, this.maxMonth + 1, 0);\n          }\n        }\n\n        if (options.beforeShowMonth !== undefined) {\n          this.beforeShow = typeof options.beforeShowMonth === 'function' ? options.beforeShowMonth : undefined;\n        }\n      } // Update view's settings to reflect the viewDate set on the picker\n\n    }, {\n      key: \"updateFocus\",\n      value: function updateFocus() {\n        var viewDate = new Date(this.picker.viewDate);\n        this.year = viewDate.getFullYear();\n        this.focused = viewDate.getMonth();\n      } // Update view's settings to reflect the selected dates\n\n    }, {\n      key: \"updateSelection\",\n      value: function updateSelection() {\n        var _this$picker$datepick2 = this.picker.datepicker,\n            dates = _this$picker$datepick2.dates,\n            rangepicker = _this$picker$datepick2.rangepicker;\n        this.selected = dates.reduce(function (selected, timeValue) {\n          var date = new Date(timeValue);\n          var year = date.getFullYear();\n          var month = date.getMonth();\n\n          if (selected[year] === undefined) {\n            selected[year] = [month];\n          } else {\n            pushUnique(selected[year], month);\n          }\n\n          return selected;\n        }, {});\n\n        if (rangepicker && rangepicker.dates) {\n          this.range = rangepicker.dates.map(function (timeValue) {\n            var date = new Date(timeValue);\n            return isNaN(date) ? undefined : [date.getFullYear(), date.getMonth()];\n          });\n        }\n      } // Update the entire view UI\n\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this4 = this;\n\n        // refresh disabled months on every render in order to clear the ones added\n        // by beforeShow hook at previous render\n        this.disabled = [];\n        this.picker.setViewSwitchLabel(this.year);\n        this.picker.setPrevBtnDisabled(this.year <= this.minYear);\n        this.picker.setNextBtnDisabled(this.year >= this.maxYear);\n        var selected = this.selected[this.year] || [];\n        var yrOutOfRange = this.year < this.minYear || this.year > this.maxYear;\n        var isMinYear = this.year === this.minYear;\n        var isMaxYear = this.year === this.maxYear;\n        var range = computeMonthRange(this.range, this.year);\n        Array.from(this.grid.children).forEach(function (el, index) {\n          var classList = el.classList;\n          var date = dateValue(_this4.year, index, 1);\n          el.className = \"datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm \".concat(_this4.cellClass);\n\n          if (_this4.isMinView) {\n            el.dataset.date = date;\n          } // reset text on every render to clear the custom content set\n          // by beforeShow hook at previous render\n\n\n          el.textContent = _this4.monthNames[index];\n\n          if (yrOutOfRange || isMinYear && index < _this4.minMonth || isMaxYear && index > _this4.maxMonth) {\n            classList.add('disabled');\n          }\n\n          if (range) {\n            var _range2 = _slicedToArray(range, 2),\n                rangeStart = _range2[0],\n                rangeEnd = _range2[1];\n\n            if (index > rangeStart && index < rangeEnd) {\n              classList.add('range');\n            }\n\n            if (index === rangeStart) {\n              classList.add('range-start');\n            }\n\n            if (index === rangeEnd) {\n              classList.add('range-end');\n            }\n          }\n\n          if (selected.includes(index)) {\n            classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');\n            classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');\n          }\n\n          if (index === _this4.focused) {\n            classList.add('focused', 'bg-gray-100', 'dark:bg-gray-600');\n          }\n\n          if (_this4.beforeShow) {\n            _this4.performBeforeHook(el, index, date);\n          }\n        });\n      } // Update the view UI by applying the changes of selected and focused items\n\n    }, {\n      key: \"refresh\",\n      value: function refresh() {\n        var _this5 = this;\n\n        var selected = this.selected[this.year] || [];\n\n        var _ref4 = computeMonthRange(this.range, this.year) || [],\n            _ref5 = _slicedToArray(_ref4, 2),\n            rangeStart = _ref5[0],\n            rangeEnd = _ref5[1];\n\n        this.grid.querySelectorAll('.range, .range-start, .range-end, .selected, .focused').forEach(function (el) {\n          el.classList.remove('range', 'range-start', 'range-end', 'selected', 'bg-blue-700', 'dark:bg-blue-600', 'dark:text-white', 'text-white', 'focused', 'bg-gray-100', 'dark:bg-gray-600');\n          el.classList.add('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');\n        });\n        Array.from(this.grid.children).forEach(function (el, index) {\n          var classList = el.classList;\n\n          if (index > rangeStart && index < rangeEnd) {\n            classList.add('range');\n          }\n\n          if (index === rangeStart) {\n            classList.add('range-start');\n          }\n\n          if (index === rangeEnd) {\n            classList.add('range-end');\n          }\n\n          if (selected.includes(index)) {\n            classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');\n            classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');\n          }\n\n          if (index === _this5.focused) {\n            classList.add('focused', 'bg-gray-100', 'dark:bg-gray-600');\n          }\n        });\n      } // Update the view UI by applying the change of focused item\n\n    }, {\n      key: \"refreshFocus\",\n      value: function refreshFocus() {\n        this.grid.querySelectorAll('.focused').forEach(function (el) {\n          el.classList.remove('focused', 'bg-gray-100'), 'dark:bg-gray-600';\n        });\n        this.grid.children[this.focused].classList.add('focused', 'bg-gray-100', 'dark:bg-gray-600');\n      }\n    }]);\n\n    return MonthsView;\n  }(View);\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/picker/views/YearsView.js\n\n  function toTitleCase(word) {\n    return _toConsumableArray(word).reduce(function (str, ch, ix) {\n      return str += ix ? ch : ch.toUpperCase();\n    }, '');\n  } // Class representing the years and decades view elements\n\n\n  var YearsView = /*#__PURE__*/function (_View3) {\n    _inherits(YearsView, _View3);\n\n    var _super3 = _createSuper(YearsView);\n\n    function YearsView(picker, config) {\n      _classCallCheck(this, YearsView);\n\n      return _super3.call(this, picker, config);\n    }\n\n    _createClass(YearsView, [{\n      key: \"init\",\n      value: function init(options) {\n        var onConstruction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (onConstruction) {\n          this.navStep = this.step * 10;\n          this.beforeShowOption = \"beforeShow\".concat(toTitleCase(this.cellClass));\n          this.grid = this.element;\n          this.element.classList.add(this.name, 'datepicker-grid', 'w-64', 'grid', 'grid-cols-4');\n          this.grid.appendChild(parseHTML(createTagRepeat('span', 12)));\n        }\n\n        _get(_getPrototypeOf(YearsView.prototype), \"init\", this).call(this, options);\n      }\n    }, {\n      key: \"setOptions\",\n      value: function setOptions(options) {\n        if (hasProperty(options, 'minDate')) {\n          if (options.minDate === undefined) {\n            this.minYear = this.minDate = undefined;\n          } else {\n            this.minYear = startOfYearPeriod(options.minDate, this.step);\n            this.minDate = dateValue(this.minYear, 0, 1);\n          }\n        }\n\n        if (hasProperty(options, 'maxDate')) {\n          if (options.maxDate === undefined) {\n            this.maxYear = this.maxDate = undefined;\n          } else {\n            this.maxYear = startOfYearPeriod(options.maxDate, this.step);\n            this.maxDate = dateValue(this.maxYear, 11, 31);\n          }\n        }\n\n        if (options[this.beforeShowOption] !== undefined) {\n          var beforeShow = options[this.beforeShowOption];\n          this.beforeShow = typeof beforeShow === 'function' ? beforeShow : undefined;\n        }\n      } // Update view's settings to reflect the viewDate set on the picker\n\n    }, {\n      key: \"updateFocus\",\n      value: function updateFocus() {\n        var viewDate = new Date(this.picker.viewDate);\n        var first = startOfYearPeriod(viewDate, this.navStep);\n        var last = first + 9 * this.step;\n        this.first = first;\n        this.last = last;\n        this.start = first - this.step;\n        this.focused = startOfYearPeriod(viewDate, this.step);\n      } // Update view's settings to reflect the selected dates\n\n    }, {\n      key: \"updateSelection\",\n      value: function updateSelection() {\n        var _this6 = this;\n\n        var _this$picker$datepick3 = this.picker.datepicker,\n            dates = _this$picker$datepick3.dates,\n            rangepicker = _this$picker$datepick3.rangepicker;\n        this.selected = dates.reduce(function (years, timeValue) {\n          return pushUnique(years, startOfYearPeriod(timeValue, _this6.step));\n        }, []);\n\n        if (rangepicker && rangepicker.dates) {\n          this.range = rangepicker.dates.map(function (timeValue) {\n            if (timeValue !== undefined) {\n              return startOfYearPeriod(timeValue, _this6.step);\n            }\n          });\n        }\n      } // Update the entire view UI\n\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this7 = this;\n\n        // refresh disabled years on every render in order to clear the ones added\n        // by beforeShow hook at previous render\n        this.disabled = [];\n        this.picker.setViewSwitchLabel(\"\".concat(this.first, \"-\").concat(this.last));\n        this.picker.setPrevBtnDisabled(this.first <= this.minYear);\n        this.picker.setNextBtnDisabled(this.last >= this.maxYear);\n        Array.from(this.grid.children).forEach(function (el, index) {\n          var classList = el.classList;\n          var current = _this7.start + index * _this7.step;\n          var date = dateValue(current, 0, 1);\n          el.className = \"datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm \".concat(_this7.cellClass);\n\n          if (_this7.isMinView) {\n            el.dataset.date = date;\n          }\n\n          el.textContent = el.dataset.year = current;\n\n          if (index === 0) {\n            classList.add('prev');\n          } else if (index === 11) {\n            classList.add('next');\n          }\n\n          if (current < _this7.minYear || current > _this7.maxYear) {\n            classList.add('disabled');\n          }\n\n          if (_this7.range) {\n            var _this7$range = _slicedToArray(_this7.range, 2),\n                rangeStart = _this7$range[0],\n                rangeEnd = _this7$range[1];\n\n            if (current > rangeStart && current < rangeEnd) {\n              classList.add('range');\n            }\n\n            if (current === rangeStart) {\n              classList.add('range-start');\n            }\n\n            if (current === rangeEnd) {\n              classList.add('range-end');\n            }\n          }\n\n          if (_this7.selected.includes(current)) {\n            classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');\n            classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');\n          }\n\n          if (current === _this7.focused) {\n            classList.add('focused', 'bg-gray-100', 'dark:bg-gray-600');\n          }\n\n          if (_this7.beforeShow) {\n            _this7.performBeforeHook(el, current, date);\n          }\n        });\n      } // Update the view UI by applying the changes of selected and focused items\n\n    }, {\n      key: \"refresh\",\n      value: function refresh() {\n        var _this8 = this;\n\n        var _ref6 = this.range || [],\n            _ref7 = _slicedToArray(_ref6, 2),\n            rangeStart = _ref7[0],\n            rangeEnd = _ref7[1];\n\n        this.grid.querySelectorAll('.range, .range-start, .range-end, .selected, .focused').forEach(function (el) {\n          el.classList.remove('range', 'range-start', 'range-end', 'selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white', 'focused', 'bg-gray-100', 'dark:bg-gray-600');\n        });\n        Array.from(this.grid.children).forEach(function (el) {\n          var current = Number(el.textContent);\n          var classList = el.classList;\n\n          if (current > rangeStart && current < rangeEnd) {\n            classList.add('range');\n          }\n\n          if (current === rangeStart) {\n            classList.add('range-start');\n          }\n\n          if (current === rangeEnd) {\n            classList.add('range-end');\n          }\n\n          if (_this8.selected.includes(current)) {\n            classList.add('selected', 'bg-blue-700', 'text-white', 'dark:bg-blue-600', 'dark:text-white');\n            classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');\n          }\n\n          if (current === _this8.focused) {\n            classList.add('focused', 'bg-gray-100', 'dark:bg-gray-600');\n          }\n        });\n      } // Update the view UI by applying the change of focused item\n\n    }, {\n      key: \"refreshFocus\",\n      value: function refreshFocus() {\n        var index = Math.round((this.focused - this.start) / this.step);\n        this.grid.querySelectorAll('.focused').forEach(function (el) {\n          el.classList.remove('focused', 'bg-gray-100', 'dark:bg-gray-600');\n        });\n        this.grid.children[index].classList.add('focused', 'bg-gray-100', 'dark:bg-gray-600');\n      }\n    }]);\n\n    return YearsView;\n  }(View);\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/events/functions.js\n\n  function triggerDatepickerEvent(datepicker, type) {\n    var detail = {\n      date: datepicker.getDate(),\n      viewDate: new Date(datepicker.picker.viewDate),\n      viewId: datepicker.picker.currentView.id,\n      datepicker: datepicker\n    };\n    datepicker.element.dispatchEvent(new CustomEvent(type, {\n      detail: detail\n    }));\n  } // direction: -1 (to previous), 1 (to next)\n\n\n  function goToPrevOrNext(datepicker, direction) {\n    var _datepicker$config = datepicker.config,\n        minDate = _datepicker$config.minDate,\n        maxDate = _datepicker$config.maxDate;\n    var _datepicker$picker = datepicker.picker,\n        currentView = _datepicker$picker.currentView,\n        viewDate = _datepicker$picker.viewDate;\n    var newViewDate;\n\n    switch (currentView.id) {\n      case 0:\n        newViewDate = addMonths(viewDate, direction);\n        break;\n\n      case 1:\n        newViewDate = addYears(viewDate, direction);\n        break;\n\n      default:\n        newViewDate = addYears(viewDate, direction * currentView.navStep);\n    }\n\n    newViewDate = limitToRange(newViewDate, minDate, maxDate);\n    datepicker.picker.changeFocus(newViewDate).render();\n  }\n\n  function switchView(datepicker) {\n    var viewId = datepicker.picker.currentView.id;\n\n    if (viewId === datepicker.config.maxView) {\n      return;\n    }\n\n    datepicker.picker.changeView(viewId + 1).render();\n  }\n\n  function unfocus(datepicker) {\n    if (datepicker.config.updateOnBlur) {\n      datepicker.update({\n        autohide: true\n      });\n    } else {\n      datepicker.refresh('input');\n      datepicker.hide();\n    }\n  }\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/events/pickerListeners.js\n\n  function goToSelectedMonthOrYear(datepicker, selection) {\n    var picker = datepicker.picker;\n    var viewDate = new Date(picker.viewDate);\n    var viewId = picker.currentView.id;\n    var newDate = viewId === 1 ? addMonths(viewDate, selection - viewDate.getMonth()) : addYears(viewDate, selection - viewDate.getFullYear());\n    picker.changeFocus(newDate).changeView(viewId - 1).render();\n  }\n\n  function onClickTodayBtn(datepicker) {\n    var picker = datepicker.picker;\n    var currentDate = today();\n\n    if (datepicker.config.todayBtnMode === 1) {\n      if (datepicker.config.autohide) {\n        datepicker.setDate(currentDate);\n        return;\n      }\n\n      datepicker.setDate(currentDate, {\n        render: false\n      });\n      picker.update();\n    }\n\n    if (picker.viewDate !== currentDate) {\n      picker.changeFocus(currentDate);\n    }\n\n    picker.changeView(0).render();\n  }\n\n  function onClickClearBtn(datepicker) {\n    datepicker.setDate({\n      clear: true\n    });\n  }\n\n  function onClickViewSwitch(datepicker) {\n    switchView(datepicker);\n  }\n\n  function onClickPrevBtn(datepicker) {\n    goToPrevOrNext(datepicker, -1);\n  }\n\n  function onClickNextBtn(datepicker) {\n    goToPrevOrNext(datepicker, 1);\n  } // For the picker's main block to delegete the events from `datepicker-cell`s\n\n\n  function onClickView(datepicker, ev) {\n    var target = findElementInEventPath(ev, '.datepicker-cell');\n\n    if (!target || target.classList.contains('disabled')) {\n      return;\n    }\n\n    var _datepicker$picker$cu = datepicker.picker.currentView,\n        id = _datepicker$picker$cu.id,\n        isMinView = _datepicker$picker$cu.isMinView;\n\n    if (isMinView) {\n      datepicker.setDate(Number(target.dataset.date));\n    } else if (id === 1) {\n      goToSelectedMonthOrYear(datepicker, Number(target.dataset.month));\n    } else {\n      goToSelectedMonthOrYear(datepicker, Number(target.dataset.year));\n    }\n  }\n\n  function onClickPicker(datepicker) {\n    if (!datepicker.inline && !datepicker.config.disableTouchKeyboard) {\n      datepicker.inputField.focus();\n    }\n  }\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/picker/Picker.js\n\n  function processPickerOptions(picker, options) {\n    if (options.title !== undefined) {\n      if (options.title) {\n        picker.controls.title.textContent = options.title;\n        showElement(picker.controls.title);\n      } else {\n        picker.controls.title.textContent = '';\n        hideElement(picker.controls.title);\n      }\n    }\n\n    if (options.prevArrow) {\n      var prevBtn = picker.controls.prevBtn;\n      emptyChildNodes(prevBtn);\n      options.prevArrow.forEach(function (node) {\n        prevBtn.appendChild(node.cloneNode(true));\n      });\n    }\n\n    if (options.nextArrow) {\n      var nextBtn = picker.controls.nextBtn;\n      emptyChildNodes(nextBtn);\n      options.nextArrow.forEach(function (node) {\n        nextBtn.appendChild(node.cloneNode(true));\n      });\n    }\n\n    if (options.locale) {\n      picker.controls.todayBtn.textContent = options.locale.today;\n      picker.controls.clearBtn.textContent = options.locale.clear;\n    }\n\n    if (options.todayBtn !== undefined) {\n      if (options.todayBtn) {\n        showElement(picker.controls.todayBtn);\n      } else {\n        hideElement(picker.controls.todayBtn);\n      }\n    }\n\n    if (hasProperty(options, 'minDate') || hasProperty(options, 'maxDate')) {\n      var _picker$datepicker$co = picker.datepicker.config,\n          minDate = _picker$datepicker$co.minDate,\n          maxDate = _picker$datepicker$co.maxDate;\n      picker.controls.todayBtn.disabled = !isInRange(today(), minDate, maxDate);\n    }\n\n    if (options.clearBtn !== undefined) {\n      if (options.clearBtn) {\n        showElement(picker.controls.clearBtn);\n      } else {\n        hideElement(picker.controls.clearBtn);\n      }\n    }\n  } // Compute view date to reset, which will be...\n  // - the last item of the selected dates or defaultViewDate if no selection\n  // - limitted to minDate or maxDate if it exceeds the range\n\n\n  function computeResetViewDate(datepicker) {\n    var dates = datepicker.dates,\n        config = datepicker.config;\n    var viewDate = dates.length > 0 ? lastItemOf(dates) : config.defaultViewDate;\n    return limitToRange(viewDate, config.minDate, config.maxDate);\n  } // Change current view's view date\n\n\n  function setViewDate(picker, newDate) {\n    var oldViewDate = new Date(picker.viewDate);\n    var newViewDate = new Date(newDate);\n    var _picker$currentView = picker.currentView,\n        id = _picker$currentView.id,\n        year = _picker$currentView.year,\n        first = _picker$currentView.first,\n        last = _picker$currentView.last;\n    var viewYear = newViewDate.getFullYear();\n    picker.viewDate = newDate;\n\n    if (viewYear !== oldViewDate.getFullYear()) {\n      triggerDatepickerEvent(picker.datepicker, 'changeYear');\n    }\n\n    if (newViewDate.getMonth() !== oldViewDate.getMonth()) {\n      triggerDatepickerEvent(picker.datepicker, 'changeMonth');\n    } // return whether the new date is in different period on time from the one\n    // displayed in the current view\n    // when true, the view needs to be re-rendered on the next UI refresh.\n\n\n    switch (id) {\n      case 0:\n        return newDate < first || newDate > last;\n\n      case 1:\n        return viewYear !== year;\n\n      default:\n        return viewYear < first || viewYear > last;\n    }\n  }\n\n  function getTextDirection(el) {\n    return window.getComputedStyle(el).direction;\n  } // Class representing the picker UI\n\n\n  var Picker = /*#__PURE__*/function () {\n    function Picker(datepicker) {\n      _classCallCheck(this, Picker);\n\n      this.datepicker = datepicker;\n      var template = templates_pickerTemplate.replace(/%buttonClass%/g, datepicker.config.buttonClass);\n      var element = this.element = parseHTML(template).firstChild;\n\n      var _element$firstChild$c = _slicedToArray(element.firstChild.children, 3),\n          header = _element$firstChild$c[0],\n          main = _element$firstChild$c[1],\n          footer = _element$firstChild$c[2];\n\n      var title = header.firstElementChild;\n\n      var _header$lastElementCh = _slicedToArray(header.lastElementChild.children, 3),\n          prevBtn = _header$lastElementCh[0],\n          viewSwitch = _header$lastElementCh[1],\n          nextBtn = _header$lastElementCh[2];\n\n      var _footer$firstChild$ch = _slicedToArray(footer.firstChild.children, 2),\n          todayBtn = _footer$firstChild$ch[0],\n          clearBtn = _footer$firstChild$ch[1];\n\n      var controls = {\n        title: title,\n        prevBtn: prevBtn,\n        viewSwitch: viewSwitch,\n        nextBtn: nextBtn,\n        todayBtn: todayBtn,\n        clearBtn: clearBtn\n      };\n      this.main = main;\n      this.controls = controls;\n      var elementClass = datepicker.inline ? 'inline' : 'dropdown';\n      element.classList.add(\"datepicker-\".concat(elementClass));\n      elementClass === 'dropdown' ? element.classList.add('dropdown', 'absolute', 'top-0', 'left-0', 'z-20', 'pt-2') : null;\n      processPickerOptions(this, datepicker.config);\n      this.viewDate = computeResetViewDate(datepicker); // set up event listeners\n\n      registerListeners(datepicker, [[element, 'click', onClickPicker.bind(null, datepicker), {\n        capture: true\n      }], [main, 'click', onClickView.bind(null, datepicker)], [controls.viewSwitch, 'click', onClickViewSwitch.bind(null, datepicker)], [controls.prevBtn, 'click', onClickPrevBtn.bind(null, datepicker)], [controls.nextBtn, 'click', onClickNextBtn.bind(null, datepicker)], [controls.todayBtn, 'click', onClickTodayBtn.bind(null, datepicker)], [controls.clearBtn, 'click', onClickClearBtn.bind(null, datepicker)]]); // set up views\n\n      this.views = [new DaysView(this), new MonthsView(this), new YearsView(this, {\n        id: 2,\n        name: 'years',\n        cellClass: 'year',\n        step: 1\n      }), new YearsView(this, {\n        id: 3,\n        name: 'decades',\n        cellClass: 'decade',\n        step: 10\n      })];\n      this.currentView = this.views[datepicker.config.startView];\n      this.currentView.render();\n      this.main.appendChild(this.currentView.element);\n      datepicker.config.container.appendChild(this.element);\n    }\n\n    _createClass(Picker, [{\n      key: \"setOptions\",\n      value: function setOptions(options) {\n        processPickerOptions(this, options);\n        this.views.forEach(function (view) {\n          view.init(options, false);\n        });\n        this.currentView.render();\n      }\n    }, {\n      key: \"detach\",\n      value: function detach() {\n        this.datepicker.config.container.removeChild(this.element);\n      }\n    }, {\n      key: \"show\",\n      value: function show() {\n        if (this.active) {\n          return;\n        }\n\n        this.element.classList.add('active', 'block');\n        this.element.classList.remove('hidden');\n        this.active = true;\n        var datepicker = this.datepicker;\n\n        if (!datepicker.inline) {\n          // ensure picker's direction matches input's\n          var inputDirection = getTextDirection(datepicker.inputField);\n\n          if (inputDirection !== getTextDirection(datepicker.config.container)) {\n            this.element.dir = inputDirection;\n          } else if (this.element.dir) {\n            this.element.removeAttribute('dir');\n          }\n\n          this.place();\n\n          if (datepicker.config.disableTouchKeyboard) {\n            datepicker.inputField.blur();\n          }\n        }\n\n        triggerDatepickerEvent(datepicker, 'show');\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        if (!this.active) {\n          return;\n        }\n\n        this.datepicker.exitEditMode();\n        this.element.classList.remove('active', 'block');\n        this.element.classList.add('active', 'block', 'hidden');\n        this.active = false;\n        triggerDatepickerEvent(this.datepicker, 'hide');\n      }\n    }, {\n      key: \"place\",\n      value: function place() {\n        var _this$element = this.element,\n            classList = _this$element.classList,\n            style = _this$element.style;\n        var _this$datepicker = this.datepicker,\n            config = _this$datepicker.config,\n            inputField = _this$datepicker.inputField;\n        var container = config.container;\n\n        var _this$element$getBoun = this.element.getBoundingClientRect(),\n            calendarWidth = _this$element$getBoun.width,\n            calendarHeight = _this$element$getBoun.height;\n\n        var _container$getBoundin = container.getBoundingClientRect(),\n            containerLeft = _container$getBoundin.left,\n            containerTop = _container$getBoundin.top,\n            containerWidth = _container$getBoundin.width;\n\n        var _inputField$getBoundi = inputField.getBoundingClientRect(),\n            inputLeft = _inputField$getBoundi.left,\n            inputTop = _inputField$getBoundi.top,\n            inputWidth = _inputField$getBoundi.width,\n            inputHeight = _inputField$getBoundi.height;\n\n        var _config$orientation = config.orientation,\n            orientX = _config$orientation.x,\n            orientY = _config$orientation.y;\n        var scrollTop;\n        var left;\n        var top;\n\n        if (container === document.body) {\n          scrollTop = window.scrollY;\n          left = inputLeft + window.scrollX;\n          top = inputTop + scrollTop;\n        } else {\n          scrollTop = container.scrollTop;\n          left = inputLeft - containerLeft;\n          top = inputTop - containerTop + scrollTop;\n        }\n\n        if (orientX === 'auto') {\n          if (left < 0) {\n            // align to the left and move into visible area if input's left edge < window's\n            orientX = 'left';\n            left = 10;\n          } else if (left + calendarWidth > containerWidth) {\n            // align to the right if canlendar's right edge > container's\n            orientX = 'right';\n          } else {\n            orientX = getTextDirection(inputField) === 'rtl' ? 'right' : 'left';\n          }\n        }\n\n        if (orientX === 'right') {\n          left -= calendarWidth - inputWidth;\n        }\n\n        if (orientY === 'auto') {\n          orientY = top - calendarHeight < scrollTop ? 'bottom' : 'top';\n        }\n\n        if (orientY === 'top') {\n          top -= calendarHeight;\n        } else {\n          top += inputHeight;\n        }\n\n        classList.remove('datepicker-orient-top', 'datepicker-orient-bottom', 'datepicker-orient-right', 'datepicker-orient-left');\n        classList.add(\"datepicker-orient-\".concat(orientY), \"datepicker-orient-\".concat(orientX));\n        style.top = top ? \"\".concat(top, \"px\") : top;\n        style.left = left ? \"\".concat(left, \"px\") : left;\n      }\n    }, {\n      key: \"setViewSwitchLabel\",\n      value: function setViewSwitchLabel(labelText) {\n        this.controls.viewSwitch.textContent = labelText;\n      }\n    }, {\n      key: \"setPrevBtnDisabled\",\n      value: function setPrevBtnDisabled(disabled) {\n        this.controls.prevBtn.disabled = disabled;\n      }\n    }, {\n      key: \"setNextBtnDisabled\",\n      value: function setNextBtnDisabled(disabled) {\n        this.controls.nextBtn.disabled = disabled;\n      }\n    }, {\n      key: \"changeView\",\n      value: function changeView(viewId) {\n        var oldView = this.currentView;\n        var newView = this.views[viewId];\n\n        if (newView.id !== oldView.id) {\n          this.currentView = newView;\n          this._renderMethod = 'render';\n          triggerDatepickerEvent(this.datepicker, 'changeView');\n          this.main.replaceChild(newView.element, oldView.element);\n        }\n\n        return this;\n      } // Change the focused date (view date)\n\n    }, {\n      key: \"changeFocus\",\n      value: function changeFocus(newViewDate) {\n        this._renderMethod = setViewDate(this, newViewDate) ? 'render' : 'refreshFocus';\n        this.views.forEach(function (view) {\n          view.updateFocus();\n        });\n        return this;\n      } // Apply the change of the selected dates\n\n    }, {\n      key: \"update\",\n      value: function update() {\n        var newViewDate = computeResetViewDate(this.datepicker);\n        this._renderMethod = setViewDate(this, newViewDate) ? 'render' : 'refresh';\n        this.views.forEach(function (view) {\n          view.updateFocus();\n          view.updateSelection();\n        });\n        return this;\n      } // Refresh the picker UI\n\n    }, {\n      key: \"render\",\n      value: function render() {\n        var quickRender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var renderMethod = quickRender && this._renderMethod || 'render';\n        delete this._renderMethod;\n        this.currentView[renderMethod]();\n      }\n    }]);\n\n    return Picker;\n  }();\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/events/inputFieldListeners.js\n  // Find the closest date that doesn't meet the condition for unavailable date\n  // Returns undefined if no available date is found\n  // addFn: function to calculate the next date\n  //   - args: time value, amount\n  // increase: amount to pass to addFn\n  // testFn: function to test the unavailablity of the date\n  //   - args: time value; retun: true if unavailable\n\n  function findNextAvailableOne(date, addFn, increase, testFn, min, max) {\n    if (!isInRange(date, min, max)) {\n      return;\n    }\n\n    if (testFn(date)) {\n      var newDate = addFn(date, increase);\n      return findNextAvailableOne(newDate, addFn, increase, testFn, min, max);\n    }\n\n    return date;\n  } // direction: -1 (left/up), 1 (right/down)\n  // vertical: true for up/down, false for left/right\n\n\n  function moveByArrowKey(datepicker, ev, direction, vertical) {\n    var picker = datepicker.picker;\n    var currentView = picker.currentView;\n    var step = currentView.step || 1;\n    var viewDate = picker.viewDate;\n    var addFn;\n    var testFn;\n\n    switch (currentView.id) {\n      case 0:\n        if (vertical) {\n          viewDate = addDays(viewDate, direction * 7);\n        } else if (ev.ctrlKey || ev.metaKey) {\n          viewDate = addYears(viewDate, direction);\n        } else {\n          viewDate = addDays(viewDate, direction);\n        }\n\n        addFn = addDays;\n\n        testFn = function testFn(date) {\n          return currentView.disabled.includes(date);\n        };\n\n        break;\n\n      case 1:\n        viewDate = addMonths(viewDate, vertical ? direction * 4 : direction);\n        addFn = addMonths;\n\n        testFn = function testFn(date) {\n          var dt = new Date(date);\n          var year = currentView.year,\n              disabled = currentView.disabled;\n          return dt.getFullYear() === year && disabled.includes(dt.getMonth());\n        };\n\n        break;\n\n      default:\n        viewDate = addYears(viewDate, direction * (vertical ? 4 : 1) * step);\n        addFn = addYears;\n\n        testFn = function testFn(date) {\n          return currentView.disabled.includes(startOfYearPeriod(date, step));\n        };\n\n    }\n\n    viewDate = findNextAvailableOne(viewDate, addFn, direction < 0 ? -step : step, testFn, currentView.minDate, currentView.maxDate);\n\n    if (viewDate !== undefined) {\n      picker.changeFocus(viewDate).render();\n    }\n  }\n\n  function onKeydown(datepicker, ev) {\n    if (ev.key === 'Tab') {\n      unfocus(datepicker);\n      return;\n    }\n\n    var picker = datepicker.picker;\n    var _picker$currentView2 = picker.currentView,\n        id = _picker$currentView2.id,\n        isMinView = _picker$currentView2.isMinView;\n\n    if (!picker.active) {\n      switch (ev.key) {\n        case 'ArrowDown':\n        case 'Escape':\n          picker.show();\n          break;\n\n        case 'Enter':\n          datepicker.update();\n          break;\n\n        default:\n          return;\n      }\n    } else if (datepicker.editMode) {\n      switch (ev.key) {\n        case 'Escape':\n          picker.hide();\n          break;\n\n        case 'Enter':\n          datepicker.exitEditMode({\n            update: true,\n            autohide: datepicker.config.autohide\n          });\n          break;\n\n        default:\n          return;\n      }\n    } else {\n      switch (ev.key) {\n        case 'Escape':\n          picker.hide();\n          break;\n\n        case 'ArrowLeft':\n          if (ev.ctrlKey || ev.metaKey) {\n            goToPrevOrNext(datepicker, -1);\n          } else if (ev.shiftKey) {\n            datepicker.enterEditMode();\n            return;\n          } else {\n            moveByArrowKey(datepicker, ev, -1, false);\n          }\n\n          break;\n\n        case 'ArrowRight':\n          if (ev.ctrlKey || ev.metaKey) {\n            goToPrevOrNext(datepicker, 1);\n          } else if (ev.shiftKey) {\n            datepicker.enterEditMode();\n            return;\n          } else {\n            moveByArrowKey(datepicker, ev, 1, false);\n          }\n\n          break;\n\n        case 'ArrowUp':\n          if (ev.ctrlKey || ev.metaKey) {\n            switchView(datepicker);\n          } else if (ev.shiftKey) {\n            datepicker.enterEditMode();\n            return;\n          } else {\n            moveByArrowKey(datepicker, ev, -1, true);\n          }\n\n          break;\n\n        case 'ArrowDown':\n          if (ev.shiftKey && !ev.ctrlKey && !ev.metaKey) {\n            datepicker.enterEditMode();\n            return;\n          }\n\n          moveByArrowKey(datepicker, ev, 1, true);\n          break;\n\n        case 'Enter':\n          if (isMinView) {\n            datepicker.setDate(picker.viewDate);\n          } else {\n            picker.changeView(id - 1).render();\n          }\n\n          break;\n\n        case 'Backspace':\n        case 'Delete':\n          datepicker.enterEditMode();\n          return;\n\n        default:\n          if (ev.key.length === 1 && !ev.ctrlKey && !ev.metaKey) {\n            datepicker.enterEditMode();\n          }\n\n          return;\n      }\n    }\n\n    ev.preventDefault();\n    ev.stopPropagation();\n  }\n\n  function onFocus(datepicker) {\n    if (datepicker.config.showOnFocus && !datepicker._showing) {\n      datepicker.show();\n    }\n  } // for the prevention for entering edit mode while getting focus on click\n\n\n  function onMousedown(datepicker, ev) {\n    var el = ev.target;\n\n    if (datepicker.picker.active || datepicker.config.showOnClick) {\n      el._active = el === document.activeElement;\n      el._clicking = setTimeout(function () {\n        delete el._active;\n        delete el._clicking;\n      }, 2000);\n    }\n  }\n\n  function onClickInput(datepicker, ev) {\n    var el = ev.target;\n\n    if (!el._clicking) {\n      return;\n    }\n\n    clearTimeout(el._clicking);\n    delete el._clicking;\n\n    if (el._active) {\n      datepicker.enterEditMode();\n    }\n\n    delete el._active;\n\n    if (datepicker.config.showOnClick) {\n      datepicker.show();\n    }\n  }\n\n  function onPaste(datepicker, ev) {\n    if (ev.clipboardData.types.includes('text/plain')) {\n      datepicker.enterEditMode();\n    }\n  }\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/events/otherListeners.js\n  // for the `document` to delegate the events from outside the picker/input field\n\n  function onClickOutside(datepicker, ev) {\n    var element = datepicker.element;\n\n    if (element !== document.activeElement) {\n      return;\n    }\n\n    var pickerElem = datepicker.picker.element;\n\n    if (findElementInEventPath(ev, function (el) {\n      return el === element || el === pickerElem;\n    })) {\n      return;\n    }\n\n    unfocus(datepicker);\n  }\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/Datepicker.js\n\n  function stringifyDates(dates, config) {\n    return dates.map(function (dt) {\n      return _formatDate(dt, config.format, config.locale);\n    }).join(config.dateDelimiter);\n  } // parse input dates and create an array of time values for selection\n  // returns undefined if there are no valid dates in inputDates\n  // when origDates (current selection) is passed, the function works to mix\n  // the input dates into the current selection\n\n\n  function processInputDates(datepicker, inputDates) {\n    var clear = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var config = datepicker.config,\n        origDates = datepicker.dates,\n        rangepicker = datepicker.rangepicker;\n\n    if (inputDates.length === 0) {\n      // empty input is considered valid unless origiDates is passed\n      return clear ? [] : undefined;\n    }\n\n    var rangeEnd = rangepicker && datepicker === rangepicker.datepickers[1];\n    var newDates = inputDates.reduce(function (dates, dt) {\n      var date = _parseDate(dt, config.format, config.locale);\n\n      if (date === undefined) {\n        return dates;\n      }\n\n      if (config.pickLevel > 0) {\n        // adjust to 1st of the month/Jan 1st of the year\n        // or to the last day of the monh/Dec 31st of the year if the datepicker\n        // is the range-end picker of a rangepicker\n        var _dt = new Date(date);\n\n        if (config.pickLevel === 1) {\n          date = rangeEnd ? _dt.setMonth(_dt.getMonth() + 1, 0) : _dt.setDate(1);\n        } else {\n          date = rangeEnd ? _dt.setFullYear(_dt.getFullYear() + 1, 0, 0) : _dt.setMonth(0, 1);\n        }\n      }\n\n      if (isInRange(date, config.minDate, config.maxDate) && !dates.includes(date) && !config.datesDisabled.includes(date) && !config.daysOfWeekDisabled.includes(new Date(date).getDay())) {\n        dates.push(date);\n      }\n\n      return dates;\n    }, []);\n\n    if (newDates.length === 0) {\n      return;\n    }\n\n    if (config.multidate && !clear) {\n      // get the synmetric difference between origDates and newDates\n      newDates = newDates.reduce(function (dates, date) {\n        if (!origDates.includes(date)) {\n          dates.push(date);\n        }\n\n        return dates;\n      }, origDates.filter(function (date) {\n        return !newDates.includes(date);\n      }));\n    } // do length check always because user can input multiple dates regardless of the mode\n\n\n    return config.maxNumberOfDates && newDates.length > config.maxNumberOfDates ? newDates.slice(config.maxNumberOfDates * -1) : newDates;\n  } // refresh the UI elements\n  // modes: 1: input only, 2, picker only, 3 both\n\n\n  function refreshUI(datepicker) {\n    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n    var quickRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var config = datepicker.config,\n        picker = datepicker.picker,\n        inputField = datepicker.inputField;\n\n    if (mode & 2) {\n      var newView = picker.active ? config.pickLevel : config.startView;\n      picker.update().changeView(newView).render(quickRender);\n    }\n\n    if (mode & 1 && inputField) {\n      inputField.value = stringifyDates(datepicker.dates, config);\n    }\n  }\n\n  function _setDate(datepicker, inputDates, options) {\n    var clear = options.clear,\n        render = options.render,\n        autohide = options.autohide;\n\n    if (render === undefined) {\n      render = true;\n    }\n\n    if (!render) {\n      autohide = false;\n    } else if (autohide === undefined) {\n      autohide = datepicker.config.autohide;\n    }\n\n    var newDates = processInputDates(datepicker, inputDates, clear);\n\n    if (!newDates) {\n      return;\n    }\n\n    if (newDates.toString() !== datepicker.dates.toString()) {\n      datepicker.dates = newDates;\n      refreshUI(datepicker, render ? 3 : 1);\n      triggerDatepickerEvent(datepicker, 'changeDate');\n    } else {\n      refreshUI(datepicker, 1);\n    }\n\n    if (autohide) {\n      datepicker.hide();\n    }\n  }\n  /**\r\n   * Class representing a date picker\r\n   */\n\n\n  var Datepicker = /*#__PURE__*/function () {\n    /**\r\n     * Create a date picker\r\n     * @param  {Element} element - element to bind a date picker\r\n     * @param  {Object} [options] - config options\r\n     * @param  {DateRangePicker} [rangepicker] - DateRangePicker instance the\r\n     * date picker belongs to. Use this only when creating date picker as a part\r\n     * of date range picker\r\n     */\n    function Datepicker(element) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var rangepicker = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n      _classCallCheck(this, Datepicker);\n\n      element.datepicker = this;\n      this.element = element; // set up config\n\n      var config = this.config = Object.assign({\n        buttonClass: options.buttonClass && String(options.buttonClass) || 'button',\n        container: document.body,\n        defaultViewDate: today(),\n        maxDate: undefined,\n        minDate: undefined\n      }, processOptions(options_defaultOptions, this));\n      this._options = options;\n      Object.assign(config, processOptions(options, this)); // configure by type\n\n      var inline = this.inline = element.tagName !== 'INPUT';\n      var inputField;\n      var initialDates;\n\n      if (inline) {\n        config.container = element;\n        initialDates = stringToArray(element.dataset.date, config.dateDelimiter);\n        delete element.dataset.date;\n      } else {\n        var container = options.container ? document.querySelector(options.container) : null;\n\n        if (container) {\n          config.container = container;\n        }\n\n        inputField = this.inputField = element;\n        inputField.classList.add('datepicker-input');\n        initialDates = stringToArray(inputField.value, config.dateDelimiter);\n      }\n\n      if (rangepicker) {\n        // check validiry\n        var index = rangepicker.inputs.indexOf(inputField);\n        var datepickers = rangepicker.datepickers;\n\n        if (index < 0 || index > 1 || !Array.isArray(datepickers)) {\n          throw Error('Invalid rangepicker object.');\n        } // attach itaelf to the rangepicker here so that processInputDates() can\n        // determine if this is the range-end picker of the rangepicker while\n        // setting inital values when pickLevel > 0\n\n\n        datepickers[index] = this; // add getter for rangepicker\n\n        Object.defineProperty(this, 'rangepicker', {\n          get: function get() {\n            return rangepicker;\n          }\n        });\n      } // set initial dates\n\n\n      this.dates = []; // process initial value\n\n      var inputDateValues = processInputDates(this, initialDates);\n\n      if (inputDateValues && inputDateValues.length > 0) {\n        this.dates = inputDateValues;\n      }\n\n      if (inputField) {\n        inputField.value = stringifyDates(this.dates, config);\n      }\n\n      var picker = this.picker = new Picker(this);\n\n      if (inline) {\n        this.show();\n      } else {\n        // set up event listeners in other modes\n        var onMousedownDocument = onClickOutside.bind(null, this);\n        var listeners = [[inputField, 'keydown', onKeydown.bind(null, this)], [inputField, 'focus', onFocus.bind(null, this)], [inputField, 'mousedown', onMousedown.bind(null, this)], [inputField, 'click', onClickInput.bind(null, this)], [inputField, 'paste', onPaste.bind(null, this)], [document, 'mousedown', onMousedownDocument], [document, 'touchstart', onMousedownDocument], [window, 'resize', picker.place.bind(picker)]];\n        registerListeners(this, listeners);\n      }\n    }\n    /**\r\n     * Format Date object or time value in given format and language\r\n     * @param  {Date|Number} date - date or time value to format\r\n     * @param  {String|Object} format - format string or object that contains\r\n     * toDisplay() custom formatter, whose signature is\r\n     * - args:\r\n     *   - date: {Date} - Date instance of the date passed to the method\r\n     *   - format: {Object} - the format object passed to the method\r\n     *   - locale: {Object} - locale for the language specified by `lang`\r\n     * - return:\r\n     *     {String} formatted date\r\n     * @param  {String} [lang=en] - language code for the locale to use\r\n     * @return {String} formatted date\r\n     */\n\n\n    _createClass(Datepicker, [{\n      key: \"active\",\n      get:\n      /**\r\n       * @type {Boolean} - Whether the picker element is shown. `true` whne shown\r\n       */\n      function get() {\n        return !!(this.picker && this.picker.active);\n      }\n      /**\r\n       * @type {HTMLDivElement} - DOM object of picker element\r\n       */\n\n    }, {\n      key: \"pickerElement\",\n      get: function get() {\n        return this.picker ? this.picker.element : undefined;\n      }\n      /**\r\n       * Set new values to the config options\r\n       * @param {Object} options - config options to update\r\n       */\n\n    }, {\n      key: \"setOptions\",\n      value: function setOptions(options) {\n        var picker = this.picker;\n        var newOptions = processOptions(options, this);\n        Object.assign(this._options, options);\n        Object.assign(this.config, newOptions);\n        picker.setOptions(newOptions);\n        refreshUI(this, 3);\n      }\n      /**\r\n       * Show the picker element\r\n       */\n\n    }, {\n      key: \"show\",\n      value: function show() {\n        if (this.inputField) {\n          if (this.inputField.disabled) {\n            return;\n          }\n\n          if (this.inputField !== document.activeElement) {\n            this._showing = true;\n            this.inputField.focus();\n            delete this._showing;\n          }\n        }\n\n        this.picker.show();\n      }\n      /**\r\n       * Hide the picker element\r\n       * Not available on inline picker\r\n       */\n\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        if (this.inline) {\n          return;\n        }\n\n        this.picker.hide();\n        this.picker.update().changeView(this.config.startView).render();\n      }\n      /**\r\n       * Destroy the Datepicker instance\r\n       * @return {Detepicker} - the instance destroyed\r\n       */\n\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        this.hide();\n        unregisterListeners(this);\n        this.picker.detach();\n\n        if (!this.inline) {\n          this.inputField.classList.remove('datepicker-input');\n        }\n\n        delete this.element.datepicker;\n        return this;\n      }\n      /**\r\n       * Get the selected date(s)\r\n       *\r\n       * The method returns a Date object of selected date by default, and returns\r\n       * an array of selected dates in multidate mode. If format string is passed,\r\n       * it returns date string(s) formatted in given format.\r\n       *\r\n       * @param  {String} [format] - Format string to stringify the date(s)\r\n       * @return {Date|String|Date[]|String[]} - selected date(s), or if none is\r\n       * selected, empty array in multidate mode and untitled in sigledate mode\r\n       */\n\n    }, {\n      key: \"getDate\",\n      value: function getDate() {\n        var _this9 = this;\n\n        var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n        var callback = format ? function (date) {\n          return _formatDate(date, format, _this9.config.locale);\n        } : function (date) {\n          return new Date(date);\n        };\n\n        if (this.config.multidate) {\n          return this.dates.map(callback);\n        }\n\n        if (this.dates.length > 0) {\n          return callback(this.dates[0]);\n        }\n      }\n      /**\r\n       * Set selected date(s)\r\n       *\r\n       * In multidate mode, you can pass multiple dates as a series of arguments\r\n       * or an array. (Since each date is parsed individually, the type of the\r\n       * dates doesn't have to be the same.)\r\n       * The given dates are used to toggle the select status of each date. The\r\n       * number of selected dates is kept from exceeding the length set to\r\n       * maxNumberOfDates.\r\n       *\r\n       * With clear: true option, the method can be used to clear the selection\r\n       * and to replace the selection instead of toggling in multidate mode.\r\n       * If the option is passed with no date arguments or an empty dates array,\r\n       * it works as \"clear\" (clear the selection then set nothing), and if the\r\n       * option is passed with new dates to select, it works as \"replace\" (clear\r\n       * the selection then set the given dates)\r\n       *\r\n       * When render: false option is used, the method omits re-rendering the\r\n       * picker element. In this case, you need to call refresh() method later in\r\n       * order for the picker element to reflect the changes. The input field is\r\n       * refreshed always regardless of this option.\r\n       *\r\n       * When invalid (unparsable, repeated, disabled or out-of-range) dates are\r\n       * passed, the method ignores them and applies only valid ones. In the case\r\n       * that all the given dates are invalid, which is distinguished from passing\r\n       * no dates, the method considers it as an error and leaves the selection\r\n       * untouched.\r\n       *\r\n       * @param {...(Date|Number|String)|Array} [dates] - Date strings, Date\r\n       * objects, time values or mix of those for new selection\r\n       * @param {Object} [options] - function options\r\n       * - clear: {boolean} - Whether to clear the existing selection\r\n       *     defualt: false\r\n       * - render: {boolean} - Whether to re-render the picker element\r\n       *     default: true\r\n       * - autohide: {boolean} - Whether to hide the picker element after re-render\r\n       *     Ignored when used with render: false\r\n       *     default: config.autohide\r\n       */\n\n    }, {\n      key: \"setDate\",\n      value: function setDate() {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        var dates = [].concat(args);\n        var opts = {};\n        var lastArg = lastItemOf(args);\n\n        if (_typeof(lastArg) === 'object' && !Array.isArray(lastArg) && !(lastArg instanceof Date) && lastArg) {\n          Object.assign(opts, dates.pop());\n        }\n\n        var inputDates = Array.isArray(dates[0]) ? dates[0] : dates;\n\n        _setDate(this, inputDates, opts);\n      }\n      /**\r\n       * Update the selected date(s) with input field's value\r\n       * Not available on inline picker\r\n       *\r\n       * The input field will be refreshed with properly formatted date string.\r\n       *\r\n       * @param  {Object} [options] - function options\r\n       * - autohide: {boolean} - whether to hide the picker element after refresh\r\n       *     default: false\r\n       */\n\n    }, {\n      key: \"update\",\n      value: function update() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n        if (this.inline) {\n          return;\n        }\n\n        var opts = {\n          clear: true,\n          autohide: !!(options && options.autohide)\n        };\n        var inputDates = stringToArray(this.inputField.value, this.config.dateDelimiter);\n\n        _setDate(this, inputDates, opts);\n      }\n      /**\r\n       * Refresh the picker element and the associated input field\r\n       * @param {String} [target] - target item when refreshing one item only\r\n       * 'picker' or 'input'\r\n       * @param {Boolean} [forceRender] - whether to re-render the picker element\r\n       * regardless of its state instead of optimized refresh\r\n       */\n\n    }, {\n      key: \"refresh\",\n      value: function refresh() {\n        var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n        var forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (target && typeof target !== 'string') {\n          forceRender = target;\n          target = undefined;\n        }\n\n        var mode;\n\n        if (target === 'picker') {\n          mode = 2;\n        } else if (target === 'input') {\n          mode = 1;\n        } else {\n          mode = 3;\n        }\n\n        refreshUI(this, mode, !forceRender);\n      }\n      /**\r\n       * Enter edit mode\r\n       * Not available on inline picker or when the picker element is hidden\r\n       */\n\n    }, {\n      key: \"enterEditMode\",\n      value: function enterEditMode() {\n        if (this.inline || !this.picker.active || this.editMode) {\n          return;\n        }\n\n        this.editMode = true;\n        this.inputField.classList.add('in-edit', 'border-blue-700');\n      }\n      /**\r\n       * Exit from edit mode\r\n       * Not available on inline picker\r\n       * @param  {Object} [options] - function options\r\n       * - update: {boolean} - whether to call update() after exiting\r\n       *     If false, input field is revert to the existing selection\r\n       *     default: false\r\n       */\n\n    }, {\n      key: \"exitEditMode\",\n      value: function exitEditMode() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n        if (this.inline || !this.editMode) {\n          return;\n        }\n\n        var opts = Object.assign({\n          update: false\n        }, options);\n        delete this.editMode;\n        this.inputField.classList.remove('in-edit', 'border-blue-700');\n\n        if (opts.update) {\n          this.update(opts);\n        }\n      }\n    }], [{\n      key: \"formatDate\",\n      value: function formatDate(date, format, lang) {\n        return _formatDate(date, format, lang && locales[lang] || locales.en);\n      }\n      /**\r\n       * Parse date string\r\n       * @param  {String|Date|Number} dateStr - date string, Date object or time\r\n       * value to parse\r\n       * @param  {String|Object} format - format string or object that contains\r\n       * toValue() custom parser, whose signature is\r\n       * - args:\r\n       *   - dateStr: {String|Date|Number} - the dateStr passed to the method\r\n       *   - format: {Object} - the format object passed to the method\r\n       *   - locale: {Object} - locale for the language specified by `lang`\r\n       * - return:\r\n       *     {Date|Number} parsed date or its time value\r\n       * @param  {String} [lang=en] - language code for the locale to use\r\n       * @return {Number} time value of parsed date\r\n       */\n\n    }, {\n      key: \"parseDate\",\n      value: function parseDate(dateStr, format, lang) {\n        return _parseDate(dateStr, format, lang && locales[lang] || locales.en);\n      }\n      /**\r\n       * @type {Object} - Installed locales in `[languageCode]: localeObject` format\r\n       * en`:_English (US)_ is pre-installed.\r\n       */\n\n    }, {\n      key: \"locales\",\n      get: function get() {\n        return locales;\n      }\n    }]);\n\n    return Datepicker;\n  }();\n\n  ; // CONCATENATED MODULE: ./node_modules/@themesberg/tailwind-datepicker/js/DateRangePicker.js\n  // filter out the config options inapproprite to pass to Datepicker\n\n  function filterOptions(options) {\n    var newOpts = Object.assign({}, options);\n    delete newOpts.inputs;\n    delete newOpts.allowOneSidedRange;\n    delete newOpts.maxNumberOfDates; // to ensure each datepicker handles a single date\n\n    return newOpts;\n  }\n\n  function setupDatepicker(rangepicker, changeDateListener, el, options) {\n    registerListeners(rangepicker, [[el, 'changeDate', changeDateListener]]);\n    new Datepicker(el, options, rangepicker);\n  }\n\n  function onChangeDate(rangepicker, ev) {\n    // to prevent both datepickers trigger the other side's update each other\n    if (rangepicker._updating) {\n      return;\n    }\n\n    rangepicker._updating = true;\n    var target = ev.target;\n\n    if (target.datepicker === undefined) {\n      return;\n    }\n\n    var datepickers = rangepicker.datepickers;\n    var setDateOptions = {\n      render: false\n    };\n    var changedSide = rangepicker.inputs.indexOf(target);\n    var otherSide = changedSide === 0 ? 1 : 0;\n    var changedDate = datepickers[changedSide].dates[0];\n    var otherDate = datepickers[otherSide].dates[0];\n\n    if (changedDate !== undefined && otherDate !== undefined) {\n      // if the start of the range > the end, swap them\n      if (changedSide === 0 && changedDate > otherDate) {\n        datepickers[0].setDate(otherDate, setDateOptions);\n        datepickers[1].setDate(changedDate, setDateOptions);\n      } else if (changedSide === 1 && changedDate < otherDate) {\n        datepickers[0].setDate(changedDate, setDateOptions);\n        datepickers[1].setDate(otherDate, setDateOptions);\n      }\n    } else if (!rangepicker.allowOneSidedRange) {\n      // to prevent the range from becoming one-sided, copy changed side's\n      // selection (no matter if it's empty) to the other side\n      if (changedDate !== undefined || otherDate !== undefined) {\n        setDateOptions.clear = true;\n        datepickers[otherSide].setDate(datepickers[changedSide].dates, setDateOptions);\n      }\n    }\n\n    datepickers[0].picker.update().render();\n    datepickers[1].picker.update().render();\n    delete rangepicker._updating;\n  }\n  /**\r\n   * Class representing a date range picker\r\n   */\n\n\n  var DateRangePicker = /*#__PURE__*/function () {\n    /**\r\n     * Create a date range picker\r\n     * @param  {Element} element - element to bind a date range picker\r\n     * @param  {Object} [options] - config options\r\n     */\n    function DateRangePicker(element) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _classCallCheck(this, DateRangePicker);\n\n      var inputs = Array.isArray(options.inputs) ? options.inputs : Array.from(element.querySelectorAll('input'));\n\n      if (inputs.length < 2) {\n        return;\n      }\n\n      element.rangepicker = this;\n      this.element = element;\n      this.inputs = inputs.slice(0, 2);\n      this.allowOneSidedRange = !!options.allowOneSidedRange;\n      var changeDateListener = onChangeDate.bind(null, this);\n      var cleanOptions = filterOptions(options); // in order for initial date setup to work right when pcicLvel > 0,\n      // let Datepicker constructor add the instance to the rangepicker\n\n      var datepickers = [];\n      Object.defineProperty(this, 'datepickers', {\n        get: function get() {\n          return datepickers;\n        }\n      });\n      setupDatepicker(this, changeDateListener, this.inputs[0], cleanOptions);\n      setupDatepicker(this, changeDateListener, this.inputs[1], cleanOptions);\n      Object.freeze(datepickers); // normalize the range if inital dates are given\n\n      if (datepickers[0].dates.length > 0) {\n        onChangeDate(this, {\n          target: this.inputs[0]\n        });\n      } else if (datepickers[1].dates.length > 0) {\n        onChangeDate(this, {\n          target: this.inputs[1]\n        });\n      }\n    }\n    /**\r\n     * @type {Array} - selected date of the linked date pickers\r\n     */\n\n\n    _createClass(DateRangePicker, [{\n      key: \"dates\",\n      get: function get() {\n        return this.datepickers.length === 2 ? [this.datepickers[0].dates[0], this.datepickers[1].dates[0]] : undefined;\n      }\n      /**\r\n       * Set new values to the config options\r\n       * @param {Object} options - config options to update\r\n       */\n\n    }, {\n      key: \"setOptions\",\n      value: function setOptions(options) {\n        this.allowOneSidedRange = !!options.allowOneSidedRange;\n        var cleanOptions = filterOptions(options);\n        this.datepickers[0].setOptions(cleanOptions);\n        this.datepickers[1].setOptions(cleanOptions);\n      }\n      /**\r\n       * Destroy the DateRangePicker instance\r\n       * @return {DateRangePicker} - the instance destroyed\r\n       */\n\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        this.datepickers[0].destroy();\n        this.datepickers[1].destroy();\n        unregisterListeners(this);\n        delete this.element.rangepicker;\n      }\n      /**\r\n       * Get the start and end dates of the date range\r\n       *\r\n       * The method returns Date objects by default. If format string is passed,\r\n       * it returns date strings formatted in given format.\r\n       * The result array always contains 2 items (start date/end date) and\r\n       * undefined is used for unselected side. (e.g. If none is selected,\r\n       * the result will be [undefined, undefined]. If only the end date is set\r\n       * when allowOneSidedRange config option is true, [undefined, endDate] will\r\n       * be returned.)\r\n       *\r\n       * @param  {String} [format] - Format string to stringify the dates\r\n       * @return {Array} - Start and end dates\r\n       */\n\n    }, {\n      key: \"getDates\",\n      value: function getDates() {\n        var _this10 = this;\n\n        var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n        var callback = format ? function (date) {\n          return _formatDate(date, format, _this10.datepickers[0].config.locale);\n        } : function (date) {\n          return new Date(date);\n        };\n        return this.dates.map(function (date) {\n          return date === undefined ? date : callback(date);\n        });\n      }\n      /**\r\n       * Set the start and end dates of the date range\r\n       *\r\n       * The method calls datepicker.setDate() internally using each of the\r\n       * arguments in startend order.\r\n       *\r\n       * When a clear: true option object is passed instead of a date, the method\r\n       * clears the date.\r\n       *\r\n       * If an invalid date, the same date as the current one or an option object\r\n       * without clear: true is passed, the method considers that argument as an\r\n       * \"ineffective\" argument because calling datepicker.setDate() with those\r\n       * values makes no changes to the date selection.\r\n       *\r\n       * When the allowOneSidedRange config option is false, passing {clear: true}\r\n       * to clear the range works only when it is done to the last effective\r\n       * argument (in other words, passed to rangeEnd or to rangeStart along with\r\n       * ineffective rangeEnd). This is because when the date range is changed,\r\n       * it gets normalized based on the last change at the end of the changing\r\n       * process.\r\n       *\r\n       * @param {Date|Number|String|Object} rangeStart - Start date of the range\r\n       * or {clear: true} to clear the date\r\n       * @param {Date|Number|String|Object} rangeEnd - End date of the range\r\n       * or {clear: true} to clear the date\r\n       */\n\n    }, {\n      key: \"setDates\",\n      value: function setDates(rangeStart, rangeEnd) {\n        var _this$datepickers = _slicedToArray(this.datepickers, 2),\n            datepicker0 = _this$datepickers[0],\n            datepicker1 = _this$datepickers[1];\n\n        var origDates = this.dates; // If range normalization runs on every change, we can't set a new range\n        // that starts after the end of the current range correctly because the\n        // normalization process swaps startend right after setting the new start\n        // date. To prevent this, the normalization process needs to run once after\n        // both of the new dates are set.\n\n        this._updating = true;\n        datepicker0.setDate(rangeStart);\n        datepicker1.setDate(rangeEnd);\n        delete this._updating;\n\n        if (datepicker1.dates[0] !== origDates[1]) {\n          onChangeDate(this, {\n            target: this.inputs[1]\n          });\n        } else if (datepicker0.dates[0] !== origDates[0]) {\n          onChangeDate(this, {\n            target: this.inputs[0]\n          });\n        }\n      }\n    }]);\n\n    return DateRangePicker;\n  }();\n\n  ; // CONCATENATED MODULE: ./src/plugins/datepicker.js\n\n  var getDatepickerOptions = function getDatepickerOptions(datepickerEl) {\n    var buttons = datepickerEl.hasAttribute('datepicker-buttons');\n    var autohide = datepickerEl.hasAttribute('datepicker-autohide');\n    var format = datepickerEl.hasAttribute('datepicker-format');\n    var orientation = datepickerEl.hasAttribute('datepicker-orientation');\n    var title = datepickerEl.hasAttribute('datepicker-title');\n    var options = {};\n\n    if (buttons) {\n      options.todayBtn = true;\n      options.clearBtn = true;\n    }\n\n    if (autohide) {\n      options.autohide = true;\n    }\n\n    if (format) {\n      options.format = datepickerEl.getAttribute('datepicker-format');\n    }\n\n    if (orientation) {\n      options.orientation = datepickerEl.getAttribute('datepicker-orientation');\n    }\n\n    if (title) {\n      options.title = datepickerEl.getAttribute('datepicker-title');\n    }\n\n    return options;\n  };\n\n  document.addEventListener('DOMContentLoaded', function () {\n    document.querySelectorAll('[datepicker]').forEach(function (datepickerEl) {\n      new Datepicker(datepickerEl, getDatepickerOptions(datepickerEl));\n    });\n    document.querySelectorAll('[inline-datepicker]').forEach(function (datepickerEl) {\n      new Datepicker(datepickerEl, getDatepickerOptions(datepickerEl));\n    });\n    document.querySelectorAll('[date-rangepicker]').forEach(function (datepickerEl) {\n      new DateRangePicker(datepickerEl, getDatepickerOptions(datepickerEl));\n    });\n  });\n  /******/\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvZGF0ZXBpY2tlci5qcz80NTdmIl0sIm5hbWVzIjpbIl9fd2VicGFja19leHBvcnRzX18iLCJoYXNQcm9wZXJ0eSIsIm9iaiIsInByb3AiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJsYXN0SXRlbU9mIiwiYXJyIiwibGVuZ3RoIiwicHVzaFVuaXF1ZSIsIml0ZW1zIiwiZm9yRWFjaCIsIml0ZW0iLCJpbmNsdWRlcyIsInB1c2giLCJzdHJpbmdUb0FycmF5Iiwic3RyIiwic2VwYXJhdG9yIiwic3BsaXQiLCJpc0luUmFuZ2UiLCJ0ZXN0VmFsIiwibWluIiwibWF4IiwibWluT0siLCJ1bmRlZmluZWQiLCJtYXhPSyIsImxpbWl0VG9SYW5nZSIsInZhbCIsImNyZWF0ZVRhZ1JlcGVhdCIsInRhZ05hbWUiLCJyZXBlYXQiLCJhdHRyaWJ1dGVzIiwiaW5kZXgiLCJodG1sIiwib3BlblRhZ1NyYyIsImtleXMiLCJyZWR1Y2UiLCJzcmMiLCJhdHRyIiwibmV4dCIsIm9wdGltaXplVGVtcGxhdGVIVE1MIiwicmVwbGFjZSIsInN0cmlwVGltZSIsInRpbWVWYWx1ZSIsIkRhdGUiLCJzZXRIb3VycyIsInRvZGF5IiwiZGF0ZVZhbHVlIiwibmV3RGF0ZSIsInNldEZ1bGxZZWFyIiwiYWRkRGF5cyIsImRhdGUiLCJhbW91bnQiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsImFkZFdlZWtzIiwiYWRkTW9udGhzIiwibW9udGhzVG9TZXQiLCJnZXRNb250aCIsImV4cGVjdGVkTW9udGgiLCJ0aW1lIiwic2V0TW9udGgiLCJhZGRZZWFycyIsImdldEZ1bGxZZWFyIiwiZGF5RGlmZiIsImRheSIsImZyb20iLCJkYXlPZlRoZVdlZWtPZiIsImJhc2VEYXRlIiwiZGF5T2ZXZWVrIiwid2Vla1N0YXJ0IiwiYmFzZURheSIsImdldERheSIsImdldFdlZWsiLCJ0aHVPZlRoZVdlZWsiLCJmaXJzdFRodSIsIk1hdGgiLCJyb3VuZCIsInN0YXJ0T2ZZZWFyUGVyaW9kIiwieWVhcnMiLCJ5ZWFyIiwiZmxvb3IiLCJyZUZvcm1hdFRva2VucyIsInJlTm9uRGF0ZVBhcnRzIiwia25vd25Gb3JtYXRzIiwicGFyc2VGbnMiLCJ5IiwicGFyc2VJbnQiLCJtIiwibW9udGgiLCJsb2NhbGUiLCJtb250aEluZGV4IiwiaXNOYU4iLCJOYU4iLCJtb250aE5hbWUiLCJ0b0xvd2VyQ2FzZSIsImNvbXBhcmVOYW1lcyIsIm5hbWUiLCJzdGFydHNXaXRoIiwibW9udGhzU2hvcnQiLCJmaW5kSW5kZXgiLCJtb250aHMiLCJub3JtYWxpemVNb250aCIsImdldFRpbWUiLCJkIiwiZm9ybWF0Rm5zIiwiZGQiLCJwYWRaZXJvIiwiRCIsImRheXNTaG9ydCIsIkREIiwiZGF5cyIsIm1tIiwiTSIsIk1NIiwieXkiLCJzbGljZSIsInl5eXkiLCJudW0iLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwicGFyc2VGb3JtYXRTdHJpbmciLCJmb3JtYXQiLCJFcnJvciIsInNlcGFyYXRvcnMiLCJwYXJ0cyIsIm1hdGNoIiwiUmVnRXhwIiwicGFydEZvcm1hdHRlcnMiLCJtYXAiLCJ0b2tlbiIsInBhcnRQYXJzZXJLZXlzIiwia2V5IiwiZmluZCIsInBhcnQiLCJwYXJzZXIiLCJkYXRlU3RyIiwiZGF0ZVBhcnRzIiwiZHRQYXJ0cyIsIm9yaWdEYXRlIiwiZm9ybWF0dGVyIiwiZm4iLCJwYXJzZURhdGUiLCJ0b1ZhbHVlIiwiZm9ybWF0RGF0ZSIsImRhdGVPYmoiLCJ0b0Rpc3BsYXkiLCJsaXN0ZW5lclJlZ2lzdHJ5IiwiV2Vha01hcCIsIkV2ZW50VGFyZ2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZWdpc3Rlckxpc3RlbmVycyIsImtleU9iaiIsImxpc3RlbmVycyIsInJlZ2lzdGVyZWQiLCJnZXQiLCJzZXQiLCJsaXN0ZW5lciIsInVucmVnaXN0ZXJMaXN0ZW5lcnMiLCJFdmVudCIsImNvbXBvc2VkUGF0aCIsImdldENvbXBvc2VkUGF0aCIsIm5vZGUiLCJwYXRoIiwicGFyZW50IiwicGFyZW50Tm9kZSIsImhvc3QiLCJkZWZhdWx0VmlldyIsInRhcmdldCIsImZpbmRGcm9tUGF0aCIsImNyaXRlcmlhIiwiY3VycmVudFRhcmdldCIsImVsIiwicGFyZW50RWxlbWVudCIsImZpbmRFbGVtZW50SW5FdmVudFBhdGgiLCJldiIsInNlbGVjdG9yIiwibWF0Y2hlcyIsImxvY2FsZXMiLCJlbiIsImRheXNNaW4iLCJjbGVhciIsInRpdGxlRm9ybWF0IiwiZGVmYXVsdE9wdGlvbnMiLCJhdXRvaGlkZSIsImJlZm9yZVNob3dEYXkiLCJiZWZvcmVTaG93RGVjYWRlIiwiYmVmb3JlU2hvd01vbnRoIiwiYmVmb3JlU2hvd1llYXIiLCJjYWxlbmRhcldlZWtzIiwiY2xlYXJCdG4iLCJkYXRlRGVsaW1pdGVyIiwiZGF0ZXNEaXNhYmxlZCIsImRheXNPZldlZWtEaXNhYmxlZCIsImRheXNPZldlZWtIaWdobGlnaHRlZCIsImRlZmF1bHRWaWV3RGF0ZSIsImRpc2FibGVUb3VjaEtleWJvYXJkIiwibGFuZ3VhZ2UiLCJtYXhEYXRlIiwibWF4TnVtYmVyT2ZEYXRlcyIsIm1heFZpZXciLCJtaW5EYXRlIiwibmV4dEFycm93Iiwib3JpZW50YXRpb24iLCJwaWNrTGV2ZWwiLCJwcmV2QXJyb3ciLCJzaG93RGF5c09mV2VlayIsInNob3dPbkNsaWNrIiwic2hvd09uRm9jdXMiLCJzdGFydFZpZXciLCJ0aXRsZSIsInRvZGF5QnRuIiwidG9kYXlCdG5Nb2RlIiwidG9kYXlIaWdobGlnaHQiLCJ1cGRhdGVPbkJsdXIiLCJvcHRpb25zX2RlZmF1bHRPcHRpb25zIiwicmFuZ2UiLCJkb2N1bWVudCIsImNyZWF0ZVJhbmdlIiwicGFyc2VIVE1MIiwiY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50IiwiaXNWaXNpYmxlIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJnZXRDbGllbnRSZWN0cyIsImhpZGVFbGVtZW50Iiwic3R5bGUiLCJkaXNwbGF5IiwiZGF0YXNldCIsInN0eWxlRGlzcGxheSIsInNob3dFbGVtZW50IiwiZW1wdHlDaGlsZE5vZGVzIiwiZmlyc3RDaGlsZCIsInJlbW92ZUNoaWxkIiwicmVwbGFjZUNoaWxkTm9kZXMiLCJuZXdDaGlsZE5vZGVzIiwiRG9jdW1lbnRGcmFnbWVudCIsImFwcGVuZENoaWxkIiwiZGVmYXVsdExhbmciLCJkZWZhdWx0Rm9ybWF0IiwiZGVmYXVsdFdlZWtTdGFydCIsInNhbml0aXplRE9XIiwiZG93IiwiY2FsY0VuZE9mV2VlayIsInN0YXJ0T2ZXZWVrIiwidmFsaWRhdGVEYXRlIiwidmFsdWUiLCJvcmlnVmFsdWUiLCJ2YWxpZGF0ZVZpZXdJZCIsInZpZXdJZCIsInByb2Nlc3NPcHRpb25zIiwib3B0aW9ucyIsImRhdGVwaWNrZXIiLCJpbk9wdHMiLCJhc3NpZ24iLCJjb25maWciLCJjb25zdHJ1Y3RvciIsImxhbmciLCJvcmlnTG9jYWxlIiwid2Vla0VuZCIsImhhc1RvRGlzcGxheSIsImhhc1RvVmFsdWUiLCJ2YWxpZEZvcm1hdFN0cmluZyIsInRlc3QiLCJtaW5EdCIsIm1heER0IiwiZGF0ZXMiLCJkdCIsInZpZXdEYXRlIiwid2tTdGFydCIsIk51bWJlciIsIm11bHRpZGF0ZSIsIlN0cmluZyIsIm5ld1BpY2tMZXZlbCIsIm5ld01heFZpZXciLCJuZXdTdGFydFZpZXciLCJjaGlsZE5vZGVzIiwieCIsInBpY2tlclRlbXBsYXRlIiwidGVtcGxhdGVzX3BpY2tlclRlbXBsYXRlIiwiZGF5c1RlbXBsYXRlIiwidGVtcGxhdGVzX2RheXNUZW1wbGF0ZSIsImNhbGVuZGFyV2Vla3NUZW1wbGF0ZSIsInRlbXBsYXRlc19jYWxlbmRhcldlZWtzVGVtcGxhdGUiLCJWaWV3IiwicGlja2VyIiwiZWxlbWVudCIsInNlbGVjdGVkIiwiaW5pdCIsImlzTWluVmlldyIsImlkIiwic2V0T3B0aW9ucyIsInVwZGF0ZUZvY3VzIiwidXBkYXRlU2VsZWN0aW9uIiwiY3VycmVudCIsInJlc3VsdCIsImJlZm9yZVNob3ciLCJlbmFibGVkIiwiY2xhc3NlcyIsImNsYXNzTGlzdCIsImFkZCIsImRpc2FibGVkIiwiZXh0cmFDbGFzc2VzIiwiY29udGVudCIsIkRheXNWaWV3IiwiY2VsbENsYXNzIiwib25Db25zdHJ1Y3Rpb24iLCJpbm5lciIsImdyaWQiLCJsYXN0Q2hpbGQiLCJ1cGRhdGVET1ciLCJkYXlOYW1lcyIsInN3aXRjaExhYmVsRm9ybWF0Iiwid2Vla3NFbGVtIiwid2Vla3MiLCJpbnNlcnRCZWZvcmUiLCJBcnJheSIsImNoaWxkcmVuIiwidGV4dENvbnRlbnQiLCJjbGFzc05hbWUiLCJ2aWV3WWVhciIsInZpZXdNb250aCIsImZpcnN0T2ZNb250aCIsInN0YXJ0IiwiZmlyc3QiLCJsYXN0IiwiZm9jdXNlZCIsInJhbmdlcGlja2VyIiwic3dpdGNoTGFiZWwiLCJzZXRWaWV3U3dpdGNoTGFiZWwiLCJzZXRQcmV2QnRuRGlzYWJsZWQiLCJzZXROZXh0QnRuRGlzYWJsZWQiLCJyYW5nZVN0YXJ0IiwicmFuZ2VFbmQiLCJyZW1vdmUiLCJwZXJmb3JtQmVmb3JlSG9vayIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJjb21wdXRlTW9udGhSYW5nZSIsInRoaXNZZWFyIiwic3RhcnRZIiwic3RhcnRNIiwiZW5kWSIsImVuZE0iLCJNb250aHNWaWV3IiwiaXgiLCJtb250aE5hbWVzIiwibWluWWVhciIsIm1pbk1vbnRoIiwibWluRGF0ZU9iaiIsIm1heFllYXIiLCJtYXhNb250aCIsIm1heERhdGVPYmoiLCJ5ck91dE9mUmFuZ2UiLCJpc01pblllYXIiLCJpc01heFllYXIiLCJ0b1RpdGxlQ2FzZSIsIndvcmQiLCJjaCIsInRvVXBwZXJDYXNlIiwiWWVhcnNWaWV3IiwibmF2U3RlcCIsInN0ZXAiLCJiZWZvcmVTaG93T3B0aW9uIiwidHJpZ2dlckRhdGVwaWNrZXJFdmVudCIsInR5cGUiLCJkZXRhaWwiLCJjdXJyZW50VmlldyIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsImdvVG9QcmV2T3JOZXh0IiwiZGlyZWN0aW9uIiwibmV3Vmlld0RhdGUiLCJjaGFuZ2VGb2N1cyIsInJlbmRlciIsInN3aXRjaFZpZXciLCJjaGFuZ2VWaWV3IiwidW5mb2N1cyIsInVwZGF0ZSIsInJlZnJlc2giLCJoaWRlIiwiZ29Ub1NlbGVjdGVkTW9udGhPclllYXIiLCJzZWxlY3Rpb24iLCJvbkNsaWNrVG9kYXlCdG4iLCJjdXJyZW50RGF0ZSIsIm9uQ2xpY2tDbGVhckJ0biIsIm9uQ2xpY2tWaWV3U3dpdGNoIiwib25DbGlja1ByZXZCdG4iLCJvbkNsaWNrTmV4dEJ0biIsIm9uQ2xpY2tWaWV3IiwiY29udGFpbnMiLCJvbkNsaWNrUGlja2VyIiwiaW5saW5lIiwiaW5wdXRGaWVsZCIsImZvY3VzIiwicHJvY2Vzc1BpY2tlck9wdGlvbnMiLCJjb250cm9scyIsInByZXZCdG4iLCJjbG9uZU5vZGUiLCJuZXh0QnRuIiwiY29tcHV0ZVJlc2V0Vmlld0RhdGUiLCJzZXRWaWV3RGF0ZSIsIm9sZFZpZXdEYXRlIiwiZ2V0VGV4dERpcmVjdGlvbiIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJQaWNrZXIiLCJ0ZW1wbGF0ZSIsImJ1dHRvbkNsYXNzIiwiaGVhZGVyIiwibWFpbiIsImZvb3RlciIsImZpcnN0RWxlbWVudENoaWxkIiwibGFzdEVsZW1lbnRDaGlsZCIsInZpZXdTd2l0Y2giLCJlbGVtZW50Q2xhc3MiLCJiaW5kIiwiY2FwdHVyZSIsInZpZXdzIiwiY29udGFpbmVyIiwidmlldyIsImFjdGl2ZSIsImlucHV0RGlyZWN0aW9uIiwiZGlyIiwicmVtb3ZlQXR0cmlidXRlIiwicGxhY2UiLCJibHVyIiwiZXhpdEVkaXRNb2RlIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2FsZW5kYXJXaWR0aCIsIndpZHRoIiwiY2FsZW5kYXJIZWlnaHQiLCJoZWlnaHQiLCJjb250YWluZXJMZWZ0IiwibGVmdCIsImNvbnRhaW5lclRvcCIsInRvcCIsImNvbnRhaW5lcldpZHRoIiwiaW5wdXRMZWZ0IiwiaW5wdXRUb3AiLCJpbnB1dFdpZHRoIiwiaW5wdXRIZWlnaHQiLCJvcmllbnRYIiwib3JpZW50WSIsInNjcm9sbFRvcCIsImJvZHkiLCJzY3JvbGxZIiwic2Nyb2xsWCIsImxhYmVsVGV4dCIsIm9sZFZpZXciLCJuZXdWaWV3IiwiX3JlbmRlck1ldGhvZCIsInJlcGxhY2VDaGlsZCIsInF1aWNrUmVuZGVyIiwicmVuZGVyTWV0aG9kIiwiZmluZE5leHRBdmFpbGFibGVPbmUiLCJhZGRGbiIsImluY3JlYXNlIiwidGVzdEZuIiwibW92ZUJ5QXJyb3dLZXkiLCJ2ZXJ0aWNhbCIsImN0cmxLZXkiLCJtZXRhS2V5Iiwib25LZXlkb3duIiwic2hvdyIsImVkaXRNb2RlIiwic2hpZnRLZXkiLCJlbnRlckVkaXRNb2RlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJvbkZvY3VzIiwiX3Nob3dpbmciLCJvbk1vdXNlZG93biIsIl9hY3RpdmUiLCJhY3RpdmVFbGVtZW50IiwiX2NsaWNraW5nIiwic2V0VGltZW91dCIsIm9uQ2xpY2tJbnB1dCIsImNsZWFyVGltZW91dCIsIm9uUGFzdGUiLCJjbGlwYm9hcmREYXRhIiwidHlwZXMiLCJvbkNsaWNrT3V0c2lkZSIsInBpY2tlckVsZW0iLCJzdHJpbmdpZnlEYXRlcyIsImpvaW4iLCJwcm9jZXNzSW5wdXREYXRlcyIsImlucHV0RGF0ZXMiLCJvcmlnRGF0ZXMiLCJkYXRlcGlja2VycyIsIm5ld0RhdGVzIiwiZmlsdGVyIiwicmVmcmVzaFVJIiwibW9kZSIsIkRhdGVwaWNrZXIiLCJfb3B0aW9ucyIsImluaXRpYWxEYXRlcyIsInF1ZXJ5U2VsZWN0b3IiLCJpbnB1dHMiLCJpbmRleE9mIiwiaXNBcnJheSIsImRlZmluZVByb3BlcnR5IiwiaW5wdXREYXRlVmFsdWVzIiwib25Nb3VzZWRvd25Eb2N1bWVudCIsIm5ld09wdGlvbnMiLCJkZXRhY2giLCJjYWxsYmFjayIsImFyZ3MiLCJvcHRzIiwibGFzdEFyZyIsInBvcCIsImZvcmNlUmVuZGVyIiwiZmlsdGVyT3B0aW9ucyIsIm5ld09wdHMiLCJhbGxvd09uZVNpZGVkUmFuZ2UiLCJzZXR1cERhdGVwaWNrZXIiLCJjaGFuZ2VEYXRlTGlzdGVuZXIiLCJvbkNoYW5nZURhdGUiLCJfdXBkYXRpbmciLCJzZXREYXRlT3B0aW9ucyIsImNoYW5nZWRTaWRlIiwib3RoZXJTaWRlIiwiY2hhbmdlZERhdGUiLCJvdGhlckRhdGUiLCJEYXRlUmFuZ2VQaWNrZXIiLCJjbGVhbk9wdGlvbnMiLCJmcmVlemUiLCJkZXN0cm95IiwiZGF0ZXBpY2tlcjAiLCJkYXRlcGlja2VyMSIsImdldERhdGVwaWNrZXJPcHRpb25zIiwiZGF0ZXBpY2tlckVsIiwiYnV0dG9ucyIsImhhc0F0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQVMsQ0FBQyxZQUFNO0FBQUU7O0FBQ2xCO0FBQVU7O0FBQ1YsTUFBSUEsbUJBQW1CLEdBQUcsRUFBMUI7QUFFQSxHQUpnQixDQUlmOztBQUNELFdBQVNDLFdBQVQsQ0FBcUJDLEdBQXJCLEVBQTBCQyxJQUExQixFQUFnQztBQUM5QixXQUFPQyxNQUFNLENBQUNDLFNBQVAsQ0FBaUJDLGNBQWpCLENBQWdDQyxJQUFoQyxDQUFxQ0wsR0FBckMsRUFBMENDLElBQTFDLENBQVA7QUFDRDs7QUFFRCxXQUFTSyxVQUFULENBQW9CQyxHQUFwQixFQUF5QjtBQUN2QixXQUFPQSxHQUFHLENBQUNBLEdBQUcsQ0FBQ0MsTUFBSixHQUFhLENBQWQsQ0FBVjtBQUNELEdBWGUsQ0FhaEI7OztBQUNBLFdBQVNDLFVBQVQsQ0FBb0JGLEdBQXBCLEVBQW1DO0FBQUEsc0NBQVBHLEtBQU87QUFBUEEsTUFBQUEsS0FBTztBQUFBOztBQUNqQ0EsSUFBQUEsS0FBSyxDQUFDQyxPQUFOLENBQWMsVUFBQ0MsSUFBRCxFQUFVO0FBQ3RCLFVBQUlMLEdBQUcsQ0FBQ00sUUFBSixDQUFhRCxJQUFiLENBQUosRUFBd0I7QUFDdEI7QUFDRDs7QUFD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Z0JnVSxZQUFZLENBQUNHLFlBQWIsQ0FBMEIsa0JBQTFCLENBQWhCO0FBQ0Q7O0FBRUQsV0FBTzFSLE9BQVA7QUFDRCxHQTlCRDs7QUFnQ0FsQyxFQUFBQSxRQUFRLENBQUNwRSxnQkFBVCxDQUEwQixrQkFBMUIsRUFBOEMsWUFBTTtBQUNsRG9FLElBQUFBLFFBQVEsQ0FBQ3VILGdCQUFULENBQTBCLGNBQTFCLEVBQTBDdFUsT0FBMUMsQ0FBa0QsVUFBVXdnQixZQUFWLEVBQXdCO0FBQ3hFLFVBQUlyQyxVQUFKLENBQWVxQyxZQUFmLEVBQTZCRCxvQkFBb0IsQ0FBQ0MsWUFBRCxDQUFqRDtBQUNELEtBRkQ7QUFHQXpULElBQUFBLFFBQVEsQ0FBQ3VILGdCQUFULENBQTBCLHFCQUExQixFQUFpRHRVLE9BQWpELENBQXlELFVBQVV3Z0IsWUFBVixFQUF3QjtBQUMvRSxVQUFJckMsVUFBSixDQUFlcUMsWUFBZixFQUE2QkQsb0JBQW9CLENBQUNDLFlBQUQsQ0FBakQ7QUFDRCxLQUZEO0FBR0F6VCxJQUFBQSxRQUFRLENBQUN1SCxnQkFBVCxDQUEwQixvQkFBMUIsRUFBZ0R0VSxPQUFoRCxDQUF3RCxVQUFVd2dCLFlBQVYsRUFBd0I7QUFDOUUsVUFBSVAsZUFBSixDQUFvQk8sWUFBcEIsRUFBa0NELG9CQUFvQixDQUFDQyxZQUFELENBQXREO0FBQ0QsS0FGRDtBQUdELEdBVkQ7QUFXQTtBQUFVLENBajNGRCIsInNvdXJjZXNDb250ZW50IjpbIi8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcclxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fTtcclxuXHJcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdGhlbWVzYmVyZy90YWlsd2luZC1kYXRlcGlja2VyL2pzL2xpYi91dGlscy5qc1xyXG5mdW5jdGlvbiBoYXNQcm9wZXJ0eShvYmosIHByb3ApIHtcclxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxhc3RJdGVtT2YoYXJyKSB7XHJcbiAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XHJcbn1cclxuXHJcbi8vIHB1c2ggb25seSB0aGUgaXRlbXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheVxyXG5mdW5jdGlvbiBwdXNoVW5pcXVlKGFyciwgLi4uaXRlbXMpIHtcclxuICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XHJcbiAgICBpZiAoYXJyLmluY2x1ZGVzKGl0ZW0pKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGFyci5wdXNoKGl0ZW0pO1xyXG4gIH0pO1xyXG4gIHJldHVybiBhcnI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyLCBzZXBhcmF0b3IpIHtcclxuICAvLyBjb252ZXJ0IGVtcHR5IHN0cmluZyB0byBhbiBlbXB0eSBhcnJheVxyXG4gIHJldHVybiBzdHIgPyBzdHIuc3BsaXQoc2VwYXJhdG9yKSA6IFtdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0luUmFuZ2UodGVzdFZhbCwgbWluLCBtYXgpIHtcclxuICBjb25zdCBtaW5PSyA9IG1pbiA9PT0gdW5kZWZpbmVkIHx8IHRlc3RWYWwgPj0gbWluO1xyXG4gIGNvbnN0IG1heE9LID0gbWF4ID09PSB1bmRlZmluZWQgfHwgdGVzdFZhbCA8PSBtYXg7XHJcbiAgcmV0dXJuIG1pbk9LICYmIG1heE9LO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsaW1pdFRvUmFuZ2UodmFsLCBtaW4sIG1heCkge1xyXG4gIGlmICh2YWwgPCBtaW4pIHtcclxuICAgIHJldHVybiBtaW47XHJcbiAgfVxyXG4gIGlmICh2YWwgPiBtYXgpIHtcclxuICAgIHJldHVybiBtYXg7XHJcbiAgfVxyXG4gIHJldHVybiB2YWw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVRhZ1JlcGVhdCh0YWdOYW1lLCByZXBlYXQsIGF0dHJpYnV0ZXMgPSB7fSwgaW5kZXggPSAwLCBodG1sID0gJycpIHtcclxuICBjb25zdCBvcGVuVGFnU3JjID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcykucmVkdWNlKChzcmMsIGF0dHIpID0+IHtcclxuICAgIGxldCB2YWwgPSBhdHRyaWJ1dGVzW2F0dHJdO1xyXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdmFsID0gdmFsKGluZGV4KTtcclxuICAgIH1cclxuICAgIHJldHVybiBgJHtzcmN9ICR7YXR0cn09XCIke3ZhbH1cImA7XHJcbiAgfSwgdGFnTmFtZSk7XHJcbiAgaHRtbCArPSBgPCR7b3BlblRhZ1NyY30+PC8ke3RhZ05hbWV9PmA7XHJcblxyXG4gIGNvbnN0IG5leHQgPSBpbmRleCArIDE7XHJcbiAgcmV0dXJuIG5leHQgPCByZXBlYXRcclxuICAgID8gY3JlYXRlVGFnUmVwZWF0KHRhZ05hbWUsIHJlcGVhdCwgYXR0cmlidXRlcywgbmV4dCwgaHRtbClcclxuICAgIDogaHRtbDtcclxufVxyXG5cclxuLy8gUmVtb3ZlIHRoZSBzcGFjaW5nIHN1cnJvdW5kaW5nIHRhZ3MgZm9yIEhUTUwgcGFyc2VyIG5vdCB0byBjcmVhdGUgdGV4dCBub2Rlc1xyXG4vLyBiZWZvcmUvYWZ0ZXIgZWxlbWVudHNcclxuZnVuY3Rpb24gb3B0aW1pemVUZW1wbGF0ZUhUTUwoaHRtbCkge1xyXG4gIHJldHVybiBodG1sLnJlcGxhY2UoLz5cXHMrL2csICc+JykucmVwbGFjZSgvXFxzKzwvLCAnPCcpO1xyXG59XHJcblxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHRoZW1lc2JlcmcvdGFpbHdpbmQtZGF0ZXBpY2tlci9qcy9saWIvZGF0ZS5qc1xyXG5mdW5jdGlvbiBzdHJpcFRpbWUodGltZVZhbHVlKSB7XHJcbiAgcmV0dXJuIG5ldyBEYXRlKHRpbWVWYWx1ZSkuc2V0SG91cnMoMCwgMCwgMCwgMCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRvZGF5KCkge1xyXG4gIHJldHVybiBuZXcgRGF0ZSgpLnNldEhvdXJzKDAsIDAsIDAsIDApO1xyXG59XHJcblxyXG4vLyBHZXQgdGhlIHRpbWUgdmFsdWUgb2YgdGhlIHN0YXJ0IG9mIGdpdmVuIGRhdGUgb3IgeWVhciwgbW9udGggYW5kIGRheVxyXG5mdW5jdGlvbiBkYXRlVmFsdWUoLi4uYXJncykge1xyXG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcclxuICAgIGNhc2UgMDpcclxuICAgICAgcmV0dXJuIHRvZGF5KCk7XHJcbiAgICBjYXNlIDE6XHJcbiAgICAgIHJldHVybiBzdHJpcFRpbWUoYXJnc1swXSk7XHJcbiAgfVxyXG5cclxuICAvLyB1c2Ugc2V0RnVsbFllYXIoKSB0byBrZWVwIDItZGlnaXQgeWVhciBmcm9tIGJlaW5nIG1hcHBlZCB0byAxOTAwLTE5OTlcclxuICBjb25zdCBuZXdEYXRlID0gbmV3IERhdGUoMCk7XHJcbiAgbmV3RGF0ZS5zZXRGdWxsWWVhciguLi5hcmdzKTtcclxuICByZXR1cm4gbmV3RGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkRGF5cyhkYXRlLCBhbW91bnQpIHtcclxuICBjb25zdCBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZSk7XHJcbiAgcmV0dXJuIG5ld0RhdGUuc2V0RGF0ZShuZXdEYXRlLmdldERhdGUoKSArIGFtb3VudCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFdlZWtzKGRhdGUsIGFtb3VudCkge1xyXG4gIHJldHVybiBhZGREYXlzKGRhdGUsIGFtb3VudCAqIDcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRNb250aHMoZGF0ZSwgYW1vdW50KSB7XHJcbiAgLy8gSWYgdGhlIGRheSBvZiB0aGUgZGF0ZSBpcyBub3QgaW4gdGhlIG5ldyBtb250aCwgdGhlIGxhc3QgZGF5IG9mIHRoZSBuZXdcclxuICAvLyBtb250aCB3aWxsIGJlIHJldHVybmVkLiBlLmcuIEphbiAzMSArIDEgbW9udGgg4oaSIEZlYiAyOCAobm90IE1hciAwMylcclxuICBjb25zdCBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZSk7XHJcbiAgY29uc3QgbW9udGhzVG9TZXQgPSBuZXdEYXRlLmdldE1vbnRoKCkgKyBhbW91bnQ7XHJcbiAgbGV0IGV4cGVjdGVkTW9udGggPSBtb250aHNUb1NldCAlIDEyO1xyXG4gIGlmIChleHBlY3RlZE1vbnRoIDwgMCkge1xyXG4gICAgZXhwZWN0ZWRNb250aCArPSAxMjtcclxuICB9XHJcblxyXG4gIGNvbnN0IHRpbWUgPSBuZXdEYXRlLnNldE1vbnRoKG1vbnRoc1RvU2V0KTtcclxuICByZXR1cm4gbmV3RGF0ZS5nZXRNb250aCgpICE9PSBleHBlY3RlZE1vbnRoID8gbmV3RGF0ZS5zZXREYXRlKDApIDogdGltZTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkWWVhcnMoZGF0ZSwgYW1vdW50KSB7XHJcbiAgLy8gSWYgdGhlIGRhdGUgaXMgRmViIDI5IGFuZCB0aGUgbmV3IHllYXIgaXMgbm90IGEgbGVhcCB5ZWFyLCBGZWIgMjggb2YgdGhlXHJcbiAgLy8gbmV3IHllYXIgd2lsbCBiZSByZXR1cm5lZC5cclxuICBjb25zdCBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZSk7XHJcbiAgY29uc3QgZXhwZWN0ZWRNb250aCA9IG5ld0RhdGUuZ2V0TW9udGgoKTtcclxuICBjb25zdCB0aW1lID0gbmV3RGF0ZS5zZXRGdWxsWWVhcihuZXdEYXRlLmdldEZ1bGxZZWFyKCkgKyBhbW91bnQpO1xyXG4gIHJldHVybiBleHBlY3RlZE1vbnRoID09PSAxICYmIG5ld0RhdGUuZ2V0TW9udGgoKSA9PT0gMiA/IG5ld0RhdGUuc2V0RGF0ZSgwKSA6IHRpbWU7XHJcbn1cclxuXHJcbi8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0dHdlbiAyIGRheXMgb2YgdGhlIHdlZWtcclxuZnVuY3Rpb24gZGF5RGlmZihkYXksIGZyb20pIHtcclxuICByZXR1cm4gKGRheSAtIGZyb20gKyA3KSAlIDc7XHJcbn1cclxuXHJcbi8vIEdldCB0aGUgZGF0ZSBvZiB0aGUgc3BlY2lmaWVkIGRheSBvZiB0aGUgd2VlayBvZiBnaXZlbiBiYXNlIGRhdGVcclxuZnVuY3Rpb24gZGF5T2ZUaGVXZWVrT2YoYmFzZURhdGUsIGRheU9mV2Vlaywgd2Vla1N0YXJ0ID0gMCkge1xyXG4gIGNvbnN0IGJhc2VEYXkgPSBuZXcgRGF0ZShiYXNlRGF0ZSkuZ2V0RGF5KCk7XHJcbiAgcmV0dXJuIGFkZERheXMoYmFzZURhdGUsIGRheURpZmYoZGF5T2ZXZWVrLCB3ZWVrU3RhcnQpIC0gZGF5RGlmZihiYXNlRGF5LCB3ZWVrU3RhcnQpKTtcclxufVxyXG5cclxuLy8gR2V0IHRoZSBJU08gd2VlayBvZiBhIGRhdGVcclxuZnVuY3Rpb24gZ2V0V2VlayhkYXRlKSB7XHJcbiAgLy8gc3RhcnQgb2YgSVNPIHdlZWsgaXMgTW9uZGF5XHJcbiAgY29uc3QgdGh1T2ZUaGVXZWVrID0gZGF5T2ZUaGVXZWVrT2YoZGF0ZSwgNCwgMSk7XHJcbiAgLy8gMXN0IHdlZWsgPT0gdGhlIHdlZWsgd2hlcmUgdGhlIDR0aCBvZiBKYW51YXJ5IGlzIGluXHJcbiAgY29uc3QgZmlyc3RUaHUgPSBkYXlPZlRoZVdlZWtPZihuZXcgRGF0ZSh0aHVPZlRoZVdlZWspLnNldE1vbnRoKDAsIDQpLCA0LCAxKTtcclxuICByZXR1cm4gTWF0aC5yb3VuZCgodGh1T2ZUaGVXZWVrIC0gZmlyc3RUaHUpIC8gNjA0ODAwMDAwKSArIDE7XHJcbn1cclxuXHJcbi8vIEdldCB0aGUgc3RhcnQgeWVhciBvZiB0aGUgcGVyaW9kIG9mIHllYXJzIHRoYXQgaW5jbHVkZXMgZ2l2ZW4gZGF0ZVxyXG4vLyB5ZWFyczogbGVuZ3RoIG9mIHRoZSB5ZWFyIHBlcmlvZFxyXG5mdW5jdGlvbiBzdGFydE9mWWVhclBlcmlvZChkYXRlLCB5ZWFycykge1xyXG4gIC8qIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWWVhcl96ZXJvI0lTT184NjAxICovXHJcbiAgY29uc3QgeWVhciA9IG5ldyBEYXRlKGRhdGUpLmdldEZ1bGxZZWFyKCk7XHJcbiAgcmV0dXJuIE1hdGguZmxvb3IoeWVhciAvIHllYXJzKSAqIHllYXJzO1xyXG59XHJcblxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHRoZW1lc2JlcmcvdGFpbHdpbmQtZGF0ZXBpY2tlci9qcy9saWIvZGF0ZS1mb3JtYXQuanNcclxuXHJcblxyXG5cclxuLy8gcGF0dGVybiBmb3IgZm9ybWF0IHBhcnRzXHJcbmNvbnN0IHJlRm9ybWF0VG9rZW5zID0gL2RkP3xERD98bW0/fE1NP3x5eT8oPzp5eSk/LztcclxuLy8gcGF0dGVybiBmb3Igbm9uIGRhdGUgcGFydHNcclxuY29uc3QgcmVOb25EYXRlUGFydHMgPSAvW1xccyEtLzotQFstYHstfuW5tOaciOaXpV0rLztcclxuLy8gY2FjaGUgZm9yIHBlcnNlZCBmb3JtYXRzXHJcbmxldCBrbm93bkZvcm1hdHMgPSB7fTtcclxuLy8gcGFyc2UgZnVudGlvbnMgZm9yIGRhdGUgcGFydHNcclxuY29uc3QgcGFyc2VGbnMgPSB7XHJcbiAgeShkYXRlLCB5ZWFyKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSkuc2V0RnVsbFllYXIocGFyc2VJbnQoeWVhciwgMTApKTtcclxuICB9LFxyXG4gIG0oZGF0ZSwgbW9udGgsIGxvY2FsZSkge1xyXG4gICAgY29uc3QgbmV3RGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xyXG4gICAgbGV0IG1vbnRoSW5kZXggPSBwYXJzZUludChtb250aCwgMTApIC0gMTtcclxuXHJcbiAgICBpZiAoaXNOYU4obW9udGhJbmRleCkpIHtcclxuICAgICAgaWYgKCFtb250aCkge1xyXG4gICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IG1vbnRoTmFtZSA9IG1vbnRoLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIGNvbnN0IGNvbXBhcmVOYW1lcyA9IG5hbWUgPT4gbmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgobW9udGhOYW1lKTtcclxuICAgICAgLy8gY29tcGFyZSB3aXRoIGJvdGggc2hvcnQgYW5kIGZ1bGwgbmFtZXMgYmVjYXVzZSBzb21lIGxvY2FsZXMgaGF2ZSBwZXJpb2RzXHJcbiAgICAgIC8vIGluIHRoZSBzaG9ydCBuYW1lcyAobm90IGVxdWFsIHRvIHRoZSBmaXJzdCBYIGxldHRlcnMgb2YgdGhlIGZ1bGwgbmFtZXMpXHJcbiAgICAgIG1vbnRoSW5kZXggPSBsb2NhbGUubW9udGhzU2hvcnQuZmluZEluZGV4KGNvbXBhcmVOYW1lcyk7XHJcbiAgICAgIGlmIChtb250aEluZGV4IDwgMCkge1xyXG4gICAgICAgIG1vbnRoSW5kZXggPSBsb2NhbGUubW9udGhzLmZpbmRJbmRleChjb21wYXJlTmFtZXMpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChtb250aEluZGV4IDwgMCkge1xyXG4gICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBuZXdEYXRlLnNldE1vbnRoKG1vbnRoSW5kZXgpO1xyXG4gICAgcmV0dXJuIG5ld0RhdGUuZ2V0TW9udGgoKSAhPT0gbm9ybWFsaXplTW9udGgobW9udGhJbmRleClcclxuICAgICAgPyBuZXdEYXRlLnNldERhdGUoMClcclxuICAgICAgOiBuZXdEYXRlLmdldFRpbWUoKTtcclxuICB9LFxyXG4gIGQoZGF0ZSwgZGF5KSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSkuc2V0RGF0ZShwYXJzZUludChkYXksIDEwKSk7XHJcbiAgfSxcclxufTtcclxuLy8gZm9ybWF0IGZ1bmN0aW9ucyBmb3IgZGF0ZSBwYXJ0c1xyXG5jb25zdCBmb3JtYXRGbnMgPSB7XHJcbiAgZChkYXRlKSB7XHJcbiAgICByZXR1cm4gZGF0ZS5nZXREYXRlKCk7XHJcbiAgfSxcclxuICBkZChkYXRlKSB7XHJcbiAgICByZXR1cm4gcGFkWmVybyhkYXRlLmdldERhdGUoKSwgMik7XHJcbiAgfSxcclxuICBEKGRhdGUsIGxvY2FsZSkge1xyXG4gICAgcmV0dXJuIGxvY2FsZS5kYXlzU2hvcnRbZGF0ZS5nZXREYXkoKV07XHJcbiAgfSxcclxuICBERChkYXRlLCBsb2NhbGUpIHtcclxuICAgIHJldHVybiBsb2NhbGUuZGF5c1tkYXRlLmdldERheSgpXTtcclxuICB9LFxyXG4gIG0oZGF0ZSkge1xyXG4gICAgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKSArIDE7XHJcbiAgfSxcclxuICBtbShkYXRlKSB7XHJcbiAgICByZXR1cm4gcGFkWmVybyhkYXRlLmdldE1vbnRoKCkgKyAxLCAyKTtcclxuICB9LFxyXG4gIE0oZGF0ZSwgbG9jYWxlKSB7XHJcbiAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1Nob3J0W2RhdGUuZ2V0TW9udGgoKV07XHJcbiAgfSxcclxuICBNTShkYXRlLCBsb2NhbGUpIHtcclxuICAgIHJldHVybiBsb2NhbGUubW9udGhzW2RhdGUuZ2V0TW9udGgoKV07XHJcbiAgfSxcclxuICB5KGRhdGUpIHtcclxuICAgIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCk7XHJcbiAgfSxcclxuICB5eShkYXRlKSB7XHJcbiAgICByZXR1cm4gcGFkWmVybyhkYXRlLmdldEZ1bGxZZWFyKCksIDIpLnNsaWNlKC0yKTtcclxuICB9LFxyXG4gIHl5eXkoZGF0ZSkge1xyXG4gICAgcmV0dXJuIHBhZFplcm8oZGF0ZS5nZXRGdWxsWWVhcigpLCA0KTtcclxuICB9LFxyXG59O1xyXG5cclxuLy8gZ2V0IG1vbnRoIGluZGV4IGluIG5vcm1hbCByYW5nZSAoMCAtIDExKSBmcm9tIGFueSBudW1iZXJcclxuZnVuY3Rpb24gbm9ybWFsaXplTW9udGgobW9udGhJbmRleCkge1xyXG4gIHJldHVybiBtb250aEluZGV4ID4gLTEgPyBtb250aEluZGV4ICUgMTIgOiBub3JtYWxpemVNb250aChtb250aEluZGV4ICsgMTIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYWRaZXJvKG51bSwgbGVuZ3RoKSB7XHJcbiAgcmV0dXJuIG51bS50b1N0cmluZygpLnBhZFN0YXJ0KGxlbmd0aCwgJzAnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VGb3JtYXRTdHJpbmcoZm9ybWF0KSB7XHJcbiAgaWYgKHR5cGVvZiBmb3JtYXQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGUgZm9ybWF0LlwiKTtcclxuICB9XHJcbiAgaWYgKGZvcm1hdCBpbiBrbm93bkZvcm1hdHMpIHtcclxuICAgIHJldHVybiBrbm93bkZvcm1hdHNbZm9ybWF0XTtcclxuICB9XHJcblxyXG4gIC8vIHNwcml0IHRoZSBmb3JtYXQgc3RyaW5nIGludG8gcGFydHMgYW5kIHNlcHJhdG9yc1xyXG4gIGNvbnN0IHNlcGFyYXRvcnMgPSBmb3JtYXQuc3BsaXQocmVGb3JtYXRUb2tlbnMpO1xyXG4gIGNvbnN0IHBhcnRzID0gZm9ybWF0Lm1hdGNoKG5ldyBSZWdFeHAocmVGb3JtYXRUb2tlbnMsICdnJykpO1xyXG4gIGlmIChzZXBhcmF0b3JzLmxlbmd0aCA9PT0gMCB8fCAhcGFydHMpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBmb3JtYXQuXCIpO1xyXG4gIH1cclxuXHJcbiAgLy8gY29sbGVjdCBmb3JtYXQgZnVuY3Rpb25zIHVzZWQgaW4gdGhlIGZvcm1hdFxyXG4gIGNvbnN0IHBhcnRGb3JtYXR0ZXJzID0gcGFydHMubWFwKHRva2VuID0+IGZvcm1hdEZuc1t0b2tlbl0pO1xyXG5cclxuICAvLyBjb2xsZWN0IHBhcnNlIGZ1bmN0aW9uIGtleXMgdXNlZCBpbiB0aGUgZm9ybWF0XHJcbiAgLy8gaXRlcmF0ZSBvdmVyIHBhcnNlRm5zJyBrZXlzIGluIG9yZGVyIHRvIGtlZXAgdGhlIG9yZGVyIG9mIHRoZSBrZXlzLlxyXG4gIGNvbnN0IHBhcnRQYXJzZXJLZXlzID0gT2JqZWN0LmtleXMocGFyc2VGbnMpLnJlZHVjZSgoa2V5cywga2V5KSA9PiB7XHJcbiAgICBjb25zdCB0b2tlbiA9IHBhcnRzLmZpbmQocGFydCA9PiBwYXJ0WzBdICE9PSAnRCcgJiYgcGFydFswXS50b0xvd2VyQ2FzZSgpID09PSBrZXkpO1xyXG4gICAgaWYgKHRva2VuKSB7XHJcbiAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGtleXM7XHJcbiAgfSwgW10pO1xyXG5cclxuICByZXR1cm4ga25vd25Gb3JtYXRzW2Zvcm1hdF0gPSB7XHJcbiAgICBwYXJzZXIoZGF0ZVN0ciwgbG9jYWxlKSB7XHJcbiAgICAgIGNvbnN0IGRhdGVQYXJ0cyA9IGRhdGVTdHIuc3BsaXQocmVOb25EYXRlUGFydHMpLnJlZHVjZSgoZHRQYXJ0cywgcGFydCwgaW5kZXgpID0+IHtcclxuICAgICAgICBpZiAocGFydC5sZW5ndGggPiAwICYmIHBhcnRzW2luZGV4XSkge1xyXG4gICAgICAgICAgY29uc3QgdG9rZW4gPSBwYXJ0c1tpbmRleF1bMF07XHJcbiAgICAgICAgICBpZiAodG9rZW4gPT09ICdNJykge1xyXG4gICAgICAgICAgICBkdFBhcnRzLm0gPSBwYXJ0O1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh0b2tlbiAhPT0gJ0QnKSB7XHJcbiAgICAgICAgICAgIGR0UGFydHNbdG9rZW5dID0gcGFydDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGR0UGFydHM7XHJcbiAgICAgIH0sIHt9KTtcclxuXHJcbiAgICAgIC8vIGl0ZXJhdGUgb3ZlciBwYXJ0UGFyc2Vya2V5cyBzbyB0aGF0IHRoZSBwYXJzaW5nIGlzIG1hZGUgaW4gdGhlIG9kZXJcclxuICAgICAgLy8gb2YgeWVhciwgbW9udGggYW5kIGRheSB0byBwcmV2ZW50IHRoZSBkYXkgcGFyc2VyIGZyb20gY29ycmVjdGluZyBsYXN0XHJcbiAgICAgIC8vIGRheSBvZiBtb250aCB3cm9uZ2x5XHJcbiAgICAgIHJldHVybiBwYXJ0UGFyc2VyS2V5cy5yZWR1Y2UoKG9yaWdEYXRlLCBrZXkpID0+IHtcclxuICAgICAgICBjb25zdCBuZXdEYXRlID0gcGFyc2VGbnNba2V5XShvcmlnRGF0ZSwgZGF0ZVBhcnRzW2tleV0sIGxvY2FsZSk7XHJcbiAgICAgICAgLy8gaW5nbm9yZSB0aGUgcGFydCBmYWlsZWQgdG8gcGFyc2VcclxuICAgICAgICByZXR1cm4gaXNOYU4obmV3RGF0ZSkgPyBvcmlnRGF0ZSA6IG5ld0RhdGU7XHJcbiAgICAgIH0sIHRvZGF5KCkpO1xyXG4gICAgfSxcclxuICAgIGZvcm1hdHRlcihkYXRlLCBsb2NhbGUpIHtcclxuICAgICAgbGV0IGRhdGVTdHIgPSBwYXJ0Rm9ybWF0dGVycy5yZWR1Y2UoKHN0ciwgZm4sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHN0ciArPSBgJHtzZXBhcmF0b3JzW2luZGV4XX0ke2ZuKGRhdGUsIGxvY2FsZSl9YDtcclxuICAgICAgfSwgJycpO1xyXG4gICAgICAvLyBzZXBhcmF0b3JzJyBsZW5ndGggaXMgYWx3YXlzIHBhcnRzJyBsZW5ndGggKyAxLFxyXG4gICAgICByZXR1cm4gZGF0ZVN0ciArPSBsYXN0SXRlbU9mKHNlcGFyYXRvcnMpO1xyXG4gICAgfSxcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZURhdGUoZGF0ZVN0ciwgZm9ybWF0LCBsb2NhbGUpIHtcclxuICBpZiAoZGF0ZVN0ciBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIGRhdGVTdHIgPT09ICdudW1iZXInKSB7XHJcbiAgICBjb25zdCBkYXRlID0gc3RyaXBUaW1lKGRhdGVTdHIpO1xyXG4gICAgcmV0dXJuIGlzTmFOKGRhdGUpID8gdW5kZWZpbmVkIDogZGF0ZTtcclxuICB9XHJcbiAgaWYgKCFkYXRlU3RyKSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuICBpZiAoZGF0ZVN0ciA9PT0gJ3RvZGF5Jykge1xyXG4gICAgcmV0dXJuIHRvZGF5KCk7XHJcbiAgfVxyXG5cclxuICBpZiAoZm9ybWF0ICYmIGZvcm1hdC50b1ZhbHVlKSB7XHJcbiAgICBjb25zdCBkYXRlID0gZm9ybWF0LnRvVmFsdWUoZGF0ZVN0ciwgZm9ybWF0LCBsb2NhbGUpO1xyXG4gICAgcmV0dXJuIGlzTmFOKGRhdGUpID8gdW5kZWZpbmVkIDogc3RyaXBUaW1lKGRhdGUpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHBhcnNlRm9ybWF0U3RyaW5nKGZvcm1hdCkucGFyc2VyKGRhdGVTdHIsIGxvY2FsZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCBsb2NhbGUpIHtcclxuICBpZiAoaXNOYU4oZGF0ZSkgfHwgKCFkYXRlICYmIGRhdGUgIT09IDApKSB7XHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfVxyXG5cclxuICBjb25zdCBkYXRlT2JqID0gdHlwZW9mIGRhdGUgPT09ICdudW1iZXInID8gbmV3IERhdGUoZGF0ZSkgOiBkYXRlO1xyXG5cclxuICBpZiAoZm9ybWF0LnRvRGlzcGxheSkge1xyXG4gICAgcmV0dXJuIGZvcm1hdC50b0Rpc3BsYXkoZGF0ZU9iaiwgZm9ybWF0LCBsb2NhbGUpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHBhcnNlRm9ybWF0U3RyaW5nKGZvcm1hdCkuZm9ybWF0dGVyKGRhdGVPYmosIGxvY2FsZSk7XHJcbn1cclxuXHJcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdGhlbWVzYmVyZy90YWlsd2luZC1kYXRlcGlja2VyL2pzL2xpYi9ldmVudC5qc1xyXG5jb25zdCBsaXN0ZW5lclJlZ2lzdHJ5ID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3Qge2FkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXJ9ID0gRXZlbnRUYXJnZXQucHJvdG90eXBlO1xyXG5cclxuLy8gUmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzIHRvIGEga2V5IG9iamVjdFxyXG4vLyBsaXN0ZW5lcnM6IGFycmF5IG9mIGxpc3RlbmVyIGRlZmluaXRpb25zO1xyXG4vLyAgIC0gZWFjaCBkZWZpbml0aW9uIG11c3QgYmUgYSBmbGF0IGFycmF5IG9mIGV2ZW50IHRhcmdldCBhbmQgdGhlIGFyZ3VtZW50c1xyXG4vLyAgICAgdXNlZCB0byBjYWxsIGFkZEV2ZW50TGlzdGVuZXIoKSBvbiB0aGUgdGFyZ2V0XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXJzKGtleU9iaiwgbGlzdGVuZXJzKSB7XHJcbiAgbGV0IHJlZ2lzdGVyZWQgPSBsaXN0ZW5lclJlZ2lzdHJ5LmdldChrZXlPYmopO1xyXG4gIGlmICghcmVnaXN0ZXJlZCkge1xyXG4gICAgcmVnaXN0ZXJlZCA9IFtdO1xyXG4gICAgbGlzdGVuZXJSZWdpc3RyeS5zZXQoa2V5T2JqLCByZWdpc3RlcmVkKTtcclxuICB9XHJcbiAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XHJcbiAgICBhZGRFdmVudExpc3RlbmVyLmNhbGwoLi4ubGlzdGVuZXIpO1xyXG4gICAgcmVnaXN0ZXJlZC5wdXNoKGxpc3RlbmVyKTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gdW5yZWdpc3Rlckxpc3RlbmVycyhrZXlPYmopIHtcclxuICBsZXQgbGlzdGVuZXJzID0gbGlzdGVuZXJSZWdpc3RyeS5nZXQoa2V5T2JqKTtcclxuICBpZiAoIWxpc3RlbmVycykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBsaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcclxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbCguLi5saXN0ZW5lcik7XHJcbiAgfSk7XHJcbiAgbGlzdGVuZXJSZWdpc3RyeS5kZWxldGUoa2V5T2JqKTtcclxufVxyXG5cclxuLy8gRXZlbnQuY29tcG9zZWRQYXRoKCkgcG9seWZpbGwgZm9yIEVkZ2VcclxuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20va2xlaW5mcmV1bmQvZTk3ODdkNzM3NzZjMGUzNzUwZGNmY2RjODlmMTAwZWNcclxuaWYgKCFFdmVudC5wcm90b3R5cGUuY29tcG9zZWRQYXRoKSB7XHJcbiAgY29uc3QgZ2V0Q29tcG9zZWRQYXRoID0gKG5vZGUsIHBhdGggPSBbXSkgPT4ge1xyXG4gICAgcGF0aC5wdXNoKG5vZGUpO1xyXG5cclxuICAgIGxldCBwYXJlbnQ7XHJcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XHJcbiAgICAgIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcclxuICAgIH0gZWxzZSBpZiAobm9kZS5ob3N0KSB7IC8vIFNoYWRvd1Jvb3RcclxuICAgICAgcGFyZW50ID0gbm9kZS5ob3N0O1xyXG4gICAgfSBlbHNlIGlmIChub2RlLmRlZmF1bHRWaWV3KSB7ICAvLyBEb2N1bWVudFxyXG4gICAgICBwYXJlbnQgPSBub2RlLmRlZmF1bHRWaWV3O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcmVudCA/IGdldENvbXBvc2VkUGF0aChwYXJlbnQsIHBhdGgpIDogcGF0aDtcclxuICB9O1xyXG5cclxuICBFdmVudC5wcm90b3R5cGUuY29tcG9zZWRQYXRoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGdldENvbXBvc2VkUGF0aCh0aGlzLnRhcmdldCk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZmluZEZyb21QYXRoKHBhdGgsIGNyaXRlcmlhLCBjdXJyZW50VGFyZ2V0LCBpbmRleCA9IDApIHtcclxuICBjb25zdCBlbCA9IHBhdGhbaW5kZXhdO1xyXG4gIGlmIChjcml0ZXJpYShlbCkpIHtcclxuICAgIHJldHVybiBlbDtcclxuICB9IGVsc2UgaWYgKGVsID09PSBjdXJyZW50VGFyZ2V0IHx8ICFlbC5wYXJlbnRFbGVtZW50KSB7XHJcbiAgICAvLyBzdG9wIHdoZW4gcmVhY2hpbmcgY3VycmVudFRhcmdldCBvciA8aHRtbD5cclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgcmV0dXJuIGZpbmRGcm9tUGF0aChwYXRoLCBjcml0ZXJpYSwgY3VycmVudFRhcmdldCwgaW5kZXggKyAxKTtcclxufVxyXG5cclxuLy8gU2VhcmNoIGZvciB0aGUgYWN0dWFsIHRhcmdldCBvZiBhIGRlbGVnYXRlZCBldmVudFxyXG5mdW5jdGlvbiBmaW5kRWxlbWVudEluRXZlbnRQYXRoKGV2LCBzZWxlY3Rvcikge1xyXG4gIGNvbnN0IGNyaXRlcmlhID0gdHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nID8gc2VsZWN0b3IgOiBlbCA9PiBlbC5tYXRjaGVzKHNlbGVjdG9yKTtcclxuICByZXR1cm4gZmluZEZyb21QYXRoKGV2LmNvbXBvc2VkUGF0aCgpLCBjcml0ZXJpYSwgZXYuY3VycmVudFRhcmdldCk7XHJcbn1cclxuXHJcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdGhlbWVzYmVyZy90YWlsd2luZC1kYXRlcGlja2VyL2pzL2kxOG4vYmFzZS1sb2NhbGVzLmpzXHJcbi8vIGRlZmF1bHQgbG9jYWxlc1xyXG5jb25zdCBsb2NhbGVzID0ge1xyXG4gIGVuOiB7XHJcbiAgICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcclxuICAgIGRheXNTaG9ydDogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxyXG4gICAgZGF5c01pbjogW1wiU3VcIiwgXCJNb1wiLCBcIlR1XCIsIFwiV2VcIiwgXCJUaFwiLCBcIkZyXCIsIFwiU2FcIl0sXHJcbiAgICBtb250aHM6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxyXG4gICAgbW9udGhzU2hvcnQ6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXSxcclxuICAgIHRvZGF5OiBcIlRvZGF5XCIsXHJcbiAgICBjbGVhcjogXCJDbGVhclwiLFxyXG4gICAgdGl0bGVGb3JtYXQ6IFwiTU0geVwiXHJcbiAgfVxyXG59O1xyXG5cclxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0B0aGVtZXNiZXJnL3RhaWx3aW5kLWRhdGVwaWNrZXIvanMvb3B0aW9ucy9kZWZhdWx0T3B0aW9ucy5qc1xyXG4vLyBjb25maWcgb3B0aW9ucyB1cGRhdGFibGUgYnkgc2V0T3B0aW9ucygpIGFuZCB0aGVpciBkZWZhdWx0IHZhbHVlc1xyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICBhdXRvaGlkZTogZmFsc2UsXHJcbiAgYmVmb3JlU2hvd0RheTogbnVsbCxcclxuICBiZWZvcmVTaG93RGVjYWRlOiBudWxsLFxyXG4gIGJlZm9yZVNob3dNb250aDogbnVsbCxcclxuICBiZWZvcmVTaG93WWVhcjogbnVsbCxcclxuICBjYWxlbmRhcldlZWtzOiBmYWxzZSxcclxuICBjbGVhckJ0bjogZmFsc2UsXHJcbiAgZGF0ZURlbGltaXRlcjogJywnLFxyXG4gIGRhdGVzRGlzYWJsZWQ6IFtdLFxyXG4gIGRheXNPZldlZWtEaXNhYmxlZDogW10sXHJcbiAgZGF5c09mV2Vla0hpZ2hsaWdodGVkOiBbXSxcclxuICBkZWZhdWx0Vmlld0RhdGU6IHVuZGVmaW5lZCwgLy8gcGxhY2Vob2xkZXIsIGRlZmF1bHRzIHRvIHRvZGF5KCkgYnkgdGhlIHByb2dyYW1cclxuICBkaXNhYmxlVG91Y2hLZXlib2FyZDogZmFsc2UsXHJcbiAgZm9ybWF0OiAnbW0vZGQveXl5eScsXHJcbiAgbGFuZ3VhZ2U6ICdlbicsXHJcbiAgbWF4RGF0ZTogbnVsbCxcclxuICBtYXhOdW1iZXJPZkRhdGVzOiAxLFxyXG4gIG1heFZpZXc6IDMsXHJcbiAgbWluRGF0ZTogbnVsbCxcclxuICBuZXh0QXJyb3c6ICc8c3ZnIGNsYXNzPVwidy00IGgtNFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDIwIDIwXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTEyLjI5MyA1LjI5M2ExIDEgMCAwMTEuNDE0IDBsNCA0YTEgMSAwIDAxMCAxLjQxNGwtNCA0YTEgMSAwIDAxLTEuNDE0LTEuNDE0TDE0LjU4NiAxMUgzYTEgMSAwIDExMC0yaDExLjU4NmwtMi4yOTMtMi4yOTNhMSAxIDAgMDEwLTEuNDE0elwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIj48L3BhdGg+PC9zdmc+JyxcclxuICBvcmllbnRhdGlvbjogJ2F1dG8nLFxyXG4gIHBpY2tMZXZlbDogMCxcclxuICBwcmV2QXJyb3c6ICc8c3ZnIGNsYXNzPVwidy00IGgtNFwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDIwIDIwXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTkuNzA3IDE2LjcwN2ExIDEgMCAwMS0xLjQxNCAwbC02LTZhMSAxIDAgMDEwLTEuNDE0bDYtNmExIDEgMCAwMTEuNDE0IDEuNDE0TDUuNDE0IDlIMTdhMSAxIDAgMTEwIDJINS40MTRsNC4yOTMgNC4yOTNhMSAxIDAgMDEwIDEuNDE0elwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIj48L3BhdGg+PC9zdmc+JyxcclxuICBzaG93RGF5c09mV2VlazogdHJ1ZSxcclxuICBzaG93T25DbGljazogdHJ1ZSxcclxuICBzaG93T25Gb2N1czogdHJ1ZSxcclxuICBzdGFydFZpZXc6IDAsXHJcbiAgdGl0bGU6ICcnLFxyXG4gIHRvZGF5QnRuOiBmYWxzZSxcclxuICB0b2RheUJ0bk1vZGU6IDAsXHJcbiAgdG9kYXlIaWdobGlnaHQ6IGZhbHNlLFxyXG4gIHVwZGF0ZU9uQmx1cjogdHJ1ZSxcclxuICB3ZWVrU3RhcnQ6IDAsXHJcbn07XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IG9wdGlvbnNfZGVmYXVsdE9wdGlvbnMgPSAoZGVmYXVsdE9wdGlvbnMpO1xyXG5cclxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0B0aGVtZXNiZXJnL3RhaWx3aW5kLWRhdGVwaWNrZXIvanMvbGliL2RvbS5qc1xyXG5jb25zdCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XHJcblxyXG5mdW5jdGlvbiBwYXJzZUhUTUwoaHRtbCkge1xyXG4gIHJldHVybiByYW5nZS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoaHRtbCk7XHJcbn1cclxuXHJcbi8vIGVxdWl2YWxlbnQgdG8galF1ZXJ5J3MgOnZpc2JsZVxyXG5mdW5jdGlvbiBpc1Zpc2libGUoZWwpIHtcclxuICByZXR1cm4gISEoZWwub2Zmc2V0V2lkdGggfHwgZWwub2Zmc2V0SGVpZ2h0IHx8IGVsLmdldENsaWVudFJlY3RzKCkubGVuZ3RoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGlkZUVsZW1lbnQoZWwpIHtcclxuICBpZiAoZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIC8vIGJhY2sgdXAgdGhlIGV4aXN0aW5nIGRpc3BsYXkgc2V0dGluZyBpbiBkYXRhLXN0eWxlLWRpc3BsYXlcclxuICBpZiAoZWwuc3R5bGUuZGlzcGxheSkge1xyXG4gICAgZWwuZGF0YXNldC5zdHlsZURpc3BsYXkgPSBlbC5zdHlsZS5kaXNwbGF5O1xyXG4gIH1cclxuICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzaG93RWxlbWVudChlbCkge1xyXG4gIGlmIChlbC5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKGVsLmRhdGFzZXQuc3R5bGVEaXNwbGF5KSB7XHJcbiAgICAvLyByZXN0b3JlIGJhY2tlZC11cCBkaXNwYXkgcHJvcGVydHlcclxuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5kYXRhc2V0LnN0eWxlRGlzcGxheTtcclxuICAgIGRlbGV0ZSBlbC5kYXRhc2V0LnN0eWxlRGlzcGxheTtcclxuICB9IGVsc2Uge1xyXG4gICAgZWwuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZW1wdHlDaGlsZE5vZGVzKGVsKSB7XHJcbiAgaWYgKGVsLmZpcnN0Q2hpbGQpIHtcclxuICAgIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xyXG4gICAgZW1wdHlDaGlsZE5vZGVzKGVsKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlcGxhY2VDaGlsZE5vZGVzKGVsLCBuZXdDaGlsZE5vZGVzKSB7XHJcbiAgZW1wdHlDaGlsZE5vZGVzKGVsKTtcclxuICBpZiAobmV3Q2hpbGROb2RlcyBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcclxuICAgIGVsLmFwcGVuZENoaWxkKG5ld0NoaWxkTm9kZXMpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG5ld0NoaWxkTm9kZXMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBlbC5hcHBlbmRDaGlsZChwYXJzZUhUTUwobmV3Q2hpbGROb2RlcykpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG5ld0NoaWxkTm9kZXMuZm9yRWFjaCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgbmV3Q2hpbGROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XHJcbiAgICAgIGVsLmFwcGVuZENoaWxkKG5vZGUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHRoZW1lc2JlcmcvdGFpbHdpbmQtZGF0ZXBpY2tlci9qcy9vcHRpb25zL3Byb2Nlc3NPcHRpb25zLmpzXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNvbnN0IHtcclxuICBsYW5ndWFnZTogZGVmYXVsdExhbmcsXHJcbiAgZm9ybWF0OiBkZWZhdWx0Rm9ybWF0LFxyXG4gIHdlZWtTdGFydDogZGVmYXVsdFdlZWtTdGFydCxcclxufSA9IG9wdGlvbnNfZGVmYXVsdE9wdGlvbnM7XHJcblxyXG4vLyBSZWR1Y2VyIGZ1bmN0aW9uIHRvIGZpbHRlciBvdXQgaW52YWxpZCBkYXktb2Ytd2VlayBmcm9tIHRoZSBpbnB1dFxyXG5mdW5jdGlvbiBzYW5pdGl6ZURPVyhkb3csIGRheSkge1xyXG4gIHJldHVybiBkb3cubGVuZ3RoIDwgNiAmJiBkYXkgPj0gMCAmJiBkYXkgPCA3XHJcbiAgICA/IHB1c2hVbmlxdWUoZG93LCBkYXkpXHJcbiAgICA6IGRvdztcclxufVxyXG5cclxuZnVuY3Rpb24gY2FsY0VuZE9mV2VlayhzdGFydE9mV2Vlaykge1xyXG4gIHJldHVybiAoc3RhcnRPZldlZWsgKyA2KSAlIDc7XHJcbn1cclxuXHJcbi8vIHZhbGlkYXRlIGlucHV0IGRhdGUuIGlmIGludmFsaWQsIGZhbGxiYWNrIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZVxyXG5mdW5jdGlvbiB2YWxpZGF0ZURhdGUodmFsdWUsIGZvcm1hdCwgbG9jYWxlLCBvcmlnVmFsdWUpIHtcclxuICBjb25zdCBkYXRlID0gcGFyc2VEYXRlKHZhbHVlLCBmb3JtYXQsIGxvY2FsZSk7XHJcbiAgcmV0dXJuIGRhdGUgIT09IHVuZGVmaW5lZCA/IGRhdGUgOiBvcmlnVmFsdWU7XHJcbn1cclxuXHJcbi8vIFZhbGlkYXRlIHZpZXdJZC4gaWYgaW52YWxpZCwgZmFsbGJhY2sgdG8gdGhlIG9yaWdpbmFsIHZhbHVlXHJcbmZ1bmN0aW9uIHZhbGlkYXRlVmlld0lkKHZhbHVlLCBvcmlnVmFsdWUsIG1heCA9IDMpIHtcclxuICBjb25zdCB2aWV3SWQgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xyXG4gIHJldHVybiB2aWV3SWQgPj0gMCAmJiB2aWV3SWQgPD0gbWF4ID8gdmlld0lkIDogb3JpZ1ZhbHVlO1xyXG59XHJcblxyXG4vLyBDcmVhdGUgRGF0ZXBpY2tlciBjb25maWd1cmF0aW9uIHRvIHNldFxyXG5mdW5jdGlvbiBwcm9jZXNzT3B0aW9ucyhvcHRpb25zLCBkYXRlcGlja2VyKSB7XHJcbiAgY29uc3QgaW5PcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XHJcbiAgY29uc3QgY29uZmlnID0ge307XHJcbiAgY29uc3QgbG9jYWxlcyA9IGRhdGVwaWNrZXIuY29uc3RydWN0b3IubG9jYWxlcztcclxuICBsZXQge1xyXG4gICAgZm9ybWF0LFxyXG4gICAgbGFuZ3VhZ2UsXHJcbiAgICBsb2NhbGUsXHJcbiAgICBtYXhEYXRlLFxyXG4gICAgbWF4VmlldyxcclxuICAgIG1pbkRhdGUsXHJcbiAgICBwaWNrTGV2ZWwsXHJcbiAgICBzdGFydFZpZXcsXHJcbiAgICB3ZWVrU3RhcnQsXHJcbiAgfSA9IGRhdGVwaWNrZXIuY29uZmlnIHx8IHt9O1xyXG5cclxuICBpZiAoaW5PcHRzLmxhbmd1YWdlKSB7XHJcbiAgICBsZXQgbGFuZztcclxuICAgIGlmIChpbk9wdHMubGFuZ3VhZ2UgIT09IGxhbmd1YWdlKSB7XHJcbiAgICAgIGlmIChsb2NhbGVzW2luT3B0cy5sYW5ndWFnZV0pIHtcclxuICAgICAgICBsYW5nID0gaW5PcHRzLmxhbmd1YWdlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIGxhbmdhdWdlICsgcmVnaW9uIHRhZyBjYW4gZmFsbGJhY2sgdG8gdGhlIG9uZSB3aXRob3V0XHJcbiAgICAgICAgLy8gcmVnaW9uIChlLmcuIGZyLUNBIOKGkiBmcilcclxuICAgICAgICBsYW5nID0gaW5PcHRzLmxhbmd1YWdlLnNwbGl0KCctJylbMF07XHJcbiAgICAgICAgaWYgKGxvY2FsZXNbbGFuZ10gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgbGFuZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVsZXRlIGluT3B0cy5sYW5ndWFnZTtcclxuICAgIGlmIChsYW5nKSB7XHJcbiAgICAgIGxhbmd1YWdlID0gY29uZmlnLmxhbmd1YWdlID0gbGFuZztcclxuXHJcbiAgICAgIC8vIHVwZGF0ZSBsb2NhbGUgYXMgd2VsbCB3aGVuIHVwZGF0aW5nIGxhbmd1YWdlXHJcbiAgICAgIGNvbnN0IG9yaWdMb2NhbGUgPSBsb2NhbGUgfHwgbG9jYWxlc1tkZWZhdWx0TGFuZ107XHJcbiAgICAgIC8vIHVzZSBkZWZhdWx0IGxhbmd1YWdlJ3MgcHJvcGVydGllcyBmb3IgdGhlIGZhbGxiYWNrXHJcbiAgICAgIGxvY2FsZSA9IE9iamVjdC5hc3NpZ24oe1xyXG4gICAgICAgIGZvcm1hdDogZGVmYXVsdEZvcm1hdCxcclxuICAgICAgICB3ZWVrU3RhcnQ6IGRlZmF1bHRXZWVrU3RhcnRcclxuICAgICAgfSwgbG9jYWxlc1tkZWZhdWx0TGFuZ10pO1xyXG4gICAgICBpZiAobGFuZ3VhZ2UgIT09IGRlZmF1bHRMYW5nKSB7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihsb2NhbGUsIGxvY2FsZXNbbGFuZ3VhZ2VdKTtcclxuICAgICAgfVxyXG4gICAgICBjb25maWcubG9jYWxlID0gbG9jYWxlO1xyXG4gICAgICAvLyBpZiBmb3JtYXQgYW5kL29yIHdlZWtTdGFydCBhcmUgdGhlIHNhbWUgYXMgb2xkIGxvY2FsZSdzIGRlZmF1bHRzLFxyXG4gICAgICAvLyB1cGRhdGUgdGhlbSB0byBuZXcgbG9jYWxlJ3MgZGVmYXVsdHNcclxuICAgICAgaWYgKGZvcm1hdCA9PT0gb3JpZ0xvY2FsZS5mb3JtYXQpIHtcclxuICAgICAgICBmb3JtYXQgPSBjb25maWcuZm9ybWF0ID0gbG9jYWxlLmZvcm1hdDtcclxuICAgICAgfVxyXG4gICAgICBpZiAod2Vla1N0YXJ0ID09PSBvcmlnTG9jYWxlLndlZWtTdGFydCkge1xyXG4gICAgICAgIHdlZWtTdGFydCA9IGNvbmZpZy53ZWVrU3RhcnQgPSBsb2NhbGUud2Vla1N0YXJ0O1xyXG4gICAgICAgIGNvbmZpZy53ZWVrRW5kID0gY2FsY0VuZE9mV2Vlayhsb2NhbGUud2Vla1N0YXJ0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGluT3B0cy5mb3JtYXQpIHtcclxuICAgIGNvbnN0IGhhc1RvRGlzcGxheSA9IHR5cGVvZiBpbk9wdHMuZm9ybWF0LnRvRGlzcGxheSA9PT0gJ2Z1bmN0aW9uJztcclxuICAgIGNvbnN0IGhhc1RvVmFsdWUgPSB0eXBlb2YgaW5PcHRzLmZvcm1hdC50b1ZhbHVlID09PSAnZnVuY3Rpb24nO1xyXG4gICAgY29uc3QgdmFsaWRGb3JtYXRTdHJpbmcgPSByZUZvcm1hdFRva2Vucy50ZXN0KGluT3B0cy5mb3JtYXQpO1xyXG4gICAgaWYgKChoYXNUb0Rpc3BsYXkgJiYgaGFzVG9WYWx1ZSkgfHwgdmFsaWRGb3JtYXRTdHJpbmcpIHtcclxuICAgICAgZm9ybWF0ID0gY29uZmlnLmZvcm1hdCA9IGluT3B0cy5mb3JtYXQ7XHJcbiAgICB9XHJcbiAgICBkZWxldGUgaW5PcHRzLmZvcm1hdDtcclxuICB9XHJcblxyXG4gIC8vKioqIGRhdGVzICoqKi8vXHJcbiAgLy8gd2hpbGUgbWluIGFuZCBtYXhEYXRlIGZvciBcIm5vIGxpbWl0XCIgaW4gdGhlIG9wdGlvbnMgYXJlIGJldHRlciB0byBiZSBudWxsXHJcbiAgLy8gKGVzcGVjaWFsbHkgd2hlbiB1cGRhdGluZyksIHRoZSBvbmVzIGluIHRoZSBjb25maWcgaGF2ZSB0byBiZSB1bmRlZmluZWRcclxuICAvLyBiZWNhdXNlIG51bGwgaXMgdHJlYXRlZCBhcyAwICg9IHVuaXggZXBvY2gpIHdoZW4gY29tcGFyaW5nIHdpdGggdGltZSB2YWx1ZVxyXG4gIGxldCBtaW5EdCA9IG1pbkRhdGU7XHJcbiAgbGV0IG1heER0ID0gbWF4RGF0ZTtcclxuICBpZiAoaW5PcHRzLm1pbkRhdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgbWluRHQgPSBpbk9wdHMubWluRGF0ZSA9PT0gbnVsbFxyXG4gICAgICA/IGRhdGVWYWx1ZSgwLCAwLCAxKSAgLy8gc2V0IDAwMDAtMDEtMDEgdG8gcHJldmVudCBuZWdhdGl2ZSB2YWx1ZXMgZm9yIHllYXJcclxuICAgICAgOiB2YWxpZGF0ZURhdGUoaW5PcHRzLm1pbkRhdGUsIGZvcm1hdCwgbG9jYWxlLCBtaW5EdCk7XHJcbiAgICBkZWxldGUgaW5PcHRzLm1pbkRhdGU7XHJcbiAgfVxyXG4gIGlmIChpbk9wdHMubWF4RGF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBtYXhEdCA9IGluT3B0cy5tYXhEYXRlID09PSBudWxsXHJcbiAgICAgID8gdW5kZWZpbmVkXHJcbiAgICAgIDogdmFsaWRhdGVEYXRlKGluT3B0cy5tYXhEYXRlLCBmb3JtYXQsIGxvY2FsZSwgbWF4RHQpO1xyXG4gICAgZGVsZXRlIGluT3B0cy5tYXhEYXRlO1xyXG4gIH1cclxuICBpZiAobWF4RHQgPCBtaW5EdCkge1xyXG4gICAgbWluRGF0ZSA9IGNvbmZpZy5taW5EYXRlID0gbWF4RHQ7XHJcbiAgICBtYXhEYXRlID0gY29uZmlnLm1heERhdGUgPSBtaW5EdDtcclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKG1pbkRhdGUgIT09IG1pbkR0KSB7XHJcbiAgICAgIG1pbkRhdGUgPSBjb25maWcubWluRGF0ZSA9IG1pbkR0O1xyXG4gICAgfVxyXG4gICAgaWYgKG1heERhdGUgIT09IG1heER0KSB7XHJcbiAgICAgIG1heERhdGUgPSBjb25maWcubWF4RGF0ZSA9IG1heER0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGluT3B0cy5kYXRlc0Rpc2FibGVkKSB7XHJcbiAgICBjb25maWcuZGF0ZXNEaXNhYmxlZCA9IGluT3B0cy5kYXRlc0Rpc2FibGVkLnJlZHVjZSgoZGF0ZXMsIGR0KSA9PiB7XHJcbiAgICAgIGNvbnN0IGRhdGUgPSBwYXJzZURhdGUoZHQsIGZvcm1hdCwgbG9jYWxlKTtcclxuICAgICAgcmV0dXJuIGRhdGUgIT09IHVuZGVmaW5lZCA/IHB1c2hVbmlxdWUoZGF0ZXMsIGRhdGUpIDogZGF0ZXM7XHJcbiAgICB9LCBbXSk7XHJcbiAgICBkZWxldGUgaW5PcHRzLmRhdGVzRGlzYWJsZWQ7XHJcbiAgfVxyXG4gIGlmIChpbk9wdHMuZGVmYXVsdFZpZXdEYXRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGNvbnN0IHZpZXdEYXRlID0gcGFyc2VEYXRlKGluT3B0cy5kZWZhdWx0Vmlld0RhdGUsIGZvcm1hdCwgbG9jYWxlKTtcclxuICAgIGlmICh2aWV3RGF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbmZpZy5kZWZhdWx0Vmlld0RhdGUgPSB2aWV3RGF0ZTtcclxuICAgIH1cclxuICAgIGRlbGV0ZSBpbk9wdHMuZGVmYXVsdFZpZXdEYXRlO1xyXG4gIH1cclxuXHJcbiAgLy8qKiogZGF5cyBvZiB3ZWVrICoqKi8vXHJcbiAgaWYgKGluT3B0cy53ZWVrU3RhcnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgY29uc3Qgd2tTdGFydCA9IE51bWJlcihpbk9wdHMud2Vla1N0YXJ0KSAlIDc7XHJcbiAgICBpZiAoIWlzTmFOKHdrU3RhcnQpKSB7XHJcbiAgICAgIHdlZWtTdGFydCA9IGNvbmZpZy53ZWVrU3RhcnQgPSB3a1N0YXJ0O1xyXG4gICAgICBjb25maWcud2Vla0VuZCA9IGNhbGNFbmRPZldlZWsod2tTdGFydCk7XHJcbiAgICB9XHJcbiAgICBkZWxldGUgaW5PcHRzLndlZWtTdGFydDtcclxuICB9XHJcbiAgaWYgKGluT3B0cy5kYXlzT2ZXZWVrRGlzYWJsZWQpIHtcclxuICAgIGNvbmZpZy5kYXlzT2ZXZWVrRGlzYWJsZWQgPSBpbk9wdHMuZGF5c09mV2Vla0Rpc2FibGVkLnJlZHVjZShzYW5pdGl6ZURPVywgW10pO1xyXG4gICAgZGVsZXRlIGluT3B0cy5kYXlzT2ZXZWVrRGlzYWJsZWQ7XHJcbiAgfVxyXG4gIGlmIChpbk9wdHMuZGF5c09mV2Vla0hpZ2hsaWdodGVkKSB7XHJcbiAgICBjb25maWcuZGF5c09mV2Vla0hpZ2hsaWdodGVkID0gaW5PcHRzLmRheXNPZldlZWtIaWdobGlnaHRlZC5yZWR1Y2Uoc2FuaXRpemVET1csIFtdKTtcclxuICAgIGRlbGV0ZSBpbk9wdHMuZGF5c09mV2Vla0hpZ2hsaWdodGVkO1xyXG4gIH1cclxuXHJcbiAgLy8qKiogbXVsdGkgZGF0ZSAqKiovL1xyXG4gIGlmIChpbk9wdHMubWF4TnVtYmVyT2ZEYXRlcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBjb25zdCBtYXhOdW1iZXJPZkRhdGVzID0gcGFyc2VJbnQoaW5PcHRzLm1heE51bWJlck9mRGF0ZXMsIDEwKTtcclxuICAgIGlmIChtYXhOdW1iZXJPZkRhdGVzID49IDApIHtcclxuICAgICAgY29uZmlnLm1heE51bWJlck9mRGF0ZXMgPSBtYXhOdW1iZXJPZkRhdGVzO1xyXG4gICAgICBjb25maWcubXVsdGlkYXRlID0gbWF4TnVtYmVyT2ZEYXRlcyAhPT0gMTtcclxuICAgIH1cclxuICAgIGRlbGV0ZSBpbk9wdHMubWF4TnVtYmVyT2ZEYXRlcztcclxuICB9XHJcbiAgaWYgKGluT3B0cy5kYXRlRGVsaW1pdGVyKSB7XHJcbiAgICBjb25maWcuZGF0ZURlbGltaXRlciA9IFN0cmluZyhpbk9wdHMuZGF0ZURlbGltaXRlcik7XHJcbiAgICBkZWxldGUgaW5PcHRzLmRhdGVEZWxpbWl0ZXI7XHJcbiAgfVxyXG5cclxuICAvLyoqKiBwaWNrIGxldmVsICYgdmlldyAqKiovL1xyXG4gIGxldCBuZXdQaWNrTGV2ZWwgPSBwaWNrTGV2ZWw7XHJcbiAgaWYgKGluT3B0cy5waWNrTGV2ZWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgbmV3UGlja0xldmVsID0gdmFsaWRhdGVWaWV3SWQoaW5PcHRzLnBpY2tMZXZlbCwgMik7XHJcbiAgICBkZWxldGUgaW5PcHRzLnBpY2tMZXZlbDtcclxuICB9XHJcbiAgaWYgKG5ld1BpY2tMZXZlbCAhPT0gcGlja0xldmVsKSB7XHJcbiAgICBwaWNrTGV2ZWwgPSBjb25maWcucGlja0xldmVsID0gbmV3UGlja0xldmVsO1xyXG4gIH1cclxuXHJcbiAgbGV0IG5ld01heFZpZXcgPSBtYXhWaWV3O1xyXG4gIGlmIChpbk9wdHMubWF4VmlldyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBuZXdNYXhWaWV3ID0gdmFsaWRhdGVWaWV3SWQoaW5PcHRzLm1heFZpZXcsIG1heFZpZXcpO1xyXG4gICAgZGVsZXRlIGluT3B0cy5tYXhWaWV3O1xyXG4gIH1cclxuICAvLyBlbnN1cmUgbWF4IHZpZXcgPj0gcGljayBsZXZlbFxyXG4gIG5ld01heFZpZXcgPSBwaWNrTGV2ZWwgPiBuZXdNYXhWaWV3ID8gcGlja0xldmVsIDogbmV3TWF4VmlldztcclxuICBpZiAobmV3TWF4VmlldyAhPT0gbWF4Vmlldykge1xyXG4gICAgbWF4VmlldyA9IGNvbmZpZy5tYXhWaWV3ID0gbmV3TWF4VmlldztcclxuICB9XHJcblxyXG4gIGxldCBuZXdTdGFydFZpZXcgPSBzdGFydFZpZXc7XHJcbiAgaWYgKGluT3B0cy5zdGFydFZpZXcgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgbmV3U3RhcnRWaWV3ID0gdmFsaWRhdGVWaWV3SWQoaW5PcHRzLnN0YXJ0VmlldywgbmV3U3RhcnRWaWV3KTtcclxuICAgIGRlbGV0ZSBpbk9wdHMuc3RhcnRWaWV3O1xyXG4gIH1cclxuICAvLyBlbnN1cmUgcGljayBsZXZlbCA8PSBzdGFydCB2aWV3IDw9IG1heCB2aWV3XHJcbiAgaWYgKG5ld1N0YXJ0VmlldyA8IHBpY2tMZXZlbCkge1xyXG4gICAgbmV3U3RhcnRWaWV3ID0gcGlja0xldmVsO1xyXG4gIH0gZWxzZSBpZiAobmV3U3RhcnRWaWV3ID4gbWF4Vmlldykge1xyXG4gICAgbmV3U3RhcnRWaWV3ID0gbWF4VmlldztcclxuICB9XHJcbiAgaWYgKG5ld1N0YXJ0VmlldyAhPT0gc3RhcnRWaWV3KSB7XHJcbiAgICBjb25maWcuc3RhcnRWaWV3ID0gbmV3U3RhcnRWaWV3O1xyXG4gIH1cclxuXHJcbiAgLy8qKiogdGVtcGxhdGUgKioqLy9cclxuICBpZiAoaW5PcHRzLnByZXZBcnJvdykge1xyXG4gICAgY29uc3QgcHJldkFycm93ID0gcGFyc2VIVE1MKGluT3B0cy5wcmV2QXJyb3cpO1xyXG4gICAgaWYgKHByZXZBcnJvdy5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uZmlnLnByZXZBcnJvdyA9IHByZXZBcnJvdy5jaGlsZE5vZGVzO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlIGluT3B0cy5wcmV2QXJyb3c7XHJcbiAgfVxyXG4gIGlmIChpbk9wdHMubmV4dEFycm93KSB7XHJcbiAgICBjb25zdCBuZXh0QXJyb3cgPSBwYXJzZUhUTUwoaW5PcHRzLm5leHRBcnJvdyk7XHJcbiAgICBpZiAobmV4dEFycm93LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25maWcubmV4dEFycm93ID0gbmV4dEFycm93LmNoaWxkTm9kZXM7XHJcbiAgICB9XHJcbiAgICBkZWxldGUgaW5PcHRzLm5leHRBcnJvdztcclxuICB9XHJcblxyXG4gIC8vKioqIG1pc2MgKioqLy9cclxuICBpZiAoaW5PcHRzLmRpc2FibGVUb3VjaEtleWJvYXJkICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGNvbmZpZy5kaXNhYmxlVG91Y2hLZXlib2FyZCA9ICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50ICYmICEhaW5PcHRzLmRpc2FibGVUb3VjaEtleWJvYXJkO1xyXG4gICAgZGVsZXRlIGluT3B0cy5kaXNhYmxlVG91Y2hLZXlib2FyZDtcclxuICB9XHJcbiAgaWYgKGluT3B0cy5vcmllbnRhdGlvbikge1xyXG4gICAgY29uc3Qgb3JpZW50YXRpb24gPSBpbk9wdHMub3JpZW50YXRpb24udG9Mb3dlckNhc2UoKS5zcGxpdCgvXFxzKy9nKTtcclxuICAgIGNvbmZpZy5vcmllbnRhdGlvbiA9IHtcclxuICAgICAgeDogb3JpZW50YXRpb24uZmluZCh4ID0+ICh4ID09PSAnbGVmdCcgfHwgeCA9PT0gJ3JpZ2h0JykpIHx8ICdhdXRvJyxcclxuICAgICAgeTogb3JpZW50YXRpb24uZmluZCh5ID0+ICh5ID09PSAndG9wJyB8fCB5ID09PSAnYm90dG9tJykpIHx8ICdhdXRvJyxcclxuICAgIH07XHJcbiAgICBkZWxldGUgaW5PcHRzLm9yaWVudGF0aW9uO1xyXG4gIH1cclxuICBpZiAoaW5PcHRzLnRvZGF5QnRuTW9kZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBzd2l0Y2goaW5PcHRzLnRvZGF5QnRuTW9kZSkge1xyXG4gICAgICBjYXNlIDA6XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICBjb25maWcudG9kYXlCdG5Nb2RlID0gaW5PcHRzLnRvZGF5QnRuTW9kZTtcclxuICAgIH1cclxuICAgIGRlbGV0ZSBpbk9wdHMudG9kYXlCdG5Nb2RlO1xyXG4gIH1cclxuXHJcbiAgLy8qKiogY29weSB0aGUgcmVzdCAqKiovL1xyXG4gIE9iamVjdC5rZXlzKGluT3B0cykuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICBpZiAoaW5PcHRzW2tleV0gIT09IHVuZGVmaW5lZCAmJiBoYXNQcm9wZXJ0eShvcHRpb25zX2RlZmF1bHRPcHRpb25zLCBrZXkpKSB7XHJcbiAgICAgIGNvbmZpZ1trZXldID0gaW5PcHRzW2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBjb25maWc7XHJcbn1cclxuXHJcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdGhlbWVzYmVyZy90YWlsd2luZC1kYXRlcGlja2VyL2pzL3BpY2tlci90ZW1wbGF0ZXMvcGlja2VyVGVtcGxhdGUuanNcclxuXHJcblxyXG5jb25zdCBwaWNrZXJUZW1wbGF0ZSA9IG9wdGltaXplVGVtcGxhdGVIVE1MKGA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlciBoaWRkZW5cIj5cclxuICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1waWNrZXIgaW5saW5lLWJsb2NrIHJvdW5kZWQtbGcgYmctd2hpdGUgZGFyazpiZy1ncmF5LTcwMCBzaGFkb3ctbGcgcC00XCI+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1oZWFkZXJcIj5cclxuICAgICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItdGl0bGUgYmctd2hpdGUgZGFyazpiZy1ncmF5LTcwMCBkYXJrOnRleHQtd2hpdGUgcHgtMiBweS0zIHRleHQtY2VudGVyIGZvbnQtc2VtaWJvbGRcIj48L2Rpdj5cclxuICAgICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItY29udHJvbHMgZmxleCBqdXN0aWZ5LWJldHdlZW4gbWItMlwiPlxyXG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYmctd2hpdGUgZGFyazpiZy1ncmF5LTcwMCByb3VuZGVkLWxnIHRleHQtZ3JheS01MDAgZGFyazp0ZXh0LXdoaXRlIGhvdmVyOmJnLWdyYXktMTAwIGRhcms6aG92ZXI6YmctZ3JheS02MDAgaG92ZXI6dGV4dC1ncmF5LTkwMCBkYXJrOmhvdmVyOnRleHQtd2hpdGUgdGV4dC1sZyBwLTIuNSBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctZ3JheS0yMDAgcHJldi1idG5cIj48L2J1dHRvbj5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cInRleHQtc20gcm91bmRlZC1sZyB0ZXh0LWdyYXktOTAwIGRhcms6dGV4dC13aGl0ZSBiZy13aGl0ZSBkYXJrOmJnLWdyYXktNzAwIGZvbnQtc2VtaWJvbGQgcHktMi41IHB4LTUgaG92ZXI6YmctZ3JheS0xMDAgZGFyazpob3ZlcjpiZy1ncmF5LTYwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctZ3JheS0yMDAgdmlldy1zd2l0Y2hcIj48L2J1dHRvbj5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJnLXdoaXRlIGRhcms6YmctZ3JheS03MDAgcm91bmRlZC1sZyB0ZXh0LWdyYXktNTAwIGRhcms6dGV4dC13aGl0ZSBob3ZlcjpiZy1ncmF5LTEwMCBkYXJrOmhvdmVyOmJnLWdyYXktNjAwIGhvdmVyOnRleHQtZ3JheS05MDAgZGFyazpob3Zlcjp0ZXh0LXdoaXRlIHRleHQtbGcgcC0yLjUgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWdyYXktMjAwIG5leHQtYnRuXCI+PC9idXR0b24+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1tYWluIHAtMVwiPjwvZGl2PlxyXG4gICAgPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItZm9vdGVyXCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLWNvbnRyb2xzIGZsZXggc3BhY2UteC0yIG10LTJcIj5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIiVidXR0b25DbGFzcyUgdG9kYXktYnRuIHRleHQtd2hpdGUgYmctYmx1ZS03MDAgZGFyazpiZy1ibHVlLTYwMCBob3ZlcjpiZy1ibHVlLTgwMCBkYXJrOmhvdmVyOmJnLWJsdWUtNzAwIGZvY3VzOnJpbmctNCBmb2N1czpyaW5nLWJsdWUtMzAwIGZvbnQtbWVkaXVtIHJvdW5kZWQtbGcgdGV4dC1zbSBweC01IHB5LTIgdGV4dC1jZW50ZXIgdy0xLzJcIj48L2J1dHRvbj5cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIiVidXR0b25DbGFzcyUgY2xlYXItYnRuIHRleHQtZ3JheS05MDAgZGFyazp0ZXh0LXdoaXRlIGJnLXdoaXRlIGRhcms6YmctZ3JheS03MDAgYm9yZGVyIGJvcmRlci1ncmF5LTMwMCBkYXJrOmJvcmRlci1ncmF5LTYwMCBob3ZlcjpiZy1ncmF5LTEwMCBkYXJrOmhvdmVyOmJnLWdyYXktNjAwIGZvY3VzOnJpbmctNCBmb2N1czpyaW5nLWJsdWUtMzAwIGZvbnQtbWVkaXVtIHJvdW5kZWQtbGcgdGV4dC1zbSBweC01IHB5LTIgdGV4dC1jZW50ZXIgdy0xLzJcIj48L2J1dHRvbj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICA8L2Rpdj5cclxuPC9kaXY+YCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IHRlbXBsYXRlc19waWNrZXJUZW1wbGF0ZSA9IChwaWNrZXJUZW1wbGF0ZSk7XHJcblxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHRoZW1lc2JlcmcvdGFpbHdpbmQtZGF0ZXBpY2tlci9qcy9waWNrZXIvdGVtcGxhdGVzL2RheXNUZW1wbGF0ZS5qc1xyXG5cclxuXHJcbmNvbnN0IGRheXNUZW1wbGF0ZSA9IG9wdGltaXplVGVtcGxhdGVIVE1MKGA8ZGl2IGNsYXNzPVwiZGF5c1wiPlxyXG4gIDxkaXYgY2xhc3M9XCJkYXlzLW9mLXdlZWsgZ3JpZCBncmlkLWNvbHMtNyBtYi0xXCI+JHtjcmVhdGVUYWdSZXBlYXQoJ3NwYW4nLCA3LCB7Y2xhc3M6ICdkb3cgYmxvY2sgZmxleC0xIGxlYWRpbmctOSBib3JkZXItMCByb3VuZGVkLWxnIGN1cnNvci1kZWZhdWx0IHRleHQtY2VudGVyIHRleHQtZ3JheS05MDAgZm9udC1zZW1pYm9sZCB0ZXh0LXNtJ30pfTwvZGl2PlxyXG4gIDxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLWdyaWQgdy02NCBncmlkIGdyaWQtY29scy03XCI+JHtjcmVhdGVUYWdSZXBlYXQoJ3NwYW4nLCA0MiAsIHtjbGFzczogJ2Jsb2NrIGZsZXgtMSBsZWFkaW5nLTkgYm9yZGVyLTAgcm91bmRlZC1sZyBjdXJzb3ItZGVmYXVsdCB0ZXh0LWNlbnRlciB0ZXh0LWdyYXktOTAwIGZvbnQtc2VtaWJvbGQgdGV4dC1zbSBoLTYgbGVhZGluZy02IHRleHQtc20gZm9udC1tZWRpdW0gdGV4dC1ncmF5LTUwMCBkYXJrOnRleHQtZ3JheS00MDAnfSl9PC9kaXY+XHJcbjwvZGl2PmApO1xyXG5cclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCB0ZW1wbGF0ZXNfZGF5c1RlbXBsYXRlID0gKGRheXNUZW1wbGF0ZSk7XHJcblxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHRoZW1lc2JlcmcvdGFpbHdpbmQtZGF0ZXBpY2tlci9qcy9waWNrZXIvdGVtcGxhdGVzL2NhbGVuZGFyV2Vla3NUZW1wbGF0ZS5qc1xyXG5cclxuXHJcbmNvbnN0IGNhbGVuZGFyV2Vla3NUZW1wbGF0ZSA9IG9wdGltaXplVGVtcGxhdGVIVE1MKGA8ZGl2IGNsYXNzPVwiY2FsZW5kYXItd2Vla3NcIj5cclxuICA8ZGl2IGNsYXNzPVwiZGF5cy1vZi13ZWVrIGZsZXhcIj48c3BhbiBjbGFzcz1cImRvdyBoLTYgbGVhZGluZy02IHRleHQtc20gZm9udC1tZWRpdW0gdGV4dC1ncmF5LTUwMCBkYXJrOnRleHQtZ3JheS00MDBcIj48L3NwYW4+PC9kaXY+XHJcbiAgPGRpdiBjbGFzcz1cIndlZWtzXCI+JHtjcmVhdGVUYWdSZXBlYXQoJ3NwYW4nLCA2LCB7Y2xhc3M6ICd3ZWVrIGJsb2NrIGZsZXgtMSBsZWFkaW5nLTkgYm9yZGVyLTAgcm91bmRlZC1sZyBjdXJzb3ItZGVmYXVsdCB0ZXh0LWNlbnRlciB0ZXh0LWdyYXktOTAwIGZvbnQtc2VtaWJvbGQgdGV4dC1zbSd9KX08L2Rpdj5cclxuPC9kaXY+YCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IHRlbXBsYXRlc19jYWxlbmRhcldlZWtzVGVtcGxhdGUgPSAoY2FsZW5kYXJXZWVrc1RlbXBsYXRlKTtcclxuXHJcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdGhlbWVzYmVyZy90YWlsd2luZC1kYXRlcGlja2VyL2pzL3BpY2tlci92aWV3cy9WaWV3LmpzXHJcblxyXG5cclxuXHJcbi8vIEJhc2UgY2xhc3Mgb2YgdGhlIHZpZXcgY2xhc3Nlc1xyXG5jbGFzcyBWaWV3IHtcclxuICBjb25zdHJ1Y3RvcihwaWNrZXIsIGNvbmZpZykge1xyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjb25maWcsIHtcclxuICAgICAgcGlja2VyLFxyXG4gICAgICBlbGVtZW50OiBwYXJzZUhUTUwoYDxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLXZpZXcgZmxleFwiPjwvZGl2PmApLmZpcnN0Q2hpbGQsXHJcbiAgICAgIHNlbGVjdGVkOiBbXSxcclxuICAgIH0pO1xyXG4gICAgdGhpcy5pbml0KHRoaXMucGlja2VyLmRhdGVwaWNrZXIuY29uZmlnKTtcclxuICB9XHJcblxyXG4gIGluaXQob3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMucGlja0xldmVsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy5pc01pblZpZXcgPSB0aGlzLmlkID09PSBvcHRpb25zLnBpY2tMZXZlbDtcclxuICAgIH1cclxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcclxuICAgIHRoaXMudXBkYXRlRm9jdXMoKTtcclxuICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uKCk7XHJcbiAgfVxyXG5cclxuICAvLyBFeGVjdXRlIGJlZm9yZVNob3coKSBjYWxsYmFjayBhbmQgYXBwbHkgdGhlIHJlc3VsdCB0byB0aGUgZWxlbWVudFxyXG4gIC8vIGFyZ3M6XHJcbiAgLy8gLSBjdXJyZW50IC0gY3VycmVudCB2YWx1ZSBvbiB0aGUgaXRlcmF0aW9uIG9uIHZpZXcgcmVuZGVyaW5nXHJcbiAgLy8gLSB0aW1lVmFsdWUgLSB0aW1lIHZhbHVlIG9mIHRoZSBkYXRlIHRvIHBhc3MgdG8gYmVmb3JlU2hvdygpXHJcbiAgcGVyZm9ybUJlZm9yZUhvb2soZWwsIGN1cnJlbnQsIHRpbWVWYWx1ZSkge1xyXG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuYmVmb3JlU2hvdyhuZXcgRGF0ZSh0aW1lVmFsdWUpKTtcclxuICAgIHN3aXRjaCAodHlwZW9mIHJlc3VsdCkge1xyXG4gICAgICBjYXNlICdib29sZWFuJzpcclxuICAgICAgICByZXN1bHQgPSB7ZW5hYmxlZDogcmVzdWx0fTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgICByZXN1bHQgPSB7Y2xhc3NlczogcmVzdWx0fTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgIGlmIChyZXN1bHQuZW5hYmxlZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpO1xyXG4gICAgICAgIHB1c2hVbmlxdWUodGhpcy5kaXNhYmxlZCwgY3VycmVudCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJlc3VsdC5jbGFzc2VzKSB7XHJcbiAgICAgICAgY29uc3QgZXh0cmFDbGFzc2VzID0gcmVzdWx0LmNsYXNzZXMuc3BsaXQoL1xccysvKTtcclxuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKC4uLmV4dHJhQ2xhc3Nlcyk7XHJcbiAgICAgICAgaWYgKGV4dHJhQ2xhc3Nlcy5pbmNsdWRlcygnZGlzYWJsZWQnKSkge1xyXG4gICAgICAgICAgcHVzaFVuaXF1ZSh0aGlzLmRpc2FibGVkLCBjdXJyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJlc3VsdC5jb250ZW50KSB7XHJcbiAgICAgICAgcmVwbGFjZUNoaWxkTm9kZXMoZWwsIHJlc3VsdC5jb250ZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0B0aGVtZXNiZXJnL3RhaWx3aW5kLWRhdGVwaWNrZXIvanMvcGlja2VyL3ZpZXdzL0RheXNWaWV3LmpzXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgRGF5c1ZpZXcgZXh0ZW5kcyBWaWV3IHtcclxuICBjb25zdHJ1Y3RvcihwaWNrZXIpIHtcclxuICAgIHN1cGVyKHBpY2tlciwge1xyXG4gICAgICBpZDogMCxcclxuICAgICAgbmFtZTogJ2RheXMnLFxyXG4gICAgICBjZWxsQ2xhc3M6ICdkYXknLFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBpbml0KG9wdGlvbnMsIG9uQ29uc3RydWN0aW9uID0gdHJ1ZSkge1xyXG4gICAgaWYgKG9uQ29uc3RydWN0aW9uKSB7XHJcbiAgICAgIGNvbnN0IGlubmVyID0gcGFyc2VIVE1MKHRlbXBsYXRlc19kYXlzVGVtcGxhdGUpLmZpcnN0Q2hpbGQ7XHJcbiAgICAgIHRoaXMuZG93ID0gaW5uZXIuZmlyc3RDaGlsZDtcclxuICAgICAgdGhpcy5ncmlkID0gaW5uZXIubGFzdENoaWxkO1xyXG4gICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5uZXIpO1xyXG4gICAgfVxyXG4gICAgc3VwZXIuaW5pdChvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIHNldE9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgbGV0IHVwZGF0ZURPVztcclxuXHJcbiAgICBpZiAoaGFzUHJvcGVydHkob3B0aW9ucywgJ21pbkRhdGUnKSkge1xyXG4gICAgICB0aGlzLm1pbkRhdGUgPSBvcHRpb25zLm1pbkRhdGU7XHJcbiAgICB9XHJcbiAgICBpZiAoaGFzUHJvcGVydHkob3B0aW9ucywgJ21heERhdGUnKSkge1xyXG4gICAgICB0aGlzLm1heERhdGUgPSBvcHRpb25zLm1heERhdGU7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5kYXRlc0Rpc2FibGVkKSB7XHJcbiAgICAgIHRoaXMuZGF0ZXNEaXNhYmxlZCA9IG9wdGlvbnMuZGF0ZXNEaXNhYmxlZDtcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLmRheXNPZldlZWtEaXNhYmxlZCkge1xyXG4gICAgICB0aGlzLmRheXNPZldlZWtEaXNhYmxlZCA9IG9wdGlvbnMuZGF5c09mV2Vla0Rpc2FibGVkO1xyXG4gICAgICB1cGRhdGVET1cgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMuZGF5c09mV2Vla0hpZ2hsaWdodGVkKSB7XHJcbiAgICAgIHRoaXMuZGF5c09mV2Vla0hpZ2hsaWdodGVkID0gb3B0aW9ucy5kYXlzT2ZXZWVrSGlnaGxpZ2h0ZWQ7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy50b2RheUhpZ2hsaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMudG9kYXlIaWdobGlnaHQgPSBvcHRpb25zLnRvZGF5SGlnaGxpZ2h0O1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMud2Vla1N0YXJ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy53ZWVrU3RhcnQgPSBvcHRpb25zLndlZWtTdGFydDtcclxuICAgICAgdGhpcy53ZWVrRW5kID0gb3B0aW9ucy53ZWVrRW5kO1xyXG4gICAgICB1cGRhdGVET1cgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMubG9jYWxlKSB7XHJcbiAgICAgIGNvbnN0IGxvY2FsZSA9IHRoaXMubG9jYWxlID0gb3B0aW9ucy5sb2NhbGU7XHJcbiAgICAgIHRoaXMuZGF5TmFtZXMgPSBsb2NhbGUuZGF5c01pbjtcclxuICAgICAgdGhpcy5zd2l0Y2hMYWJlbEZvcm1hdCA9IGxvY2FsZS50aXRsZUZvcm1hdDtcclxuICAgICAgdXBkYXRlRE9XID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLmJlZm9yZVNob3dEYXkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLmJlZm9yZVNob3cgPSB0eXBlb2Ygb3B0aW9ucy5iZWZvcmVTaG93RGF5ID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgPyBvcHRpb25zLmJlZm9yZVNob3dEYXlcclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0aW9ucy5jYWxlbmRhcldlZWtzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgaWYgKG9wdGlvbnMuY2FsZW5kYXJXZWVrcyAmJiAhdGhpcy5jYWxlbmRhcldlZWtzKSB7XHJcbiAgICAgICAgY29uc3Qgd2Vla3NFbGVtID0gcGFyc2VIVE1MKHRlbXBsYXRlc19jYWxlbmRhcldlZWtzVGVtcGxhdGUpLmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhcldlZWtzID0ge1xyXG4gICAgICAgICAgZWxlbWVudDogd2Vla3NFbGVtLFxyXG4gICAgICAgICAgZG93OiB3ZWVrc0VsZW0uZmlyc3RDaGlsZCxcclxuICAgICAgICAgIHdlZWtzOiB3ZWVrc0VsZW0ubGFzdENoaWxkLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5lbGVtZW50Lmluc2VydEJlZm9yZSh3ZWVrc0VsZW0sIHRoaXMuZWxlbWVudC5maXJzdENoaWxkKTtcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLmNhbGVuZGFyV2Vla3MgJiYgIW9wdGlvbnMuY2FsZW5kYXJXZWVrcykge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLmNhbGVuZGFyV2Vla3MuZWxlbWVudCk7XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhcldlZWtzID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMuc2hvd0RheXNPZldlZWsgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpZiAob3B0aW9ucy5zaG93RGF5c09mV2Vlaykge1xyXG4gICAgICAgIHNob3dFbGVtZW50KHRoaXMuZG93KTtcclxuICAgICAgICBpZiAodGhpcy5jYWxlbmRhcldlZWtzKSB7XHJcbiAgICAgICAgICBzaG93RWxlbWVudCh0aGlzLmNhbGVuZGFyV2Vla3MuZG93KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaGlkZUVsZW1lbnQodGhpcy5kb3cpO1xyXG4gICAgICAgIGlmICh0aGlzLmNhbGVuZGFyV2Vla3MpIHtcclxuICAgICAgICAgIGhpZGVFbGVtZW50KHRoaXMuY2FsZW5kYXJXZWVrcy5kb3cpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHVwZGF0ZSBkYXlzLW9mLXdlZWsgd2hlbiBsb2NhbGUsIGRheXNPZndlZWtEaXNhYmxlZCBvciB3ZWVrU3RhcnQgaXMgY2hhbmdlZFxyXG4gICAgaWYgKHVwZGF0ZURPVykge1xyXG4gICAgICBBcnJheS5mcm9tKHRoaXMuZG93LmNoaWxkcmVuKS5mb3JFYWNoKChlbCwgaW5kZXgpID0+IHtcclxuICAgICAgICBjb25zdCBkb3cgPSAodGhpcy53ZWVrU3RhcnQgKyBpbmRleCkgJSA3O1xyXG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gdGhpcy5kYXlOYW1lc1tkb3ddO1xyXG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IHRoaXMuZGF5c09mV2Vla0Rpc2FibGVkLmluY2x1ZGVzKGRvdykgPyAnZG93IGRpc2FibGVkIHRleHQtY2VudGVyIGgtNiBsZWFkaW5nLTYgdGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LWdyYXktNTAwIGRhcms6dGV4dC1ncmF5LTQwMCBjdXJzb3Itbm90LWFsbG93ZWQnIDogJ2RvdyB0ZXh0LWNlbnRlciBoLTYgbGVhZGluZy02IHRleHQtc20gZm9udC1tZWRpdW0gdGV4dC1ncmF5LTUwMCBkYXJrOnRleHQtZ3JheS00MDAnO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFwcGx5IHVwZGF0ZSBvbiB0aGUgZm9jdXNlZCBkYXRlIHRvIHZpZXcncyBzZXR0aW5nc1xyXG4gIHVwZGF0ZUZvY3VzKCkge1xyXG4gICAgY29uc3Qgdmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLnBpY2tlci52aWV3RGF0ZSk7XHJcbiAgICBjb25zdCB2aWV3WWVhciA9IHZpZXdEYXRlLmdldEZ1bGxZZWFyKCk7XHJcbiAgICBjb25zdCB2aWV3TW9udGggPSB2aWV3RGF0ZS5nZXRNb250aCgpO1xyXG4gICAgY29uc3QgZmlyc3RPZk1vbnRoID0gZGF0ZVZhbHVlKHZpZXdZZWFyLCB2aWV3TW9udGgsIDEpO1xyXG4gICAgY29uc3Qgc3RhcnQgPSBkYXlPZlRoZVdlZWtPZihmaXJzdE9mTW9udGgsIHRoaXMud2Vla1N0YXJ0LCB0aGlzLndlZWtTdGFydCk7XHJcblxyXG4gICAgdGhpcy5maXJzdCA9IGZpcnN0T2ZNb250aDtcclxuICAgIHRoaXMubGFzdCA9IGRhdGVWYWx1ZSh2aWV3WWVhciwgdmlld01vbnRoICsgMSwgMCk7XHJcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICB0aGlzLmZvY3VzZWQgPSB0aGlzLnBpY2tlci52aWV3RGF0ZTtcclxuICB9XHJcblxyXG4gIC8vIEFwcGx5IHVwZGF0ZSBvbiB0aGUgc2VsZWN0ZWQgZGF0ZXMgdG8gdmlldydzIHNldHRpbmdzXHJcbiAgdXBkYXRlU2VsZWN0aW9uKCkge1xyXG4gICAgY29uc3Qge2RhdGVzLCByYW5nZXBpY2tlcn0gPSB0aGlzLnBpY2tlci5kYXRlcGlja2VyO1xyXG4gICAgdGhpcy5zZWxlY3RlZCA9IGRhdGVzO1xyXG4gICAgaWYgKHJhbmdlcGlja2VyKSB7XHJcbiAgICAgIHRoaXMucmFuZ2UgPSByYW5nZXBpY2tlci5kYXRlcztcclxuICAgIH1cclxuICB9XHJcblxyXG4gICAvLyBVcGRhdGUgdGhlIGVudGlyZSB2aWV3IFVJXHJcbiAgcmVuZGVyKCkge1xyXG4gICAgLy8gdXBkYXRlIHRvZGF5IG1hcmtlciBvbiBldmVyIHJlbmRlclxyXG4gICAgdGhpcy50b2RheSA9IHRoaXMudG9kYXlIaWdobGlnaHQgPyB0b2RheSgpIDogdW5kZWZpbmVkO1xyXG4gICAgLy8gcmVmcmVzaCBkaXNhYmxlZCBkYXRlcyBvbiBldmVyeSByZW5kZXIgaW4gb3JkZXIgdG8gY2xlYXIgdGhlIG9uZXMgYWRkZWRcclxuICAgIC8vIGJ5IGJlZm9yZVNob3cgaG9vayBhdCBwcmV2aW91cyByZW5kZXJcclxuICAgIHRoaXMuZGlzYWJsZWQgPSBbLi4udGhpcy5kYXRlc0Rpc2FibGVkXTtcclxuXHJcbiAgICBjb25zdCBzd2l0Y2hMYWJlbCA9IGZvcm1hdERhdGUodGhpcy5mb2N1c2VkLCB0aGlzLnN3aXRjaExhYmVsRm9ybWF0LCB0aGlzLmxvY2FsZSk7XHJcbiAgICB0aGlzLnBpY2tlci5zZXRWaWV3U3dpdGNoTGFiZWwoc3dpdGNoTGFiZWwpO1xyXG4gICAgdGhpcy5waWNrZXIuc2V0UHJldkJ0bkRpc2FibGVkKHRoaXMuZmlyc3QgPD0gdGhpcy5taW5EYXRlKTtcclxuICAgIHRoaXMucGlja2VyLnNldE5leHRCdG5EaXNhYmxlZCh0aGlzLmxhc3QgPj0gdGhpcy5tYXhEYXRlKTtcclxuXHJcbiAgICBpZiAodGhpcy5jYWxlbmRhcldlZWtzKSB7XHJcbiAgICAgIC8vIHN0YXJ0IG9mIHRoZSBVVEMgd2VlayAoTW9uZGF5KSBvZiB0aGUgMXN0IG9mIHRoZSBtb250aFxyXG4gICAgICBjb25zdCBzdGFydE9mV2VlayA9IGRheU9mVGhlV2Vla09mKHRoaXMuZmlyc3QsIDEsIDEpO1xyXG4gICAgICBBcnJheS5mcm9tKHRoaXMuY2FsZW5kYXJXZWVrcy53ZWVrcy5jaGlsZHJlbikuZm9yRWFjaCgoZWwsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSBnZXRXZWVrKGFkZFdlZWtzKHN0YXJ0T2ZXZWVrLCBpbmRleCkpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIEFycmF5LmZyb20odGhpcy5ncmlkLmNoaWxkcmVuKS5mb3JFYWNoKChlbCwgaW5kZXgpID0+IHtcclxuICAgICAgY29uc3QgY2xhc3NMaXN0ID0gZWwuY2xhc3NMaXN0O1xyXG4gICAgICBjb25zdCBjdXJyZW50ID0gYWRkRGF5cyh0aGlzLnN0YXJ0LCBpbmRleCk7XHJcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShjdXJyZW50KTtcclxuICAgICAgY29uc3QgZGF5ID0gZGF0ZS5nZXREYXkoKTtcclxuXHJcbiAgICAgIGVsLmNsYXNzTmFtZSA9IGBkYXRlcGlja2VyLWNlbGwgaG92ZXI6YmctZ3JheS0xMDAgZGFyazpob3ZlcjpiZy1ncmF5LTYwMCBibG9jayBmbGV4LTEgbGVhZGluZy05IGJvcmRlci0wIHJvdW5kZWQtbGcgY3Vyc29yLXBvaW50ZXIgdGV4dC1jZW50ZXIgdGV4dC1ncmF5LTkwMCBkYXJrOnRleHQtd2hpdGUgZm9udC1zZW1pYm9sZCB0ZXh0LXNtICR7dGhpcy5jZWxsQ2xhc3N9YDtcclxuICAgICAgZWwuZGF0YXNldC5kYXRlID0gY3VycmVudDtcclxuICAgICAgZWwudGV4dENvbnRlbnQgPSBkYXRlLmdldERhdGUoKTtcclxuXHJcbiAgICAgIGlmIChjdXJyZW50IDwgdGhpcy5maXJzdCkge1xyXG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3ByZXYnLCAndGV4dC1ncmF5LTUwMCcsICdkYXJrOnRleHQtd2hpdGUnKTtcclxuICAgICAgfSBlbHNlIGlmIChjdXJyZW50ID4gdGhpcy5sYXN0KSB7XHJcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnbmV4dCcsICd0ZXh0LWdyYXktNTAwJywgJ2Rhcms6dGV4dC13aGl0ZScpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLnRvZGF5ID09PSBjdXJyZW50KSB7XHJcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgndG9kYXknLCAnYmctZ3JheS0xMDAnLCAnZGFyazpiZy1ncmF5LTYwMCcsICdkYXJrOmJnLWdyYXktNjAwJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGN1cnJlbnQgPCB0aGlzLm1pbkRhdGUgfHwgY3VycmVudCA+IHRoaXMubWF4RGF0ZSB8fCB0aGlzLmRpc2FibGVkLmluY2x1ZGVzKGN1cnJlbnQpKSB7XHJcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQnLCAnY3Vyc29yLW5vdC1hbGxvd2VkJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuZGF5c09mV2Vla0Rpc2FibGVkLmluY2x1ZGVzKGRheSkpIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcsICdjdXJzb3Itbm90LWFsbG93ZWQnKTtcclxuICAgICAgICBwdXNoVW5pcXVlKHRoaXMuZGlzYWJsZWQsIGN1cnJlbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLmRheXNPZldlZWtIaWdobGlnaHRlZC5pbmNsdWRlcyhkYXkpKSB7XHJcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnaGlnaGxpZ2h0ZWQnKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5yYW5nZSkge1xyXG4gICAgICAgIGNvbnN0IFtyYW5nZVN0YXJ0LCByYW5nZUVuZF0gPSB0aGlzLnJhbmdlO1xyXG4gICAgICAgIGlmIChjdXJyZW50ID4gcmFuZ2VTdGFydCAmJiBjdXJyZW50IDwgcmFuZ2VFbmQpIHtcclxuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlJywgJ2JnLWdyYXktMjAwJywgJ2Rhcms6YmctZ3JheS02MDAnKTtcclxuICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3JvdW5kZWQtbGcnLCAncm91bmRlZC1sLWxnJywgJ3JvdW5kZWQtci1sZycpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjdXJyZW50ID09PSByYW5nZVN0YXJ0KSB7XHJcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1zdGFydCcsICdiZy1ncmF5LTEwMCcsICdkYXJrOmJnLWdyYXktNjAwJywgJ3JvdW5kZWQtbC1sZycpO1xyXG4gICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgncm91bmRlZC1sZycsICdyb3VuZGVkLXItbGcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlRW5kKSB7XHJcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1lbmQnLCAnYmctZ3JheS0xMDAnLCAnZGFyazpiZy1ncmF5LTYwMCcsICdyb3VuZGVkLXItbGcnKTtcclxuICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3JvdW5kZWQtbGcnLCAncm91bmRlZC1sLWxnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkLmluY2x1ZGVzKGN1cnJlbnQpKSB7XHJcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnLCAnYmctYmx1ZS03MDAnLCAndGV4dC13aGl0ZScsICdkYXJrOmJnLWJsdWUtNjAwJywgJ2Rhcms6dGV4dC13aGl0ZScpO1xyXG4gICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3RleHQtZ3JheS05MDAnLCAndGV4dC1ncmF5LTUwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZvY3VzZWQpIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdmb2N1c2VkJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLmJlZm9yZVNob3cpIHtcclxuICAgICAgICB0aGlzLnBlcmZvcm1CZWZvcmVIb29rKGVsLCBjdXJyZW50LCBjdXJyZW50KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBVcGRhdGUgdGhlIHZpZXcgVUkgYnkgYXBwbHlpbmcgdGhlIGNoYW5nZXMgb2Ygc2VsZWN0ZWQgYW5kIGZvY3VzZWQgaXRlbXNcclxuICByZWZyZXNoKCkge1xyXG4gICAgY29uc3QgW3JhbmdlU3RhcnQsIHJhbmdlRW5kXSA9IHRoaXMucmFuZ2UgfHwgW107XHJcbiAgICB0aGlzLmdyaWRcclxuICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoJy5yYW5nZSwgLnJhbmdlLXN0YXJ0LCAucmFuZ2UtZW5kLCAuc2VsZWN0ZWQsIC5mb2N1c2VkJylcclxuICAgICAgLmZvckVhY2goKGVsKSA9PiB7XHJcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgncmFuZ2UnLCAncmFuZ2Utc3RhcnQnLCAncmFuZ2UtZW5kJywgJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJ3RleHQtd2hpdGUnLCAnZGFyazpiZy1ibHVlLTYwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZm9jdXNlZCcsICdiZy1ncmF5LTEwMCcsICdkYXJrOmJnLWdyYXktNjAwJyk7XHJcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgndGV4dC1ncmF5LTkwMCcsICdyb3VuZGVkLWxnJywgJ2Rhcms6dGV4dC13aGl0ZScpO1xyXG4gICAgICB9KTtcclxuICAgIEFycmF5LmZyb20odGhpcy5ncmlkLmNoaWxkcmVuKS5mb3JFYWNoKChlbCkgPT4ge1xyXG4gICAgICBjb25zdCBjdXJyZW50ID0gTnVtYmVyKGVsLmRhdGFzZXQuZGF0ZSk7XHJcbiAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IGVsLmNsYXNzTGlzdDtcclxuICAgICAgaWYgKGN1cnJlbnQgPiByYW5nZVN0YXJ0ICYmIGN1cnJlbnQgPCByYW5nZUVuZCkge1xyXG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlJywgJ2JnLWdyYXktMjAwJywgJ2Rhcms6YmctZ3JheS02MDAnKTtcclxuICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCdyb3VuZGVkLWxnJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlU3RhcnQpIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1zdGFydCcsICdiZy1ncmF5LTIwMCcsICdkYXJrOmJnLWdyYXktNjAwJywgJ3JvdW5kZWQtbC1sZycpO1xyXG4gICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3JvdW5kZWQtbGcnLCAncm91bmRlZC1yLWxnJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlRW5kKSB7XHJcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UtZW5kJywgJ2JnLWdyYXktMjAwJywgJ2Rhcms6YmctZ3JheS02MDAnLCAncm91bmRlZC1yLWxnJyk7XHJcbiAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgncm91bmRlZC1sZycsICdyb3VuZGVkLWwtbGcnKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5zZWxlY3RlZC5pbmNsdWRlcyhjdXJyZW50KSkge1xyXG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJ3RleHQtd2hpdGUnLCAnZGFyazpiZy1ibHVlLTYwMCcsICdkYXJrOnRleHQtd2hpdGUnKTtcclxuICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCd0ZXh0LWdyYXktOTAwJywgJ2hvdmVyOmJnLWdyYXktMTAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICdkYXJrOmhvdmVyOmJnLWdyYXktNjAwJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZm9jdXNlZCkge1xyXG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ2ZvY3VzZWQnLCAnYmctZ3JheS0xMDAnLCAnZGFyazpiZy1ncmF5LTYwMCcpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIFVwZGF0ZSB0aGUgdmlldyBVSSBieSBhcHBseWluZyB0aGUgY2hhbmdlIG9mIGZvY3VzZWQgaXRlbVxyXG4gIHJlZnJlc2hGb2N1cygpIHtcclxuICAgIGNvbnN0IGluZGV4ID0gTWF0aC5yb3VuZCgodGhpcy5mb2N1c2VkIC0gdGhpcy5zdGFydCkgLyA4NjQwMDAwMCk7XHJcbiAgICB0aGlzLmdyaWQucXVlcnlTZWxlY3RvckFsbCgnLmZvY3VzZWQnKS5mb3JFYWNoKChlbCkgPT4ge1xyXG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdmb2N1c2VkJywgJ2JnLWdyYXktMTAwJywgJ2Rhcms6YmctZ3JheS02MDAnKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5ncmlkLmNoaWxkcmVuW2luZGV4XS5jbGFzc0xpc3QuYWRkKCdmb2N1c2VkJywgJ2JnLWdyYXktMTAwJywgJ2Rhcms6YmctZ3JheS02MDAnKTtcclxuICB9XHJcbn1cclxuXHJcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdGhlbWVzYmVyZy90YWlsd2luZC1kYXRlcGlja2VyL2pzL3BpY2tlci92aWV3cy9Nb250aHNWaWV3LmpzXHJcblxyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gY29tcHV0ZU1vbnRoUmFuZ2UocmFuZ2UsIHRoaXNZZWFyKSB7XHJcbiAgaWYgKCFyYW5nZSB8fCAhcmFuZ2VbMF0gfHwgIXJhbmdlWzFdKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBjb25zdCBbW3N0YXJ0WSwgc3RhcnRNXSwgW2VuZFksIGVuZE1dXSA9IHJhbmdlO1xyXG4gIGlmIChzdGFydFkgPiB0aGlzWWVhciB8fCBlbmRZIDwgdGhpc1llYXIpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgcmV0dXJuIFtcclxuICAgIHN0YXJ0WSA9PT0gdGhpc1llYXIgPyBzdGFydE0gOiAtMSxcclxuICAgIGVuZFkgPT09IHRoaXNZZWFyID8gZW5kTSA6IDEyLFxyXG4gIF07XHJcbn1cclxuXHJcbmNsYXNzIE1vbnRoc1ZpZXcgZXh0ZW5kcyBWaWV3IHtcclxuICBjb25zdHJ1Y3RvcihwaWNrZXIpIHtcclxuICAgIHN1cGVyKHBpY2tlciwge1xyXG4gICAgICBpZDogMSxcclxuICAgICAgbmFtZTogJ21vbnRocycsXHJcbiAgICAgIGNlbGxDbGFzczogJ21vbnRoJyxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaW5pdChvcHRpb25zLCBvbkNvbnN0cnVjdGlvbiA9IHRydWUpIHtcclxuICAgIGlmIChvbkNvbnN0cnVjdGlvbikge1xyXG4gICAgICB0aGlzLmdyaWQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdtb250aHMnLCAnZGF0ZXBpY2tlci1ncmlkJywgJ3ctNjQnLCAnZ3JpZCcsICdncmlkLWNvbHMtNCcpO1xyXG4gICAgICB0aGlzLmdyaWQuYXBwZW5kQ2hpbGQocGFyc2VIVE1MKGNyZWF0ZVRhZ1JlcGVhdCgnc3BhbicsIDEyLCB7J2RhdGEtbW9udGgnOiBpeCA9PiBpeH0pKSk7XHJcbiAgICB9XHJcbiAgICBzdXBlci5pbml0KG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucy5sb2NhbGUpIHtcclxuICAgICAgdGhpcy5tb250aE5hbWVzID0gb3B0aW9ucy5sb2NhbGUubW9udGhzU2hvcnQ7XHJcbiAgICB9XHJcbiAgICBpZiAoaGFzUHJvcGVydHkob3B0aW9ucywgJ21pbkRhdGUnKSkge1xyXG4gICAgICBpZiAob3B0aW9ucy5taW5EYXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aGlzLm1pblllYXIgPSB0aGlzLm1pbk1vbnRoID0gdGhpcy5taW5EYXRlID0gdW5kZWZpbmVkO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG1pbkRhdGVPYmogPSBuZXcgRGF0ZShvcHRpb25zLm1pbkRhdGUpO1xyXG4gICAgICAgIHRoaXMubWluWWVhciA9IG1pbkRhdGVPYmouZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICB0aGlzLm1pbk1vbnRoID0gbWluRGF0ZU9iai5nZXRNb250aCgpO1xyXG4gICAgICAgIHRoaXMubWluRGF0ZSA9IG1pbkRhdGVPYmouc2V0RGF0ZSgxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGhhc1Byb3BlcnR5KG9wdGlvbnMsICdtYXhEYXRlJykpIHtcclxuICAgICAgaWYgKG9wdGlvbnMubWF4RGF0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhpcy5tYXhZZWFyID0gdGhpcy5tYXhNb250aCA9IHRoaXMubWF4RGF0ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBtYXhEYXRlT2JqID0gbmV3IERhdGUob3B0aW9ucy5tYXhEYXRlKTtcclxuICAgICAgICB0aGlzLm1heFllYXIgPSBtYXhEYXRlT2JqLmdldEZ1bGxZZWFyKCk7XHJcbiAgICAgICAgdGhpcy5tYXhNb250aCA9IG1heERhdGVPYmouZ2V0TW9udGgoKTtcclxuICAgICAgICB0aGlzLm1heERhdGUgPSBkYXRlVmFsdWUodGhpcy5tYXhZZWFyLCB0aGlzLm1heE1vbnRoICsgMSwgMCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLmJlZm9yZVNob3dNb250aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMuYmVmb3JlU2hvdyA9IHR5cGVvZiBvcHRpb25zLmJlZm9yZVNob3dNb250aCA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgID8gb3B0aW9ucy5iZWZvcmVTaG93TW9udGhcclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFVwZGF0ZSB2aWV3J3Mgc2V0dGluZ3MgdG8gcmVmbGVjdCB0aGUgdmlld0RhdGUgc2V0IG9uIHRoZSBwaWNrZXJcclxuICB1cGRhdGVGb2N1cygpIHtcclxuICAgIGNvbnN0IHZpZXdEYXRlID0gbmV3IERhdGUodGhpcy5waWNrZXIudmlld0RhdGUpO1xyXG4gICAgdGhpcy55ZWFyID0gdmlld0RhdGUuZ2V0RnVsbFllYXIoKTtcclxuICAgIHRoaXMuZm9jdXNlZCA9IHZpZXdEYXRlLmdldE1vbnRoKCk7XHJcbiAgfVxyXG5cclxuICAvLyBVcGRhdGUgdmlldydzIHNldHRpbmdzIHRvIHJlZmxlY3QgdGhlIHNlbGVjdGVkIGRhdGVzXHJcbiAgdXBkYXRlU2VsZWN0aW9uKCkge1xyXG4gICAgY29uc3Qge2RhdGVzLCByYW5nZXBpY2tlcn0gPSB0aGlzLnBpY2tlci5kYXRlcGlja2VyO1xyXG4gICAgdGhpcy5zZWxlY3RlZCA9IGRhdGVzLnJlZHVjZSgoc2VsZWN0ZWQsIHRpbWVWYWx1ZSkgPT4ge1xyXG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodGltZVZhbHVlKTtcclxuICAgICAgY29uc3QgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgY29uc3QgbW9udGggPSBkYXRlLmdldE1vbnRoKCk7XHJcbiAgICAgIGlmIChzZWxlY3RlZFt5ZWFyXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgc2VsZWN0ZWRbeWVhcl0gPSBbbW9udGhdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHB1c2hVbmlxdWUoc2VsZWN0ZWRbeWVhcl0sIG1vbnRoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XHJcbiAgICB9LCB7fSk7XHJcbiAgICBpZiAocmFuZ2VwaWNrZXIgJiYgcmFuZ2VwaWNrZXIuZGF0ZXMpIHtcclxuICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlcGlja2VyLmRhdGVzLm1hcCh0aW1lVmFsdWUgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aW1lVmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBpc05hTihkYXRlKSA/IHVuZGVmaW5lZCA6IFtkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKV07XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gVXBkYXRlIHRoZSBlbnRpcmUgdmlldyBVSVxyXG4gIHJlbmRlcigpIHtcclxuICAgIC8vIHJlZnJlc2ggZGlzYWJsZWQgbW9udGhzIG9uIGV2ZXJ5IHJlbmRlciBpbiBvcmRlciB0byBjbGVhciB0aGUgb25lcyBhZGRlZFxyXG4gICAgLy8gYnkgYmVmb3JlU2hvdyBob29rIGF0IHByZXZpb3VzIHJlbmRlclxyXG4gICAgdGhpcy5kaXNhYmxlZCA9IFtdO1xyXG5cclxuICAgIHRoaXMucGlja2VyLnNldFZpZXdTd2l0Y2hMYWJlbCh0aGlzLnllYXIpO1xyXG4gICAgdGhpcy5waWNrZXIuc2V0UHJldkJ0bkRpc2FibGVkKHRoaXMueWVhciA8PSB0aGlzLm1pblllYXIpO1xyXG4gICAgdGhpcy5waWNrZXIuc2V0TmV4dEJ0bkRpc2FibGVkKHRoaXMueWVhciA+PSB0aGlzLm1heFllYXIpO1xyXG5cclxuICAgIGNvbnN0IHNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZFt0aGlzLnllYXJdIHx8IFtdO1xyXG4gICAgY29uc3QgeXJPdXRPZlJhbmdlID0gdGhpcy55ZWFyIDwgdGhpcy5taW5ZZWFyIHx8IHRoaXMueWVhciA+IHRoaXMubWF4WWVhcjtcclxuICAgIGNvbnN0IGlzTWluWWVhciA9IHRoaXMueWVhciA9PT0gdGhpcy5taW5ZZWFyO1xyXG4gICAgY29uc3QgaXNNYXhZZWFyID0gdGhpcy55ZWFyID09PSB0aGlzLm1heFllYXI7XHJcbiAgICBjb25zdCByYW5nZSA9IGNvbXB1dGVNb250aFJhbmdlKHRoaXMucmFuZ2UsIHRoaXMueWVhcik7XHJcblxyXG4gICAgQXJyYXkuZnJvbSh0aGlzLmdyaWQuY2hpbGRyZW4pLmZvckVhY2goKGVsLCBpbmRleCkgPT4ge1xyXG4gICAgICBjb25zdCBjbGFzc0xpc3QgPSBlbC5jbGFzc0xpc3Q7XHJcbiAgICAgIGNvbnN0IGRhdGUgPSBkYXRlVmFsdWUodGhpcy55ZWFyLCBpbmRleCwgMSk7XHJcblxyXG4gICAgICBlbC5jbGFzc05hbWUgPSBgZGF0ZXBpY2tlci1jZWxsIGhvdmVyOmJnLWdyYXktMTAwIGRhcms6aG92ZXI6YmctZ3JheS02MDAgYmxvY2sgZmxleC0xIGxlYWRpbmctOSBib3JkZXItMCByb3VuZGVkLWxnIGN1cnNvci1wb2ludGVyIHRleHQtY2VudGVyIHRleHQtZ3JheS05MDAgZGFyazp0ZXh0LXdoaXRlIGZvbnQtc2VtaWJvbGQgdGV4dC1zbSAke3RoaXMuY2VsbENsYXNzfWA7XHJcbiAgICAgIGlmICh0aGlzLmlzTWluVmlldykge1xyXG4gICAgICAgIGVsLmRhdGFzZXQuZGF0ZSA9IGRhdGU7XHJcbiAgICAgIH1cclxuICAgICAgLy8gcmVzZXQgdGV4dCBvbiBldmVyeSByZW5kZXIgdG8gY2xlYXIgdGhlIGN1c3RvbSBjb250ZW50IHNldFxyXG4gICAgICAvLyBieSBiZWZvcmVTaG93IGhvb2sgYXQgcHJldmlvdXMgcmVuZGVyXHJcbiAgICAgIGVsLnRleHRDb250ZW50ID0gdGhpcy5tb250aE5hbWVzW2luZGV4XTtcclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICB5ck91dE9mUmFuZ2VcclxuICAgICAgICB8fCBpc01pblllYXIgJiYgaW5kZXggPCB0aGlzLm1pbk1vbnRoXHJcbiAgICAgICAgfHwgaXNNYXhZZWFyICYmIGluZGV4ID4gdGhpcy5tYXhNb250aFxyXG4gICAgICApIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyYW5nZSkge1xyXG4gICAgICAgIGNvbnN0IFtyYW5nZVN0YXJ0LCByYW5nZUVuZF0gPSByYW5nZTtcclxuICAgICAgICBpZiAoaW5kZXggPiByYW5nZVN0YXJ0ICYmIGluZGV4IDwgcmFuZ2VFbmQpIHtcclxuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbmRleCA9PT0gcmFuZ2VTdGFydCkge1xyXG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2Utc3RhcnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluZGV4ID09PSByYW5nZUVuZCkge1xyXG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UtZW5kJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChzZWxlY3RlZC5pbmNsdWRlcyhpbmRleCkpIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcsICdiZy1ibHVlLTcwMCcsICd0ZXh0LXdoaXRlJywgJ2Rhcms6YmctYmx1ZS02MDAnLCAnZGFyazp0ZXh0LXdoaXRlJyk7XHJcbiAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1ncmF5LTkwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5mb2N1c2VkKSB7XHJcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcsICdiZy1ncmF5LTEwMCcsICdkYXJrOmJnLWdyYXktNjAwJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLmJlZm9yZVNob3cpIHtcclxuICAgICAgICB0aGlzLnBlcmZvcm1CZWZvcmVIb29rKGVsLCBpbmRleCwgZGF0ZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gVXBkYXRlIHRoZSB2aWV3IFVJIGJ5IGFwcGx5aW5nIHRoZSBjaGFuZ2VzIG9mIHNlbGVjdGVkIGFuZCBmb2N1c2VkIGl0ZW1zXHJcbiAgcmVmcmVzaCgpIHtcclxuICAgIGNvbnN0IHNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZFt0aGlzLnllYXJdIHx8IFtdO1xyXG4gICAgY29uc3QgW3JhbmdlU3RhcnQsIHJhbmdlRW5kXSA9IGNvbXB1dGVNb250aFJhbmdlKHRoaXMucmFuZ2UsIHRoaXMueWVhcikgfHwgW107XHJcbiAgICB0aGlzLmdyaWRcclxuICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoJy5yYW5nZSwgLnJhbmdlLXN0YXJ0LCAucmFuZ2UtZW5kLCAuc2VsZWN0ZWQsIC5mb2N1c2VkJylcclxuICAgICAgLmZvckVhY2goKGVsKSA9PiB7XHJcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgncmFuZ2UnLCAncmFuZ2Utc3RhcnQnLCAncmFuZ2UtZW5kJywgJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJ2Rhcms6YmctYmx1ZS02MDAnLCAnZGFyazp0ZXh0LXdoaXRlJywgJ3RleHQtd2hpdGUnLCAnZm9jdXNlZCcsICdiZy1ncmF5LTEwMCcsICdkYXJrOmJnLWdyYXktNjAwJyk7XHJcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgndGV4dC1ncmF5LTkwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcpO1xyXG4gICAgICB9KTtcclxuICAgIEFycmF5LmZyb20odGhpcy5ncmlkLmNoaWxkcmVuKS5mb3JFYWNoKChlbCwgaW5kZXgpID0+IHtcclxuICAgICAgY29uc3QgY2xhc3NMaXN0ID0gZWwuY2xhc3NMaXN0O1xyXG4gICAgICBpZiAoaW5kZXggPiByYW5nZVN0YXJ0ICYmIGluZGV4IDwgcmFuZ2VFbmQpIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZScpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpbmRleCA9PT0gcmFuZ2VTdGFydCkge1xyXG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlLXN0YXJ0Jyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGluZGV4ID09PSByYW5nZUVuZCkge1xyXG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlLWVuZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzZWxlY3RlZC5pbmNsdWRlcyhpbmRleCkpIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcsICdiZy1ibHVlLTcwMCcsICd0ZXh0LXdoaXRlJywgJ2Rhcms6YmctYmx1ZS02MDAnLCAnZGFyazp0ZXh0LXdoaXRlJyk7XHJcbiAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1ncmF5LTkwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5mb2N1c2VkKSB7XHJcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcsICdiZy1ncmF5LTEwMCcsICdkYXJrOmJnLWdyYXktNjAwJyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gVXBkYXRlIHRoZSB2aWV3IFVJIGJ5IGFwcGx5aW5nIHRoZSBjaGFuZ2Ugb2YgZm9jdXNlZCBpdGVtXHJcbiAgcmVmcmVzaEZvY3VzKCkge1xyXG4gICAgdGhpcy5ncmlkLnF1ZXJ5U2VsZWN0b3JBbGwoJy5mb2N1c2VkJykuZm9yRWFjaCgoZWwpID0+IHtcclxuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnZm9jdXNlZCcsICdiZy1ncmF5LTEwMCcpLCAnZGFyazpiZy1ncmF5LTYwMCc7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuZ3JpZC5jaGlsZHJlblt0aGlzLmZvY3VzZWRdLmNsYXNzTGlzdC5hZGQoJ2ZvY3VzZWQnLCAnYmctZ3JheS0xMDAnLCAnZGFyazpiZy1ncmF5LTYwMCcpO1xyXG4gIH1cclxufVxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHRoZW1lc2JlcmcvdGFpbHdpbmQtZGF0ZXBpY2tlci9qcy9waWNrZXIvdmlld3MvWWVhcnNWaWV3LmpzXHJcblxyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gdG9UaXRsZUNhc2Uod29yZCkge1xyXG4gIHJldHVybiBbLi4ud29yZF0ucmVkdWNlKChzdHIsIGNoLCBpeCkgPT4gc3RyICs9IGl4ID8gY2ggOiBjaC50b1VwcGVyQ2FzZSgpLCAnJyk7XHJcbn1cclxuXHJcbi8vIENsYXNzIHJlcHJlc2VudGluZyB0aGUgeWVhcnMgYW5kIGRlY2FkZXMgdmlldyBlbGVtZW50c1xyXG5jbGFzcyBZZWFyc1ZpZXcgZXh0ZW5kcyBWaWV3IHtcclxuICBjb25zdHJ1Y3RvcihwaWNrZXIsIGNvbmZpZykge1xyXG4gICAgc3VwZXIocGlja2VyLCBjb25maWcpO1xyXG4gIH1cclxuXHJcbiAgaW5pdChvcHRpb25zLCBvbkNvbnN0cnVjdGlvbiA9IHRydWUpIHtcclxuICAgIGlmIChvbkNvbnN0cnVjdGlvbikge1xyXG4gICAgICB0aGlzLm5hdlN0ZXAgPSB0aGlzLnN0ZXAgKiAxMDtcclxuICAgICAgdGhpcy5iZWZvcmVTaG93T3B0aW9uID0gYGJlZm9yZVNob3cke3RvVGl0bGVDYXNlKHRoaXMuY2VsbENsYXNzKX1gO1xyXG4gICAgICB0aGlzLmdyaWQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMubmFtZSwgJ2RhdGVwaWNrZXItZ3JpZCcsICd3LTY0JywgJ2dyaWQnLCAnZ3JpZC1jb2xzLTQnKTtcclxuICAgICAgdGhpcy5ncmlkLmFwcGVuZENoaWxkKHBhcnNlSFRNTChjcmVhdGVUYWdSZXBlYXQoJ3NwYW4nLCAxMikpKTtcclxuICAgIH1cclxuICAgIHN1cGVyLmluaXQob3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcclxuICAgIGlmIChoYXNQcm9wZXJ0eShvcHRpb25zLCAnbWluRGF0ZScpKSB7XHJcbiAgICAgIGlmIChvcHRpb25zLm1pbkRhdGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRoaXMubWluWWVhciA9IHRoaXMubWluRGF0ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLm1pblllYXIgPSBzdGFydE9mWWVhclBlcmlvZChvcHRpb25zLm1pbkRhdGUsIHRoaXMuc3RlcCk7XHJcbiAgICAgICAgdGhpcy5taW5EYXRlID0gZGF0ZVZhbHVlKHRoaXMubWluWWVhciwgMCwgMSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChoYXNQcm9wZXJ0eShvcHRpb25zLCAnbWF4RGF0ZScpKSB7XHJcbiAgICAgIGlmIChvcHRpb25zLm1heERhdGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRoaXMubWF4WWVhciA9IHRoaXMubWF4RGF0ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLm1heFllYXIgPSBzdGFydE9mWWVhclBlcmlvZChvcHRpb25zLm1heERhdGUsIHRoaXMuc3RlcCk7XHJcbiAgICAgICAgdGhpcy5tYXhEYXRlID0gZGF0ZVZhbHVlKHRoaXMubWF4WWVhciwgMTEsIDMxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnNbdGhpcy5iZWZvcmVTaG93T3B0aW9uXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbnN0IGJlZm9yZVNob3cgPSBvcHRpb25zW3RoaXMuYmVmb3JlU2hvd09wdGlvbl07XHJcbiAgICAgIHRoaXMuYmVmb3JlU2hvdyA9IHR5cGVvZiBiZWZvcmVTaG93ID09PSAnZnVuY3Rpb24nID8gYmVmb3JlU2hvdyA6IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFVwZGF0ZSB2aWV3J3Mgc2V0dGluZ3MgdG8gcmVmbGVjdCB0aGUgdmlld0RhdGUgc2V0IG9uIHRoZSBwaWNrZXJcclxuICB1cGRhdGVGb2N1cygpIHtcclxuICAgIGNvbnN0IHZpZXdEYXRlID0gbmV3IERhdGUodGhpcy5waWNrZXIudmlld0RhdGUpO1xyXG4gICAgY29uc3QgZmlyc3QgPSBzdGFydE9mWWVhclBlcmlvZCh2aWV3RGF0ZSwgdGhpcy5uYXZTdGVwKTtcclxuICAgIGNvbnN0IGxhc3QgPSBmaXJzdCArIDkgKiB0aGlzLnN0ZXA7XHJcblxyXG4gICAgdGhpcy5maXJzdCA9IGZpcnN0O1xyXG4gICAgdGhpcy5sYXN0ID0gbGFzdDtcclxuICAgIHRoaXMuc3RhcnQgPSBmaXJzdCAtIHRoaXMuc3RlcDtcclxuICAgIHRoaXMuZm9jdXNlZCA9IHN0YXJ0T2ZZZWFyUGVyaW9kKHZpZXdEYXRlLCB0aGlzLnN0ZXApO1xyXG4gIH1cclxuXHJcbiAgLy8gVXBkYXRlIHZpZXcncyBzZXR0aW5ncyB0byByZWZsZWN0IHRoZSBzZWxlY3RlZCBkYXRlc1xyXG4gIHVwZGF0ZVNlbGVjdGlvbigpIHtcclxuICAgIGNvbnN0IHtkYXRlcywgcmFuZ2VwaWNrZXJ9ID0gdGhpcy5waWNrZXIuZGF0ZXBpY2tlcjtcclxuICAgIHRoaXMuc2VsZWN0ZWQgPSBkYXRlcy5yZWR1Y2UoKHllYXJzLCB0aW1lVmFsdWUpID0+IHtcclxuICAgICAgcmV0dXJuIHB1c2hVbmlxdWUoeWVhcnMsIHN0YXJ0T2ZZZWFyUGVyaW9kKHRpbWVWYWx1ZSwgdGhpcy5zdGVwKSk7XHJcbiAgICB9LCBbXSk7XHJcbiAgICBpZiAocmFuZ2VwaWNrZXIgJiYgcmFuZ2VwaWNrZXIuZGF0ZXMpIHtcclxuICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlcGlja2VyLmRhdGVzLm1hcCh0aW1lVmFsdWUgPT4ge1xyXG4gICAgICAgIGlmICh0aW1lVmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZZZWFyUGVyaW9kKHRpbWVWYWx1ZSwgdGhpcy5zdGVwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gVXBkYXRlIHRoZSBlbnRpcmUgdmlldyBVSVxyXG4gIHJlbmRlcigpIHtcclxuICAgIC8vIHJlZnJlc2ggZGlzYWJsZWQgeWVhcnMgb24gZXZlcnkgcmVuZGVyIGluIG9yZGVyIHRvIGNsZWFyIHRoZSBvbmVzIGFkZGVkXHJcbiAgICAvLyBieSBiZWZvcmVTaG93IGhvb2sgYXQgcHJldmlvdXMgcmVuZGVyXHJcbiAgICB0aGlzLmRpc2FibGVkID0gW107XHJcblxyXG4gICAgdGhpcy5waWNrZXIuc2V0Vmlld1N3aXRjaExhYmVsKGAke3RoaXMuZmlyc3R9LSR7dGhpcy5sYXN0fWApO1xyXG4gICAgdGhpcy5waWNrZXIuc2V0UHJldkJ0bkRpc2FibGVkKHRoaXMuZmlyc3QgPD0gdGhpcy5taW5ZZWFyKTtcclxuICAgIHRoaXMucGlja2VyLnNldE5leHRCdG5EaXNhYmxlZCh0aGlzLmxhc3QgPj0gdGhpcy5tYXhZZWFyKTtcclxuXHJcbiAgICBBcnJheS5mcm9tKHRoaXMuZ3JpZC5jaGlsZHJlbikuZm9yRWFjaCgoZWwsIGluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IGVsLmNsYXNzTGlzdDtcclxuICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuc3RhcnQgKyAoaW5kZXggKiB0aGlzLnN0ZXApO1xyXG4gICAgICBjb25zdCBkYXRlID0gZGF0ZVZhbHVlKGN1cnJlbnQsIDAsIDEpO1xyXG5cclxuICAgICAgZWwuY2xhc3NOYW1lID0gYGRhdGVwaWNrZXItY2VsbCBob3ZlcjpiZy1ncmF5LTEwMCBkYXJrOmhvdmVyOmJnLWdyYXktNjAwIGJsb2NrIGZsZXgtMSBsZWFkaW5nLTkgYm9yZGVyLTAgcm91bmRlZC1sZyBjdXJzb3ItcG9pbnRlciB0ZXh0LWNlbnRlciB0ZXh0LWdyYXktOTAwIGRhcms6dGV4dC13aGl0ZSBmb250LXNlbWlib2xkIHRleHQtc20gJHt0aGlzLmNlbGxDbGFzc31gO1xyXG4gICAgICBpZiAodGhpcy5pc01pblZpZXcpIHtcclxuICAgICAgICBlbC5kYXRhc2V0LmRhdGUgPSBkYXRlO1xyXG4gICAgICB9XHJcbiAgICAgIGVsLnRleHRDb250ZW50ID0gZWwuZGF0YXNldC55ZWFyID0gY3VycmVudDtcclxuXHJcbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xyXG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3ByZXYnKTtcclxuICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMTEpIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCduZXh0Jyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGN1cnJlbnQgPCB0aGlzLm1pblllYXIgfHwgY3VycmVudCA+IHRoaXMubWF4WWVhcikge1xyXG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ2Rpc2FibGVkJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMucmFuZ2UpIHtcclxuICAgICAgICBjb25zdCBbcmFuZ2VTdGFydCwgcmFuZ2VFbmRdID0gdGhpcy5yYW5nZTtcclxuICAgICAgICBpZiAoY3VycmVudCA+IHJhbmdlU3RhcnQgJiYgY3VycmVudCA8IHJhbmdlRW5kKSB7XHJcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY3VycmVudCA9PT0gcmFuZ2VTdGFydCkge1xyXG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2Utc3RhcnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlRW5kKSB7XHJcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1lbmQnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQuaW5jbHVkZXMoY3VycmVudCkpIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcsICdiZy1ibHVlLTcwMCcsICd0ZXh0LXdoaXRlJywgJ2Rhcms6YmctYmx1ZS02MDAnLCAnZGFyazp0ZXh0LXdoaXRlJyk7XHJcbiAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1ncmF5LTkwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZvY3VzZWQpIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdmb2N1c2VkJywgJ2JnLWdyYXktMTAwJywgJ2Rhcms6YmctZ3JheS02MDAnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuYmVmb3JlU2hvdykge1xyXG4gICAgICAgIHRoaXMucGVyZm9ybUJlZm9yZUhvb2soZWwsIGN1cnJlbnQsIGRhdGUpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIFVwZGF0ZSB0aGUgdmlldyBVSSBieSBhcHBseWluZyB0aGUgY2hhbmdlcyBvZiBzZWxlY3RlZCBhbmQgZm9jdXNlZCBpdGVtc1xyXG4gIHJlZnJlc2goKSB7XHJcbiAgICBjb25zdCBbcmFuZ2VTdGFydCwgcmFuZ2VFbmRdID0gdGhpcy5yYW5nZSB8fCBbXTtcclxuICAgIHRoaXMuZ3JpZFxyXG4gICAgICAucXVlcnlTZWxlY3RvckFsbCgnLnJhbmdlLCAucmFuZ2Utc3RhcnQsIC5yYW5nZS1lbmQsIC5zZWxlY3RlZCwgLmZvY3VzZWQnKVxyXG4gICAgICAuZm9yRWFjaCgoZWwpID0+IHtcclxuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdyYW5nZScsICdyYW5nZS1zdGFydCcsICdyYW5nZS1lbmQnLCAnc2VsZWN0ZWQnLCAnYmctYmx1ZS03MDAnLCAndGV4dC13aGl0ZScsICdkYXJrOmJnLWJsdWUtNjAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICdmb2N1c2VkJywgJ2JnLWdyYXktMTAwJywgJ2Rhcms6YmctZ3JheS02MDAnKTtcclxuICAgICAgfSk7XHJcbiAgICBBcnJheS5mcm9tKHRoaXMuZ3JpZC5jaGlsZHJlbikuZm9yRWFjaCgoZWwpID0+IHtcclxuICAgICAgY29uc3QgY3VycmVudCA9IE51bWJlcihlbC50ZXh0Q29udGVudCk7XHJcbiAgICAgIGNvbnN0IGNsYXNzTGlzdCA9IGVsLmNsYXNzTGlzdDtcclxuICAgICAgaWYgKGN1cnJlbnQgPiByYW5nZVN0YXJ0ICYmIGN1cnJlbnQgPCByYW5nZUVuZCkge1xyXG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlU3RhcnQpIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1zdGFydCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjdXJyZW50ID09PSByYW5nZUVuZCkge1xyXG4gICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlLWVuZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkLmluY2x1ZGVzKGN1cnJlbnQpKSB7XHJcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnLCAnYmctYmx1ZS03MDAnLCAndGV4dC13aGl0ZScsICdkYXJrOmJnLWJsdWUtNjAwJywgJ2Rhcms6dGV4dC13aGl0ZScpO1xyXG4gICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3RleHQtZ3JheS05MDAnLCAnaG92ZXI6YmctZ3JheS0xMDAnLCAnZGFyazp0ZXh0LXdoaXRlJywgJ2Rhcms6aG92ZXI6YmctZ3JheS02MDAnKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5mb2N1c2VkKSB7XHJcbiAgICAgICAgY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcsICdiZy1ncmF5LTEwMCcsICdkYXJrOmJnLWdyYXktNjAwJyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gVXBkYXRlIHRoZSB2aWV3IFVJIGJ5IGFwcGx5aW5nIHRoZSBjaGFuZ2Ugb2YgZm9jdXNlZCBpdGVtXHJcbiAgcmVmcmVzaEZvY3VzKCkge1xyXG4gICAgY29uc3QgaW5kZXggPSBNYXRoLnJvdW5kKCh0aGlzLmZvY3VzZWQgLSB0aGlzLnN0YXJ0KSAvIHRoaXMuc3RlcCk7XHJcbiAgICB0aGlzLmdyaWQucXVlcnlTZWxlY3RvckFsbCgnLmZvY3VzZWQnKS5mb3JFYWNoKChlbCkgPT4ge1xyXG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdmb2N1c2VkJywgJ2JnLWdyYXktMTAwJywgJ2Rhcms6YmctZ3JheS02MDAnKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5ncmlkLmNoaWxkcmVuW2luZGV4XS5jbGFzc0xpc3QuYWRkKCdmb2N1c2VkJywgJ2JnLWdyYXktMTAwJywgJ2Rhcms6YmctZ3JheS02MDAnKTtcclxuICB9XHJcbn1cclxuXHJcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdGhlbWVzYmVyZy90YWlsd2luZC1kYXRlcGlja2VyL2pzL2V2ZW50cy9mdW5jdGlvbnMuanNcclxuXHJcblxyXG5cclxuZnVuY3Rpb24gdHJpZ2dlckRhdGVwaWNrZXJFdmVudChkYXRlcGlja2VyLCB0eXBlKSB7XHJcbiAgY29uc3QgZGV0YWlsID0ge1xyXG4gICAgZGF0ZTogZGF0ZXBpY2tlci5nZXREYXRlKCksXHJcbiAgICB2aWV3RGF0ZTogbmV3IERhdGUoZGF0ZXBpY2tlci5waWNrZXIudmlld0RhdGUpLFxyXG4gICAgdmlld0lkOiBkYXRlcGlja2VyLnBpY2tlci5jdXJyZW50Vmlldy5pZCxcclxuICAgIGRhdGVwaWNrZXIsXHJcbiAgfTtcclxuICBkYXRlcGlja2VyLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQodHlwZSwge2RldGFpbH0pKTtcclxufVxyXG5cclxuLy8gZGlyZWN0aW9uOiAtMSAodG8gcHJldmlvdXMpLCAxICh0byBuZXh0KVxyXG5mdW5jdGlvbiBnb1RvUHJldk9yTmV4dChkYXRlcGlja2VyLCBkaXJlY3Rpb24pIHtcclxuICBjb25zdCB7bWluRGF0ZSwgbWF4RGF0ZX0gPSBkYXRlcGlja2VyLmNvbmZpZztcclxuICBjb25zdCB7Y3VycmVudFZpZXcsIHZpZXdEYXRlfSA9IGRhdGVwaWNrZXIucGlja2VyO1xyXG4gIGxldCBuZXdWaWV3RGF0ZTtcclxuICBzd2l0Y2ggKGN1cnJlbnRWaWV3LmlkKSB7XHJcbiAgICBjYXNlIDA6XHJcbiAgICAgIG5ld1ZpZXdEYXRlID0gYWRkTW9udGhzKHZpZXdEYXRlLCBkaXJlY3Rpb24pO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMTpcclxuICAgICAgbmV3Vmlld0RhdGUgPSBhZGRZZWFycyh2aWV3RGF0ZSwgZGlyZWN0aW9uKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBuZXdWaWV3RGF0ZSA9IGFkZFllYXJzKHZpZXdEYXRlLCBkaXJlY3Rpb24gKiBjdXJyZW50Vmlldy5uYXZTdGVwKTtcclxuICB9XHJcbiAgbmV3Vmlld0RhdGUgPSBsaW1pdFRvUmFuZ2UobmV3Vmlld0RhdGUsIG1pbkRhdGUsIG1heERhdGUpO1xyXG4gIGRhdGVwaWNrZXIucGlja2VyLmNoYW5nZUZvY3VzKG5ld1ZpZXdEYXRlKS5yZW5kZXIoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3dpdGNoVmlldyhkYXRlcGlja2VyKSB7XHJcbiAgY29uc3Qgdmlld0lkID0gZGF0ZXBpY2tlci5waWNrZXIuY3VycmVudFZpZXcuaWQ7XHJcbiAgaWYgKHZpZXdJZCA9PT0gZGF0ZXBpY2tlci5jb25maWcubWF4Vmlldykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBkYXRlcGlja2VyLnBpY2tlci5jaGFuZ2VWaWV3KHZpZXdJZCArIDEpLnJlbmRlcigpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1bmZvY3VzKGRhdGVwaWNrZXIpIHtcclxuICBpZiAoZGF0ZXBpY2tlci5jb25maWcudXBkYXRlT25CbHVyKSB7XHJcbiAgICBkYXRlcGlja2VyLnVwZGF0ZSh7YXV0b2hpZGU6IHRydWV9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgZGF0ZXBpY2tlci5yZWZyZXNoKCdpbnB1dCcpO1xyXG4gICAgZGF0ZXBpY2tlci5oaWRlKCk7XHJcbiAgfVxyXG59XHJcblxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHRoZW1lc2JlcmcvdGFpbHdpbmQtZGF0ZXBpY2tlci9qcy9ldmVudHMvcGlja2VyTGlzdGVuZXJzLmpzXHJcblxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBnb1RvU2VsZWN0ZWRNb250aE9yWWVhcihkYXRlcGlja2VyLCBzZWxlY3Rpb24pIHtcclxuICBjb25zdCBwaWNrZXIgPSBkYXRlcGlja2VyLnBpY2tlcjtcclxuICBjb25zdCB2aWV3RGF0ZSA9IG5ldyBEYXRlKHBpY2tlci52aWV3RGF0ZSk7XHJcbiAgY29uc3Qgdmlld0lkID0gcGlja2VyLmN1cnJlbnRWaWV3LmlkO1xyXG4gIGNvbnN0IG5ld0RhdGUgPSB2aWV3SWQgPT09IDFcclxuICAgID8gYWRkTW9udGhzKHZpZXdEYXRlLCBzZWxlY3Rpb24gLSB2aWV3RGF0ZS5nZXRNb250aCgpKVxyXG4gICAgOiBhZGRZZWFycyh2aWV3RGF0ZSwgc2VsZWN0aW9uIC0gdmlld0RhdGUuZ2V0RnVsbFllYXIoKSk7XHJcblxyXG4gIHBpY2tlci5jaGFuZ2VGb2N1cyhuZXdEYXRlKS5jaGFuZ2VWaWV3KHZpZXdJZCAtIDEpLnJlbmRlcigpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvbkNsaWNrVG9kYXlCdG4oZGF0ZXBpY2tlcikge1xyXG4gIGNvbnN0IHBpY2tlciA9IGRhdGVwaWNrZXIucGlja2VyO1xyXG4gIGNvbnN0IGN1cnJlbnREYXRlID0gdG9kYXkoKTtcclxuICBpZiAoZGF0ZXBpY2tlci5jb25maWcudG9kYXlCdG5Nb2RlID09PSAxKSB7XHJcbiAgICBpZiAoZGF0ZXBpY2tlci5jb25maWcuYXV0b2hpZGUpIHtcclxuICAgICAgZGF0ZXBpY2tlci5zZXREYXRlKGN1cnJlbnREYXRlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZGF0ZXBpY2tlci5zZXREYXRlKGN1cnJlbnREYXRlLCB7cmVuZGVyOiBmYWxzZX0pO1xyXG4gICAgcGlja2VyLnVwZGF0ZSgpO1xyXG4gIH1cclxuICBpZiAocGlja2VyLnZpZXdEYXRlICE9PSBjdXJyZW50RGF0ZSkge1xyXG4gICAgcGlja2VyLmNoYW5nZUZvY3VzKGN1cnJlbnREYXRlKTtcclxuICB9XHJcbiAgcGlja2VyLmNoYW5nZVZpZXcoMCkucmVuZGVyKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9uQ2xpY2tDbGVhckJ0bihkYXRlcGlja2VyKSB7XHJcbiAgZGF0ZXBpY2tlci5zZXREYXRlKHtjbGVhcjogdHJ1ZX0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvbkNsaWNrVmlld1N3aXRjaChkYXRlcGlja2VyKSB7XHJcbiAgc3dpdGNoVmlldyhkYXRlcGlja2VyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gb25DbGlja1ByZXZCdG4oZGF0ZXBpY2tlcikge1xyXG4gIGdvVG9QcmV2T3JOZXh0KGRhdGVwaWNrZXIsIC0xKTtcclxufVxyXG5cclxuZnVuY3Rpb24gb25DbGlja05leHRCdG4oZGF0ZXBpY2tlcikge1xyXG4gIGdvVG9QcmV2T3JOZXh0KGRhdGVwaWNrZXIsIDEpO1xyXG59XHJcblxyXG4vLyBGb3IgdGhlIHBpY2tlcidzIG1haW4gYmxvY2sgdG8gZGVsZWdldGUgdGhlIGV2ZW50cyBmcm9tIGBkYXRlcGlja2VyLWNlbGxgc1xyXG5mdW5jdGlvbiBvbkNsaWNrVmlldyhkYXRlcGlja2VyLCBldikge1xyXG4gIGNvbnN0IHRhcmdldCA9IGZpbmRFbGVtZW50SW5FdmVudFBhdGgoZXYsICcuZGF0ZXBpY2tlci1jZWxsJyk7XHJcbiAgaWYgKCF0YXJnZXQgfHwgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qge2lkLCBpc01pblZpZXd9ID0gZGF0ZXBpY2tlci5waWNrZXIuY3VycmVudFZpZXc7XHJcbiAgaWYgKGlzTWluVmlldykge1xyXG4gICAgZGF0ZXBpY2tlci5zZXREYXRlKE51bWJlcih0YXJnZXQuZGF0YXNldC5kYXRlKSk7XHJcbiAgfSBlbHNlIGlmIChpZCA9PT0gMSkge1xyXG4gICAgZ29Ub1NlbGVjdGVkTW9udGhPclllYXIoZGF0ZXBpY2tlciwgTnVtYmVyKHRhcmdldC5kYXRhc2V0Lm1vbnRoKSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGdvVG9TZWxlY3RlZE1vbnRoT3JZZWFyKGRhdGVwaWNrZXIsIE51bWJlcih0YXJnZXQuZGF0YXNldC55ZWFyKSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBvbkNsaWNrUGlja2VyKGRhdGVwaWNrZXIpIHtcclxuICBpZiAoIWRhdGVwaWNrZXIuaW5saW5lICYmICFkYXRlcGlja2VyLmNvbmZpZy5kaXNhYmxlVG91Y2hLZXlib2FyZCkge1xyXG4gICAgZGF0ZXBpY2tlci5pbnB1dEZpZWxkLmZvY3VzKCk7XHJcbiAgfVxyXG59XHJcblxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHRoZW1lc2JlcmcvdGFpbHdpbmQtZGF0ZXBpY2tlci9qcy9waWNrZXIvUGlja2VyLmpzXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc1BpY2tlck9wdGlvbnMocGlja2VyLCBvcHRpb25zKSB7XHJcbiAgaWYgKG9wdGlvbnMudGl0bGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKG9wdGlvbnMudGl0bGUpIHtcclxuICAgICAgcGlja2VyLmNvbnRyb2xzLnRpdGxlLnRleHRDb250ZW50ID0gb3B0aW9ucy50aXRsZTtcclxuICAgICAgc2hvd0VsZW1lbnQocGlja2VyLmNvbnRyb2xzLnRpdGxlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBpY2tlci5jb250cm9scy50aXRsZS50ZXh0Q29udGVudCA9ICcnO1xyXG4gICAgICBoaWRlRWxlbWVudChwaWNrZXIuY29udHJvbHMudGl0bGUpO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAob3B0aW9ucy5wcmV2QXJyb3cpIHtcclxuICAgIGNvbnN0IHByZXZCdG4gPSBwaWNrZXIuY29udHJvbHMucHJldkJ0bjtcclxuICAgIGVtcHR5Q2hpbGROb2RlcyhwcmV2QnRuKTtcclxuICAgIG9wdGlvbnMucHJldkFycm93LmZvckVhY2goKG5vZGUpID0+IHtcclxuICAgICAgcHJldkJ0bi5hcHBlbmRDaGlsZChub2RlLmNsb25lTm9kZSh0cnVlKSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgaWYgKG9wdGlvbnMubmV4dEFycm93KSB7XHJcbiAgICBjb25zdCBuZXh0QnRuID0gcGlja2VyLmNvbnRyb2xzLm5leHRCdG47XHJcbiAgICBlbXB0eUNoaWxkTm9kZXMobmV4dEJ0bik7XHJcbiAgICBvcHRpb25zLm5leHRBcnJvdy5mb3JFYWNoKChub2RlKSA9PiB7XHJcbiAgICAgIG5leHRCdG4uYXBwZW5kQ2hpbGQobm9kZS5jbG9uZU5vZGUodHJ1ZSkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGlmIChvcHRpb25zLmxvY2FsZSkge1xyXG4gICAgcGlja2VyLmNvbnRyb2xzLnRvZGF5QnRuLnRleHRDb250ZW50ID0gb3B0aW9ucy5sb2NhbGUudG9kYXk7XHJcbiAgICBwaWNrZXIuY29udHJvbHMuY2xlYXJCdG4udGV4dENvbnRlbnQgPSBvcHRpb25zLmxvY2FsZS5jbGVhcjtcclxuICB9XHJcbiAgaWYgKG9wdGlvbnMudG9kYXlCdG4gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKG9wdGlvbnMudG9kYXlCdG4pIHtcclxuICAgICAgc2hvd0VsZW1lbnQocGlja2VyLmNvbnRyb2xzLnRvZGF5QnRuKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGhpZGVFbGVtZW50KHBpY2tlci5jb250cm9scy50b2RheUJ0bik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChoYXNQcm9wZXJ0eShvcHRpb25zLCAnbWluRGF0ZScpIHx8IGhhc1Byb3BlcnR5KG9wdGlvbnMsICdtYXhEYXRlJykpIHtcclxuICAgIGNvbnN0IHttaW5EYXRlLCBtYXhEYXRlfSA9IHBpY2tlci5kYXRlcGlja2VyLmNvbmZpZztcclxuICAgIHBpY2tlci5jb250cm9scy50b2RheUJ0bi5kaXNhYmxlZCA9ICFpc0luUmFuZ2UodG9kYXkoKSwgbWluRGF0ZSwgbWF4RGF0ZSk7XHJcbiAgfVxyXG4gIGlmIChvcHRpb25zLmNsZWFyQnRuICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGlmIChvcHRpb25zLmNsZWFyQnRuKSB7XHJcbiAgICAgIHNob3dFbGVtZW50KHBpY2tlci5jb250cm9scy5jbGVhckJ0bik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBoaWRlRWxlbWVudChwaWNrZXIuY29udHJvbHMuY2xlYXJCdG4pO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gQ29tcHV0ZSB2aWV3IGRhdGUgdG8gcmVzZXQsIHdoaWNoIHdpbGwgYmUuLi5cclxuLy8gLSB0aGUgbGFzdCBpdGVtIG9mIHRoZSBzZWxlY3RlZCBkYXRlcyBvciBkZWZhdWx0Vmlld0RhdGUgaWYgbm8gc2VsZWN0aW9uXHJcbi8vIC0gbGltaXR0ZWQgdG8gbWluRGF0ZSBvciBtYXhEYXRlIGlmIGl0IGV4Y2VlZHMgdGhlIHJhbmdlXHJcbmZ1bmN0aW9uIGNvbXB1dGVSZXNldFZpZXdEYXRlKGRhdGVwaWNrZXIpIHtcclxuICBjb25zdCB7ZGF0ZXMsIGNvbmZpZ30gPSBkYXRlcGlja2VyO1xyXG4gIGNvbnN0IHZpZXdEYXRlID0gZGF0ZXMubGVuZ3RoID4gMCA/IGxhc3RJdGVtT2YoZGF0ZXMpIDogY29uZmlnLmRlZmF1bHRWaWV3RGF0ZTtcclxuICByZXR1cm4gbGltaXRUb1JhbmdlKHZpZXdEYXRlLCBjb25maWcubWluRGF0ZSwgY29uZmlnLm1heERhdGUpO1xyXG59XHJcblxyXG4vLyBDaGFuZ2UgY3VycmVudCB2aWV3J3MgdmlldyBkYXRlXHJcbmZ1bmN0aW9uIHNldFZpZXdEYXRlKHBpY2tlciwgbmV3RGF0ZSkge1xyXG4gIGNvbnN0IG9sZFZpZXdEYXRlID0gbmV3IERhdGUocGlja2VyLnZpZXdEYXRlKTtcclxuICBjb25zdCBuZXdWaWV3RGF0ZSA9IG5ldyBEYXRlKG5ld0RhdGUpO1xyXG4gIGNvbnN0IHtpZCwgeWVhciwgZmlyc3QsIGxhc3R9ID0gcGlja2VyLmN1cnJlbnRWaWV3O1xyXG4gIGNvbnN0IHZpZXdZZWFyID0gbmV3Vmlld0RhdGUuZ2V0RnVsbFllYXIoKTtcclxuXHJcbiAgcGlja2VyLnZpZXdEYXRlID0gbmV3RGF0ZTtcclxuICBpZiAodmlld1llYXIgIT09IG9sZFZpZXdEYXRlLmdldEZ1bGxZZWFyKCkpIHtcclxuICAgIHRyaWdnZXJEYXRlcGlja2VyRXZlbnQocGlja2VyLmRhdGVwaWNrZXIsICdjaGFuZ2VZZWFyJyk7XHJcbiAgfVxyXG4gIGlmIChuZXdWaWV3RGF0ZS5nZXRNb250aCgpICE9PSBvbGRWaWV3RGF0ZS5nZXRNb250aCgpKSB7XHJcbiAgICB0cmlnZ2VyRGF0ZXBpY2tlckV2ZW50KHBpY2tlci5kYXRlcGlja2VyLCAnY2hhbmdlTW9udGgnKTtcclxuICB9XHJcblxyXG4gIC8vIHJldHVybiB3aGV0aGVyIHRoZSBuZXcgZGF0ZSBpcyBpbiBkaWZmZXJlbnQgcGVyaW9kIG9uIHRpbWUgZnJvbSB0aGUgb25lXHJcbiAgLy8gZGlzcGxheWVkIGluIHRoZSBjdXJyZW50IHZpZXdcclxuICAvLyB3aGVuIHRydWUsIHRoZSB2aWV3IG5lZWRzIHRvIGJlIHJlLXJlbmRlcmVkIG9uIHRoZSBuZXh0IFVJIHJlZnJlc2guXHJcbiAgc3dpdGNoIChpZCkge1xyXG4gICAgY2FzZSAwOlxyXG4gICAgICByZXR1cm4gbmV3RGF0ZSA8IGZpcnN0IHx8IG5ld0RhdGUgPiBsYXN0O1xyXG4gICAgY2FzZSAxOlxyXG4gICAgICByZXR1cm4gdmlld1llYXIgIT09IHllYXI7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gdmlld1llYXIgPCBmaXJzdCB8fCB2aWV3WWVhciA+IGxhc3Q7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRUZXh0RGlyZWN0aW9uKGVsKSB7XHJcbiAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5kaXJlY3Rpb247XHJcbn1cclxuXHJcbi8vIENsYXNzIHJlcHJlc2VudGluZyB0aGUgcGlja2VyIFVJXHJcbmNsYXNzIFBpY2tlciB7XHJcbiAgY29uc3RydWN0b3IoZGF0ZXBpY2tlcikge1xyXG4gICAgdGhpcy5kYXRlcGlja2VyID0gZGF0ZXBpY2tlcjtcclxuXHJcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlc19waWNrZXJUZW1wbGF0ZS5yZXBsYWNlKC8lYnV0dG9uQ2xhc3MlL2csIGRhdGVwaWNrZXIuY29uZmlnLmJ1dHRvbkNsYXNzKTtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQgPSBwYXJzZUhUTUwodGVtcGxhdGUpLmZpcnN0Q2hpbGQ7XHJcbiAgICBjb25zdCBbaGVhZGVyLCBtYWluLCBmb290ZXJdID0gZWxlbWVudC5maXJzdENoaWxkLmNoaWxkcmVuO1xyXG4gICAgY29uc3QgdGl0bGUgPSBoZWFkZXIuZmlyc3RFbGVtZW50Q2hpbGQ7XHJcbiAgICBjb25zdCBbcHJldkJ0biwgdmlld1N3aXRjaCwgbmV4dEJ0bl0gPSBoZWFkZXIubGFzdEVsZW1lbnRDaGlsZC5jaGlsZHJlbjtcclxuICAgIGNvbnN0IFt0b2RheUJ0biwgY2xlYXJCdG5dID0gZm9vdGVyLmZpcnN0Q2hpbGQuY2hpbGRyZW47XHJcbiAgICBjb25zdCBjb250cm9scyA9IHtcclxuICAgICAgdGl0bGUsXHJcbiAgICAgIHByZXZCdG4sXHJcbiAgICAgIHZpZXdTd2l0Y2gsXHJcbiAgICAgIG5leHRCdG4sXHJcbiAgICAgIHRvZGF5QnRuLFxyXG4gICAgICBjbGVhckJ0bixcclxuICAgIH07XHJcbiAgICB0aGlzLm1haW4gPSBtYWluO1xyXG4gICAgdGhpcy5jb250cm9scyA9IGNvbnRyb2xzO1xyXG5cclxuICAgIGNvbnN0IGVsZW1lbnRDbGFzcyA9IGRhdGVwaWNrZXIuaW5saW5lID8gJ2lubGluZScgOiAnZHJvcGRvd24nO1xyXG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGBkYXRlcGlja2VyLSR7ZWxlbWVudENsYXNzfWApO1xyXG4gICAgZWxlbWVudENsYXNzID09PSAnZHJvcGRvd24nID8gZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdkcm9wZG93bicsICdhYnNvbHV0ZScsICd0b3AtMCcsICdsZWZ0LTAnLCAnei0yMCcsICdwdC0yJykgOiBudWxsO1xyXG5cclxuICAgIHByb2Nlc3NQaWNrZXJPcHRpb25zKHRoaXMsIGRhdGVwaWNrZXIuY29uZmlnKTtcclxuICAgIHRoaXMudmlld0RhdGUgPSBjb21wdXRlUmVzZXRWaWV3RGF0ZShkYXRlcGlja2VyKTtcclxuXHJcbiAgICAvLyBzZXQgdXAgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICByZWdpc3Rlckxpc3RlbmVycyhkYXRlcGlja2VyLCBbXHJcbiAgICAgIFtlbGVtZW50LCAnY2xpY2snLCBvbkNsaWNrUGlja2VyLmJpbmQobnVsbCwgZGF0ZXBpY2tlciksIHtjYXB0dXJlOiB0cnVlfV0sXHJcbiAgICAgIFttYWluLCAnY2xpY2snLCBvbkNsaWNrVmlldy5iaW5kKG51bGwsIGRhdGVwaWNrZXIpXSxcclxuICAgICAgW2NvbnRyb2xzLnZpZXdTd2l0Y2gsICdjbGljaycsIG9uQ2xpY2tWaWV3U3dpdGNoLmJpbmQobnVsbCwgZGF0ZXBpY2tlcildLFxyXG4gICAgICBbY29udHJvbHMucHJldkJ0biwgJ2NsaWNrJywgb25DbGlja1ByZXZCdG4uYmluZChudWxsLCBkYXRlcGlja2VyKV0sXHJcbiAgICAgIFtjb250cm9scy5uZXh0QnRuLCAnY2xpY2snLCBvbkNsaWNrTmV4dEJ0bi5iaW5kKG51bGwsIGRhdGVwaWNrZXIpXSxcclxuICAgICAgW2NvbnRyb2xzLnRvZGF5QnRuLCAnY2xpY2snLCBvbkNsaWNrVG9kYXlCdG4uYmluZChudWxsLCBkYXRlcGlja2VyKV0sXHJcbiAgICAgIFtjb250cm9scy5jbGVhckJ0biwgJ2NsaWNrJywgb25DbGlja0NsZWFyQnRuLmJpbmQobnVsbCwgZGF0ZXBpY2tlcildLFxyXG4gICAgXSk7XHJcblxyXG4gICAgLy8gc2V0IHVwIHZpZXdzXHJcbiAgICB0aGlzLnZpZXdzID0gW1xyXG4gICAgICBuZXcgRGF5c1ZpZXcodGhpcyksXHJcbiAgICAgIG5ldyBNb250aHNWaWV3KHRoaXMpLFxyXG4gICAgICBuZXcgWWVhcnNWaWV3KHRoaXMsIHtpZDogMiwgbmFtZTogJ3llYXJzJywgY2VsbENsYXNzOiAneWVhcicsIHN0ZXA6IDF9KSxcclxuICAgICAgbmV3IFllYXJzVmlldyh0aGlzLCB7aWQ6IDMsIG5hbWU6ICdkZWNhZGVzJywgY2VsbENsYXNzOiAnZGVjYWRlJywgc3RlcDogMTB9KSxcclxuICAgIF07XHJcbiAgICB0aGlzLmN1cnJlbnRWaWV3ID0gdGhpcy52aWV3c1tkYXRlcGlja2VyLmNvbmZpZy5zdGFydFZpZXddO1xyXG5cclxuICAgIHRoaXMuY3VycmVudFZpZXcucmVuZGVyKCk7XHJcbiAgICB0aGlzLm1haW4uYXBwZW5kQ2hpbGQodGhpcy5jdXJyZW50Vmlldy5lbGVtZW50KTtcclxuICAgIGRhdGVwaWNrZXIuY29uZmlnLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xyXG4gIH1cclxuXHJcbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICBwcm9jZXNzUGlja2VyT3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuICAgIHRoaXMudmlld3MuZm9yRWFjaCgodmlldykgPT4ge1xyXG4gICAgICB2aWV3LmluaXQob3B0aW9ucywgZmFsc2UpO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLmN1cnJlbnRWaWV3LnJlbmRlcigpO1xyXG4gIH1cclxuXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhpcy5kYXRlcGlja2VyLmNvbmZpZy5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcclxuICB9XHJcblxyXG4gIHNob3coKSB7XHJcbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScsICdibG9jaycpO1xyXG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xyXG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG5cclxuICAgIGNvbnN0IGRhdGVwaWNrZXIgPSB0aGlzLmRhdGVwaWNrZXI7XHJcbiAgICBpZiAoIWRhdGVwaWNrZXIuaW5saW5lKSB7XHJcbiAgICAgIC8vIGVuc3VyZSBwaWNrZXIncyBkaXJlY3Rpb24gbWF0Y2hlcyBpbnB1dCdzXHJcbiAgICAgIGNvbnN0IGlucHV0RGlyZWN0aW9uID0gZ2V0VGV4dERpcmVjdGlvbihkYXRlcGlja2VyLmlucHV0RmllbGQpO1xyXG4gICAgICBpZiAoaW5wdXREaXJlY3Rpb24gIT09IGdldFRleHREaXJlY3Rpb24oZGF0ZXBpY2tlci5jb25maWcuY29udGFpbmVyKSkge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudC5kaXIgPSBpbnB1dERpcmVjdGlvbjtcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLmVsZW1lbnQuZGlyKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGlyJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMucGxhY2UoKTtcclxuICAgICAgaWYgKGRhdGVwaWNrZXIuY29uZmlnLmRpc2FibGVUb3VjaEtleWJvYXJkKSB7XHJcbiAgICAgICAgZGF0ZXBpY2tlci5pbnB1dEZpZWxkLmJsdXIoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdHJpZ2dlckRhdGVwaWNrZXJFdmVudChkYXRlcGlja2VyLCAnc2hvdycpO1xyXG4gIH1cclxuXHJcbiAgaGlkZSgpIHtcclxuICAgIGlmICghdGhpcy5hY3RpdmUpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5kYXRlcGlja2VyLmV4aXRFZGl0TW9kZSgpO1xyXG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScsICdibG9jaycpO1xyXG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScsICdibG9jaycsICdoaWRkZW4nKTtcclxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICB0cmlnZ2VyRGF0ZXBpY2tlckV2ZW50KHRoaXMuZGF0ZXBpY2tlciwgJ2hpZGUnKTtcclxuICB9XHJcblxyXG4gIHBsYWNlKCkge1xyXG4gICAgY29uc3Qge2NsYXNzTGlzdCwgc3R5bGV9ID0gdGhpcy5lbGVtZW50O1xyXG4gICAgY29uc3Qge2NvbmZpZywgaW5wdXRGaWVsZH0gPSB0aGlzLmRhdGVwaWNrZXI7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBjb25maWcuY29udGFpbmVyO1xyXG4gICAgY29uc3Qge1xyXG4gICAgICB3aWR0aDogY2FsZW5kYXJXaWR0aCxcclxuICAgICAgaGVpZ2h0OiBjYWxlbmRhckhlaWdodCxcclxuICAgIH0gPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIGxlZnQ6IGNvbnRhaW5lckxlZnQsXHJcbiAgICAgIHRvcDogY29udGFpbmVyVG9wLFxyXG4gICAgICB3aWR0aDogY29udGFpbmVyV2lkdGgsXHJcbiAgICB9ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBsZWZ0OiBpbnB1dExlZnQsXHJcbiAgICAgIHRvcDogaW5wdXRUb3AsXHJcbiAgICAgIHdpZHRoOiBpbnB1dFdpZHRoLFxyXG4gICAgICBoZWlnaHQ6IGlucHV0SGVpZ2h0XHJcbiAgICB9ID0gaW5wdXRGaWVsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIGxldCB7eDogb3JpZW50WCwgeTogb3JpZW50WX0gPSBjb25maWcub3JpZW50YXRpb247XHJcbiAgICBsZXQgc2Nyb2xsVG9wO1xyXG4gICAgbGV0IGxlZnQ7XHJcbiAgICBsZXQgdG9wO1xyXG5cclxuICAgIGlmIChjb250YWluZXIgPT09IGRvY3VtZW50LmJvZHkpIHtcclxuICAgICAgc2Nyb2xsVG9wID0gd2luZG93LnNjcm9sbFk7XHJcbiAgICAgIGxlZnQgPSBpbnB1dExlZnQgKyB3aW5kb3cuc2Nyb2xsWDtcclxuICAgICAgdG9wID0gaW5wdXRUb3AgKyBzY3JvbGxUb3A7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzY3JvbGxUb3AgPSBjb250YWluZXIuc2Nyb2xsVG9wO1xyXG4gICAgICBsZWZ0ID0gaW5wdXRMZWZ0IC0gY29udGFpbmVyTGVmdDtcclxuICAgICAgdG9wID0gaW5wdXRUb3AgLSBjb250YWluZXJUb3AgKyBzY3JvbGxUb3A7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9yaWVudFggPT09ICdhdXRvJykge1xyXG4gICAgICBpZiAobGVmdCA8IDApIHtcclxuICAgICAgICAvLyBhbGlnbiB0byB0aGUgbGVmdCBhbmQgbW92ZSBpbnRvIHZpc2libGUgYXJlYSBpZiBpbnB1dCdzIGxlZnQgZWRnZSA8IHdpbmRvdydzXHJcbiAgICAgICAgb3JpZW50WCA9ICdsZWZ0JztcclxuICAgICAgICBsZWZ0ID0gMTA7XHJcbiAgICAgIH0gZWxzZSBpZiAobGVmdCArIGNhbGVuZGFyV2lkdGggPiBjb250YWluZXJXaWR0aCkge1xyXG4gICAgICAgIC8vIGFsaWduIHRvIHRoZSByaWdodCBpZiBjYW5sZW5kYXIncyByaWdodCBlZGdlID4gY29udGFpbmVyJ3NcclxuICAgICAgICBvcmllbnRYID0gJ3JpZ2h0JztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBvcmllbnRYID0gZ2V0VGV4dERpcmVjdGlvbihpbnB1dEZpZWxkKSA9PT0gJ3J0bCcgPyAncmlnaHQnIDogJ2xlZnQnO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAob3JpZW50WCA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgICBsZWZ0IC09IGNhbGVuZGFyV2lkdGggLSBpbnB1dFdpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvcmllbnRZID09PSAnYXV0bycpIHtcclxuICAgICAgb3JpZW50WSA9IHRvcCAtIGNhbGVuZGFySGVpZ2h0IDwgc2Nyb2xsVG9wID8gJ2JvdHRvbScgOiAndG9wJztcclxuICAgIH1cclxuICAgIGlmIChvcmllbnRZID09PSAndG9wJykge1xyXG4gICAgICB0b3AgLT0gY2FsZW5kYXJIZWlnaHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0b3AgKz0gaW5wdXRIZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3NMaXN0LnJlbW92ZShcclxuICAgICAgJ2RhdGVwaWNrZXItb3JpZW50LXRvcCcsXHJcbiAgICAgICdkYXRlcGlja2VyLW9yaWVudC1ib3R0b20nLFxyXG4gICAgICAnZGF0ZXBpY2tlci1vcmllbnQtcmlnaHQnLFxyXG4gICAgICAnZGF0ZXBpY2tlci1vcmllbnQtbGVmdCdcclxuICAgICk7XHJcbiAgICBjbGFzc0xpc3QuYWRkKGBkYXRlcGlja2VyLW9yaWVudC0ke29yaWVudFl9YCwgYGRhdGVwaWNrZXItb3JpZW50LSR7b3JpZW50WH1gKTtcclxuXHJcbiAgICBzdHlsZS50b3AgPSB0b3AgPyBgJHt0b3B9cHhgIDogdG9wO1xyXG4gICAgc3R5bGUubGVmdCA9IGxlZnQgPyBgJHtsZWZ0fXB4YCA6IGxlZnQ7XHJcbiAgfVxyXG5cclxuICBzZXRWaWV3U3dpdGNoTGFiZWwobGFiZWxUZXh0KSB7XHJcbiAgICB0aGlzLmNvbnRyb2xzLnZpZXdTd2l0Y2gudGV4dENvbnRlbnQgPSBsYWJlbFRleHQ7XHJcbiAgfVxyXG5cclxuICBzZXRQcmV2QnRuRGlzYWJsZWQoZGlzYWJsZWQpIHtcclxuICAgIHRoaXMuY29udHJvbHMucHJldkJ0bi5kaXNhYmxlZCA9IGRpc2FibGVkO1xyXG4gIH1cclxuXHJcbiAgc2V0TmV4dEJ0bkRpc2FibGVkKGRpc2FibGVkKSB7XHJcbiAgICB0aGlzLmNvbnRyb2xzLm5leHRCdG4uZGlzYWJsZWQgPSBkaXNhYmxlZDtcclxuICB9XHJcblxyXG4gIGNoYW5nZVZpZXcodmlld0lkKSB7XHJcbiAgICBjb25zdCBvbGRWaWV3ID0gdGhpcy5jdXJyZW50VmlldztcclxuICAgIGNvbnN0IG5ld1ZpZXcgPSAgdGhpcy52aWV3c1t2aWV3SWRdO1xyXG4gICAgaWYgKG5ld1ZpZXcuaWQgIT09IG9sZFZpZXcuaWQpIHtcclxuICAgICAgdGhpcy5jdXJyZW50VmlldyA9IG5ld1ZpZXc7XHJcbiAgICAgIHRoaXMuX3JlbmRlck1ldGhvZCA9ICdyZW5kZXInO1xyXG4gICAgICB0cmlnZ2VyRGF0ZXBpY2tlckV2ZW50KHRoaXMuZGF0ZXBpY2tlciwgJ2NoYW5nZVZpZXcnKTtcclxuICAgICAgdGhpcy5tYWluLnJlcGxhY2VDaGlsZChuZXdWaWV3LmVsZW1lbnQsIG9sZFZpZXcuZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIENoYW5nZSB0aGUgZm9jdXNlZCBkYXRlICh2aWV3IGRhdGUpXHJcbiAgY2hhbmdlRm9jdXMobmV3Vmlld0RhdGUpIHtcclxuICAgIHRoaXMuX3JlbmRlck1ldGhvZCA9IHNldFZpZXdEYXRlKHRoaXMsIG5ld1ZpZXdEYXRlKSA/ICdyZW5kZXInIDogJ3JlZnJlc2hGb2N1cyc7XHJcbiAgICB0aGlzLnZpZXdzLmZvckVhY2goKHZpZXcpID0+IHtcclxuICAgICAgdmlldy51cGRhdGVGb2N1cygpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIEFwcGx5IHRoZSBjaGFuZ2Ugb2YgdGhlIHNlbGVjdGVkIGRhdGVzXHJcbiAgdXBkYXRlKCkge1xyXG4gICAgY29uc3QgbmV3Vmlld0RhdGUgPSBjb21wdXRlUmVzZXRWaWV3RGF0ZSh0aGlzLmRhdGVwaWNrZXIpO1xyXG4gICAgdGhpcy5fcmVuZGVyTWV0aG9kID0gc2V0Vmlld0RhdGUodGhpcywgbmV3Vmlld0RhdGUpID8gJ3JlbmRlcicgOiAncmVmcmVzaCc7XHJcbiAgICB0aGlzLnZpZXdzLmZvckVhY2goKHZpZXcpID0+IHtcclxuICAgICAgdmlldy51cGRhdGVGb2N1cygpO1xyXG4gICAgICB2aWV3LnVwZGF0ZVNlbGVjdGlvbigpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIFJlZnJlc2ggdGhlIHBpY2tlciBVSVxyXG4gIHJlbmRlcihxdWlja1JlbmRlciA9IHRydWUpIHtcclxuICAgIGNvbnN0IHJlbmRlck1ldGhvZCA9IChxdWlja1JlbmRlciAmJiB0aGlzLl9yZW5kZXJNZXRob2QpIHx8ICdyZW5kZXInO1xyXG4gICAgZGVsZXRlIHRoaXMuX3JlbmRlck1ldGhvZDtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRWaWV3W3JlbmRlck1ldGhvZF0oKTtcclxuICB9XHJcbn1cclxuXHJcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdGhlbWVzYmVyZy90YWlsd2luZC1kYXRlcGlja2VyL2pzL2V2ZW50cy9pbnB1dEZpZWxkTGlzdGVuZXJzLmpzXHJcblxyXG5cclxuXHJcblxyXG4vLyBGaW5kIHRoZSBjbG9zZXN0IGRhdGUgdGhhdCBkb2Vzbid0IG1lZXQgdGhlIGNvbmRpdGlvbiBmb3IgdW5hdmFpbGFibGUgZGF0ZVxyXG4vLyBSZXR1cm5zIHVuZGVmaW5lZCBpZiBubyBhdmFpbGFibGUgZGF0ZSBpcyBmb3VuZFxyXG4vLyBhZGRGbjogZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHRoZSBuZXh0IGRhdGVcclxuLy8gICAtIGFyZ3M6IHRpbWUgdmFsdWUsIGFtb3VudFxyXG4vLyBpbmNyZWFzZTogYW1vdW50IHRvIHBhc3MgdG8gYWRkRm5cclxuLy8gdGVzdEZuOiBmdW5jdGlvbiB0byB0ZXN0IHRoZSB1bmF2YWlsYWJsaXR5IG9mIHRoZSBkYXRlXHJcbi8vICAgLSBhcmdzOiB0aW1lIHZhbHVlOyByZXR1bjogdHJ1ZSBpZiB1bmF2YWlsYWJsZVxyXG5mdW5jdGlvbiBmaW5kTmV4dEF2YWlsYWJsZU9uZShkYXRlLCBhZGRGbiwgaW5jcmVhc2UsIHRlc3RGbiwgbWluLCBtYXgpIHtcclxuICBpZiAoIWlzSW5SYW5nZShkYXRlLCBtaW4sIG1heCkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKHRlc3RGbihkYXRlKSkge1xyXG4gICAgY29uc3QgbmV3RGF0ZSA9IGFkZEZuKGRhdGUsIGluY3JlYXNlKTtcclxuICAgIHJldHVybiBmaW5kTmV4dEF2YWlsYWJsZU9uZShuZXdEYXRlLCBhZGRGbiwgaW5jcmVhc2UsIHRlc3RGbiwgbWluLCBtYXgpO1xyXG4gIH1cclxuICByZXR1cm4gZGF0ZTtcclxufVxyXG5cclxuLy8gZGlyZWN0aW9uOiAtMSAobGVmdC91cCksIDEgKHJpZ2h0L2Rvd24pXHJcbi8vIHZlcnRpY2FsOiB0cnVlIGZvciB1cC9kb3duLCBmYWxzZSBmb3IgbGVmdC9yaWdodFxyXG5mdW5jdGlvbiBtb3ZlQnlBcnJvd0tleShkYXRlcGlja2VyLCBldiwgZGlyZWN0aW9uLCB2ZXJ0aWNhbCkge1xyXG4gIGNvbnN0IHBpY2tlciA9IGRhdGVwaWNrZXIucGlja2VyO1xyXG4gIGNvbnN0IGN1cnJlbnRWaWV3ID0gcGlja2VyLmN1cnJlbnRWaWV3O1xyXG4gIGNvbnN0IHN0ZXAgPSBjdXJyZW50Vmlldy5zdGVwIHx8IDE7XHJcbiAgbGV0IHZpZXdEYXRlID0gcGlja2VyLnZpZXdEYXRlO1xyXG4gIGxldCBhZGRGbjtcclxuICBsZXQgdGVzdEZuO1xyXG4gIHN3aXRjaCAoY3VycmVudFZpZXcuaWQpIHtcclxuICAgIGNhc2UgMDpcclxuICAgICAgaWYgKHZlcnRpY2FsKSB7XHJcbiAgICAgICAgdmlld0RhdGUgPSBhZGREYXlzKHZpZXdEYXRlLCBkaXJlY3Rpb24gKiA3KTtcclxuICAgICAgfSBlbHNlIGlmIChldi5jdHJsS2V5IHx8IGV2Lm1ldGFLZXkpIHtcclxuICAgICAgICB2aWV3RGF0ZSA9IGFkZFllYXJzKHZpZXdEYXRlLCBkaXJlY3Rpb24pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZpZXdEYXRlID0gYWRkRGF5cyh2aWV3RGF0ZSwgZGlyZWN0aW9uKTtcclxuICAgICAgfVxyXG4gICAgICBhZGRGbiA9IGFkZERheXM7XHJcbiAgICAgIHRlc3RGbiA9IChkYXRlKSA9PiBjdXJyZW50Vmlldy5kaXNhYmxlZC5pbmNsdWRlcyhkYXRlKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDE6XHJcbiAgICAgIHZpZXdEYXRlID0gYWRkTW9udGhzKHZpZXdEYXRlLCB2ZXJ0aWNhbCA/IGRpcmVjdGlvbiAqIDQgOiBkaXJlY3Rpb24pO1xyXG4gICAgICBhZGRGbiA9IGFkZE1vbnRocztcclxuICAgICAgdGVzdEZuID0gKGRhdGUpID0+IHtcclxuICAgICAgICBjb25zdCBkdCA9IG5ldyBEYXRlKGRhdGUpO1xyXG4gICAgICAgIGNvbnN0IHt5ZWFyLCBkaXNhYmxlZH0gPSBjdXJyZW50VmlldztcclxuICAgICAgICByZXR1cm4gZHQuZ2V0RnVsbFllYXIoKSA9PT0geWVhciAmJiBkaXNhYmxlZC5pbmNsdWRlcyhkdC5nZXRNb250aCgpKTtcclxuICAgICAgfTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB2aWV3RGF0ZSA9IGFkZFllYXJzKHZpZXdEYXRlLCBkaXJlY3Rpb24gKiAodmVydGljYWwgPyA0IDogMSkgKiBzdGVwKTtcclxuICAgICAgYWRkRm4gPSBhZGRZZWFycztcclxuICAgICAgdGVzdEZuID0gZGF0ZSA9PiBjdXJyZW50Vmlldy5kaXNhYmxlZC5pbmNsdWRlcyhzdGFydE9mWWVhclBlcmlvZChkYXRlLCBzdGVwKSk7XHJcbiAgfVxyXG4gIHZpZXdEYXRlID0gZmluZE5leHRBdmFpbGFibGVPbmUoXHJcbiAgICB2aWV3RGF0ZSxcclxuICAgIGFkZEZuLFxyXG4gICAgZGlyZWN0aW9uIDwgMCA/IC1zdGVwIDogc3RlcCxcclxuICAgIHRlc3RGbixcclxuICAgIGN1cnJlbnRWaWV3Lm1pbkRhdGUsXHJcbiAgICBjdXJyZW50Vmlldy5tYXhEYXRlXHJcbiAgKTtcclxuICBpZiAodmlld0RhdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgcGlja2VyLmNoYW5nZUZvY3VzKHZpZXdEYXRlKS5yZW5kZXIoKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9uS2V5ZG93bihkYXRlcGlja2VyLCBldikge1xyXG4gIGlmIChldi5rZXkgPT09ICdUYWInKSB7XHJcbiAgICB1bmZvY3VzKGRhdGVwaWNrZXIpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgcGlja2VyID0gZGF0ZXBpY2tlci5waWNrZXI7XHJcbiAgY29uc3Qge2lkLCBpc01pblZpZXd9ID0gcGlja2VyLmN1cnJlbnRWaWV3O1xyXG4gIGlmICghcGlja2VyLmFjdGl2ZSkge1xyXG4gICAgc3dpdGNoIChldi5rZXkpIHtcclxuICAgICAgY2FzZSAnQXJyb3dEb3duJzpcclxuICAgICAgY2FzZSAnRXNjYXBlJzpcclxuICAgICAgICBwaWNrZXIuc2hvdygpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdFbnRlcic6XHJcbiAgICAgICAgZGF0ZXBpY2tlci51cGRhdGUoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChkYXRlcGlja2VyLmVkaXRNb2RlKSB7XHJcbiAgICBzd2l0Y2ggKGV2LmtleSkge1xyXG4gICAgICBjYXNlICdFc2NhcGUnOlxyXG4gICAgICAgIHBpY2tlci5oaWRlKCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ0VudGVyJzpcclxuICAgICAgICBkYXRlcGlja2VyLmV4aXRFZGl0TW9kZSh7dXBkYXRlOiB0cnVlLCBhdXRvaGlkZTogZGF0ZXBpY2tlci5jb25maWcuYXV0b2hpZGV9KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHN3aXRjaCAoZXYua2V5KSB7XHJcbiAgICAgIGNhc2UgJ0VzY2FwZSc6XHJcbiAgICAgICAgcGlja2VyLmhpZGUoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcclxuICAgICAgICBpZiAoZXYuY3RybEtleSB8fCBldi5tZXRhS2V5KSB7XHJcbiAgICAgICAgICBnb1RvUHJldk9yTmV4dChkYXRlcGlja2VyLCAtMSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChldi5zaGlmdEtleSkge1xyXG4gICAgICAgICAgZGF0ZXBpY2tlci5lbnRlckVkaXRNb2RlKCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG1vdmVCeUFycm93S2V5KGRhdGVwaWNrZXIsIGV2LCAtMSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnQXJyb3dSaWdodCc6XHJcbiAgICAgICAgaWYgKGV2LmN0cmxLZXkgfHwgZXYubWV0YUtleSkge1xyXG4gICAgICAgICAgZ29Ub1ByZXZPck5leHQoZGF0ZXBpY2tlciwgMSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChldi5zaGlmdEtleSkge1xyXG4gICAgICAgICAgZGF0ZXBpY2tlci5lbnRlckVkaXRNb2RlKCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG1vdmVCeUFycm93S2V5KGRhdGVwaWNrZXIsIGV2LCAxLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdBcnJvd1VwJzpcclxuICAgICAgICBpZiAoZXYuY3RybEtleSB8fCBldi5tZXRhS2V5KSB7XHJcbiAgICAgICAgICBzd2l0Y2hWaWV3KGRhdGVwaWNrZXIpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZXYuc2hpZnRLZXkpIHtcclxuICAgICAgICAgIGRhdGVwaWNrZXIuZW50ZXJFZGl0TW9kZSgpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBtb3ZlQnlBcnJvd0tleShkYXRlcGlja2VyLCBldiwgLTEsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnQXJyb3dEb3duJzpcclxuICAgICAgICBpZiAoZXYuc2hpZnRLZXkgJiYgIWV2LmN0cmxLZXkgJiYgIWV2Lm1ldGFLZXkpIHtcclxuICAgICAgICAgIGRhdGVwaWNrZXIuZW50ZXJFZGl0TW9kZSgpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtb3ZlQnlBcnJvd0tleShkYXRlcGlja2VyLCBldiwgMSwgdHJ1ZSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ0VudGVyJzpcclxuICAgICAgICBpZiAoaXNNaW5WaWV3KSB7XHJcbiAgICAgICAgICBkYXRlcGlja2VyLnNldERhdGUocGlja2VyLnZpZXdEYXRlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcGlja2VyLmNoYW5nZVZpZXcoaWQgLSAxKS5yZW5kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ0JhY2tzcGFjZSc6XHJcbiAgICAgIGNhc2UgJ0RlbGV0ZSc6XHJcbiAgICAgICAgZGF0ZXBpY2tlci5lbnRlckVkaXRNb2RlKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGlmIChldi5rZXkubGVuZ3RoID09PSAxICYmICFldi5jdHJsS2V5ICYmICFldi5tZXRhS2V5KSB7XHJcbiAgICAgICAgICBkYXRlcGlja2VyLmVudGVyRWRpdE1vZGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gIH1cclxuICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvbkZvY3VzKGRhdGVwaWNrZXIpIHtcclxuICBpZiAoZGF0ZXBpY2tlci5jb25maWcuc2hvd09uRm9jdXMgJiYgIWRhdGVwaWNrZXIuX3Nob3dpbmcpIHtcclxuICAgIGRhdGVwaWNrZXIuc2hvdygpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gZm9yIHRoZSBwcmV2ZW50aW9uIGZvciBlbnRlcmluZyBlZGl0IG1vZGUgd2hpbGUgZ2V0dGluZyBmb2N1cyBvbiBjbGlja1xyXG5mdW5jdGlvbiBvbk1vdXNlZG93bihkYXRlcGlja2VyLCBldikge1xyXG4gIGNvbnN0IGVsID0gZXYudGFyZ2V0O1xyXG4gIGlmIChkYXRlcGlja2VyLnBpY2tlci5hY3RpdmUgfHwgZGF0ZXBpY2tlci5jb25maWcuc2hvd09uQ2xpY2spIHtcclxuICAgIGVsLl9hY3RpdmUgPSBlbCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcclxuICAgIGVsLl9jbGlja2luZyA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBkZWxldGUgZWwuX2FjdGl2ZTtcclxuICAgICAgZGVsZXRlIGVsLl9jbGlja2luZztcclxuICAgIH0sIDIwMDApO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gb25DbGlja0lucHV0KGRhdGVwaWNrZXIsIGV2KSB7XHJcbiAgY29uc3QgZWwgPSBldi50YXJnZXQ7XHJcbiAgaWYgKCFlbC5fY2xpY2tpbmcpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY2xlYXJUaW1lb3V0KGVsLl9jbGlja2luZyk7XHJcbiAgZGVsZXRlIGVsLl9jbGlja2luZztcclxuXHJcbiAgaWYgKGVsLl9hY3RpdmUpIHtcclxuICAgIGRhdGVwaWNrZXIuZW50ZXJFZGl0TW9kZSgpO1xyXG4gIH1cclxuICBkZWxldGUgZWwuX2FjdGl2ZTtcclxuXHJcbiAgaWYgKGRhdGVwaWNrZXIuY29uZmlnLnNob3dPbkNsaWNrKSB7XHJcbiAgICBkYXRlcGlja2VyLnNob3coKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9uUGFzdGUoZGF0ZXBpY2tlciwgZXYpIHtcclxuICBpZiAoZXYuY2xpcGJvYXJkRGF0YS50eXBlcy5pbmNsdWRlcygndGV4dC9wbGFpbicpKSB7XHJcbiAgICBkYXRlcGlja2VyLmVudGVyRWRpdE1vZGUoKTtcclxuICB9XHJcbn1cclxuXHJcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AdGhlbWVzYmVyZy90YWlsd2luZC1kYXRlcGlja2VyL2pzL2V2ZW50cy9vdGhlckxpc3RlbmVycy5qc1xyXG5cclxuXHJcblxyXG4vLyBmb3IgdGhlIGBkb2N1bWVudGAgdG8gZGVsZWdhdGUgdGhlIGV2ZW50cyBmcm9tIG91dHNpZGUgdGhlIHBpY2tlci9pbnB1dCBmaWVsZFxyXG5mdW5jdGlvbiBvbkNsaWNrT3V0c2lkZShkYXRlcGlja2VyLCBldikge1xyXG4gIGNvbnN0IGVsZW1lbnQgPSBkYXRlcGlja2VyLmVsZW1lbnQ7XHJcbiAgaWYgKGVsZW1lbnQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY29uc3QgcGlja2VyRWxlbSA9IGRhdGVwaWNrZXIucGlja2VyLmVsZW1lbnQ7XHJcbiAgaWYgKGZpbmRFbGVtZW50SW5FdmVudFBhdGgoZXYsIGVsID0+IGVsID09PSBlbGVtZW50IHx8IGVsID09PSBwaWNrZXJFbGVtKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB1bmZvY3VzKGRhdGVwaWNrZXIpO1xyXG59XHJcblxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHRoZW1lc2JlcmcvdGFpbHdpbmQtZGF0ZXBpY2tlci9qcy9EYXRlcGlja2VyLmpzXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeURhdGVzKGRhdGVzLCBjb25maWcpIHtcclxuICByZXR1cm4gZGF0ZXNcclxuICAgIC5tYXAoZHQgPT4gZm9ybWF0RGF0ZShkdCwgY29uZmlnLmZvcm1hdCwgY29uZmlnLmxvY2FsZSkpXHJcbiAgICAuam9pbihjb25maWcuZGF0ZURlbGltaXRlcik7XHJcbn1cclxuXHJcbi8vIHBhcnNlIGlucHV0IGRhdGVzIGFuZCBjcmVhdGUgYW4gYXJyYXkgb2YgdGltZSB2YWx1ZXMgZm9yIHNlbGVjdGlvblxyXG4vLyByZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGVyZSBhcmUgbm8gdmFsaWQgZGF0ZXMgaW4gaW5wdXREYXRlc1xyXG4vLyB3aGVuIG9yaWdEYXRlcyAoY3VycmVudCBzZWxlY3Rpb24pIGlzIHBhc3NlZCwgdGhlIGZ1bmN0aW9uIHdvcmtzIHRvIG1peFxyXG4vLyB0aGUgaW5wdXQgZGF0ZXMgaW50byB0aGUgY3VycmVudCBzZWxlY3Rpb25cclxuZnVuY3Rpb24gcHJvY2Vzc0lucHV0RGF0ZXMoZGF0ZXBpY2tlciwgaW5wdXREYXRlcywgY2xlYXIgPSBmYWxzZSkge1xyXG4gIGNvbnN0IHtjb25maWcsIGRhdGVzOiBvcmlnRGF0ZXMsIHJhbmdlcGlja2VyfSA9IGRhdGVwaWNrZXI7XHJcbiAgaWYgKGlucHV0RGF0ZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAvLyBlbXB0eSBpbnB1dCBpcyBjb25zaWRlcmVkIHZhbGlkIHVubGVzcyBvcmlnaURhdGVzIGlzIHBhc3NlZFxyXG4gICAgcmV0dXJuIGNsZWFyID8gW10gOiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBjb25zdCByYW5nZUVuZCA9IHJhbmdlcGlja2VyICYmIGRhdGVwaWNrZXIgPT09IHJhbmdlcGlja2VyLmRhdGVwaWNrZXJzWzFdO1xyXG4gIGxldCBuZXdEYXRlcyA9IGlucHV0RGF0ZXMucmVkdWNlKChkYXRlcywgZHQpID0+IHtcclxuICAgIGxldCBkYXRlID0gcGFyc2VEYXRlKGR0LCBjb25maWcuZm9ybWF0LCBjb25maWcubG9jYWxlKTtcclxuICAgIGlmIChkYXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIGRhdGVzO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbmZpZy5waWNrTGV2ZWwgPiAwKSB7XHJcbiAgICAgIC8vIGFkanVzdCB0byAxc3Qgb2YgdGhlIG1vbnRoL0phbiAxc3Qgb2YgdGhlIHllYXJcclxuICAgICAgLy8gb3IgdG8gdGhlIGxhc3QgZGF5IG9mIHRoZSBtb25oL0RlYyAzMXN0IG9mIHRoZSB5ZWFyIGlmIHRoZSBkYXRlcGlja2VyXHJcbiAgICAgIC8vIGlzIHRoZSByYW5nZS1lbmQgcGlja2VyIG9mIGEgcmFuZ2VwaWNrZXJcclxuICAgICAgY29uc3QgZHQgPSBuZXcgRGF0ZShkYXRlKTtcclxuICAgICAgaWYgKGNvbmZpZy5waWNrTGV2ZWwgPT09IDEpIHtcclxuICAgICAgICBkYXRlID0gcmFuZ2VFbmRcclxuICAgICAgICAgID8gZHQuc2V0TW9udGgoZHQuZ2V0TW9udGgoKSArIDEsIDApXHJcbiAgICAgICAgICA6IGR0LnNldERhdGUoMSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGF0ZSA9IHJhbmdlRW5kXHJcbiAgICAgICAgICA/IGR0LnNldEZ1bGxZZWFyKGR0LmdldEZ1bGxZZWFyKCkgKyAxLCAwLCAwKVxyXG4gICAgICAgICAgOiBkdC5zZXRNb250aCgwLCAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKFxyXG4gICAgICBpc0luUmFuZ2UoZGF0ZSwgY29uZmlnLm1pbkRhdGUsIGNvbmZpZy5tYXhEYXRlKVxyXG4gICAgICAmJiAhZGF0ZXMuaW5jbHVkZXMoZGF0ZSlcclxuICAgICAgJiYgIWNvbmZpZy5kYXRlc0Rpc2FibGVkLmluY2x1ZGVzKGRhdGUpXHJcbiAgICAgICYmICFjb25maWcuZGF5c09mV2Vla0Rpc2FibGVkLmluY2x1ZGVzKG5ldyBEYXRlKGRhdGUpLmdldERheSgpKVxyXG4gICAgKSB7XHJcbiAgICAgIGRhdGVzLnB1c2goZGF0ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0ZXM7XHJcbiAgfSwgW10pO1xyXG4gIGlmIChuZXdEYXRlcy5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKGNvbmZpZy5tdWx0aWRhdGUgJiYgIWNsZWFyKSB7XHJcbiAgICAvLyBnZXQgdGhlIHN5bm1ldHJpYyBkaWZmZXJlbmNlIGJldHdlZW4gb3JpZ0RhdGVzIGFuZCBuZXdEYXRlc1xyXG4gICAgbmV3RGF0ZXMgPSBuZXdEYXRlcy5yZWR1Y2UoKGRhdGVzLCBkYXRlKSA9PiB7XHJcbiAgICAgIGlmICghb3JpZ0RhdGVzLmluY2x1ZGVzKGRhdGUpKSB7XHJcbiAgICAgICAgZGF0ZXMucHVzaChkYXRlKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZGF0ZXM7XHJcbiAgICB9LCBvcmlnRGF0ZXMuZmlsdGVyKGRhdGUgPT4gIW5ld0RhdGVzLmluY2x1ZGVzKGRhdGUpKSk7XHJcbiAgfVxyXG4gIC8vIGRvIGxlbmd0aCBjaGVjayBhbHdheXMgYmVjYXVzZSB1c2VyIGNhbiBpbnB1dCBtdWx0aXBsZSBkYXRlcyByZWdhcmRsZXNzIG9mIHRoZSBtb2RlXHJcbiAgcmV0dXJuIGNvbmZpZy5tYXhOdW1iZXJPZkRhdGVzICYmIG5ld0RhdGVzLmxlbmd0aCA+IGNvbmZpZy5tYXhOdW1iZXJPZkRhdGVzXHJcbiAgICA/IG5ld0RhdGVzLnNsaWNlKGNvbmZpZy5tYXhOdW1iZXJPZkRhdGVzICogLTEpXHJcbiAgICA6IG5ld0RhdGVzO1xyXG59XHJcblxyXG4vLyByZWZyZXNoIHRoZSBVSSBlbGVtZW50c1xyXG4vLyBtb2RlczogMTogaW5wdXQgb25seSwgMiwgcGlja2VyIG9ubHksIDMgYm90aFxyXG5mdW5jdGlvbiByZWZyZXNoVUkoZGF0ZXBpY2tlciwgbW9kZSA9IDMsIHF1aWNrUmVuZGVyID0gdHJ1ZSkge1xyXG4gIGNvbnN0IHtjb25maWcsIHBpY2tlciwgaW5wdXRGaWVsZH0gPSBkYXRlcGlja2VyO1xyXG4gIGlmIChtb2RlICYgMikge1xyXG4gICAgY29uc3QgbmV3VmlldyA9IHBpY2tlci5hY3RpdmUgPyBjb25maWcucGlja0xldmVsIDogY29uZmlnLnN0YXJ0VmlldztcclxuICAgIHBpY2tlci51cGRhdGUoKS5jaGFuZ2VWaWV3KG5ld1ZpZXcpLnJlbmRlcihxdWlja1JlbmRlcik7XHJcbiAgfVxyXG4gIGlmIChtb2RlICYgMSAmJiBpbnB1dEZpZWxkKSB7XHJcbiAgICBpbnB1dEZpZWxkLnZhbHVlID0gc3RyaW5naWZ5RGF0ZXMoZGF0ZXBpY2tlci5kYXRlcywgY29uZmlnKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldERhdGUoZGF0ZXBpY2tlciwgaW5wdXREYXRlcywgb3B0aW9ucykge1xyXG4gIGxldCB7Y2xlYXIsIHJlbmRlciwgYXV0b2hpZGV9ID0gb3B0aW9ucztcclxuICBpZiAocmVuZGVyID09PSB1bmRlZmluZWQpIHtcclxuICAgIHJlbmRlciA9IHRydWU7XHJcbiAgfVxyXG4gIGlmICghcmVuZGVyKSB7XHJcbiAgICBhdXRvaGlkZSA9IGZhbHNlO1xyXG4gIH0gZWxzZSBpZiAoYXV0b2hpZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgYXV0b2hpZGUgPSBkYXRlcGlja2VyLmNvbmZpZy5hdXRvaGlkZTtcclxuICB9XHJcblxyXG4gIGNvbnN0IG5ld0RhdGVzID0gcHJvY2Vzc0lucHV0RGF0ZXMoZGF0ZXBpY2tlciwgaW5wdXREYXRlcywgY2xlYXIpO1xyXG4gIGlmICghbmV3RGF0ZXMpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKG5ld0RhdGVzLnRvU3RyaW5nKCkgIT09IGRhdGVwaWNrZXIuZGF0ZXMudG9TdHJpbmcoKSkge1xyXG4gICAgZGF0ZXBpY2tlci5kYXRlcyA9IG5ld0RhdGVzO1xyXG4gICAgcmVmcmVzaFVJKGRhdGVwaWNrZXIsIHJlbmRlciA/IDMgOiAxKTtcclxuICAgIHRyaWdnZXJEYXRlcGlja2VyRXZlbnQoZGF0ZXBpY2tlciwgJ2NoYW5nZURhdGUnKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmVmcmVzaFVJKGRhdGVwaWNrZXIsIDEpO1xyXG4gIH1cclxuICBpZiAoYXV0b2hpZGUpIHtcclxuICAgIGRhdGVwaWNrZXIuaGlkZSgpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGRhdGUgcGlja2VyXHJcbiAqL1xyXG5jbGFzcyBEYXRlcGlja2VyIHtcclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBkYXRlIHBpY2tlclxyXG4gICAqIEBwYXJhbSAge0VsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIGJpbmQgYSBkYXRlIHBpY2tlclxyXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIC0gY29uZmlnIG9wdGlvbnNcclxuICAgKiBAcGFyYW0gIHtEYXRlUmFuZ2VQaWNrZXJ9IFtyYW5nZXBpY2tlcl0gLSBEYXRlUmFuZ2VQaWNrZXIgaW5zdGFuY2UgdGhlXHJcbiAgICogZGF0ZSBwaWNrZXIgYmVsb25ncyB0by4gVXNlIHRoaXMgb25seSB3aGVuIGNyZWF0aW5nIGRhdGUgcGlja2VyIGFzIGEgcGFydFxyXG4gICAqIG9mIGRhdGUgcmFuZ2UgcGlja2VyXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucyA9IHt9LCByYW5nZXBpY2tlciA9IHVuZGVmaW5lZCkge1xyXG4gICAgZWxlbWVudC5kYXRlcGlja2VyID0gdGhpcztcclxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcblxyXG4gICAgLy8gc2V0IHVwIGNvbmZpZ1xyXG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcgPSBPYmplY3QuYXNzaWduKHtcclxuICAgICAgYnV0dG9uQ2xhc3M6IChvcHRpb25zLmJ1dHRvbkNsYXNzICYmIFN0cmluZyhvcHRpb25zLmJ1dHRvbkNsYXNzKSkgfHwgJ2J1dHRvbicsXHJcbiAgICAgIGNvbnRhaW5lcjogZG9jdW1lbnQuYm9keSxcclxuICAgICAgZGVmYXVsdFZpZXdEYXRlOiB0b2RheSgpLFxyXG4gICAgICBtYXhEYXRlOiB1bmRlZmluZWQsXHJcbiAgICAgIG1pbkRhdGU6IHVuZGVmaW5lZCxcclxuICAgIH0sIHByb2Nlc3NPcHRpb25zKG9wdGlvbnNfZGVmYXVsdE9wdGlvbnMsIHRoaXMpKTtcclxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgT2JqZWN0LmFzc2lnbihjb25maWcsIHByb2Nlc3NPcHRpb25zKG9wdGlvbnMsIHRoaXMpKTtcclxuXHJcbiAgICAvLyBjb25maWd1cmUgYnkgdHlwZVxyXG4gICAgY29uc3QgaW5saW5lID0gdGhpcy5pbmxpbmUgPSBlbGVtZW50LnRhZ05hbWUgIT09ICdJTlBVVCc7XHJcbiAgICBsZXQgaW5wdXRGaWVsZDtcclxuICAgIGxldCBpbml0aWFsRGF0ZXM7XHJcblxyXG4gICAgaWYgKGlubGluZSkge1xyXG4gICAgICBjb25maWcuY29udGFpbmVyID0gZWxlbWVudDtcclxuICAgICAgaW5pdGlhbERhdGVzID0gc3RyaW5nVG9BcnJheShlbGVtZW50LmRhdGFzZXQuZGF0ZSwgY29uZmlnLmRhdGVEZWxpbWl0ZXIpO1xyXG4gICAgICBkZWxldGUgZWxlbWVudC5kYXRhc2V0LmRhdGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lciA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iob3B0aW9ucy5jb250YWluZXIpIDogbnVsbDtcclxuICAgICAgaWYgKGNvbnRhaW5lcikge1xyXG4gICAgICAgIGNvbmZpZy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgIH1cclxuICAgICAgaW5wdXRGaWVsZCA9IHRoaXMuaW5wdXRGaWVsZCA9IGVsZW1lbnQ7XHJcbiAgICAgIGlucHV0RmllbGQuY2xhc3NMaXN0LmFkZCgnZGF0ZXBpY2tlci1pbnB1dCcpO1xyXG4gICAgICBpbml0aWFsRGF0ZXMgPSBzdHJpbmdUb0FycmF5KGlucHV0RmllbGQudmFsdWUsIGNvbmZpZy5kYXRlRGVsaW1pdGVyKTtcclxuICAgIH1cclxuICAgIGlmIChyYW5nZXBpY2tlcikge1xyXG4gICAgICAvLyBjaGVjayB2YWxpZGlyeVxyXG4gICAgICBjb25zdCBpbmRleCA9IHJhbmdlcGlja2VyLmlucHV0cy5pbmRleE9mKGlucHV0RmllbGQpO1xyXG4gICAgICBjb25zdCBkYXRlcGlja2VycyA9IHJhbmdlcGlja2VyLmRhdGVwaWNrZXJzO1xyXG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gMSB8fCAhQXJyYXkuaXNBcnJheShkYXRlcGlja2VycykpIHtcclxuICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCByYW5nZXBpY2tlciBvYmplY3QuJyk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gYXR0YWNoIGl0YWVsZiB0byB0aGUgcmFuZ2VwaWNrZXIgaGVyZSBzbyB0aGF0IHByb2Nlc3NJbnB1dERhdGVzKCkgY2FuXHJcbiAgICAgIC8vIGRldGVybWluZSBpZiB0aGlzIGlzIHRoZSByYW5nZS1lbmQgcGlja2VyIG9mIHRoZSByYW5nZXBpY2tlciB3aGlsZVxyXG4gICAgICAvLyBzZXR0aW5nIGluaXRhbCB2YWx1ZXMgd2hlbiBwaWNrTGV2ZWwgPiAwXHJcbiAgICAgIGRhdGVwaWNrZXJzW2luZGV4XSA9IHRoaXM7XHJcbiAgICAgIC8vIGFkZCBnZXR0ZXIgZm9yIHJhbmdlcGlja2VyXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmFuZ2VwaWNrZXInLCB7XHJcbiAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgcmV0dXJuIHJhbmdlcGlja2VyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNldCBpbml0aWFsIGRhdGVzXHJcbiAgICB0aGlzLmRhdGVzID0gW107XHJcbiAgICAvLyBwcm9jZXNzIGluaXRpYWwgdmFsdWVcclxuICAgIGNvbnN0IGlucHV0RGF0ZVZhbHVlcyA9IHByb2Nlc3NJbnB1dERhdGVzKHRoaXMsIGluaXRpYWxEYXRlcyk7XHJcbiAgICBpZiAoaW5wdXREYXRlVmFsdWVzICYmIGlucHV0RGF0ZVZhbHVlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMuZGF0ZXMgPSBpbnB1dERhdGVWYWx1ZXM7XHJcbiAgICB9XHJcbiAgICBpZiAoaW5wdXRGaWVsZCkge1xyXG4gICAgICBpbnB1dEZpZWxkLnZhbHVlID0gc3RyaW5naWZ5RGF0ZXModGhpcy5kYXRlcywgY29uZmlnKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwaWNrZXIgPSB0aGlzLnBpY2tlciA9IG5ldyBQaWNrZXIodGhpcyk7XHJcblxyXG4gICAgaWYgKGlubGluZSkge1xyXG4gICAgICB0aGlzLnNob3coKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHNldCB1cCBldmVudCBsaXN0ZW5lcnMgaW4gb3RoZXIgbW9kZXNcclxuICAgICAgY29uc3Qgb25Nb3VzZWRvd25Eb2N1bWVudCA9IG9uQ2xpY2tPdXRzaWRlLmJpbmQobnVsbCwgdGhpcyk7XHJcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IFtcclxuICAgICAgICBbaW5wdXRGaWVsZCwgJ2tleWRvd24nLCBvbktleWRvd24uYmluZChudWxsLCB0aGlzKV0sXHJcbiAgICAgICAgW2lucHV0RmllbGQsICdmb2N1cycsIG9uRm9jdXMuYmluZChudWxsLCB0aGlzKV0sXHJcbiAgICAgICAgW2lucHV0RmllbGQsICdtb3VzZWRvd24nLCBvbk1vdXNlZG93bi5iaW5kKG51bGwsIHRoaXMpXSxcclxuICAgICAgICBbaW5wdXRGaWVsZCwgJ2NsaWNrJywgb25DbGlja0lucHV0LmJpbmQobnVsbCwgdGhpcyldLFxyXG4gICAgICAgIFtpbnB1dEZpZWxkLCAncGFzdGUnLCBvblBhc3RlLmJpbmQobnVsbCwgdGhpcyldLFxyXG4gICAgICAgIFtkb2N1bWVudCwgJ21vdXNlZG93bicsIG9uTW91c2Vkb3duRG9jdW1lbnRdLFxyXG4gICAgICAgIFtkb2N1bWVudCwgJ3RvdWNoc3RhcnQnLCBvbk1vdXNlZG93bkRvY3VtZW50XSxcclxuICAgICAgICBbd2luZG93LCAncmVzaXplJywgcGlja2VyLnBsYWNlLmJpbmQocGlja2VyKV1cclxuICAgICAgXTtcclxuICAgICAgcmVnaXN0ZXJMaXN0ZW5lcnModGhpcywgbGlzdGVuZXJzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZvcm1hdCBEYXRlIG9iamVjdCBvciB0aW1lIHZhbHVlIGluIGdpdmVuIGZvcm1hdCBhbmQgbGFuZ3VhZ2VcclxuICAgKiBAcGFyYW0gIHtEYXRlfE51bWJlcn0gZGF0ZSAtIGRhdGUgb3IgdGltZSB2YWx1ZSB0byBmb3JtYXRcclxuICAgKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fSBmb3JtYXQgLSBmb3JtYXQgc3RyaW5nIG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zXHJcbiAgICogdG9EaXNwbGF5KCkgY3VzdG9tIGZvcm1hdHRlciwgd2hvc2Ugc2lnbmF0dXJlIGlzXHJcbiAgICogLSBhcmdzOlxyXG4gICAqICAgLSBkYXRlOiB7RGF0ZX0gLSBEYXRlIGluc3RhbmNlIG9mIHRoZSBkYXRlIHBhc3NlZCB0byB0aGUgbWV0aG9kXHJcbiAgICogICAtIGZvcm1hdDoge09iamVjdH0gLSB0aGUgZm9ybWF0IG9iamVjdCBwYXNzZWQgdG8gdGhlIG1ldGhvZFxyXG4gICAqICAgLSBsb2NhbGU6IHtPYmplY3R9IC0gbG9jYWxlIGZvciB0aGUgbGFuZ3VhZ2Ugc3BlY2lmaWVkIGJ5IGBsYW5nYFxyXG4gICAqIC0gcmV0dXJuOlxyXG4gICAqICAgICB7U3RyaW5nfSBmb3JtYXR0ZWQgZGF0ZVxyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gW2xhbmc9ZW5dIC0gbGFuZ3VhZ2UgY29kZSBmb3IgdGhlIGxvY2FsZSB0byB1c2VcclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGZvcm1hdHRlZCBkYXRlXHJcbiAgICovXHJcbiAgc3RhdGljIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCBsYW5nKSB7XHJcbiAgICByZXR1cm4gZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQsIGxhbmcgJiYgbG9jYWxlc1tsYW5nXSB8fCBsb2NhbGVzLmVuKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhcnNlIGRhdGUgc3RyaW5nXHJcbiAgICogQHBhcmFtICB7U3RyaW5nfERhdGV8TnVtYmVyfSBkYXRlU3RyIC0gZGF0ZSBzdHJpbmcsIERhdGUgb2JqZWN0IG9yIHRpbWVcclxuICAgKiB2YWx1ZSB0byBwYXJzZVxyXG4gICAqIEBwYXJhbSAge1N0cmluZ3xPYmplY3R9IGZvcm1hdCAtIGZvcm1hdCBzdHJpbmcgb3Igb2JqZWN0IHRoYXQgY29udGFpbnNcclxuICAgKiB0b1ZhbHVlKCkgY3VzdG9tIHBhcnNlciwgd2hvc2Ugc2lnbmF0dXJlIGlzXHJcbiAgICogLSBhcmdzOlxyXG4gICAqICAgLSBkYXRlU3RyOiB7U3RyaW5nfERhdGV8TnVtYmVyfSAtIHRoZSBkYXRlU3RyIHBhc3NlZCB0byB0aGUgbWV0aG9kXHJcbiAgICogICAtIGZvcm1hdDoge09iamVjdH0gLSB0aGUgZm9ybWF0IG9iamVjdCBwYXNzZWQgdG8gdGhlIG1ldGhvZFxyXG4gICAqICAgLSBsb2NhbGU6IHtPYmplY3R9IC0gbG9jYWxlIGZvciB0aGUgbGFuZ3VhZ2Ugc3BlY2lmaWVkIGJ5IGBsYW5nYFxyXG4gICAqIC0gcmV0dXJuOlxyXG4gICAqICAgICB7RGF0ZXxOdW1iZXJ9IHBhcnNlZCBkYXRlIG9yIGl0cyB0aW1lIHZhbHVlXHJcbiAgICogQHBhcmFtICB7U3RyaW5nfSBbbGFuZz1lbl0gLSBsYW5ndWFnZSBjb2RlIGZvciB0aGUgbG9jYWxlIHRvIHVzZVxyXG4gICAqIEByZXR1cm4ge051bWJlcn0gdGltZSB2YWx1ZSBvZiBwYXJzZWQgZGF0ZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBwYXJzZURhdGUoZGF0ZVN0ciwgZm9ybWF0LCBsYW5nKSB7XHJcbiAgICByZXR1cm4gcGFyc2VEYXRlKGRhdGVTdHIsIGZvcm1hdCwgbGFuZyAmJiBsb2NhbGVzW2xhbmddIHx8IGxvY2FsZXMuZW4pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge09iamVjdH0gLSBJbnN0YWxsZWQgbG9jYWxlcyBpbiBgW2xhbmd1YWdlQ29kZV06IGxvY2FsZU9iamVjdGAgZm9ybWF0XHJcbiAgICogZW5gOl9FbmdsaXNoIChVUylfIGlzIHByZS1pbnN0YWxsZWQuXHJcbiAgICovXHJcbiAgc3RhdGljIGdldCBsb2NhbGVzKCkge1xyXG4gICAgcmV0dXJuIGxvY2FsZXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn0gLSBXaGV0aGVyIHRoZSBwaWNrZXIgZWxlbWVudCBpcyBzaG93bi4gYHRydWVgIHdobmUgc2hvd25cclxuICAgKi9cclxuICBnZXQgYWN0aXZlKCkge1xyXG4gICAgcmV0dXJuICEhKHRoaXMucGlja2VyICYmIHRoaXMucGlja2VyLmFjdGl2ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9IC0gRE9NIG9iamVjdCBvZiBwaWNrZXIgZWxlbWVudFxyXG4gICAqL1xyXG4gIGdldCBwaWNrZXJFbGVtZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMucGlja2VyID8gdGhpcy5waWNrZXIuZWxlbWVudCA6IHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBuZXcgdmFsdWVzIHRvIHRoZSBjb25maWcgb3B0aW9uc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlnIG9wdGlvbnMgdG8gdXBkYXRlXHJcbiAgICovXHJcbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICBjb25zdCBwaWNrZXIgPSB0aGlzLnBpY2tlcjtcclxuICAgIGNvbnN0IG5ld09wdGlvbnMgPSBwcm9jZXNzT3B0aW9ucyhvcHRpb25zLCB0aGlzKTtcclxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7XHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuY29uZmlnLCBuZXdPcHRpb25zKTtcclxuICAgIHBpY2tlci5zZXRPcHRpb25zKG5ld09wdGlvbnMpO1xyXG5cclxuICAgIHJlZnJlc2hVSSh0aGlzLCAzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNob3cgdGhlIHBpY2tlciBlbGVtZW50XHJcbiAgICovXHJcbiAgc2hvdygpIHtcclxuICAgIGlmICh0aGlzLmlucHV0RmllbGQpIHtcclxuICAgICAgaWYgKHRoaXMuaW5wdXRGaWVsZC5kaXNhYmxlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5pbnB1dEZpZWxkICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5fc2hvd2luZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmZvY3VzKCk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX3Nob3dpbmc7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMucGlja2VyLnNob3coKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhpZGUgdGhlIHBpY2tlciBlbGVtZW50XHJcbiAgICogTm90IGF2YWlsYWJsZSBvbiBpbmxpbmUgcGlja2VyXHJcbiAgICovXHJcbiAgaGlkZSgpIHtcclxuICAgIGlmICh0aGlzLmlubGluZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLnBpY2tlci5oaWRlKCk7XHJcbiAgICB0aGlzLnBpY2tlci51cGRhdGUoKS5jaGFuZ2VWaWV3KHRoaXMuY29uZmlnLnN0YXJ0VmlldykucmVuZGVyKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95IHRoZSBEYXRlcGlja2VyIGluc3RhbmNlXHJcbiAgICogQHJldHVybiB7RGV0ZXBpY2tlcn0gLSB0aGUgaW5zdGFuY2UgZGVzdHJveWVkXHJcbiAgICovXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgdW5yZWdpc3Rlckxpc3RlbmVycyh0aGlzKTtcclxuICAgIHRoaXMucGlja2VyLmRldGFjaCgpO1xyXG4gICAgaWYgKCF0aGlzLmlubGluZSkge1xyXG4gICAgICB0aGlzLmlucHV0RmllbGQuY2xhc3NMaXN0LnJlbW92ZSgnZGF0ZXBpY2tlci1pbnB1dCcpO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlIHRoaXMuZWxlbWVudC5kYXRlcGlja2VyO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIHNlbGVjdGVkIGRhdGUocylcclxuICAgKlxyXG4gICAqIFRoZSBtZXRob2QgcmV0dXJucyBhIERhdGUgb2JqZWN0IG9mIHNlbGVjdGVkIGRhdGUgYnkgZGVmYXVsdCwgYW5kIHJldHVybnNcclxuICAgKiBhbiBhcnJheSBvZiBzZWxlY3RlZCBkYXRlcyBpbiBtdWx0aWRhdGUgbW9kZS4gSWYgZm9ybWF0IHN0cmluZyBpcyBwYXNzZWQsXHJcbiAgICogaXQgcmV0dXJucyBkYXRlIHN0cmluZyhzKSBmb3JtYXR0ZWQgaW4gZ2l2ZW4gZm9ybWF0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7U3RyaW5nfSBbZm9ybWF0XSAtIEZvcm1hdCBzdHJpbmcgdG8gc3RyaW5naWZ5IHRoZSBkYXRlKHMpXHJcbiAgICogQHJldHVybiB7RGF0ZXxTdHJpbmd8RGF0ZVtdfFN0cmluZ1tdfSAtIHNlbGVjdGVkIGRhdGUocyksIG9yIGlmIG5vbmUgaXNcclxuICAgKiBzZWxlY3RlZCwgZW1wdHkgYXJyYXkgaW4gbXVsdGlkYXRlIG1vZGUgYW5kIHVudGl0bGVkIGluIHNpZ2xlZGF0ZSBtb2RlXHJcbiAgICovXHJcbiAgZ2V0RGF0ZShmb3JtYXQgPSB1bmRlZmluZWQpIHtcclxuICAgIGNvbnN0IGNhbGxiYWNrID0gZm9ybWF0XHJcbiAgICAgID8gZGF0ZSA9PiBmb3JtYXREYXRlKGRhdGUsIGZvcm1hdCwgdGhpcy5jb25maWcubG9jYWxlKVxyXG4gICAgICA6IGRhdGUgPT4gbmV3IERhdGUoZGF0ZSk7XHJcblxyXG4gICAgaWYgKHRoaXMuY29uZmlnLm11bHRpZGF0ZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5kYXRlcy5tYXAoY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuZGF0ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5kYXRlc1swXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgc2VsZWN0ZWQgZGF0ZShzKVxyXG4gICAqXHJcbiAgICogSW4gbXVsdGlkYXRlIG1vZGUsIHlvdSBjYW4gcGFzcyBtdWx0aXBsZSBkYXRlcyBhcyBhIHNlcmllcyBvZiBhcmd1bWVudHNcclxuICAgKiBvciBhbiBhcnJheS4gKFNpbmNlIGVhY2ggZGF0ZSBpcyBwYXJzZWQgaW5kaXZpZHVhbGx5LCB0aGUgdHlwZSBvZiB0aGVcclxuICAgKiBkYXRlcyBkb2Vzbid0IGhhdmUgdG8gYmUgdGhlIHNhbWUuKVxyXG4gICAqIFRoZSBnaXZlbiBkYXRlcyBhcmUgdXNlZCB0byB0b2dnbGUgdGhlIHNlbGVjdCBzdGF0dXMgb2YgZWFjaCBkYXRlLiBUaGVcclxuICAgKiBudW1iZXIgb2Ygc2VsZWN0ZWQgZGF0ZXMgaXMga2VwdCBmcm9tIGV4Y2VlZGluZyB0aGUgbGVuZ3RoIHNldCB0b1xyXG4gICAqIG1heE51bWJlck9mRGF0ZXMuXHJcbiAgICpcclxuICAgKiBXaXRoIGNsZWFyOiB0cnVlIG9wdGlvbiwgdGhlIG1ldGhvZCBjYW4gYmUgdXNlZCB0byBjbGVhciB0aGUgc2VsZWN0aW9uXHJcbiAgICogYW5kIHRvIHJlcGxhY2UgdGhlIHNlbGVjdGlvbiBpbnN0ZWFkIG9mIHRvZ2dsaW5nIGluIG11bHRpZGF0ZSBtb2RlLlxyXG4gICAqIElmIHRoZSBvcHRpb24gaXMgcGFzc2VkIHdpdGggbm8gZGF0ZSBhcmd1bWVudHMgb3IgYW4gZW1wdHkgZGF0ZXMgYXJyYXksXHJcbiAgICogaXQgd29ya3MgYXMgXCJjbGVhclwiIChjbGVhciB0aGUgc2VsZWN0aW9uIHRoZW4gc2V0IG5vdGhpbmcpLCBhbmQgaWYgdGhlXHJcbiAgICogb3B0aW9uIGlzIHBhc3NlZCB3aXRoIG5ldyBkYXRlcyB0byBzZWxlY3QsIGl0IHdvcmtzIGFzIFwicmVwbGFjZVwiIChjbGVhclxyXG4gICAqIHRoZSBzZWxlY3Rpb24gdGhlbiBzZXQgdGhlIGdpdmVuIGRhdGVzKVxyXG4gICAqXHJcbiAgICogV2hlbiByZW5kZXI6IGZhbHNlIG9wdGlvbiBpcyB1c2VkLCB0aGUgbWV0aG9kIG9taXRzIHJlLXJlbmRlcmluZyB0aGVcclxuICAgKiBwaWNrZXIgZWxlbWVudC4gSW4gdGhpcyBjYXNlLCB5b3UgbmVlZCB0byBjYWxsIHJlZnJlc2goKSBtZXRob2QgbGF0ZXIgaW5cclxuICAgKiBvcmRlciBmb3IgdGhlIHBpY2tlciBlbGVtZW50IHRvIHJlZmxlY3QgdGhlIGNoYW5nZXMuIFRoZSBpbnB1dCBmaWVsZCBpc1xyXG4gICAqIHJlZnJlc2hlZCBhbHdheXMgcmVnYXJkbGVzcyBvZiB0aGlzIG9wdGlvbi5cclxuICAgKlxyXG4gICAqIFdoZW4gaW52YWxpZCAodW5wYXJzYWJsZSwgcmVwZWF0ZWQsIGRpc2FibGVkIG9yIG91dC1vZi1yYW5nZSkgZGF0ZXMgYXJlXHJcbiAgICogcGFzc2VkLCB0aGUgbWV0aG9kIGlnbm9yZXMgdGhlbSBhbmQgYXBwbGllcyBvbmx5IHZhbGlkIG9uZXMuIEluIHRoZSBjYXNlXHJcbiAgICogdGhhdCBhbGwgdGhlIGdpdmVuIGRhdGVzIGFyZSBpbnZhbGlkLCB3aGljaCBpcyBkaXN0aW5ndWlzaGVkIGZyb20gcGFzc2luZ1xyXG4gICAqIG5vIGRhdGVzLCB0aGUgbWV0aG9kIGNvbnNpZGVycyBpdCBhcyBhbiBlcnJvciBhbmQgbGVhdmVzIHRoZSBzZWxlY3Rpb25cclxuICAgKiB1bnRvdWNoZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gey4uLihEYXRlfE51bWJlcnxTdHJpbmcpfEFycmF5fSBbZGF0ZXNdIC0gRGF0ZSBzdHJpbmdzLCBEYXRlXHJcbiAgICogb2JqZWN0cywgdGltZSB2YWx1ZXMgb3IgbWl4IG9mIHRob3NlIGZvciBuZXcgc2VsZWN0aW9uXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIGZ1bmN0aW9uIG9wdGlvbnNcclxuICAgKiAtIGNsZWFyOiB7Ym9vbGVhbn0gLSBXaGV0aGVyIHRvIGNsZWFyIHRoZSBleGlzdGluZyBzZWxlY3Rpb25cclxuICAgKiAgICAgZGVmdWFsdDogZmFsc2VcclxuICAgKiAtIHJlbmRlcjoge2Jvb2xlYW59IC0gV2hldGhlciB0byByZS1yZW5kZXIgdGhlIHBpY2tlciBlbGVtZW50XHJcbiAgICogICAgIGRlZmF1bHQ6IHRydWVcclxuICAgKiAtIGF1dG9oaWRlOiB7Ym9vbGVhbn0gLSBXaGV0aGVyIHRvIGhpZGUgdGhlIHBpY2tlciBlbGVtZW50IGFmdGVyIHJlLXJlbmRlclxyXG4gICAqICAgICBJZ25vcmVkIHdoZW4gdXNlZCB3aXRoIHJlbmRlcjogZmFsc2VcclxuICAgKiAgICAgZGVmYXVsdDogY29uZmlnLmF1dG9oaWRlXHJcbiAgICovXHJcbiAgc2V0RGF0ZSguLi5hcmdzKSB7XHJcbiAgICBjb25zdCBkYXRlcyA9IFsuLi5hcmdzXTtcclxuICAgIGNvbnN0IG9wdHMgPSB7fTtcclxuICAgIGNvbnN0IGxhc3RBcmcgPSBsYXN0SXRlbU9mKGFyZ3MpO1xyXG4gICAgaWYgKFxyXG4gICAgICB0eXBlb2YgbGFzdEFyZyA9PT0gJ29iamVjdCdcclxuICAgICAgJiYgIUFycmF5LmlzQXJyYXkobGFzdEFyZylcclxuICAgICAgJiYgIShsYXN0QXJnIGluc3RhbmNlb2YgRGF0ZSlcclxuICAgICAgJiYgbGFzdEFyZ1xyXG4gICAgKSB7XHJcbiAgICAgIE9iamVjdC5hc3NpZ24ob3B0cywgZGF0ZXMucG9wKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGlucHV0RGF0ZXMgPSBBcnJheS5pc0FycmF5KGRhdGVzWzBdKSA/IGRhdGVzWzBdIDogZGF0ZXM7XHJcbiAgICBzZXREYXRlKHRoaXMsIGlucHV0RGF0ZXMsIG9wdHMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBzZWxlY3RlZCBkYXRlKHMpIHdpdGggaW5wdXQgZmllbGQncyB2YWx1ZVxyXG4gICAqIE5vdCBhdmFpbGFibGUgb24gaW5saW5lIHBpY2tlclxyXG4gICAqXHJcbiAgICogVGhlIGlucHV0IGZpZWxkIHdpbGwgYmUgcmVmcmVzaGVkIHdpdGggcHJvcGVybHkgZm9ybWF0dGVkIGRhdGUgc3RyaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gLSBmdW5jdGlvbiBvcHRpb25zXHJcbiAgICogLSBhdXRvaGlkZToge2Jvb2xlYW59IC0gd2hldGhlciB0byBoaWRlIHRoZSBwaWNrZXIgZWxlbWVudCBhZnRlciByZWZyZXNoXHJcbiAgICogICAgIGRlZmF1bHQ6IGZhbHNlXHJcbiAgICovXHJcbiAgdXBkYXRlKG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcclxuICAgIGlmICh0aGlzLmlubGluZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb3B0cyA9IHtjbGVhcjogdHJ1ZSwgYXV0b2hpZGU6ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5hdXRvaGlkZSl9O1xyXG4gICAgY29uc3QgaW5wdXREYXRlcyA9IHN0cmluZ1RvQXJyYXkodGhpcy5pbnB1dEZpZWxkLnZhbHVlLCB0aGlzLmNvbmZpZy5kYXRlRGVsaW1pdGVyKTtcclxuICAgIHNldERhdGUodGhpcywgaW5wdXREYXRlcywgb3B0cyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWZyZXNoIHRoZSBwaWNrZXIgZWxlbWVudCBhbmQgdGhlIGFzc29jaWF0ZWQgaW5wdXQgZmllbGRcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3RhcmdldF0gLSB0YXJnZXQgaXRlbSB3aGVuIHJlZnJlc2hpbmcgb25lIGl0ZW0gb25seVxyXG4gICAqICdwaWNrZXInIG9yICdpbnB1dCdcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZVJlbmRlcl0gLSB3aGV0aGVyIHRvIHJlLXJlbmRlciB0aGUgcGlja2VyIGVsZW1lbnRcclxuICAgKiByZWdhcmRsZXNzIG9mIGl0cyBzdGF0ZSBpbnN0ZWFkIG9mIG9wdGltaXplZCByZWZyZXNoXHJcbiAgICovXHJcbiAgcmVmcmVzaCh0YXJnZXQgPSB1bmRlZmluZWQsIGZvcmNlUmVuZGVyID0gZmFsc2UpIHtcclxuICAgIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgZm9yY2VSZW5kZXIgPSB0YXJnZXQ7XHJcbiAgICAgIHRhcmdldCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgbW9kZTtcclxuICAgIGlmICh0YXJnZXQgPT09ICdwaWNrZXInKSB7XHJcbiAgICAgIG1vZGUgPSAyO1xyXG4gICAgfSBlbHNlIGlmICh0YXJnZXQgPT09ICdpbnB1dCcpIHtcclxuICAgICAgbW9kZSA9IDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBtb2RlID0gMztcclxuICAgIH1cclxuICAgIHJlZnJlc2hVSSh0aGlzLCBtb2RlLCAhZm9yY2VSZW5kZXIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW50ZXIgZWRpdCBtb2RlXHJcbiAgICogTm90IGF2YWlsYWJsZSBvbiBpbmxpbmUgcGlja2VyIG9yIHdoZW4gdGhlIHBpY2tlciBlbGVtZW50IGlzIGhpZGRlblxyXG4gICAqL1xyXG4gIGVudGVyRWRpdE1vZGUoKSB7XHJcbiAgICBpZiAodGhpcy5pbmxpbmUgfHwgIXRoaXMucGlja2VyLmFjdGl2ZSB8fCB0aGlzLmVkaXRNb2RlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuZWRpdE1vZGUgPSB0cnVlO1xyXG4gICAgdGhpcy5pbnB1dEZpZWxkLmNsYXNzTGlzdC5hZGQoJ2luLWVkaXQnLCAnYm9yZGVyLWJsdWUtNzAwJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeGl0IGZyb20gZWRpdCBtb2RlXHJcbiAgICogTm90IGF2YWlsYWJsZSBvbiBpbmxpbmUgcGlja2VyXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gLSBmdW5jdGlvbiBvcHRpb25zXHJcbiAgICogLSB1cGRhdGU6IHtib29sZWFufSAtIHdoZXRoZXIgdG8gY2FsbCB1cGRhdGUoKSBhZnRlciBleGl0aW5nXHJcbiAgICogICAgIElmIGZhbHNlLCBpbnB1dCBmaWVsZCBpcyByZXZlcnQgdG8gdGhlIGV4aXN0aW5nIHNlbGVjdGlvblxyXG4gICAqICAgICBkZWZhdWx0OiBmYWxzZVxyXG4gICAqL1xyXG4gIGV4aXRFZGl0TW9kZShvcHRpb25zID0gdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAodGhpcy5pbmxpbmUgfHwgIXRoaXMuZWRpdE1vZGUpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe3VwZGF0ZTogZmFsc2V9LCBvcHRpb25zKTtcclxuICAgIGRlbGV0ZSB0aGlzLmVkaXRNb2RlO1xyXG4gICAgdGhpcy5pbnB1dEZpZWxkLmNsYXNzTGlzdC5yZW1vdmUoJ2luLWVkaXQnLCAnYm9yZGVyLWJsdWUtNzAwJyk7XHJcbiAgICBpZiAob3B0cy51cGRhdGUpIHtcclxuICAgICAgdGhpcy51cGRhdGUob3B0cyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQHRoZW1lc2JlcmcvdGFpbHdpbmQtZGF0ZXBpY2tlci9qcy9EYXRlUmFuZ2VQaWNrZXIuanNcclxuXHJcblxyXG5cclxuXHJcbi8vIGZpbHRlciBvdXQgdGhlIGNvbmZpZyBvcHRpb25zIGluYXBwcm9wcml0ZSB0byBwYXNzIHRvIERhdGVwaWNrZXJcclxuZnVuY3Rpb24gZmlsdGVyT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgY29uc3QgbmV3T3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xyXG5cclxuICBkZWxldGUgbmV3T3B0cy5pbnB1dHM7XHJcbiAgZGVsZXRlIG5ld09wdHMuYWxsb3dPbmVTaWRlZFJhbmdlO1xyXG4gIGRlbGV0ZSBuZXdPcHRzLm1heE51bWJlck9mRGF0ZXM7IC8vIHRvIGVuc3VyZSBlYWNoIGRhdGVwaWNrZXIgaGFuZGxlcyBhIHNpbmdsZSBkYXRlXHJcblxyXG4gIHJldHVybiBuZXdPcHRzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXR1cERhdGVwaWNrZXIocmFuZ2VwaWNrZXIsIGNoYW5nZURhdGVMaXN0ZW5lciwgZWwsIG9wdGlvbnMpIHtcclxuICByZWdpc3Rlckxpc3RlbmVycyhyYW5nZXBpY2tlciwgW1xyXG4gICAgW2VsLCAnY2hhbmdlRGF0ZScsIGNoYW5nZURhdGVMaXN0ZW5lcl0sXHJcbiAgXSk7XHJcbiAgbmV3IERhdGVwaWNrZXIoZWwsIG9wdGlvbnMsIHJhbmdlcGlja2VyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gb25DaGFuZ2VEYXRlKHJhbmdlcGlja2VyLCBldikge1xyXG4gIC8vIHRvIHByZXZlbnQgYm90aCBkYXRlcGlja2VycyB0cmlnZ2VyIHRoZSBvdGhlciBzaWRlJ3MgdXBkYXRlIGVhY2ggb3RoZXJcclxuICBpZiAocmFuZ2VwaWNrZXIuX3VwZGF0aW5nKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHJhbmdlcGlja2VyLl91cGRhdGluZyA9IHRydWU7XHJcblxyXG4gIGNvbnN0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICBpZiAodGFyZ2V0LmRhdGVwaWNrZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZGF0ZXBpY2tlcnMgPSByYW5nZXBpY2tlci5kYXRlcGlja2VycztcclxuICBjb25zdCBzZXREYXRlT3B0aW9ucyA9IHtyZW5kZXI6IGZhbHNlfTtcclxuICBjb25zdCBjaGFuZ2VkU2lkZSA9IHJhbmdlcGlja2VyLmlucHV0cy5pbmRleE9mKHRhcmdldCk7XHJcbiAgY29uc3Qgb3RoZXJTaWRlID0gY2hhbmdlZFNpZGUgPT09IDAgPyAxIDogMDtcclxuICBjb25zdCBjaGFuZ2VkRGF0ZSA9IGRhdGVwaWNrZXJzW2NoYW5nZWRTaWRlXS5kYXRlc1swXTtcclxuICBjb25zdCBvdGhlckRhdGUgPSBkYXRlcGlja2Vyc1tvdGhlclNpZGVdLmRhdGVzWzBdO1xyXG5cclxuICBpZiAoY2hhbmdlZERhdGUgIT09IHVuZGVmaW5lZCAmJiBvdGhlckRhdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgLy8gaWYgdGhlIHN0YXJ0IG9mIHRoZSByYW5nZSA+IHRoZSBlbmQsIHN3YXAgdGhlbVxyXG4gICAgaWYgKGNoYW5nZWRTaWRlID09PSAwICYmIGNoYW5nZWREYXRlID4gb3RoZXJEYXRlKSB7XHJcbiAgICAgIGRhdGVwaWNrZXJzWzBdLnNldERhdGUob3RoZXJEYXRlLCBzZXREYXRlT3B0aW9ucyk7XHJcbiAgICAgIGRhdGVwaWNrZXJzWzFdLnNldERhdGUoY2hhbmdlZERhdGUsIHNldERhdGVPcHRpb25zKTtcclxuICAgIH0gZWxzZSBpZiAoY2hhbmdlZFNpZGUgPT09IDEgJiYgY2hhbmdlZERhdGUgPCBvdGhlckRhdGUpIHtcclxuICAgICAgZGF0ZXBpY2tlcnNbMF0uc2V0RGF0ZShjaGFuZ2VkRGF0ZSwgc2V0RGF0ZU9wdGlvbnMpO1xyXG4gICAgICBkYXRlcGlja2Vyc1sxXS5zZXREYXRlKG90aGVyRGF0ZSwgc2V0RGF0ZU9wdGlvbnMpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoIXJhbmdlcGlja2VyLmFsbG93T25lU2lkZWRSYW5nZSkge1xyXG4gICAgLy8gdG8gcHJldmVudCB0aGUgcmFuZ2UgZnJvbSBiZWNvbWluZyBvbmUtc2lkZWQsIGNvcHkgY2hhbmdlZCBzaWRlJ3NcclxuICAgIC8vIHNlbGVjdGlvbiAobm8gbWF0dGVyIGlmIGl0J3MgZW1wdHkpIHRvIHRoZSBvdGhlciBzaWRlXHJcbiAgICBpZiAoY2hhbmdlZERhdGUgIT09IHVuZGVmaW5lZCB8fCBvdGhlckRhdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBzZXREYXRlT3B0aW9ucy5jbGVhciA9IHRydWU7XHJcbiAgICAgIGRhdGVwaWNrZXJzW290aGVyU2lkZV0uc2V0RGF0ZShkYXRlcGlja2Vyc1tjaGFuZ2VkU2lkZV0uZGF0ZXMsIHNldERhdGVPcHRpb25zKTtcclxuICAgIH1cclxuICB9XHJcbiAgZGF0ZXBpY2tlcnNbMF0ucGlja2VyLnVwZGF0ZSgpLnJlbmRlcigpO1xyXG4gIGRhdGVwaWNrZXJzWzFdLnBpY2tlci51cGRhdGUoKS5yZW5kZXIoKTtcclxuICBkZWxldGUgcmFuZ2VwaWNrZXIuX3VwZGF0aW5nO1xyXG59XHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgZGF0ZSByYW5nZSBwaWNrZXJcclxuICovXHJcbmNsYXNzIERhdGVSYW5nZVBpY2tlciAge1xyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIGRhdGUgcmFuZ2UgcGlja2VyXHJcbiAgICogQHBhcmFtICB7RWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gYmluZCBhIGRhdGUgcmFuZ2UgcGlja2VyXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc10gLSBjb25maWcgb3B0aW9uc1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgaW5wdXRzID0gQXJyYXkuaXNBcnJheShvcHRpb25zLmlucHV0cylcclxuICAgICAgPyBvcHRpb25zLmlucHV0c1xyXG4gICAgICA6IEFycmF5LmZyb20oZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCcpKTtcclxuICAgIGlmIChpbnB1dHMubGVuZ3RoIDwgMikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZWxlbWVudC5yYW5nZXBpY2tlciA9IHRoaXM7XHJcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgdGhpcy5pbnB1dHMgPSBpbnB1dHMuc2xpY2UoMCwgMik7XHJcbiAgICB0aGlzLmFsbG93T25lU2lkZWRSYW5nZSA9ICEhb3B0aW9ucy5hbGxvd09uZVNpZGVkUmFuZ2U7XHJcblxyXG4gICAgY29uc3QgY2hhbmdlRGF0ZUxpc3RlbmVyID0gb25DaGFuZ2VEYXRlLmJpbmQobnVsbCwgdGhpcyk7XHJcbiAgICBjb25zdCBjbGVhbk9wdGlvbnMgPSBmaWx0ZXJPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgLy8gaW4gb3JkZXIgZm9yIGluaXRpYWwgZGF0ZSBzZXR1cCB0byB3b3JrIHJpZ2h0IHdoZW4gcGNpY0x2ZWwgPiAwLFxyXG4gICAgLy8gbGV0IERhdGVwaWNrZXIgY29uc3RydWN0b3IgYWRkIHRoZSBpbnN0YW5jZSB0byB0aGUgcmFuZ2VwaWNrZXJcclxuICAgIGNvbnN0IGRhdGVwaWNrZXJzID0gW107XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2RhdGVwaWNrZXJzJywge1xyXG4gICAgICBnZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGVwaWNrZXJzO1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgICBzZXR1cERhdGVwaWNrZXIodGhpcywgY2hhbmdlRGF0ZUxpc3RlbmVyLCB0aGlzLmlucHV0c1swXSwgY2xlYW5PcHRpb25zKTtcclxuICAgIHNldHVwRGF0ZXBpY2tlcih0aGlzLCBjaGFuZ2VEYXRlTGlzdGVuZXIsIHRoaXMuaW5wdXRzWzFdLCBjbGVhbk9wdGlvbnMpO1xyXG4gICAgT2JqZWN0LmZyZWV6ZShkYXRlcGlja2Vycyk7XHJcbiAgICAvLyBub3JtYWxpemUgdGhlIHJhbmdlIGlmIGluaXRhbCBkYXRlcyBhcmUgZ2l2ZW5cclxuICAgIGlmIChkYXRlcGlja2Vyc1swXS5kYXRlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIG9uQ2hhbmdlRGF0ZSh0aGlzLCB7dGFyZ2V0OiB0aGlzLmlucHV0c1swXX0pO1xyXG4gICAgfSBlbHNlIGlmIChkYXRlcGlja2Vyc1sxXS5kYXRlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIG9uQ2hhbmdlRGF0ZSh0aGlzLCB7dGFyZ2V0OiB0aGlzLmlucHV0c1sxXX0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHR5cGUge0FycmF5fSAtIHNlbGVjdGVkIGRhdGUgb2YgdGhlIGxpbmtlZCBkYXRlIHBpY2tlcnNcclxuICAgKi9cclxuICBnZXQgZGF0ZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRlcGlja2Vycy5sZW5ndGggPT09IDJcclxuICAgICAgPyBbXHJcbiAgICAgICAgICB0aGlzLmRhdGVwaWNrZXJzWzBdLmRhdGVzWzBdLFxyXG4gICAgICAgICAgdGhpcy5kYXRlcGlja2Vyc1sxXS5kYXRlc1swXSxcclxuICAgICAgICBdXHJcbiAgICAgIDogdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IG5ldyB2YWx1ZXMgdG8gdGhlIGNvbmZpZyBvcHRpb25zXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWcgb3B0aW9ucyB0byB1cGRhdGVcclxuICAgKi9cclxuICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcclxuICAgIHRoaXMuYWxsb3dPbmVTaWRlZFJhbmdlID0gISFvcHRpb25zLmFsbG93T25lU2lkZWRSYW5nZTtcclxuXHJcbiAgICBjb25zdCBjbGVhbk9wdGlvbnMgPSBmaWx0ZXJPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgdGhpcy5kYXRlcGlja2Vyc1swXS5zZXRPcHRpb25zKGNsZWFuT3B0aW9ucyk7XHJcbiAgICB0aGlzLmRhdGVwaWNrZXJzWzFdLnNldE9wdGlvbnMoY2xlYW5PcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgdGhlIERhdGVSYW5nZVBpY2tlciBpbnN0YW5jZVxyXG4gICAqIEByZXR1cm4ge0RhdGVSYW5nZVBpY2tlcn0gLSB0aGUgaW5zdGFuY2UgZGVzdHJveWVkXHJcbiAgICovXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuZGF0ZXBpY2tlcnNbMF0uZGVzdHJveSgpO1xyXG4gICAgdGhpcy5kYXRlcGlja2Vyc1sxXS5kZXN0cm95KCk7XHJcbiAgICB1bnJlZ2lzdGVyTGlzdGVuZXJzKHRoaXMpO1xyXG4gICAgZGVsZXRlIHRoaXMuZWxlbWVudC5yYW5nZXBpY2tlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgYW5kIGVuZCBkYXRlcyBvZiB0aGUgZGF0ZSByYW5nZVxyXG4gICAqXHJcbiAgICogVGhlIG1ldGhvZCByZXR1cm5zIERhdGUgb2JqZWN0cyBieSBkZWZhdWx0LiBJZiBmb3JtYXQgc3RyaW5nIGlzIHBhc3NlZCxcclxuICAgKiBpdCByZXR1cm5zIGRhdGUgc3RyaW5ncyBmb3JtYXR0ZWQgaW4gZ2l2ZW4gZm9ybWF0LlxyXG4gICAqIFRoZSByZXN1bHQgYXJyYXkgYWx3YXlzIGNvbnRhaW5zIDIgaXRlbXMgKHN0YXJ0IGRhdGUvZW5kIGRhdGUpIGFuZFxyXG4gICAqIHVuZGVmaW5lZCBpcyB1c2VkIGZvciB1bnNlbGVjdGVkIHNpZGUuIChlLmcuIElmIG5vbmUgaXMgc2VsZWN0ZWQsXHJcbiAgICogdGhlIHJlc3VsdCB3aWxsIGJlIFt1bmRlZmluZWQsIHVuZGVmaW5lZF0uIElmIG9ubHkgdGhlIGVuZCBkYXRlIGlzIHNldFxyXG4gICAqIHdoZW4gYWxsb3dPbmVTaWRlZFJhbmdlIGNvbmZpZyBvcHRpb24gaXMgdHJ1ZSwgW3VuZGVmaW5lZCwgZW5kRGF0ZV0gd2lsbFxyXG4gICAqIGJlIHJldHVybmVkLilcclxuICAgKlxyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gW2Zvcm1hdF0gLSBGb3JtYXQgc3RyaW5nIHRvIHN0cmluZ2lmeSB0aGUgZGF0ZXNcclxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBTdGFydCBhbmQgZW5kIGRhdGVzXHJcbiAgICovXHJcbiAgZ2V0RGF0ZXMoZm9ybWF0ID0gdW5kZWZpbmVkKSB7XHJcbiAgICBjb25zdCBjYWxsYmFjayA9IGZvcm1hdFxyXG4gICAgICA/IGRhdGUgPT4gZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQsIHRoaXMuZGF0ZXBpY2tlcnNbMF0uY29uZmlnLmxvY2FsZSlcclxuICAgICAgOiBkYXRlID0+IG5ldyBEYXRlKGRhdGUpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmRhdGVzLm1hcChkYXRlID0+IGRhdGUgPT09IHVuZGVmaW5lZCA/IGRhdGUgOiBjYWxsYmFjayhkYXRlKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgb2YgdGhlIGRhdGUgcmFuZ2VcclxuICAgKlxyXG4gICAqIFRoZSBtZXRob2QgY2FsbHMgZGF0ZXBpY2tlci5zZXREYXRlKCkgaW50ZXJuYWxseSB1c2luZyBlYWNoIG9mIHRoZVxyXG4gICAqIGFyZ3VtZW50cyBpbiBzdGFydOKGkmVuZCBvcmRlci5cclxuICAgKlxyXG4gICAqIFdoZW4gYSBjbGVhcjogdHJ1ZSBvcHRpb24gb2JqZWN0IGlzIHBhc3NlZCBpbnN0ZWFkIG9mIGEgZGF0ZSwgdGhlIG1ldGhvZFxyXG4gICAqIGNsZWFycyB0aGUgZGF0ZS5cclxuICAgKlxyXG4gICAqIElmIGFuIGludmFsaWQgZGF0ZSwgdGhlIHNhbWUgZGF0ZSBhcyB0aGUgY3VycmVudCBvbmUgb3IgYW4gb3B0aW9uIG9iamVjdFxyXG4gICAqIHdpdGhvdXQgY2xlYXI6IHRydWUgaXMgcGFzc2VkLCB0aGUgbWV0aG9kIGNvbnNpZGVycyB0aGF0IGFyZ3VtZW50IGFzIGFuXHJcbiAgICogXCJpbmVmZmVjdGl2ZVwiIGFyZ3VtZW50IGJlY2F1c2UgY2FsbGluZyBkYXRlcGlja2VyLnNldERhdGUoKSB3aXRoIHRob3NlXHJcbiAgICogdmFsdWVzIG1ha2VzIG5vIGNoYW5nZXMgdG8gdGhlIGRhdGUgc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogV2hlbiB0aGUgYWxsb3dPbmVTaWRlZFJhbmdlIGNvbmZpZyBvcHRpb24gaXMgZmFsc2UsIHBhc3Npbmcge2NsZWFyOiB0cnVlfVxyXG4gICAqIHRvIGNsZWFyIHRoZSByYW5nZSB3b3JrcyBvbmx5IHdoZW4gaXQgaXMgZG9uZSB0byB0aGUgbGFzdCBlZmZlY3RpdmVcclxuICAgKiBhcmd1bWVudCAoaW4gb3RoZXIgd29yZHMsIHBhc3NlZCB0byByYW5nZUVuZCBvciB0byByYW5nZVN0YXJ0IGFsb25nIHdpdGhcclxuICAgKiBpbmVmZmVjdGl2ZSByYW5nZUVuZCkuIFRoaXMgaXMgYmVjYXVzZSB3aGVuIHRoZSBkYXRlIHJhbmdlIGlzIGNoYW5nZWQsXHJcbiAgICogaXQgZ2V0cyBub3JtYWxpemVkIGJhc2VkIG9uIHRoZSBsYXN0IGNoYW5nZSBhdCB0aGUgZW5kIG9mIHRoZSBjaGFuZ2luZ1xyXG4gICAqIHByb2Nlc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0RhdGV8TnVtYmVyfFN0cmluZ3xPYmplY3R9IHJhbmdlU3RhcnQgLSBTdGFydCBkYXRlIG9mIHRoZSByYW5nZVxyXG4gICAqIG9yIHtjbGVhcjogdHJ1ZX0gdG8gY2xlYXIgdGhlIGRhdGVcclxuICAgKiBAcGFyYW0ge0RhdGV8TnVtYmVyfFN0cmluZ3xPYmplY3R9IHJhbmdlRW5kIC0gRW5kIGRhdGUgb2YgdGhlIHJhbmdlXHJcbiAgICogb3Ige2NsZWFyOiB0cnVlfSB0byBjbGVhciB0aGUgZGF0ZVxyXG4gICAqL1xyXG4gIHNldERhdGVzKHJhbmdlU3RhcnQsIHJhbmdlRW5kKSB7XHJcbiAgICBjb25zdCBbZGF0ZXBpY2tlcjAsIGRhdGVwaWNrZXIxXSA9IHRoaXMuZGF0ZXBpY2tlcnM7XHJcbiAgICBjb25zdCBvcmlnRGF0ZXMgPSB0aGlzLmRhdGVzO1xyXG5cclxuICAgIC8vIElmIHJhbmdlIG5vcm1hbGl6YXRpb24gcnVucyBvbiBldmVyeSBjaGFuZ2UsIHdlIGNhbid0IHNldCBhIG5ldyByYW5nZVxyXG4gICAgLy8gdGhhdCBzdGFydHMgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgY3VycmVudCByYW5nZSBjb3JyZWN0bHkgYmVjYXVzZSB0aGVcclxuICAgIC8vIG5vcm1hbGl6YXRpb24gcHJvY2VzcyBzd2FwcyBzdGFydOKGlO+4jmVuZCByaWdodCBhZnRlciBzZXR0aW5nIHRoZSBuZXcgc3RhcnRcclxuICAgIC8vIGRhdGUuIFRvIHByZXZlbnQgdGhpcywgdGhlIG5vcm1hbGl6YXRpb24gcHJvY2VzcyBuZWVkcyB0byBydW4gb25jZSBhZnRlclxyXG4gICAgLy8gYm90aCBvZiB0aGUgbmV3IGRhdGVzIGFyZSBzZXQuXHJcbiAgICB0aGlzLl91cGRhdGluZyA9IHRydWU7XHJcbiAgICBkYXRlcGlja2VyMC5zZXREYXRlKHJhbmdlU3RhcnQpO1xyXG4gICAgZGF0ZXBpY2tlcjEuc2V0RGF0ZShyYW5nZUVuZCk7XHJcbiAgICBkZWxldGUgdGhpcy5fdXBkYXRpbmc7XHJcblxyXG4gICAgaWYgKGRhdGVwaWNrZXIxLmRhdGVzWzBdICE9PSBvcmlnRGF0ZXNbMV0pIHtcclxuICAgICAgb25DaGFuZ2VEYXRlKHRoaXMsIHt0YXJnZXQ6IHRoaXMuaW5wdXRzWzFdfSk7XHJcbiAgICB9IGVsc2UgaWYgKGRhdGVwaWNrZXIwLmRhdGVzWzBdICE9PSBvcmlnRGF0ZXNbMF0pIHtcclxuICAgICAgb25DaGFuZ2VEYXRlKHRoaXMsIHt0YXJnZXQ6IHRoaXMuaW5wdXRzWzBdfSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcGx1Z2lucy9kYXRlcGlja2VyLmpzXHJcblxyXG5cclxuXHJcbmNvbnN0IGdldERhdGVwaWNrZXJPcHRpb25zID0gZGF0ZXBpY2tlckVsID0+IHtcclxuICBjb25zdCBidXR0b25zID0gZGF0ZXBpY2tlckVsLmhhc0F0dHJpYnV0ZSgnZGF0ZXBpY2tlci1idXR0b25zJyk7XHJcbiAgY29uc3QgYXV0b2hpZGUgPSBkYXRlcGlja2VyRWwuaGFzQXR0cmlidXRlKCdkYXRlcGlja2VyLWF1dG9oaWRlJyk7XHJcbiAgY29uc3QgZm9ybWF0ID0gZGF0ZXBpY2tlckVsLmhhc0F0dHJpYnV0ZSgnZGF0ZXBpY2tlci1mb3JtYXQnKTtcclxuICBjb25zdCBvcmllbnRhdGlvbiA9IGRhdGVwaWNrZXJFbC5oYXNBdHRyaWJ1dGUoJ2RhdGVwaWNrZXItb3JpZW50YXRpb24nKTtcclxuICBjb25zdCB0aXRsZSA9IGRhdGVwaWNrZXJFbC5oYXNBdHRyaWJ1dGUoJ2RhdGVwaWNrZXItdGl0bGUnKTtcclxuICBsZXQgb3B0aW9ucyA9IHt9O1xyXG5cclxuICBpZiAoYnV0dG9ucykge1xyXG4gICAgb3B0aW9ucy50b2RheUJ0biA9IHRydWU7XHJcbiAgICBvcHRpb25zLmNsZWFyQnRuID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIGlmIChhdXRvaGlkZSkge1xyXG4gICAgb3B0aW9ucy5hdXRvaGlkZSA9IHRydWU7XHJcbiAgfVxyXG5cclxuICBpZiAoZm9ybWF0KSB7XHJcbiAgICBvcHRpb25zLmZvcm1hdCA9IGRhdGVwaWNrZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGVwaWNrZXItZm9ybWF0Jyk7XHJcbiAgfVxyXG5cclxuICBpZiAob3JpZW50YXRpb24pIHtcclxuICAgIG9wdGlvbnMub3JpZW50YXRpb24gPSBkYXRlcGlja2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRlcGlja2VyLW9yaWVudGF0aW9uJyk7XHJcbiAgfVxyXG5cclxuICBpZiAodGl0bGUpIHtcclxuICAgIG9wdGlvbnMudGl0bGUgPSBkYXRlcGlja2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRlcGlja2VyLXRpdGxlJyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb3B0aW9ucztcclxufTtcclxuXHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XHJcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGVwaWNrZXJdJykuZm9yRWFjaChmdW5jdGlvbiAoZGF0ZXBpY2tlckVsKSB7XHJcbiAgICBuZXcgRGF0ZXBpY2tlcihkYXRlcGlja2VyRWwsIGdldERhdGVwaWNrZXJPcHRpb25zKGRhdGVwaWNrZXJFbCkpO1xyXG4gIH0pO1xyXG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpbmxpbmUtZGF0ZXBpY2tlcl0nKS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRlcGlja2VyRWwpIHtcclxuICAgIG5ldyBEYXRlcGlja2VyKGRhdGVwaWNrZXJFbCwgZ2V0RGF0ZXBpY2tlck9wdGlvbnMoZGF0ZXBpY2tlckVsKSk7XHJcbiAgfSk7XHJcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGUtcmFuZ2VwaWNrZXJdJykuZm9yRWFjaChmdW5jdGlvbiAoZGF0ZXBpY2tlckVsKSB7XHJcbiAgICBuZXcgRGF0ZVJhbmdlUGlja2VyKGRhdGVwaWNrZXJFbCwgZ2V0RGF0ZXBpY2tlck9wdGlvbnMoZGF0ZXBpY2tlckVsKSk7XHJcbiAgfSk7XHJcbn0pO1xyXG4vKioqKioqLyB9KSgpXHJcbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0ZXBpY2tlci5qcy5tYXAiXSwiZmlsZSI6Ii4vcmVzb3VyY2VzL2pzL2RhdGVwaWNrZXIuanMuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/datepicker.js\n");

/***/ }),

/***/ "./resources/sass/app.scss":
/*!*********************************!*\
  !*** ./resources/sass/app.scss ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvc2Fzcy9hcHAuc2Nzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Fzcy9hcHAuc2Nzcz9hOTdiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/sass/app.scss\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/app": 0,
/******/ 			"css/app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/js/app.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/sass/app.scss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;